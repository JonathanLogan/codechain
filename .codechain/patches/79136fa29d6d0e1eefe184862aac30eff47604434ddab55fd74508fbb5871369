codechain patchfile version 1
treehash 79136fa29d6d0e1eefe184862aac30eff47604434ddab55fd74508fbb5871369
- f 5ed57162b92c55625759d100ecffc4d292ccb7edffab9182c383dfe3d16a6e07 cmd/ccdiff/ccdiff.go
+ f 941fab00832b05ba19e94d8fa37a547cadaf00f0ee1298e423105e9c9e68fb3f cmd/ccdiff/ccdiff.go
dmppatch 23
@@ -97,16 +97,24 @@
 mport (%0A
+%09%22flag%22%0A
 %09%22fmt%22%0A%09
@@ -252,16 +252,60 @@
 n/util%22%0A
+%09%22github.com/frankbraun/codechain/util/log%22%0A
 )%0A%0Afunc 
@@ -410,73 +410,193 @@
 ) %7B%0A
-%09fmt.Fprintf(os.Stderr, %22usage: %25s tree_a tree_b%5Cn%22, os.Args%5B0%5D)%0A
+%09fmt.Fprintf(os.Stderr, %22Usage: %25s tree_a tree_b%5Cn%22, os.Args%5B0%5D)%0A%09fmt.Fprintf(os.Stderr, %22Caluates a patch between two directory trees and print it to stdout.%5Cn%22)%0A%09flag.PrintDefaults()%0A
 %09os.
@@ -624,32 +624,177 @@
 ) %7B%0A
-%09if len(os.Args) != 3 %7B%0A
+%09verbose := flag.Bool(%22v%22, false, %22Be verbose (on stderr)%22)%0A%09flag.Usage = usage%0A%09flag.Parse()%0A%09if *verbose %7B%0A%09%09log.Std = log.NewStd(os.Stderr)%0A%09%7D%0A%09if flag.NArg() != 2 %7B%0A
 %09%09us
@@ -806,62 +806,64 @@
 %0A%09%7D%0A
-%09if err := diff(os.Args%5B1%5D, os.Args%5B2%5D); err != nil %7B%0A
+%09if err := diff(flag.Arg(0), flag.Arg(1)); err != nil %7B%0A
 %09%09ut
- f cedf020febd05e58f31411a0c6f169902fbd5cb9e81b3db5c9856cf81dfbc248 cmd/ccpatch/ccpatch.go
+ f 98f0d57628fef5c7816450e8d7e33ff9140f7fc0b9b4a80e2812ec5e930f561d cmd/ccpatch/ccpatch.go
dmppatch 23
@@ -68,16 +68,24 @@
 mport (%0A
+%09%22flag%22%0A
 %09%22fmt%22%0A%09
@@ -223,16 +223,60 @@
 n/util%22%0A
+%09%22github.com/frankbraun/codechain/util/log%22%0A
 )%0A%0Afunc 
@@ -462,79 +462,169 @@
 ) %7B%0A
-%09fmt.Fprintf(os.Stderr, %22usage: %25s directory patchfile%5Cn%22, os.Args%5B0%5D)%0A
+%09fmt.Fprintf(os.Stderr, %22Usage: %25s directory patchfile%5Cn%22, os.Args%5B0%5D)%0A%09fmt.Fprintf(os.Stderr, %22Apply a patchfile to a directory tree.%5Cn%22)%0A%09flag.PrintDefaults()%0A
 %09os.
@@ -652,32 +652,177 @@
 ) %7B%0A
-%09if len(os.Args) != 3 %7B%0A
+%09verbose := flag.Bool(%22v%22, false, %22Be verbose (on stderr)%22)%0A%09flag.Usage = usage%0A%09flag.Parse()%0A%09if *verbose %7B%0A%09%09log.Std = log.NewStd(os.Stderr)%0A%09%7D%0A%09if flag.NArg() != 2 %7B%0A
 %09%09us
@@ -834,63 +834,65 @@
 %0A%09%7D%0A
-%09if err := patch(os.Args%5B1%5D, os.Args%5B2%5D); err != nil %7B%0A
+%09if err := patch(flag.Arg(0), flag.Arg(1)); err != nil %7B%0A
 %09%09ut
+ f 13e194c28bf0136166134a2b99cba3cd970c3955ec0a7ae63adc8bdc117ad795 patchfile/apply.go
dmppatch 2
@@ -0,0 +1,9701 @@
+package patchfile%0A%0Aimport (%0A%09%22bufio%22%0A%09%22bytes%22%0A%09%22errors%22%0A%09%22fmt%22%0A%09%22io%22%0A%09%22io/ioutil%22%0A%09%22os%22%0A%09%22path/filepath%22%0A%09%22strconv%22%0A%09%22strings%22%0A%0A%09%22github.com/frankbraun/codechain/internal/hex%22%0A%09%22github.com/frankbraun/codechain/tree%22%0A%09%22github.com/frankbraun/codechain/util/file%22%0A%09%22github.com/frankbraun/codechain/util/log%22%0A)%0A%0A// state machine used to apply patch files.%0Atype state int%0A%0A// all possible state:%0Aconst (%0A%09start          state = iota + 1 // start state%0A%09treehash                        // tree hash%0A%09fileDiff                        // first file diff%0A%09secondFileDiff                  // second file diff%0A%09addFile                         // add file state%0A%09diffFile                        // diff file state%0A%09terminal                        // end state%0A)%0A%0A// codechain patchfile version 1%0Afunc procStart(line string) (state, error) %7B%0A%09fields := strings.SplitN(line, %22 %22, 4)%0A%09if len(fields) != 4 %7B%0A%09%09return 0, ErrHeaderFieldsNum%0A%09%7D%0A%09if fields%5B0%5D != %22codechain%22 %7C%7C fields%5B1%5D != %22patchfile%22 %7C%7C fields%5B2%5D != %22version%22 %7B%0A%09%09return 0, ErrHeaderFieldsText%0A%09%7D%0A%09ver, err := strconv.Atoi(fields%5B3%5D)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if ver != 1 %7B // only support Version = 1%0A%09%09return 0, ErrHeaderVersion%0A%09%7D%0A%09return treehash, nil%0A%7D%0A%0A// treehash hex_hash%0Afunc procTreeHash(line, dir string, excludePaths %5B%5Dstring) (state, error) %7B%0A%09fields := strings.SplitN(line, %22 %22, 2)%0A%09if len(fields) != 2 %7B%0A%09%09return 0, ErrTreeHashFieldsNum%0A%09%7D%0A%09if fields%5B0%5D != %22treehash%22 %7B%0A%09%09return 0, ErrTreeHashFieldsText%0A%09%7D%0A%09h, err := hex.Decode(fields%5B1%5D, 32)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09treeHash, err := tree.Hash(dir, excludePaths)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if !bytes.Equal(treeHash%5B:%5D, h) %7B%0A%09%09return 0, ErrTreeHashStartMismatch%0A%09%7D%0A%09return fileDiff, nil%0A%7D%0A%0Atype mode int%0A%0Aconst (%0A%09regularFile mode = iota + 1%0A%09binaryFile%0A)%0A%0A// + f hex_hash filename # add file, filename must not exist%0A//%0A// or%0A//%0A// - f hex_hash filename # delete file%0A//%0A// or%0A//%0A// - f hex_hash filename_a # possible mode change%0A// + x hex_hash filename_b # if filename_a and filname_b differ, filename_b must not exist%0Afunc procFileDiff(line string, dir string, prevDiffInfo *diffInfo) (state, *diffInfo, error) %7B%0A%09fields := strings.SplitN(line, %22 %22, 4)%0A%09if len(fields) != 4 %7B%0A%09%09return 0, nil, ErrFileFieldsNum%0A%09%7D%0A%09if fields%5B0%5D != %22-%22 && fields%5B0%5D != %22+%22 %7B%0A%09%09return 0, nil, ErrFileField0%0A%09%7D%0A%09if fields%5B1%5D != %22f%22 && fields%5B1%5D != %22x%22 %7B%0A%09%09return 0, nil, ErrFileField1%0A%09%7D%0A%09hash, err := hex.Decode(fields%5B2%5D, 32)%0A%09if err != nil %7B%0A%09%09return 0, nil, err%0A%09%7D%0A%09name := fields%5B3%5D%0A%09var mode mode%0A%09if fields%5B1%5D == %22f%22 %7B%0A%09%09mode = regularFile%0A%09%7D else %7B%0A%09%09mode = binaryFile%0A%09%7D%0A%09if prevDiffInfo != nil %7B%0A%09%09// We read to two file info lines after another ('-' followed by '+').%0A%09%09if name != prevDiffInfo.name %7B%0A%09%09%09// The file names changed, we have to %22move%22 the file.%0A%09%09%09// First make sure target doesn't exist.%0A%09%09%09fn := filepath.Join(dir, name)%0A%09%09%09exists, err := file.Exists(fn)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return 0, nil, err%0A%09%09%09%7D%0A%09%09%09if exists %7B%0A%09%09%09%09return 0, nil, ErrMoveTargetFileExists%0A%09%09%09%7D%0A%09%09%09// Instead of %22moving%22, we delete the previous file and then add%0A%09%09%09// the current file again.%0A%09%09%09oldpath := filepath.Join(dir, prevDiffInfo.name)%0A%09%09%09if err := os.Remove(oldpath); err != nil %7B%0A%09%09%09%09return 0, nil, err%0A%09%09%09%7D%0A%09%09%09return addFile, &diffInfo%7Bmode, hash, name%7D, nil%0A%09%09%7D%0A%09%09// The two files have the same name, check if their hash differs.%0A%09%09if bytes.Equal(hash%5B:%5D, prevDiffInfo.hash) %7B%0A%09%09%09// The hashes do not differ, check if we have to change the file%0A%09%09%09// permissions.%0A%09%09%09if mode != prevDiffInfo.mode %7B%0A%09%09%09%09// chmod%0A%09%09%09%09var perm os.FileMode%0A%09%09%09%09if mode == regularFile %7B%0A%09%09%09%09%09perm = 0644%0A%09%09%09%09%7D else %7B%0A%09%09%09%09%09perm = 0755%0A%09%09%09%09%7D%0A%09%09%09%09if err := os.Chmod(filepath.Join(dir, name), perm); err != nil %7B%0A%09%09%09%09%09return 0, nil, err%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09// Because the files have the same names and the same hash we do%0A%09%09%09// not process a diff next, but expect another file line.%0A%09%09%09return fileDiff, nil, nil%0A%09%09%7D%0A%09%09// The hash differs, we have to process a diff next.%0A%09%09return diffFile, &diffInfo%7Bmode, hash, name%7D, nil%0A%09%7D else if fields%5B0%5D == %22+%22 %7B%0A%09%09// add file%0A%09%09fn := filepath.Join(dir, name)%0A%09%09exists, err := file.Exists(fn)%0A%09%09if err != nil %7B%0A%09%09%09return 0, nil, err%0A%09%09%7D%0A%09%09if exists %7B%0A%09%09%09return 0, nil, ErrAddTargetFileExists%0A%09%09%7D%0A%09%09return addFile, &diffInfo%7Bmode, hash, name%7D, nil%0A%09%7D%0A%09// else: delete or diff?%0A%09return secondFileDiff, &diffInfo%7Bmode, hash, name%7D, nil%0A%7D%0A%0Afunc procResult(line, dir string, excludePaths %5B%5Dstring) (state, error) %7B%0A%09if _, err := procTreeHash(line, dir, excludePaths); err != nil %7B%0A%09%09if err == ErrTreeHashStartMismatch %7B%0A%09%09%09return 0, ErrTreeHashFinishMismatch%0A%09%09%7D%0A%09%09return 0, err%0A%09%7D%0A%09return terminal, nil%0A%7D%0A%0Atype applyFunc func(w io.Writer, text string, patch %5B%5Dbyte) error%0A%0Afunc apply(dir string, buf %5B%5Dbyte, state state, prev, cur *diffInfo, applyFunc applyFunc) error %7B%0A%09var text string%0A%09fileB := filepath.Join(dir, cur.name)%0A%09if state == addFile %7B%0A%09%09if err := os.MkdirAll(filepath.Dir(fileB), 0755); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%7D else %7B%0A%09%09fileA := filepath.Join(dir, prev.name)%0A%09%09hash, err := tree.SHA256(fileA)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09if !bytes.Equal(hash%5B:%5D, prev.hash) %7B%0A%09%09%09return ErrFileHashMismatchBefore%0A%09%09%7D%0A%09%09buf, err := ioutil.ReadFile(fileA)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09text = string(buf)%0A%09%7D%0A%09var flag int%0A%09if state == addFile %7B%0A%09%09flag = os.O_CREATE %7C os.O_EXCL %7C os.O_WRONLY%0A%09%7D else %7B%0A%09%09flag = os.O_TRUNC %7C os.O_WRONLY%0A%09%7D%0A%09var perm os.FileMode%0A%09if cur.mode == regularFile %7B%0A%09%09perm = 0644%0A%09%7D else %7B%0A%09%09perm = 0755%0A%09%7D%0A%09f, err := os.OpenFile(fileB, flag, perm)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if err := applyFunc(f, text, buf); err != nil %7B%0A%09%09f.Close()%0A%09%09return err%0A%09%7D%0A%09if err := f.Close(); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09hash, err := tree.SHA256(fileB)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if !bytes.Equal(hash%5B:%5D, cur.hash) %7B%0A%09%09return ErrFileHashMismatchAfter%0A%09%7D%0A%09return nil%0A%7D%0A%0Atype diffInfo struct %7B%0A%09mode%0A%09hash %5B%5Dbyte%0A%09name string%0A%7D%0A%0A// Apply applies the given patch r to the directory tree dir.%0Afunc Apply(dir string, r io.Reader, excludePaths %5B%5Dstring) error %7B%0A%09log.Println(%22patchfile.Apply()%22)%0A%09var (%0A%09%09prevDiffInfo *diffInfo%0A%09%09curDiffInfo  *diffInfo%0A%09%09err          error%0A%09)%0A%09s := bufio.NewScanner(r)%0A%09buf := make(%5B%5Dbyte, bufio.MaxScanTokenSize)%0A%09s.Buffer(buf, 64*1024*1024) // 64MB, entire files can be encoded as single lines%0A%09state := start%0A%09for s.Scan() %7B%0A%09%09line := s.Text()%0A%09%09log.Println(%22line:%22)%0A%09%09log.Println(line)%0A%09%09switch state %7B%0A%09%09case start:%0A%09%09%09log.Println(%22state: start%22)%0A%09%09%09state, err = procStart(line)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return err%0A%09%09%09%7D%0A%09%09case treehash:%0A%09%09%09log.Println(%22state: treehash%22)%0A%09%09%09state, err = procTreeHash(line, dir, excludePaths)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return err%0A%09%09%09%7D%0A%09%09case fileDiff:%0A%09%09%09log.Println(%22state: fileDiff%22)%0A%09%09%09fields := strings.SplitN(line, %22 %22, 2)%0A%09%09%09lookAhead := fields%5B0%5D%0A%09%09%09if lookAhead == %22treehash%22 %7B%0A%09%09%09%09state, err = procResult(line, dir, excludePaths)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%7D else %7B%0A%09%09%09%09prevDiffInfo = nil%0A%09%09%09%09state, curDiffInfo, err = procFileDiff(line, dir, prevDiffInfo)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09case secondFileDiff:%0A%09%09%09log.Println(%22state: secondFileDiff%22)%0A%09%09%09fields := strings.SplitN(line, %22 %22, 2)%0A%09%09%09lookAhead := fields%5B0%5D%0A%09%09%09if lookAhead == %22-%22 %7C%7C lookAhead == %22treehash%22 %7B%0A%09%09%09%09// delete%0A%09%09%09%09fn := filepath.Join(dir, curDiffInfo.name)%0A%09%09%09%09hash, err := tree.SHA256(fn)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09if !bytes.Equal(hash%5B:%5D, curDiffInfo.hash) %7B%0A%09%09%09%09%09return fmt.Errorf(%22patchfile: hash of file '%25s' to delete doesn't match%22,%0A%09%09%09%09%09%09prevDiffInfo.name)%0A%09%09%09%09%7D%0A%09%09%09%09if err := os.Remove(fn); err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09// reset%0A%09%09%09%09curDiffInfo = nil%0A%09%09%09%7D%0A%09%09%09if lookAhead == %22treehash%22 %7B%0A%09%09%09%09state, err = procResult(line, dir, excludePaths)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%7D else %7B%0A%09%09%09%09prevDiffInfo = curDiffInfo%0A%09%09%09%09state, curDiffInfo, err = procFileDiff(line, dir, prevDiffInfo)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09case addFile:%0A%09%09%09log.Println(%22state: addFile (fallthrough)%22)%0A%09%09%09fallthrough%0A%09%09case diffFile:%0A%09%09%09log.Println(%22state: diffFile%22)%0A%09%09%09fields := strings.SplitN(line, %22 %22, 2)%0A%09%09%09lookAhead := fields%5B0%5D%0A%09%09%09numLines, err := strconv.Atoi(fields%5B1%5D)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return ErrDiffLinesParse%0A%09%09%09%7D%0A%09%09%09switch lookAhead %7B%0A%09%09%09case %22ascii85%22:%0A%09%09%09%09if numLines %3C 1 %7B%0A%09%09%09%09%09return ErrDiffLinesNonPositive%0A%09%09%09%09%7D%0A%09%09%09case %22dmppatch%22:%0A%09%09%09%09if numLines %3C 0 %7B%0A%09%09%09%09%09return ErrDiffLinesNegative%0A%09%09%09%09%7D%0A%09%09%09default:%0A%09%09%09%09return ErrDiffModeUnknown%0A%09%09%09%7D%0A%09%09%09// read lines%0A%09%09%09var lines %5B%5Dstring%0A%09%09%09for i := 0; i %3C numLines; i++ %7B%0A%09%09%09%09if s.Scan() %7B%0A%09%09%09%09%09line := s.Text()%0A%09%09%09%09%09//fmt.Println(line)%0A%09%09%09%09%09lines = append(lines, line)%0A%09%09%09%09%7D else %7B%0A%09%09%09%09%09// check if we have a scanner error first%0A%09%09%09%09%09if err := s.Err(); err != nil %7B%0A%09%09%09%09%09%09return err%0A%09%09%09%09%09%7D%0A%09%09%09%09%09return ErrPrematureDiffEnd%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09switch lookAhead %7B%0A%09%09%09case %22ascii85%22:%0A%09%09%09%09buf := strings.Join(lines, %22%22)%0A%09%09%09%09err = apply(dir, %5B%5Dbyte(buf), state, prevDiffInfo, curDiffInfo, ascii85Apply)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09// reset%0A%09%09%09%09prevDiffInfo = nil%0A%09%09%09%09curDiffInfo = nil%0A%09%09%09case %22dmppatch%22:%0A%09%09%09%09var buf string%0A%09%09%09%09if len(lines) %3E 0 %7B%0A%09%09%09%09%09buf = strings.Join(lines, %22%5Cn%22) + %22%5Cn%22%0A%09%09%09%09%7D%0A%09%09%09%09err = apply(dir, %5B%5Dbyte(buf), state, prevDiffInfo, curDiffInfo, dmpApply)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09// reset%0A%09%09%09%09prevDiffInfo = nil%0A%09%09%09%09curDiffInfo = nil%0A%09%09%09%7D%0A%09%09%09state = fileDiff%0A%09%09case terminal:%0A%09%09%09log.Println(%22state: terminal%22)%0A%09%09%09return ErrNotTerminal%0A%09%09default:%0A%09%09%09log.Println(%22state: unknown%22)%0A%09%09%09return errors.New(%22patchfile: unknown state%22) // cannot happen%0A%09%09%7D%0A%09%7D%0A%09if err := s.Err(); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if state != terminal %7B%0A%09%09return ErrPrematurePatchfileEnd%0A%09%7D%0A%09return nil%0A%7D%0A
+ f 96a720a7040d37884eb4d0074c1554334f603b675b97427544e0cf11572d5d3c patchfile/diff.go
dmppatch 2
@@ -0,0 +1,2958 @@
+// Package patchfile implements a robust patchfile format for directory trees.%0Apackage patchfile%0A%0Aimport (%0A%09%22bytes%22%0A%09%22fmt%22%0A%09%22io%22%0A%09%22path/filepath%22%0A%0A%09%22github.com/frankbraun/codechain/tree%22%0A%09%22github.com/frankbraun/codechain/util/file%22%0A)%0A%0Afunc writeDeleteFile(w io.Writer, entry tree.ListEntry) %7B%0A%09fmt.Fprintf(w, %22- %25c %25x %25s%5Cn%22, entry.Mode, entry.Hash, entry.Filename)%0A%7D%0A%0Afunc writeAddFile(w io.Writer, dir string, entry tree.ListEntry) error %7B%0A%09fmt.Fprintf(w, %22+ %25c %25x %25s%5Cn%22, entry.Mode, entry.Hash, entry.Filename)%0A%09filename := filepath.Join(dir, entry.Filename)%0A%09isBinary, err := file.IsBinary(filename)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if isBinary %7B%0A%09%09err := ascii85Diff(w, filename)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%7D else %7B%0A%09%09err := dmpDiff(w, %22%22, filename)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%0A%09%7D%0A%09return nil%0A%7D%0A%0A// Diff computes a patch w between the directory trees rooted at a and b.%0A// If a and b have the same tree hash ErrNoDifference is returned.%0A// In case of error, some data might have been written to w already.%0Afunc Diff(w io.Writer, a, b string, excludePaths %5B%5Dstring) error %7B%0A%09listA, err := tree.List(a, excludePaths)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09listB, err := tree.List(b, excludePaths)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09hashA := tree.HashList(listA)%0A%09hashB := tree.HashList(listB)%0A%09if bytes.Equal(hashA%5B:%5D, hashB%5B:%5D) %7B%0A%09%09return ErrNoDifference%0A%09%7D%0A%09fmt.Fprintf(w, %22codechain patchfile version %25d%5Cn%22, Version)%0A%09fmt.Fprintf(w, %22treehash %25x%5Cn%22, hashA%5B:%5D)%0A%09idxA := 0%0A%09idxB := 0%0A%09for idxA %3C len(listA) && idxB %3C len(listB) %7B%0A%09%09entryA := listA%5BidxA%5D%0A%09%09entryB := listB%5BidxB%5D%0A%09%09if entryA.Filename == entryB.Filename %7B%0A%09%09%09if !bytes.Equal(entryA.Hash%5B:%5D, entryB.Hash%5B:%5D) %7C%7C%0A%09%09%09%09entryA.Mode != entryB.Mode %7B%0A%09%09%09%09fmt.Fprintf(w, %22- %25c %25x %25s%5Cn%22, entryA.Mode, entryA.Hash, entryA.Filename)%0A%09%09%09%09fmt.Fprintf(w, %22+ %25c %25x %25s%5Cn%22, entryB.Mode, entryB.Hash, entryB.Filename)%0A%09%09%09%7D%0A%09%09%09if !bytes.Equal(entryA.Hash%5B:%5D, entryB.Hash%5B:%5D) %7B%0A%09%09%09%09filenameA := filepath.Join(a, entryA.Filename)%0A%09%09%09%09filenameB := filepath.Join(b, entryB.Filename)%0A%09%09%09%09isBinaryA, err := file.IsBinary(filenameA)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09isBinaryB, err := file.IsBinary(filenameB)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09if isBinaryA %7C%7C isBinaryB %7B%0A%09%09%09%09%09err := ascii85Diff(w, filenameB)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09return err%0A%09%09%09%09%09%7D%0A%09%09%09%09%7D else %7B%0A%09%09%09%09%09err := dmpDiff(w, filenameA, filenameB)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09return err%0A%09%09%09%09%09%7D%0A%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%7D else if entryA.Filename %3C entryB.Filename %7B%0A%09%09%09writeDeleteFile(w, entryA)%0A%09%09%09idxA++%0A%09%09%09continue%0A%09%09%7D else %7B // entryA.Filename %3E entryB.Filename%0A%09%09%09if err := writeAddFile(w, b, entryB); err != nil %7B%0A%09%09%09%09return err%0A%09%09%09%7D%0A%09%09%09idxB++%0A%09%09%09continue%0A%09%09%7D%0A%09%09idxA++%0A%09%09idxB++%0A%09%7D%0A%09for idxA %3C len(listA) %7B%0A%09%09writeDeleteFile(w, listA%5BidxA%5D)%0A%09%09idxA++%0A%09%7D%0A%09for idxB %3C len(listB) %7B%0A%09%09if err := writeAddFile(w, b, listB%5BidxB%5D); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09idxB++%0A%09%7D%0A%09fmt.Fprintf(w, %22treehash %25x%5Cn%22, hashB%5B:%5D)%0A%09return nil%0A%7D%0A
- f a2e04daf618c7421e496f7783a8447497aae1c64a940bd3343be1ec628ff3d85 patchfile/patchfile.go
+ f 27bc72014f931d26a497384873b7f486d0ba3376d0a6c19f4ba04d6f969a590d patchfile/patchfile.go
dmppatch 7
@@ -95,253 +95,8 @@
 le%0A%0A
-import (%0A%09%22bufio%22%0A%09%22bytes%22%0A%09%22errors%22%0A%09%22fmt%22%0A%09%22io%22%0A%09%22io/ioutil%22%0A%09%22os%22%0A%09%22path/filepath%22%0A%09%22strconv%22%0A%09%22strings%22%0A%0A%09%22github.com/frankbraun/codechain/internal/hex%22%0A%09%22github.com/frankbraun/codechain/tree%22%0A%09%22github.com/frankbraun/codechain/util/file%22%0A)%0A%0A
 // V
@@ -191,10974 +191,4 @@
 = 1%0A
-%0Afunc writeDeleteFile(w io.Writer, entry tree.ListEntry) %7B%0A%09fmt.Fprintf(w, %22- %25c %25x %25s%5Cn%22, entry.Mode, entry.Hash, entry.Filename)%0A%7D%0A%0Afunc writeAddFile(w io.Writer, dir string, entry tree.ListEntry) error %7B%0A%09fmt.Fprintf(w, %22+ %25c %25x %25s%5Cn%22, entry.Mode, entry.Hash, entry.Filename)%0A%09filename := filepath.Join(dir, entry.Filename)%0A%09isBinary, err := file.IsBinary(filename)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if isBinary %7B%0A%09%09err := ascii85Diff(w, filename)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%7D else %7B%0A%09%09err := dmpDiff(w, %22%22, filename)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%0A%09%7D%0A%09return nil%0A%7D%0A%0A// Diff computes a patch w between the directory trees rooted at a and b.%0A// If a and b have the same tree hash ErrNoDifference is returned.%0A// In case of error, some data might have been written to w already.%0Afunc Diff(w io.Writer, a, b string, excludePaths %5B%5Dstring) error %7B%0A%09listA, err := tree.List(a, excludePaths)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09listB, err := tree.List(b, excludePaths)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09hashA := tree.HashList(listA)%0A%09hashB := tree.HashList(listB)%0A%09if bytes.Equal(hashA%5B:%5D, hashB%5B:%5D) %7B%0A%09%09return ErrNoDifference%0A%09%7D%0A%09fmt.Fprintf(w, %22codechain patchfile version %25d%5Cn%22, Version)%0A%09fmt.Fprintf(w, %22treehash %25x%5Cn%22, hashA%5B:%5D)%0A%09idxA := 0%0A%09idxB := 0%0A%09for idxA %3C len(listA) && idxB %3C len(listB) %7B%0A%09%09entryA := listA%5BidxA%5D%0A%09%09entryB := listB%5BidxB%5D%0A%09%09if entryA.Filename == entryB.Filename %7B%0A%09%09%09if !bytes.Equal(entryA.Hash%5B:%5D, entryB.Hash%5B:%5D) %7C%7C%0A%09%09%09%09entryA.Mode != entryB.Mode %7B%0A%09%09%09%09fmt.Fprintf(w, %22- %25c %25x %25s%5Cn%22, entryA.Mode, entryA.Hash, entryA.Filename)%0A%09%09%09%09fmt.Fprintf(w, %22+ %25c %25x %25s%5Cn%22, entryB.Mode, entryB.Hash, entryB.Filename)%0A%09%09%09%7D%0A%09%09%09if !bytes.Equal(entryA.Hash%5B:%5D, entryB.Hash%5B:%5D) %7B%0A%09%09%09%09filenameA := filepath.Join(a, entryA.Filename)%0A%09%09%09%09filenameB := filepath.Join(b, entryB.Filename)%0A%09%09%09%09isBinaryA, err := file.IsBinary(filenameA)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09isBinaryB, err := file.IsBinary(filenameB)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09if isBinaryA %7C%7C isBinaryB %7B%0A%09%09%09%09%09err := ascii85Diff(w, filenameB)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09return err%0A%09%09%09%09%09%7D%0A%09%09%09%09%7D else %7B%0A%09%09%09%09%09err := dmpDiff(w, filenameA, filenameB)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09return err%0A%09%09%09%09%09%7D%0A%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%7D else if entryA.Filename %3C entryB.Filename %7B%0A%09%09%09writeDeleteFile(w, entryA)%0A%09%09%09idxA++%0A%09%09%09continue%0A%09%09%7D else %7B // entryA.Filename %3E entryB.Filename%0A%09%09%09if err := writeAddFile(w, b, entryB); err != nil %7B%0A%09%09%09%09return err%0A%09%09%09%7D%0A%09%09%09idxB++%0A%09%09%09continue%0A%09%09%7D%0A%09%09idxA++%0A%09%09idxB++%0A%09%7D%0A%09for idxA %3C len(listA) %7B%0A%09%09writeDeleteFile(w, listA%5BidxA%5D)%0A%09%09idxA++%0A%09%7D%0A%09for idxB %3C len(listB) %7B%0A%09%09if err := writeAddFile(w, b, listB%5BidxB%5D); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09idxB++%0A%09%7D%0A%09fmt.Fprintf(w, %22treehash %25x%5Cn%22, hashB%5B:%5D)%0A%09return nil%0A%7D%0A%0Atype state int%0A%0Aconst (%0A%09start state = iota + 1%0A%09treehash%0A%09fileDiff%0A%09secondFileDiff%0A%09addFile%0A%09diffFile%0A%09result%0A%09terminal%0A)%0A%0A// codechain patchfile version 1%0Afunc procStart(line string) (state, error) %7B%0A%09fields := strings.SplitN(line, %22 %22, 4)%0A%09if len(fields) != 4 %7B%0A%09%09return 0, ErrHeaderFieldsNum%0A%09%7D%0A%09if fields%5B0%5D != %22codechain%22 %7C%7C fields%5B1%5D != %22patchfile%22 %7C%7C fields%5B2%5D != %22version%22 %7B%0A%09%09return 0, ErrHeaderFieldsText%0A%09%7D%0A%09ver, err := strconv.Atoi(fields%5B3%5D)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if ver != 1 %7B // only support Version = 1%0A%09%09return 0, ErrHeaderVersion%0A%09%7D%0A%09return treehash, nil%0A%7D%0A%0A// treehash hex_hash%0Afunc procTreeHash(line, dir string, excludePaths %5B%5Dstring) (state, error) %7B%0A%09fields := strings.SplitN(line, %22 %22, 2)%0A%09if len(fields) != 2 %7B%0A%09%09return 0, ErrTreeHashFieldsNum%0A%09%7D%0A%09if fields%5B0%5D != %22treehash%22 %7B%0A%09%09return 0, ErrTreeHashFieldsText%0A%09%7D%0A%09h, err := hex.Decode(fields%5B1%5D, 32)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09treeHash, err := tree.Hash(dir, excludePaths)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if !bytes.Equal(treeHash%5B:%5D, h) %7B%0A%09%09return 0, ErrTreeHashStartMismatch%0A%09%7D%0A%09return fileDiff, nil%0A%7D%0A%0Atype mode int%0A%0Aconst (%0A%09regularFile mode = iota + 1%0A%09binaryFile%0A)%0A%0A// + f hex_hash filename # add file, filename must not exist%0A//%0A// or%0A//%0A// - f hex_hash filename # delete file%0A//%0A// or%0A//%0A// - f hex_hash filename_a # possible mode change%0A// + x hex_hash filename_b # if filename_a and filname_b differ, filename_b must not exist%0Afunc procFileDiff(line string, dir string, prevDiffInfo *diffInfo) (state, *diffInfo, error) %7B%0A%09fields := strings.SplitN(line, %22 %22, 4)%0A%09if len(fields) != 4 %7B%0A%09%09return 0, nil, ErrFileFieldsNum%0A%09%7D%0A%09if fields%5B0%5D != %22-%22 && fields%5B0%5D != %22+%22 %7B%0A%09%09return 0, nil, ErrFileField0%0A%09%7D%0A%09if fields%5B1%5D != %22f%22 && fields%5B1%5D != %22x%22 %7B%0A%09%09return 0, nil, ErrFileField1%0A%09%7D%0A%09hash, err := hex.Decode(fields%5B2%5D, 32)%0A%09if err != nil %7B%0A%09%09return 0, nil, err%0A%09%7D%0A%09name := fields%5B3%5D%0A%09var mode mode%0A%09if fields%5B1%5D == %22f%22 %7B%0A%09%09mode = regularFile%0A%09%7D else %7B%0A%09%09mode = binaryFile%0A%09%7D%0A%09if prevDiffInfo != nil %7B%0A%09%09if name != prevDiffInfo.name %7B%0A%09%09%09// move, make sure target doesn't exist%0A%09%09%09fn := filepath.Join(dir, name)%0A%09%09%09exists, err := file.Exists(fn)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return 0, nil, err%0A%09%09%09%7D%0A%09%09%09if exists %7B%0A%09%09%09%09return 0, nil, ErrMoveTargetFileExists%0A%09%09%09%7D%0A%09%09%7D%0A%09%09if bytes.Equal(hash%5B:%5D, prevDiffInfo.hash) %7B%0A%09%09%09if mode != prevDiffInfo.mode %7B%0A%09%09%09%09// chmod%0A%09%09%09%09var perm os.FileMode%0A%09%09%09%09if mode == regularFile %7B%0A%09%09%09%09%09perm = 0644%0A%09%09%09%09%7D else %7B%0A%09%09%09%09%09perm = 0755%0A%09%09%09%09%7D%0A%09%09%09%09if err := os.Chmod(filepath.Join(dir, name), perm); err != nil %7B%0A%09%09%09%09%09return 0, nil, err%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09if name != prevDiffInfo.name %7B%0A%09%09%09%09// delete and then add%0A%09%09%09%09oldpath := filepath.Join(dir, prevDiffInfo.name)%0A%09%09%09%09if err := os.Remove(oldpath); err != nil %7B%0A%09%09%09%09%09return 0, nil, err%0A%09%09%09%09%7D%0A%09%09%09%09return addFile, &diffInfo%7Bmode, hash, name%7D, nil%0A%09%09%09%7D%0A%09%09%09return fileDiff, nil, nil%0A%09%09%7D%0A%09%09// diff%0A%09%09return diffFile, &diffInfo%7Bmode, hash, name%7D, nil%0A%09%7D else if fields%5B0%5D == %22+%22 %7B%0A%09%09// add file%0A%09%09fn := filepath.Join(dir, name)%0A%09%09exists, err := file.Exists(fn)%0A%09%09if err != nil %7B%0A%09%09%09return 0, nil, err%0A%09%09%7D%0A%09%09if exists %7B%0A%09%09%09return 0, nil, ErrAddTargetFileExists%0A%09%09%7D%0A%09%09return addFile, &diffInfo%7Bmode, hash, name%7D, nil%0A%09%7D%0A%09// else: delete or diff?%0A%09return secondFileDiff, &diffInfo%7Bmode, hash, name%7D, nil%0A%7D%0A%0Afunc procResult(line, dir string, excludePaths %5B%5Dstring) (state, error) %7B%0A%09if _, err := procTreeHash(line, dir, excludePaths); err != nil %7B%0A%09%09if err == ErrTreeHashStartMismatch %7B%0A%09%09%09return 0, ErrTreeHashFinishMismatch%0A%09%09%7D%0A%09%09return 0, err%0A%09%7D%0A%09return terminal, nil%0A%7D%0A%0Atype applyFunc func(w io.Writer, text string, patch %5B%5Dbyte) error%0A%0Afunc apply(dir string, buf %5B%5Dbyte, state state, prev, cur *diffInfo, applyFunc applyFunc) error %7B%0A%09var text string%0A%09fileB := filepath.Join(dir, cur.name)%0A%09if state == addFile %7B%0A%09%09if err := os.MkdirAll(filepath.Dir(fileB), 0755); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%7D else %7B%0A%09%09fileA := filepath.Join(dir, prev.name)%0A%09%09hash, err := tree.SHA256(fileA)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09if !bytes.Equal(hash%5B:%5D, prev.hash) %7B%0A%09%09%09return ErrFileHashMismatchBefore%0A%09%09%7D%0A%09%09buf, err := ioutil.ReadFile(fileA)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09text = string(buf)%0A%09%7D%0A%09var flag int%0A%09if state == addFile %7B%0A%09%09flag = os.O_CREATE %7C os.O_EXCL %7C os.O_WRONLY%0A%09%7D else %7B%0A%09%09flag = os.O_TRUNC %7C os.O_WRONLY%0A%09%7D%0A%09var perm os.FileMode%0A%09if cur.mode == regularFile %7B%0A%09%09perm = 0644%0A%09%7D else %7B%0A%09%09perm = 0755%0A%09%7D%0A%09f, err := os.OpenFile(fileB, flag, perm)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if err := applyFunc(f, text, buf); err != nil %7B%0A%09%09f.Close()%0A%09%09return err%0A%09%7D%0A%09if err := f.Close(); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09hash, err := tree.SHA256(fileB)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if !bytes.Equal(hash%5B:%5D, cur.hash) %7B%0A%09%09return ErrFileHashMismatchAfter%0A%09%7D%0A%09return nil%0A%7D%0A%0Atype diffInfo struct %7B%0A%09mode%0A%09hash %5B%5Dbyte%0A%09name string%0A%7D%0A%0A// Apply applies the given patch r to the directory tree dir.%0Afunc Apply(dir string, r io.Reader, excludePaths %5B%5Dstring) error %7B%0A%09var (%0A%09%09prevDiffInfo *diffInfo%0A%09%09curDiffInfo  *diffInfo%0A%09%09err          error%0A%09)%0A%09s := bufio.NewScanner(r)%0A%09buf := make(%5B%5Dbyte, bufio.MaxScanTokenSize)%0A%09s.Buffer(buf, 64*1024*1024) // 64MB, entire files can be encoded as single lines%0A%09state := start%0A%09for s.Scan() %7B%0A%09%09line := s.Text()%0A%09%09//fmt.Println(line)%0A%09%09switch state %7B%0A%09%09case start:%0A%09%09%09state, err = procStart(line)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return err%0A%09%09%09%7D%0A%09%09case treehash:%0A%09%09%09state, err = procTreeHash(line, dir, excludePaths)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return err%0A%09%09%09%7D%0A%09%09case fileDiff:%0A%09%09%09fields := strings.SplitN(line, %22 %22, 2)%0A%09%09%09lookAhead := fields%5B0%5D%0A%09%09%09if lookAhead == %22treehash%22 %7B%0A%09%09%09%09state, err = procResult(line, dir, excludePaths)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%7D else %7B%0A%09%09%09%09prevDiffInfo = nil%0A%09%09%09%09state, curDiffInfo, err = procFileDiff(line, dir, prevDiffInfo)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09case secondFileDiff:%0A%09%09%09fields := strings.SplitN(line, %22 %22, 2)%0A%09%09%09lookAhead := fields%5B0%5D%0A%09%09%09if lookAhead == %22-%22 %7C%7C lookAhead == %22treehash%22 %7B%0A%09%09%09%09// delete%0A%09%09%09%09fn := filepath.Join(dir, curDiffInfo.name)%0A%09%09%09%09hash, err := tree.SHA256(fn)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09if !bytes.Equal(hash%5B:%5D, curDiffInfo.hash) %7B%0A%09%09%09%09%09return fmt.Errorf(%22patchfile: hash of file '%25s' to delete doesn't match%22,%0A%09%09%09%09%09%09prevDiffInfo.name)%0A%09%09%09%09%7D%0A%09%09%09%09if err := os.Remove(fn); err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09// reset%0A%09%09%09%09curDiffInfo = nil%0A%09%09%09%7D%0A%09%09%09if lookAhead == %22treehash%22 %7B%0A%09%09%09%09state, err = procResult(line, dir, excludePaths)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%7D else %7B%0A%09%09%09%09prevDiffInfo = curDiffInfo%0A%09%09%09%09state, curDiffInfo, err = procFileDiff(line, dir, prevDiffInfo)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09case addFile:%0A%09%09%09fallthrough%0A%09%09case diffFile:%0A%09%09%09fields := strings.SplitN(line, %22 %22, 2)%0A%09%09%09lookAhead := fields%5B0%5D%0A%09%09%09numLines, err := strconv.Atoi(fields%5B1%5D)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return ErrDiffLinesParse%0A%09%09%09%7D%0A%09%09%09switch lookAhead %7B%0A%09%09%09case %22ascii85%22:%0A%09%09%09%09if numLines %3C 1 %7B%0A%09%09%09%09%09return ErrDiffLinesNonPositive%0A%09%09%09%09%7D%0A%09%09%09case %22dmppatch%22:%0A%09%09%09%09if numLines %3C 0 %7B%0A%09%09%09%09%09return ErrDiffLinesNegative%0A%09%09%09%09%7D%0A%09%09%09default:%0A%09%09%09%09return ErrDiffModeUnknown%0A%09%09%09%7D%0A%09%09%09// read lines%0A%09%09%09var lines %5B%5Dstring%0A%09%09%09for i := 0; i %3C numLines; i++ %7B%0A%09%09%09%09if s.Scan() %7B%0A%09%09%09%09%09line := s.Text()%0A%09%09%09%09%09//fmt.Println(line)%0A%09%09%09%09%09lines = append(lines, line)%0A%09%09%09%09%7D else %7B%0A%09%09%09%09%09// check if we have a scanner error first%0A%09%09%09%09%09if err := s.Err(); err != nil %7B%0A%09%09%09%09%09%09return err%0A%09%09%09%09%09%7D%0A%09%09%09%09%09return ErrPrematureDiffEnd%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09switch lookAhead %7B%0A%09%09%09case %22ascii85%22:%0A%09%09%09%09buf := strings.Join(lines, %22%22)%0A%09%09%09%09err = apply(dir, %5B%5Dbyte(buf), state, prevDiffInfo, curDiffInfo, ascii85Apply)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09// reset%0A%09%09%09%09prevDiffInfo = nil%0A%09%09%09%09curDiffInfo = nil%0A%09%09%09case %22dmppatch%22:%0A%09%09%09%09var buf string%0A%09%09%09%09if len(lines) %3E 0 %7B%0A%09%09%09%09%09buf = strings.Join(lines, %22%5Cn%22) + %22%5Cn%22%0A%09%09%09%09%7D%0A%09%09%09%09err = apply(dir, %5B%5Dbyte(buf), state, prevDiffInfo, curDiffInfo, dmpApply)%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09return err%0A%09%09%09%09%7D%0A%09%09%09%09// reset%0A%09%09%09%09prevDiffInfo = nil%0A%09%09%09%09curDiffInfo = nil%0A%09%09%09%7D%0A%09%09%09state = fileDiff%0A%09%09case terminal:%0A%09%09%09return ErrNotTerminal%0A%09%09default:%0A%09%09%09return errors.New(%22patchfile: unknown state%22) // cannot happen%0A%09%09%7D%0A%09%7D%0A%09if err := s.Err(); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if state != terminal %7B%0A%09%09return ErrPrematurePatchfileEnd%0A%09%7D%0A%09return nil%0A%7D%0A
- f ebb1958c5f2b20d1c0d2edfd3650fabb186bd51c375a2044df4118019b8487b6 patchfile/patchfile_test.go
+ f 75144bda5c17cf113f2c7bd4d2e2a68b377618a691ff940341bd38c944beaa45 patchfile/patchfile_test.go
dmppatch 8
@@ -4384,16 +4384,74 @@
 omove%22)%0A
+%09helloMove2Dir := filepath.Join(%22testdata%22, %22hellomove2%22)%0A
 %09helloEx
@@ -7790,16 +7790,559 @@
 19247b6%0A
+%60,%0A%09%09%7D,%0A%09%09%7B%0A%09%09%09helloDir,%0A%09%09%09helloMove2Dir,%0A%09%09%09%60codechain patchfile version 1%0Atreehash 5998c63aca42e471297c0fa353538a93d4d4cfafe9a672df6989e694188b4a92%0A- f ad125cc5c1fb680be130908a0838ca2235db04285bcdd29e8e25087927e7dd0d hello.go%0A+ f 1b239e494fa201667627de82f0e4dc27b7b00b6ec06146e4d062730bf3762141 hellomove.go%0Admppatch 2%0A@@ -0,0 +1,94 @@%0A+package main%250A%250Aimport (%250A%2509%2522fmt%2522%250A)%250A%250Afunc main() %257B%250A%2509fmt.Println(%2522hello world, second version!%2522)%250A%257D%250A%0Atreehash a0b37dfb7b79f877a922aa4aecc4d9d2a91c4db0f6e337caddbee6bf89f5f0fd%0A
 %60,%0A%09%09%7D,%0A
+ f 1b239e494fa201667627de82f0e4dc27b7b00b6ec06146e4d062730bf3762141 patchfile/testdata/hellomove2/hellomove.go
dmppatch 2
@@ -0,0 +1,94 @@
+package main%0A%0Aimport (%0A%09%22fmt%22%0A)%0A%0Afunc main() %7B%0A%09fmt.Println(%22hello world, second version!%22)%0A%7D%0A
treehash 29fd9a6001eecd30acae48befe63a3eea303037c9e0a430be1a4462513f8078b
