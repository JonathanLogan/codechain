diff --git a/.codechain/tree/a/command/review.go b/.codechain/tree/b/command/review.go
index fb80913..7c87182 100644
--- a/.codechain/tree/a/command/review.go
+++ b/.codechain/tree/b/command/review.go
@@ -9,6 +9,7 @@ import (
 	"strings"
 
 	"github.com/frankbraun/codechain/hashchain"
+	"github.com/frankbraun/codechain/internal/base64"
 	"github.com/frankbraun/codechain/tree"
 	"github.com/frankbraun/codechain/util/git"
 	"github.com/frankbraun/codechain/util/interrupt"
@@ -24,11 +25,13 @@ func review(c *hashchain.HashChain, secKeyFile, treeHash string) error {
 	}
 
 	// get last tree hashes
-	signedTreeHash, idx := c.LastSignedTreeHash()
-	if signedTreeHash == c.LastTreeHash() {
-		fmt.Printf("%s: already signed\n", signedTreeHash)
-		return nil
-	}
+	_, idx := c.LastSignedTreeHash()
+	/*
+		if signedTreeHash == c.LastTreeHash() {
+			fmt.Printf("%s: already signed\n", signedTreeHash)
+			return nil
+		}
+	*/
 	treeHashes := c.TreeHashes()
 	treeComments := c.TreeComments()
 	if len(treeHashes) != len(treeComments) {
@@ -65,8 +68,88 @@ func review(c *hashchain.HashChain, secKeyFile, treeHash string) error {
 		}
 	}
 
-	// TODO: also show commits which have been signed, but not by this signer
-	// TODO: show changes in signers/sigctl!
+	// show changes in signers/sigctl
+	var signed bool
+	pubKey := base64.Encode(secKey[32:])
+	infos, err := c.UnsignedInfo(pubKey, treeHash, true)
+	if err != nil {
+		return err
+	}
+	if len(infos) > 0 {
+		fmt.Println("signer/sigctl changes:")
+		for _, info := range infos {
+			fmt.Println(info)
+		}
+		for {
+			fmt.Print("confirm signer/sigctl changes? [y/n]: ")
+			answer, err := terminal.ReadLine(os.Stdin)
+			if err != nil {
+				return err
+			}
+			a := string(bytes.ToLower(answer))
+			if strings.HasPrefix(a, "y") {
+				signed = true
+				break
+			} else if strings.HasPrefix(a, "n") {
+				return errors.New("aborted")
+			} else {
+				fmt.Println("answer not recognized")
+			}
+		}
+	}
+
+	// show commits which have been signed, but not by this signer
+	barrier := c.SignerBarrier(pubKey)
+	// TODO: deduplicate code
+outer:
+	for i := 1; i <= idx; i++ {
+		if c.SourceLine(treeHashes[i]) > barrier {
+			// show patche info
+			pub, comment := c.SignerInfo(treeHashes[i])
+			fmt.Printf("patch %d/%d\n", i-idx, len(treeHashes)-idx-1)
+			if treeComments[i] != "" {
+				fmt.Println(treeComments[i])
+			}
+			fmt.Printf("developer: %s\n", pub)
+			if comment != "" {
+				fmt.Println(comment)
+			}
+			for {
+				fmt.Print("review already signed patch (no continues)? [y/n]: ")
+				answer, err := terminal.ReadLine(os.Stdin)
+				if err != nil {
+					return err
+				}
+				a := string(bytes.ToLower(answer))
+				if strings.HasPrefix(a, "y") {
+					break
+				} else if strings.HasPrefix(a, "n") {
+					continue outer
+				} else {
+					fmt.Println("answer not recognized")
+				}
+			}
+
+			// bring .codechain/tree/a in sync
+			log.Println("bring .codechain/tree/a in sync")
+			err = tree.Sync(treeDirA, treeHashes[i-1], patchDir, treeHashes, excludePaths, true)
+			if err != nil {
+				return err
+			}
+
+			// bring .codechain/tree/b in sync
+			log.Println("bring .codechain/tree/b in sync")
+			err = tree.Sync(treeDirB, treeHashes[i], patchDir, treeHashes, excludePaths, true)
+			if err != nil {
+				return err
+			}
+
+			// display diff *pager
+			if err := git.DiffPager(treeDirA, treeDirB); err != nil {
+				return err
+			}
+		}
+	}
 
 	for i := idx + 1; i < len(treeHashes); i++ {
 		// bring .codechain/tree/a in sync
@@ -83,7 +166,7 @@ func review(c *hashchain.HashChain, secKeyFile, treeHash string) error {
 			return err
 		}
 
-		// show patches info
+		// show patche info
 		pub, comment := c.SignerInfo(treeHashes[i])
 		fmt.Printf("patch %d/%d\n", i-idx, len(treeHashes)-idx-1)
 		if treeComments[i] != "" {
@@ -94,13 +177,14 @@ func review(c *hashchain.HashChain, secKeyFile, treeHash string) error {
 			fmt.Println(comment)
 		}
 		for {
-			fmt.Print("review patch? [y/n]: ")
+			fmt.Print("review patch (no aborts)? [y/n]: ")
 			answer, err := terminal.ReadLine(os.Stdin)
 			if err != nil {
 				return err
 			}
 			a := string(bytes.ToLower(answer))
 			if strings.HasPrefix(a, "y") {
+				signed = true
 				break
 			} else if strings.HasPrefix(a, "n") {
 				return errors.New("aborted")
@@ -132,6 +216,26 @@ func review(c *hashchain.HashChain, secKeyFile, treeHash string) error {
 		}
 	}
 
+	if !signed {
+		for {
+			fmt.Println("no new signer/sigctl changes or source publications to sign")
+			fmt.Print("sign anyway? [y/n]: ")
+			answer, err := terminal.ReadLine(os.Stdin)
+			if err != nil {
+				return err
+			}
+			a := string(bytes.ToLower(answer))
+			if strings.HasPrefix(a, "y") {
+				signed = true
+				break
+			} else if strings.HasPrefix(a, "n") {
+				return errors.New("aborted")
+			} else {
+				fmt.Println("answer not recognized")
+			}
+		}
+	}
+
 	// sign patches and add to hash chain
 	var linkHash [32]byte
 	if treeHash != "" {
diff --git a/.codechain/tree/a/command/status.go b/.codechain/tree/b/command/status.go
index 906914e..9a9b677 100644
--- a/.codechain/tree/a/command/status.go
+++ b/.codechain/tree/b/command/status.go
@@ -37,7 +37,7 @@ func showSignedReleases(c *hashchain.HashChain) {
 }
 
 func showUnsigned(c *hashchain.HashChain) error {
-	infos, err := c.UnsignedInfo("", false)
+	infos, err := c.UnsignedInfo("", "", false)
 	if err != nil {
 		return err
 	}
diff --git a/.codechain/tree/a/hashchain/hashchain.go b/.codechain/tree/b/hashchain/hashchain.go
index db044d3..eee5d58 100644
--- a/.codechain/tree/a/hashchain/hashchain.go
+++ b/.codechain/tree/b/hashchain/hashchain.go
@@ -93,6 +93,11 @@ func (c *HashChain) LinkHash(treeHash string) [32]byte {
 	return c.state.LinkHash(treeHash)
 }
 
+// SourceLine returns the line number where the given tree hash was signed.
+func (c *HashChain) SourceLine(treeHash string) int {
+	return c.state.SourceLine(treeHash)
+}
+
 // EntryHash returns the entry hash for the given treeHash.
 func (c *HashChain) EntryHash(treeHash [32]byte) [32]byte {
 	var h [32]byte
@@ -104,6 +109,10 @@ func (c *HashChain) EntryHash(treeHash [32]byte) [32]byte {
 // entries suitable for printing.
 // If TreeHash is defined it returns info until that treeHash.
 // If omitSource is true source lines are omitted
-func (c *HashChain) UnsignedInfo(treeHash string, omitSource bool) ([]string, error) {
-	return c.state.UnsignedInfo(treeHash, omitSource)
+func (c *HashChain) UnsignedInfo(pubkey, treeHash string, omitSource bool) ([]string, error) {
+	return c.state.UnsignedInfo(pubkey, treeHash, omitSource)
+}
+
+func (c *HashChain) SignerBarrier(pubKey string) int {
+	return c.state.SignerBarrier(pubKey)
 }
diff --git a/.codechain/tree/a/hashchain/internal/state/state.go b/.codechain/tree/b/hashchain/internal/state/state.go
index b4a5fa9..4b4ad7a 100644
--- a/.codechain/tree/a/hashchain/internal/state/state.go
+++ b/.codechain/tree/b/hashchain/internal/state/state.go
@@ -8,6 +8,7 @@ import (
 	"github.com/frankbraun/codechain/internal/base64"
 	"github.com/frankbraun/codechain/internal/hex"
 	"github.com/frankbraun/codechain/tree"
+	"github.com/frankbraun/codechain/util/log"
 )
 
 // State hold the state of a hashchain.
@@ -181,9 +182,9 @@ func (s *State) TreeComments() []string {
 	return treeComments
 }
 
-// LastWeight returns the last weight added for given pubKey (unconfirmed or
+// lastWeight returns the last weight added for given pubKey (unconfirmed or
 // confirmed).
-func (s *State) LastWeight(pubKey [32]byte) (int, error) {
+func (s *State) lastWeight(pubKey [32]byte) (int, error) {
 	pub := base64.Encode(pubKey[:])
 	for i := len(s.unconfirmedOPs) - 1; i > s.signedLine; i-- {
 		switch op := s.unconfirmedOPs[i].(type) {
@@ -242,10 +243,38 @@ func (s *State) AddSigner(pubKey [32]byte, weight int, comment string) {
 
 // RemoveSigner removes pubKey with weight (must equal last addition) from
 // state (unconfirmed).
-func (s *State) RemoveSigner(pubKey [32]byte, weight int) {
+func (s *State) RemoveSigner(pubKey [32]byte) error {
 	pub := base64.Encode(pubKey[:])
-	op := newRemKeyOP(pub, weight)
+	w, err := s.lastWeight(pubKey)
+	if err != nil {
+		return err
+	}
+	op := newRemKeyOP(pub, w)
+
+	m := s.m
+	n := s.n
+	for i := s.signedLine + 1; i < len(s.unconfirmedOPs); i++ {
+		switch op := s.unconfirmedOPs[i].(type) {
+		case *noOP:
+			continue
+		case *sourceOP:
+			continue
+		case *addKeyOP:
+			n += op.weight
+		case *remKeyOP:
+			n -= op.weight
+		case *sigCtlOp:
+			m = op.m
+		default:
+			return errors.New("state: RemoveSigner(): unknown OP type")
+		}
+	}
+	if n-w < m {
+		return errors.New("remkey would lead to n < m, lower sigctl first")
+	}
 	s.unconfirmedOPs = append(s.unconfirmedOPs, op)
+	return nil
+
 }
 
 // SetSignatureControl sets new signature control m (unconfirmed).
@@ -266,10 +295,21 @@ func (s *State) Sign(linkHash, pubKey [32]byte) error {
 	if !ok {
 		return errors.New("state: Sign(): unknown pubKey")
 	}
-	// sign lines
-	for i := s.signedLine + 1; i <= line; i++ {
+	// make sure this pubkey hasn't already signed
+	log.Printf("state.Sign(): pubKey=%s", pub)
+	log.Printf("state.Sign(): line=%d", line)
+	log.Printf("state.Sign(): signerBarrier=%d", s.signerBarriers[pub])
+	/* let him sign again?
+	if line <= s.signerBarriers[pub]+1 {
+		return errors.New("this pubkey has already signed")
+	}
+	*/
+	// sign lines not signed by this signer yet
+	for i := s.signerBarriers[pub] + 1; i <= line; i++ {
 		s.unconfirmedOPs[i].sign(weight)
 	}
+	s.signerBarriers[pub] = line
+	log.Printf("state.Sign(): signerBarrier=%d", s.signerBarriers[pub])
 	// check if we can commit stuff
 	var i int
 	for i = s.signedLine + 1; i <= line; i++ {
@@ -306,7 +346,6 @@ func (s *State) Sign(linkHash, pubKey [32]byte) error {
 		}
 	}
 	s.signedLine = i - 1
-	s.signerBarriers[pub] = i - 1
 	s.unconfirmedOPs = append(s.unconfirmedOPs, nop)
 	return nil
 }
@@ -315,13 +354,17 @@ func (s *State) Sign(linkHash, pubKey [32]byte) error {
 // entries suitable for printing.
 // If TreeHash is defined it returns info until that treeHash.
 // If omitSource is true source lines are omitted
-func (s *State) UnsignedInfo(treeHash string, omitSource bool) ([]string, error) {
+func (s *State) UnsignedInfo(pubKey, treeHash string, omitSource bool) ([]string, error) {
 	var infos []string
 	end := len(s.unconfirmedOPs)
 	if treeHash != "" {
 		end = s.SourceLine(treeHash)
 	}
-	for i := s.signedLine + 1; i < end; i++ {
+	i := s.signedLine + 1
+	if pubKey != "" {
+		i = s.signerBarriers[pubKey] + 1
+	}
+	for ; i < end; i++ {
 		switch op := s.unconfirmedOPs[i].(type) {
 		case *noOP:
 			continue
@@ -329,17 +372,17 @@ func (s *State) UnsignedInfo(treeHash string, omitSource bool) ([]string, error)
 			if omitSource {
 				continue
 			}
-			info := fmt.Sprintf("source %s %s", op.treeHash, op.comment)
+			info := fmt.Sprintf("%d source %s %s", op.signatures(), op.treeHash, op.comment)
 			infos = append(infos, info)
 		case *addKeyOP:
-			info := fmt.Sprintf("addkey %d %s %s", op.weight, op.pubKey, op.comment)
+			info := fmt.Sprintf("%d addkey %d %s %s", op.signatures(), op.weight, op.pubKey, op.comment)
 			infos = append(infos, info)
 		case *remKeyOP:
-			info := fmt.Sprintf("remkey %d %s %s", op.weight, op.pubKey,
+			info := fmt.Sprintf("%d remkey %d %s %s", op.signatures(), op.weight, op.pubKey,
 				s.signerComments[op.pubKey]) // shows only comments from already confirmed signers, but that's fine
 			infos = append(infos, info)
 		case *sigCtlOp:
-			info := fmt.Sprintf("sigctl %d", op.m)
+			info := fmt.Sprintf("%d sigctl %d", op.signatures(), op.m)
 			infos = append(infos, info)
 		default:
 			return nil, errors.New("state: Sign(): unknown OP type")
@@ -347,3 +390,7 @@ func (s *State) UnsignedInfo(treeHash string, omitSource bool) ([]string, error)
 	}
 	return infos, nil
 }
+
+func (s *State) SignerBarrier(pubKey string) int {
+	return s.signerBarriers[pubKey]
+}
diff --git a/.codechain/tree/a/hashchain/read.go b/.codechain/tree/b/hashchain/read.go
index a7f2168..91f405c 100644
--- a/.codechain/tree/a/hashchain/read.go
+++ b/.codechain/tree/b/hashchain/read.go
@@ -31,6 +31,7 @@ func Read(filename string) (*HashChain, error) {
 	}
 	c.fp, err = os.OpenFile(filename, os.O_RDWR|os.O_APPEND, 0644)
 	if err != nil {
+		c.lock.Release()
 		return nil, err
 	}
 
@@ -42,12 +43,14 @@ func Read(filename string) (*HashChain, error) {
 		line := strings.SplitN(text, " ", 4)
 		previous, err := hex.Decode(line[0], 32)
 		if err != nil {
+			c.lock.Release()
 			return nil, err
 		}
 		var prev [32]byte
 		copy(prev[:], previous)
 		t, err := time.Parse(line[1])
 		if err != nil {
+			c.lock.Release()
 			return nil, fmt.Errorf("hashchain: cannot parse time '%s': %s", line[1], err)
 		}
 		l := &link{
@@ -57,16 +60,19 @@ func Read(filename string) (*HashChain, error) {
 			typeFields: strings.SplitN(line[3], " ", 4),
 		}
 		if l.String() != text {
+			c.lock.Release()
 			return nil, fmt.Errorf("hashchain: cannot reproduce line:\n%s", text)
 		}
 		c.chain = append(c.chain, l)
 	}
 	if err := s.Err(); err != nil {
+		c.lock.Release()
 		return nil, err
 	}
 
 	// verify
 	if err := c.verify(); err != nil {
+		c.lock.Release()
 		return nil, err
 	}
 	return &c, nil
diff --git a/.codechain/tree/a/hashchain/start.go b/.codechain/tree/b/hashchain/start.go
index 00fe0bc..a879d13 100644
--- a/.codechain/tree/a/hashchain/start.go
+++ b/.codechain/tree/b/hashchain/start.go
@@ -33,12 +33,14 @@ func Start(filename string, secKey [64]byte, comment []byte) (*HashChain, string
 	}
 	c.fp, err = os.Create(filename)
 	if err != nil {
+		c.lock.Release()
 		return nil, "", err
 	}
 
 	// create signature
 	var nonce [24]byte
 	if _, err := io.ReadFull(rand.Reader, nonce[:]); err != nil {
+		c.lock.Release()
 		return nil, "", err
 	}
 	pub := secKey[32:]
@@ -67,12 +69,14 @@ func Start(filename string, secKey [64]byte, comment []byte) (*HashChain, string
 
 	// verify
 	if err := c.verify(); err != nil {
+		c.lock.Release()
 		return nil, "", err
 	}
 
 	// save
 	entry := l.String()
 	if _, err := fmt.Fprintln(c.fp, entry); err != nil {
+		c.lock.Release()
 		return nil, "", err
 	}
 	return &c, entry, nil
diff --git a/.codechain/tree/a/hashchain/verify.go b/.codechain/tree/b/hashchain/verify.go
index cd46889..7d86c35 100644
--- a/.codechain/tree/a/hashchain/verify.go
+++ b/.codechain/tree/b/hashchain/verify.go
@@ -11,11 +11,13 @@ import (
 	"github.com/frankbraun/codechain/hashchain/linktype"
 	"github.com/frankbraun/codechain/internal/base64"
 	"github.com/frankbraun/codechain/internal/hex"
+	"github.com/frankbraun/codechain/util/log"
 	"golang.org/x/crypto/ed25519"
 )
 
 // hash-of-previous current-time cstart pubkey nonce signature [comment]
 func (c *HashChain) verifyChainStartType(i int, fields []string) error {
+	log.Printf("%d verify cstart", i)
 	// check arguments
 	if i != 0 {
 		return ErrIllegalCStart
@@ -57,6 +59,7 @@ func (c *HashChain) verifyChainStartType(i int, fields []string) error {
 
 // hash-of-previous current-time source source-hash pubkey signature [comment]
 func (c *HashChain) verifySourceType(i int, fields []string) error {
+	log.Printf("%d verify source", i)
 	// check arguments
 	if i == 0 {
 		return ErrMustStartWithCStart
@@ -106,6 +109,7 @@ func (c *HashChain) verifySourceType(i int, fields []string) error {
 
 // hash-of-previous current-time signtr hash-of-chain-entry pubkey signature
 func (c *HashChain) verifySignatureType(i int, fields []string) error {
+	log.Printf("%d verify signtr", i)
 	// check arguments
 	if i == 0 {
 		return ErrMustStartWithCStart
@@ -149,6 +153,7 @@ func (c *HashChain) verifySignatureType(i int, fields []string) error {
 
 // hash-of-previous current-time addkey pubkey-add w pubkey signature [comment]
 func (c *HashChain) verifyAddKeyType(i int, fields []string) error {
+	log.Printf("%d verify addkey", i)
 	// check arguments
 	if i == 0 {
 		return ErrMustStartWithCStart
@@ -196,6 +201,7 @@ func (c *HashChain) verifyAddKeyType(i int, fields []string) error {
 
 // hash-of-previous current-time remkey pubkey
 func (c *HashChain) verifyRemoveKeyType(i int, fields []string) error {
+	log.Printf("%d verify remkey", i)
 	// check arguments
 	if i == 0 {
 		return ErrMustStartWithCStart
@@ -211,22 +217,15 @@ func (c *HashChain) verifyRemoveKeyType(i int, fields []string) error {
 		return err
 	}
 
-	// validate fields
+	// update state
 	var p [32]byte
 	copy(p[:], pubKey)
-	w, err := c.state.LastWeight(p)
-	if err != nil {
-		return err
-	}
-
-	// update state
-	c.state.RemoveSigner(p, w)
-
-	return nil
+	return c.state.RemoveSigner(p)
 }
 
 // hash-of-previous current-time sigctl m
 func (c *HashChain) verifySignatureControlType(i int, fields []string) error {
+	log.Printf("%d verify sigctl", i)
 	// check arguments
 	if i == 0 {
 		return ErrMustStartWithCStart
