codechain patchfile version 1
treehash d6a0846709f73516bddc9baafa501cf40013bdc667799274a32698297f487da9
- f b3ada8e58dcd0f01191b0c5c9a7458a3a72cb12900fc0b1473788b0a5382cfa1 Gopkg.lock
+ f 47c14b7940ca6987436c0ff2f1ca07b5b4c5a679ec09b242dd9a0c1965ab0973 Gopkg.lock
dmppatch 19
@@ -999,24 +999,47 @@
 ards25519%22,%0A
+    %22internal/subtle%22,%0A
     %22nacl/se
@@ -1112,64 +1112,64 @@
   %5D%0A
-  revision = %221a580b3eff7814fc9b40602fd35256c63b50f491%22%0A
+  revision = %22de0752318171da717af4ce24d0a2e8626afaeb11%22%0A
 %0A%5B%5Bp
@@ -1286,64 +1286,64 @@
   %5D%0A
-  revision = %227c87d13f8e835d2fb3a70a2912c811ed0c1d241b%22%0A
+  revision = %224e1fef5609515ec7a2cee7b5de30ba6d9b438cbf%22%0A
 %0A%5Bso
@@ -1403,93 +1403,93 @@
 = 1%0A
-  inputs-digest = %22eba0cf7bcedd98584f04ccc7ab8b051df38cdd53b95713e3fb58c762ae5b85f2%22%0A
+  inputs-digest = %22799f18a038d12fed4790aa7798e08ae76406ba85f1e26c166968f925773e6893%22%0A
   so
- f a8351b3485cd92393aa085ae53734bd1c744b2ce39935906b9df36ef6937497b Gopkg.toml
+ f 213f45665dec4e489bd0956ea25a68c07545ccc4f5b8aa2bc96a3a45378b2d96 Gopkg.toml
dmppatch 9
@@ -20,69 +20,80 @@
 e%0A#%0A
-# Refer to https://golang.github.io/dep/docs/Gopkg.toml.html%0A
+# Refer to https://github.com/golang/dep/blob/master/docs/Gopkg.toml.md%0A
 # fo
@@ -607,16 +607,230 @@
 = true%0A%0A
+%0A%5B%5Bconstraint%5D%5D%0A  name = %22github.com/fatih/color%22%0A  version = %221.7.0%22%0A%0A%5B%5Bconstraint%5D%5D%0A  branch = %22master%22%0A  name = %22github.com/mutecomm/mute%22%0A%0A%5B%5Bconstraint%5D%5D%0A  name = %22github.com/sergi/go-diff%22%0A  version = %221.0.0%22%0A
 %0A%5B%5Bconst
- f e88369f31b391bfca3409bf8fca49d6b04666dd33371f06ba1f4aa14b0985e12 Makefile
+ f a3c852d5cf9b0eca04f59f8e62102f1a5200819277c11425e9c41bcfde121c8f Makefile
dmppatch 8
@@ -54,21 +54,35 @@
 ..%0A%0A
-.PHONY: test%0A
+.PHONY: test update-vendor%0A
 test
@@ -136,8 +136,131 @@
 k -g -c%0A
+%0Aupdate-vendor:%0A%09rm -f Gopkg.lock Gopkg.toml%0A%09rm -rf vendor%0A%09dep init -v%0A%09slimdep -r -v -a github.com/frankbraun/codechain%0A
- f 72ede448ddf83009883760cdfdcc0e5ed7732cd8e27ff9f7bea4159e0c331358 README.md
+ f d60d8e8c8500099b7865a6580168ea8120942b891a37ebfffd8bb725180443be README.md
dmppatch 4
@@ -2422,16 +2422,93 @@
 ugh.md)%0A
+- %5BPresentation about Codechain%5D(http://frankbraun.org/in-code-we-trust.pdf)%0A
 %0A### Ack
- f da7ee3ee7bb5e9bdfc179e4ded94a55a4542ea68f1c334fd125a0e9c775c8787 hashchain/hashchain.go
+ f 31f718193c9a7b6bf69002eea44384ac7cfa03372203fa210ec0c23d800f94c4 hashchain/hashchain.go
dmppatch 5
@@ -1315,65 +1315,141 @@
 %0A%7D%0A%0A
-// LastSignedTreeHash returns the last signed tree hash.%0A
+// LastSignedTreeHash returns the last signed tree hash and its index.%0A// The first signed tree hash is tree.EmptyHash with index 0.%0A
 func
- f c1158f7d12c6f75bd9ee20485493d65deb1a9643cf555cf5ba5b13546b2e20f7 hashchain/signature.go
+ f 417e281f986675474591971be2f697445ef8f8286f571d06fa9e57c0e6edcd4c hashchain/signature.go
dmppatch 4
@@ -1519,16 +1519,81 @@
 ached %7B%0A
+%09%09c.chain = c.chain%5B:len(c.chain)-1%5D // remove chain entry again%0A
 %09%09return
- f abc3b13187b1d0af6f264b7590a97d9ba44bae86d173f4f1c3a7242180abd767 vendor/github.com/fatih/color/color.go
+ f bf9815c57c4ce33b5742f1561ef3c9993af39aa406d8d90595ec57ca699e3f63 vendor/github.com/fatih/color/color.go
dmppatch 43
@@ -28,14 +28,8 @@
 mt%22%0A
-%09%22io%22%0A
 %09%22os
@@ -1699,298 +1699,8 @@
 %0A)%0A%0A
-// Background text colors%0Aconst (%0A%09BgBlack Attribute = iota + 40%0A%09BgRed%0A%09BgGreen%0A%09BgYellow%0A%09BgBlue%0A%09BgMagenta%0A%09BgCyan%0A%09BgWhite%0A)%0A%0A// Background Hi-Intensity text colors%0Aconst (%0A%09BgHiBlack Attribute = iota + 100%0A%09BgHiRed%0A%09BgHiGreen%0A%09BgHiYellow%0A%09BgHiBlue%0A%09BgHiMagenta%0A%09BgHiCyan%0A%09BgHiWhite%0A)%0A%0A
 // N
@@ -1855,914 +1855,8 @@
 %0A%7D%0A%0A
-// Set sets the given parameters immediately. It will change the color of%0A// output with the given SGR parameters until color.Unset() is called.%0Afunc Set(p ...Attribute) *Color %7B%0A%09c := New(p...)%0A%09c.Set()%0A%09return c%0A%7D%0A%0A// Unset resets all escape attributes and clears the output. Usually should%0A// be called after Set().%0Afunc Unset() %7B%0A%09if NoColor %7B%0A%09%09return%0A%09%7D%0A%0A%09fmt.Fprintf(Output, %22%25s%5B%25dm%22, escape, Reset)%0A%7D%0A%0A// Set sets the SGR sequence.%0Afunc (c *Color) Set() *Color %7B%0A%09if c.isNoColorSet() %7B%0A%09%09return c%0A%09%7D%0A%0A%09fmt.Fprintf(Output, c.format())%0A%09return c%0A%7D%0A%0Afunc (c *Color) unset() %7B%0A%09if c.isNoColorSet() %7B%0A%09%09return%0A%09%7D%0A%0A%09Unset()%0A%7D%0A%0Afunc (c *Color) setWriter(w io.Writer) *Color %7B%0A%09if c.isNoColorSet() %7B%0A%09%09return c%0A%09%7D%0A%0A%09fmt.Fprintf(w, c.format())%0A%09return c%0A%7D%0A%0Afunc (c *Color) unsetWriter(w io.Writer) %7B%0A%09if c.isNoColorSet() %7B%0A%09%09return%0A%09%7D%0A%0A%09if NoColor %7B%0A%09%09return%0A%09%7D%0A%0A%09fmt.Fprintf(w, %22%25s%5B%25dm%22, escape, Reset)%0A%7D%0A%0A
 // A
@@ -2113,4649 +2113,8 @@
 %0A%7D%0A%0A
-func (c *Color) prepend(value Attribute) %7B%0A%09c.params = append(c.params, 0)%0A%09copy(c.params%5B1:%5D, c.params%5B0:%5D)%0A%09c.params%5B0%5D = value%0A%7D%0A%0A// Fprint formats using the default formats for its operands and writes to w.%0A// Spaces are added between operands when neither is a string.%0A// It returns the number of bytes written and any write error encountered.%0A// On Windows, users should wrap w with colorable.NewColorable() if w is of%0A// type *os.File.%0Afunc (c *Color) Fprint(w io.Writer, a ...interface%7B%7D) (n int, err error) %7B%0A%09c.setWriter(w)%0A%09defer c.unsetWriter(w)%0A%0A%09return fmt.Fprint(w, a...)%0A%7D%0A%0A// Print formats using the default formats for its operands and writes to%0A// standard output. Spaces are added between operands when neither is a%0A// string. It returns the number of bytes written and any write error%0A// encountered. This is the standard fmt.Print() method wrapped with the given%0A// color.%0Afunc (c *Color) Print(a ...interface%7B%7D) (n int, err error) %7B%0A%09c.Set()%0A%09defer c.unset()%0A%0A%09return fmt.Fprint(Output, a...)%0A%7D%0A%0A// Fprintf formats according to a format specifier and writes to w.%0A// It returns the number of bytes written and any write error encountered.%0A// On Windows, users should wrap w with colorable.NewColorable() if w is of%0A// type *os.File.%0Afunc (c *Color) Fprintf(w io.Writer, format string, a ...interface%7B%7D) (n int, err error) %7B%0A%09c.setWriter(w)%0A%09defer c.unsetWriter(w)%0A%0A%09return fmt.Fprintf(w, format, a...)%0A%7D%0A%0A// Printf formats according to a format specifier and writes to standard output.%0A// It returns the number of bytes written and any write error encountered.%0A// This is the standard fmt.Printf() method wrapped with the given color.%0Afunc (c *Color) Printf(format string, a ...interface%7B%7D) (n int, err error) %7B%0A%09c.Set()%0A%09defer c.unset()%0A%0A%09return fmt.Fprintf(Output, format, a...)%0A%7D%0A%0A// Fprintln formats using the default formats for its operands and writes to w.%0A// Spaces are always added between operands and a newline is appended.%0A// On Windows, users should wrap w with colorable.NewColorable() if w is of%0A// type *os.File.%0Afunc (c *Color) Fprintln(w io.Writer, a ...interface%7B%7D) (n int, err error) %7B%0A%09c.setWriter(w)%0A%09defer c.unsetWriter(w)%0A%0A%09return fmt.Fprintln(w, a...)%0A%7D%0A%0A// Println formats using the default formats for its operands and writes to%0A// standard output. Spaces are always added between operands and a newline is%0A// appended. It returns the number of bytes written and any write error%0A// encountered. This is the standard fmt.Print() method wrapped with the given%0A// color.%0Afunc (c *Color) Println(a ...interface%7B%7D) (n int, err error) %7B%0A%09c.Set()%0A%09defer c.unset()%0A%0A%09return fmt.Fprintln(Output, a...)%0A%7D%0A%0A// Sprint is just like Print, but returns a string instead of printing it.%0Afunc (c *Color) Sprint(a ...interface%7B%7D) string %7B%0A%09return c.wrap(fmt.Sprint(a...))%0A%7D%0A%0A// Sprintln is just like Println, but returns a string instead of printing it.%0Afunc (c *Color) Sprintln(a ...interface%7B%7D) string %7B%0A%09return c.wrap(fmt.Sprintln(a...))%0A%7D%0A%0A// Sprintf is just like Printf, but returns a string instead of printing it.%0Afunc (c *Color) Sprintf(format string, a ...interface%7B%7D) string %7B%0A%09return c.wrap(fmt.Sprintf(format, a...))%0A%7D%0A%0A// FprintFunc returns a new function that prints the passed arguments as%0A// colorized with color.Fprint().%0Afunc (c *Color) FprintFunc() func(w io.Writer, a ...interface%7B%7D) %7B%0A%09return func(w io.Writer, a ...interface%7B%7D) %7B%0A%09%09c.Fprint(w, a...)%0A%09%7D%0A%7D%0A%0A// PrintFunc returns a new function that prints the passed arguments as%0A// colorized with color.Print().%0Afunc (c *Color) PrintFunc() func(a ...interface%7B%7D) %7B%0A%09return func(a ...interface%7B%7D) %7B%0A%09%09c.Print(a...)%0A%09%7D%0A%7D%0A%0A// FprintfFunc returns a new function that prints the passed arguments as%0A// colorized with color.Fprintf().%0Afunc (c *Color) FprintfFunc() func(w io.Writer, format string, a ...interface%7B%7D) %7B%0A%09return func(w io.Writer, format string, a ...interface%7B%7D) %7B%0A%09%09c.Fprintf(w, format, a...)%0A%09%7D%0A%7D%0A%0A// PrintfFunc returns a new function that prints the passed arguments as%0A// colorized with color.Printf().%0Afunc (c *Color) PrintfFunc() func(format string, a ...interface%7B%7D) %7B%0A%09return func(format string, a ...interface%7B%7D) %7B%0A%09%09c.Printf(format, a...)%0A%09%7D%0A%7D%0A%0A// FprintlnFunc returns a new function that prints the passed arguments as%0A// colorized with color.Fprintln().%0Afunc (c *Color) FprintlnFunc() func(w io.Writer, a ...interface%7B%7D) %7B%0A%09return func(w io.Writer, a ...interface%7B%7D) %7B%0A%09%09c.Fprintln(w, a...)%0A%09%7D%0A%7D%0A%0A// PrintlnFunc returns a new function that prints the passed arguments as%0A// colorized with color.Println().%0Afunc (c *Color) PrintlnFunc() func(a ...interface%7B%7D) %7B%0A%09return func(a ...interface%7B%7D) %7B%0A%09%09c.Println(a...)%0A%09%7D%0A%7D%0A%0A
 // S
@@ -2999,383 +2999,8 @@
 %0A%7D%0A%0A
-// SprintlnFunc returns a new function that returns colorized strings for the%0A// given arguments with fmt.Sprintln(). Useful to put into or mix into other%0A// string. Windows users should use this in conjunction with color.Output.%0Afunc (c *Color) SprintlnFunc() func(a ...interface%7B%7D) string %7B%0A%09return func(a ...interface%7B%7D) string %7B%0A%09%09return c.wrap(fmt.Sprintln(a...))%0A%09%7D%0A%7D%0A%0A
 // s
@@ -3696,466 +3696,8 @@
 %0A%7D%0A%0A
-// DisableColor disables the color output. Useful to not change any existing%0A// code and still being able to output. Can be used for flags like%0A// %22--no-color%22. To enable back use EnableColor() method.%0Afunc (c *Color) DisableColor() %7B%0A%09c.noColor = boolPtr(true)%0A%7D%0A%0A// EnableColor enables the color output. Use it in conjunction with%0A// DisableColor(). Otherwise this method has no side effects.%0Afunc (c *Color) EnableColor() %7B%0A%09c.noColor = boolPtr(false)%0A%7D%0A%0A
 func
@@ -3912,462 +3912,8 @@
 %0A%7D%0A%0A
-// Equals returns a boolean value indicating whether two colors are equal.%0Afunc (c *Color) Equals(c2 *Color) bool %7B%0A%09if len(c.params) != len(c2.params) %7B%0A%09%09return false%0A%09%7D%0A%0A%09for _, attr := range c.params %7B%0A%09%09if !c2.attrExists(attr) %7B%0A%09%09%09return false%0A%09%09%7D%0A%09%7D%0A%0A%09return true%0A%7D%0A%0Afunc (c *Color) attrExists(a Attribute) bool %7B%0A%09for _, attr := range c.params %7B%0A%09%09if attr == a %7B%0A%09%09%09return true%0A%09%09%7D%0A%09%7D%0A%0A%09return false%0A%7D%0A%0Afunc boolPtr(v bool) *bool %7B%0A%09return &v%0A%7D%0A%0A
 func
@@ -4093,234 +4093,8 @@
 %0A%7D%0A%0A
-func colorPrint(format string, p Attribute, a ...interface%7B%7D) %7B%0A%09c := getCachedColor(p)%0A%0A%09if !strings.HasSuffix(format, %22%5Cn%22) %7B%0A%09%09format += %22%5Cn%22%0A%09%7D%0A%0A%09if len(a) == 0 %7B%0A%09%09c.Print(format)%0A%09%7D else %7B%0A%09%09c.Printf(format, a...)%0A%09%7D%0A%7D%0A%0A
 func
@@ -4285,1824 +4285,8 @@
 %0A%7D%0A%0A
-// Black is a convenient helper function to print with black foreground. A%0A// newline is appended to format by default.%0Afunc Black(format string, a ...interface%7B%7D) %7B colorPrint(format, FgBlack, a...) %7D%0A%0A// Red is a convenient helper function to print with red foreground. A%0A// newline is appended to format by default.%0Afunc Red(format string, a ...interface%7B%7D) %7B colorPrint(format, FgRed, a...) %7D%0A%0A// Green is a convenient helper function to print with green foreground. A%0A// newline is appended to format by default.%0Afunc Green(format string, a ...interface%7B%7D) %7B colorPrint(format, FgGreen, a...) %7D%0A%0A// Yellow is a convenient helper function to print with yellow foreground.%0A// A newline is appended to format by default.%0Afunc Yellow(format string, a ...interface%7B%7D) %7B colorPrint(format, FgYellow, a...) %7D%0A%0A// Blue is a convenient helper function to print with blue foreground. A%0A// newline is appended to format by default.%0Afunc Blue(format string, a ...interface%7B%7D) %7B colorPrint(format, FgBlue, a...) %7D%0A%0A// Magenta is a convenient helper function to print with magenta foreground.%0A// A newline is appended to format by default.%0Afunc Magenta(format string, a ...interface%7B%7D) %7B colorPrint(format, FgMagenta, a...) %7D%0A%0A// Cyan is a convenient helper function to print with cyan foreground. A%0A// newline is appended to format by default.%0Afunc Cyan(format string, a ...interface%7B%7D) %7B colorPrint(format, FgCyan, a...) %7D%0A%0A// White is a convenient helper function to print with white foreground. A%0A// newline is appended to format by default.%0Afunc White(format string, a ...interface%7B%7D) %7B colorPrint(format, FgWhite, a...) %7D%0A%0A// BlackString is a convenient helper function to return a string with black%0A// foreground.%0Afunc BlackString(format string, a ...interface%7B%7D) string %7B return colorString(format, FgBlack, a...) %7D%0A%0A
 // R
@@ -5654,1996 +5654,8 @@
  %7D%0A%0A
-// HiBlack is a convenient helper function to print with hi-intensity black foreground. A%0A// newline is appended to format by default.%0Afunc HiBlack(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiBlack, a...) %7D%0A%0A// HiRed is a convenient helper function to print with hi-intensity red foreground. A%0A// newline is appended to format by default.%0Afunc HiRed(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiRed, a...) %7D%0A%0A// HiGreen is a convenient helper function to print with hi-intensity green foreground. A%0A// newline is appended to format by default.%0Afunc HiGreen(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiGreen, a...) %7D%0A%0A// HiYellow is a convenient helper function to print with hi-intensity yellow foreground.%0A// A newline is appended to format by default.%0Afunc HiYellow(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiYellow, a...) %7D%0A%0A// HiBlue is a convenient helper function to print with hi-intensity blue foreground. A%0A// newline is appended to format by default.%0Afunc HiBlue(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiBlue, a...) %7D%0A%0A// HiMagenta is a convenient helper function to print with hi-intensity magenta foreground.%0A// A newline is appended to format by default.%0Afunc HiMagenta(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiMagenta, a...) %7D%0A%0A// HiCyan is a convenient helper function to print with hi-intensity cyan foreground. A%0A// newline is appended to format by default.%0Afunc HiCyan(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiCyan, a...) %7D%0A%0A// HiWhite is a convenient helper function to print with hi-intensity white foreground. A%0A// newline is appended to format by default.%0Afunc HiWhite(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiWhite, a...) %7D%0A%0A// HiBlackString is a convenient helper function to return a string with hi-intensity black%0A// foreground.%0Afunc HiBlackString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiBlack, a...)%0A%7D%0A%0A
 // H
@@ -5860,1302 +5860,4 @@
 ) %7D%0A
-%0A// HiGreenString is a convenient helper function to return a string with hi-intensity green%0A// foreground.%0Afunc HiGreenString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiGreen, a...)%0A%7D%0A%0A// HiYellowString is a convenient helper function to return a string with hi-intensity yellow%0A// foreground.%0Afunc HiYellowString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiYellow, a...)%0A%7D%0A%0A// HiBlueString is a convenient helper function to return a string with hi-intensity blue%0A// foreground.%0Afunc HiBlueString(format string, a ...interface%7B%7D) string %7B return colorString(format, FgHiBlue, a...) %7D%0A%0A// HiMagentaString is a convenient helper function to return a string with hi-intensity magenta%0A// foreground.%0Afunc HiMagentaString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiMagenta, a...)%0A%7D%0A%0A// HiCyanString is a convenient helper function to return a string with hi-intensity cyan%0A// foreground.%0Afunc HiCyanString(format string, a ...interface%7B%7D) string %7B return colorString(format, FgHiCyan, a...) %7D%0A%0A// HiWhiteString is a convenient helper function to return a string with hi-intensity white%0A// foreground.%0Afunc HiWhiteString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiWhite, a...)%0A%7D%0A
- f 425540d3fdc6090883587fde8968420a143d24ebcab357ee87f0142445f44936 vendor/github.com/mattn/go-colorable/colorable_appengine.go
+ f ca2e083a4c3bf68be17cd8b5e17cb96f3719fcc392f83b32a42dd429881b5411 vendor/github.com/mattn/go-colorable/colorable_appengine.go
dmppatch 4
@@ -94,227 +94,8 @@
 %0A)%0A%0A
-// NewColorable return new instance of Writer which handle escape sequence.%0Afunc NewColorable(file *os.File) io.Writer %7B%0A%09if file == nil %7B%0A%09%09panic(%22nil passed instead of *os.File to NewColorable()%22)%0A%09%7D%0A%0A%09return file%0A%7D%0A%0A
 // N
- f 4f5fe0d562531fa8d831ae060712cfbfd037ca5937ed348dc42e93fcaa961fa0 vendor/github.com/mattn/go-colorable/colorable_others.go
+ f 3955dadc91c3ad7f77a077383beec43578e1f6cccd5df1cd8c76ca3795264ad1 vendor/github.com/mattn/go-colorable/colorable_others.go
dmppatch 4
@@ -114,227 +114,8 @@
 %0A)%0A%0A
-// NewColorable return new instance of Writer which handle escape sequence.%0Afunc NewColorable(file *os.File) io.Writer %7B%0A%09if file == nil %7B%0A%09%09panic(%22nil passed instead of *os.File to NewColorable()%22)%0A%09%7D%0A%0A%09return file%0A%7D%0A%0A
 // N
- f b40f20990dac6e027ae40b990283636e5994c62cbc7ece287b70c00857fd2378 vendor/github.com/mattn/go-colorable/colorable_windows.go
+ f 4fbc91f5a6bbe903aa61fbe9f6baa40a7b0f33979bcba9b4542a588734dc6482 vendor/github.com/mattn/go-colorable/colorable_windows.go
dmppatch 13
@@ -65,2330 +65,23 @@
 t (%0A
-%09%22bytes%22%0A
 %09%22io%22%0A
-%09%22math%22%0A
 %09%22os%22%0A
-%09%22strconv%22%0A%09%22strings%22%0A%09%22syscall%22%0A%09%22unsafe%22%0A%0A%09%22github.com/mattn/go-isatty%22%0A
 )%0A%0A
-const (%0A%09foregroundBlue      = 0x1%0A%09foregroundGreen     = 0x2%0A%09foregroundRed       = 0x4%0A%09foregroundIntensity = 0x8%0A%09foregroundMask      = (foregroundRed %7C foregroundBlue %7C foregroundGreen %7C foregroundIntensity)%0A%09backgroundBlue      = 0x10%0A%09backgroundGreen     = 0x20%0A%09backgroundRed       = 0x40%0A%09backgroundIntensity = 0x80%0A%09backgroundMask      = (backgroundRed %7C backgroundBlue %7C backgroundGreen %7C backgroundIntensity)%0A)%0A%0Atype wchar uint16%0Atype short int16%0Atype dword uint32%0Atype word uint16%0A%0Atype coord struct %7B%0A%09x short%0A%09y short%0A%7D%0A%0Atype smallRect struct %7B%0A%09left   short%0A%09top    short%0A%09right  short%0A%09bottom short%0A%7D%0A%0Atype consoleScreenBufferInfo struct %7B%0A%09size              coord%0A%09cursorPosition    coord%0A%09attributes        word%0A%09window            smallRect%0A%09maximumWindowSize coord%0A%7D%0A%0Atype consoleCursorInfo struct %7B%0A%09size    dword%0A%09visible int32%0A%7D%0A%0Avar (%0A%09kernel32                       = syscall.NewLazyDLL(%22kernel32.dll%22)%0A%09procGetConsoleScreenBufferInfo = kernel32.NewProc(%22GetConsoleScreenBufferInfo%22)%0A%09procSetConsoleTextAttribute    = kernel32.NewProc(%22SetConsoleTextAttribute%22)%0A%09procSetConsoleCursorPosition   = kernel32.NewProc(%22SetConsoleCursorPosition%22)%0A%09procFillConsoleOutputCharacter = kernel32.NewProc(%22FillConsoleOutputCharacterW%22)%0A%09procFillConsoleOutputAttribute = kernel32.NewProc(%22FillConsoleOutputAttribute%22)%0A%09procGetConsoleCursorInfo       = kernel32.NewProc(%22GetConsoleCursorInfo%22)%0A%09procSetConsoleCursorInfo       = kernel32.NewProc(%22SetConsoleCursorInfo%22)%0A%09procSetConsoleTitle            = kernel32.NewProc(%22SetConsoleTitleW%22)%0A)%0A%0A// Writer provide colorable Writer to the console%0Atype Writer struct %7B%0A%09out     io.Writer%0A%09handle  syscall.Handle%0A%09oldattr word%0A%09oldpos  coord%0A%7D%0A%0A// NewColorable return new instance of Writer which handle escape sequence from File.%0Afunc NewColorable(file *os.File) io.Writer %7B%0A%09if file == nil %7B%0A%09%09panic(%22nil passed instead of *os.File to NewColorable()%22)%0A%09%7D%0A%0A%09if isatty.IsTerminal(file.Fd()) %7B%0A%09%09var csbi consoleScreenBufferInfo%0A%09%09handle := syscall.Handle(file.Fd())%0A%09%09procGetConsoleScreenBufferInfo.Call(uintptr(handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09return &Writer%7Bout: file, handle: handle, oldattr: csbi.attributes, oldpos: coord%7B0, 0%7D%7D%0A%09%7D%0A%09return file%0A%7D%0A%0A
 // N
@@ -411,17997 +411,4 @@
 )%0A%7D%0A
-%0Avar color256 = map%5Bint%5Dint%7B%0A%090:   0x000000,%0A%091:   0x800000,%0A%092:   0x008000,%0A%093:   0x808000,%0A%094:   0x000080,%0A%095:   0x800080,%0A%096:   0x008080,%0A%097:   0xc0c0c0,%0A%098:   0x808080,%0A%099:   0xff0000,%0A%0910:  0x00ff00,%0A%0911:  0xffff00,%0A%0912:  0x0000ff,%0A%0913:  0xff00ff,%0A%0914:  0x00ffff,%0A%0915:  0xffffff,%0A%0916:  0x000000,%0A%0917:  0x00005f,%0A%0918:  0x000087,%0A%0919:  0x0000af,%0A%0920:  0x0000d7,%0A%0921:  0x0000ff,%0A%0922:  0x005f00,%0A%0923:  0x005f5f,%0A%0924:  0x005f87,%0A%0925:  0x005faf,%0A%0926:  0x005fd7,%0A%0927:  0x005fff,%0A%0928:  0x008700,%0A%0929:  0x00875f,%0A%0930:  0x008787,%0A%0931:  0x0087af,%0A%0932:  0x0087d7,%0A%0933:  0x0087ff,%0A%0934:  0x00af00,%0A%0935:  0x00af5f,%0A%0936:  0x00af87,%0A%0937:  0x00afaf,%0A%0938:  0x00afd7,%0A%0939:  0x00afff,%0A%0940:  0x00d700,%0A%0941:  0x00d75f,%0A%0942:  0x00d787,%0A%0943:  0x00d7af,%0A%0944:  0x00d7d7,%0A%0945:  0x00d7ff,%0A%0946:  0x00ff00,%0A%0947:  0x00ff5f,%0A%0948:  0x00ff87,%0A%0949:  0x00ffaf,%0A%0950:  0x00ffd7,%0A%0951:  0x00ffff,%0A%0952:  0x5f0000,%0A%0953:  0x5f005f,%0A%0954:  0x5f0087,%0A%0955:  0x5f00af,%0A%0956:  0x5f00d7,%0A%0957:  0x5f00ff,%0A%0958:  0x5f5f00,%0A%0959:  0x5f5f5f,%0A%0960:  0x5f5f87,%0A%0961:  0x5f5faf,%0A%0962:  0x5f5fd7,%0A%0963:  0x5f5fff,%0A%0964:  0x5f8700,%0A%0965:  0x5f875f,%0A%0966:  0x5f8787,%0A%0967:  0x5f87af,%0A%0968:  0x5f87d7,%0A%0969:  0x5f87ff,%0A%0970:  0x5faf00,%0A%0971:  0x5faf5f,%0A%0972:  0x5faf87,%0A%0973:  0x5fafaf,%0A%0974:  0x5fafd7,%0A%0975:  0x5fafff,%0A%0976:  0x5fd700,%0A%0977:  0x5fd75f,%0A%0978:  0x5fd787,%0A%0979:  0x5fd7af,%0A%0980:  0x5fd7d7,%0A%0981:  0x5fd7ff,%0A%0982:  0x5fff00,%0A%0983:  0x5fff5f,%0A%0984:  0x5fff87,%0A%0985:  0x5fffaf,%0A%0986:  0x5fffd7,%0A%0987:  0x5fffff,%0A%0988:  0x870000,%0A%0989:  0x87005f,%0A%0990:  0x870087,%0A%0991:  0x8700af,%0A%0992:  0x8700d7,%0A%0993:  0x8700ff,%0A%0994:  0x875f00,%0A%0995:  0x875f5f,%0A%0996:  0x875f87,%0A%0997:  0x875faf,%0A%0998:  0x875fd7,%0A%0999:  0x875fff,%0A%09100: 0x878700,%0A%09101: 0x87875f,%0A%09102: 0x878787,%0A%09103: 0x8787af,%0A%09104: 0x8787d7,%0A%09105: 0x8787ff,%0A%09106: 0x87af00,%0A%09107: 0x87af5f,%0A%09108: 0x87af87,%0A%09109: 0x87afaf,%0A%09110: 0x87afd7,%0A%09111: 0x87afff,%0A%09112: 0x87d700,%0A%09113: 0x87d75f,%0A%09114: 0x87d787,%0A%09115: 0x87d7af,%0A%09116: 0x87d7d7,%0A%09117: 0x87d7ff,%0A%09118: 0x87ff00,%0A%09119: 0x87ff5f,%0A%09120: 0x87ff87,%0A%09121: 0x87ffaf,%0A%09122: 0x87ffd7,%0A%09123: 0x87ffff,%0A%09124: 0xaf0000,%0A%09125: 0xaf005f,%0A%09126: 0xaf0087,%0A%09127: 0xaf00af,%0A%09128: 0xaf00d7,%0A%09129: 0xaf00ff,%0A%09130: 0xaf5f00,%0A%09131: 0xaf5f5f,%0A%09132: 0xaf5f87,%0A%09133: 0xaf5faf,%0A%09134: 0xaf5fd7,%0A%09135: 0xaf5fff,%0A%09136: 0xaf8700,%0A%09137: 0xaf875f,%0A%09138: 0xaf8787,%0A%09139: 0xaf87af,%0A%09140: 0xaf87d7,%0A%09141: 0xaf87ff,%0A%09142: 0xafaf00,%0A%09143: 0xafaf5f,%0A%09144: 0xafaf87,%0A%09145: 0xafafaf,%0A%09146: 0xafafd7,%0A%09147: 0xafafff,%0A%09148: 0xafd700,%0A%09149: 0xafd75f,%0A%09150: 0xafd787,%0A%09151: 0xafd7af,%0A%09152: 0xafd7d7,%0A%09153: 0xafd7ff,%0A%09154: 0xafff00,%0A%09155: 0xafff5f,%0A%09156: 0xafff87,%0A%09157: 0xafffaf,%0A%09158: 0xafffd7,%0A%09159: 0xafffff,%0A%09160: 0xd70000,%0A%09161: 0xd7005f,%0A%09162: 0xd70087,%0A%09163: 0xd700af,%0A%09164: 0xd700d7,%0A%09165: 0xd700ff,%0A%09166: 0xd75f00,%0A%09167: 0xd75f5f,%0A%09168: 0xd75f87,%0A%09169: 0xd75faf,%0A%09170: 0xd75fd7,%0A%09171: 0xd75fff,%0A%09172: 0xd78700,%0A%09173: 0xd7875f,%0A%09174: 0xd78787,%0A%09175: 0xd787af,%0A%09176: 0xd787d7,%0A%09177: 0xd787ff,%0A%09178: 0xd7af00,%0A%09179: 0xd7af5f,%0A%09180: 0xd7af87,%0A%09181: 0xd7afaf,%0A%09182: 0xd7afd7,%0A%09183: 0xd7afff,%0A%09184: 0xd7d700,%0A%09185: 0xd7d75f,%0A%09186: 0xd7d787,%0A%09187: 0xd7d7af,%0A%09188: 0xd7d7d7,%0A%09189: 0xd7d7ff,%0A%09190: 0xd7ff00,%0A%09191: 0xd7ff5f,%0A%09192: 0xd7ff87,%0A%09193: 0xd7ffaf,%0A%09194: 0xd7ffd7,%0A%09195: 0xd7ffff,%0A%09196: 0xff0000,%0A%09197: 0xff005f,%0A%09198: 0xff0087,%0A%09199: 0xff00af,%0A%09200: 0xff00d7,%0A%09201: 0xff00ff,%0A%09202: 0xff5f00,%0A%09203: 0xff5f5f,%0A%09204: 0xff5f87,%0A%09205: 0xff5faf,%0A%09206: 0xff5fd7,%0A%09207: 0xff5fff,%0A%09208: 0xff8700,%0A%09209: 0xff875f,%0A%09210: 0xff8787,%0A%09211: 0xff87af,%0A%09212: 0xff87d7,%0A%09213: 0xff87ff,%0A%09214: 0xffaf00,%0A%09215: 0xffaf5f,%0A%09216: 0xffaf87,%0A%09217: 0xffafaf,%0A%09218: 0xffafd7,%0A%09219: 0xffafff,%0A%09220: 0xffd700,%0A%09221: 0xffd75f,%0A%09222: 0xffd787,%0A%09223: 0xffd7af,%0A%09224: 0xffd7d7,%0A%09225: 0xffd7ff,%0A%09226: 0xffff00,%0A%09227: 0xffff5f,%0A%09228: 0xffff87,%0A%09229: 0xffffaf,%0A%09230: 0xffffd7,%0A%09231: 0xffffff,%0A%09232: 0x080808,%0A%09233: 0x121212,%0A%09234: 0x1c1c1c,%0A%09235: 0x262626,%0A%09236: 0x303030,%0A%09237: 0x3a3a3a,%0A%09238: 0x444444,%0A%09239: 0x4e4e4e,%0A%09240: 0x585858,%0A%09241: 0x626262,%0A%09242: 0x6c6c6c,%0A%09243: 0x767676,%0A%09244: 0x808080,%0A%09245: 0x8a8a8a,%0A%09246: 0x949494,%0A%09247: 0x9e9e9e,%0A%09248: 0xa8a8a8,%0A%09249: 0xb2b2b2,%0A%09250: 0xbcbcbc,%0A%09251: 0xc6c6c6,%0A%09252: 0xd0d0d0,%0A%09253: 0xdadada,%0A%09254: 0xe4e4e4,%0A%09255: 0xeeeeee,%0A%7D%0A%0A// %60%5C033%5D0;TITLESTR%5C007%60%0Afunc doTitleSequence(er *bytes.Reader) error %7B%0A%09var c byte%0A%09var err error%0A%0A%09c, err = er.ReadByte()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if c != '0' && c != '2' %7B%0A%09%09return nil%0A%09%7D%0A%09c, err = er.ReadByte()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if c != ';' %7B%0A%09%09return nil%0A%09%7D%0A%09title := make(%5B%5Dbyte, 0, 80)%0A%09for %7B%0A%09%09c, err = er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09if c == 0x07 %7C%7C c == '%5Cn' %7B%0A%09%09%09break%0A%09%09%7D%0A%09%09title = append(title, c)%0A%09%7D%0A%09if len(title) %3E 0 %7B%0A%09%09title8, err := syscall.UTF16PtrFromString(string(title))%0A%09%09if err == nil %7B%0A%09%09%09procSetConsoleTitle.Call(uintptr(unsafe.Pointer(title8)))%0A%09%09%7D%0A%09%7D%0A%09return nil%0A%7D%0A%0A// Write write data on console%0Afunc (w *Writer) Write(data %5B%5Dbyte) (n int, err error) %7B%0A%09var csbi consoleScreenBufferInfo%0A%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%0A%09er := bytes.NewReader(data)%0A%09var bw %5B1%5Dbyte%0Aloop:%0A%09for %7B%0A%09%09c1, err := er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09break loop%0A%09%09%7D%0A%09%09if c1 != 0x1b %7B%0A%09%09%09bw%5B0%5D = c1%0A%09%09%09w.out.Write(bw%5B:%5D)%0A%09%09%09continue%0A%09%09%7D%0A%09%09c2, err := er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09break loop%0A%09%09%7D%0A%0A%09%09if c2 == '%5D' %7B%0A%09%09%09if err := doTitleSequence(er); err != nil %7B%0A%09%09%09%09break loop%0A%09%09%09%7D%0A%09%09%09continue%0A%09%09%7D%0A%09%09if c2 != 0x5b %7B%0A%09%09%09continue%0A%09%09%7D%0A%0A%09%09var buf bytes.Buffer%0A%09%09var m byte%0A%09%09for %7B%0A%09%09%09c, err := er.ReadByte()%0A%09%09%09if err != nil %7B%0A%09%09%09%09break loop%0A%09%09%09%7D%0A%09%09%09if ('a' %3C= c && c %3C= 'z') %7C%7C ('A' %3C= c && c %3C= 'Z') %7C%7C c == '@' %7B%0A%09%09%09%09m = c%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%09buf.Write(%5B%5Dbyte(string(c)))%0A%09%09%7D%0A%0A%09%09switch m %7B%0A%09%09case 'A':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.y -= short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'B':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.y += short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'C':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x += short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'D':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x -= short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'E':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x = 0%0A%09%09%09csbi.cursorPosition.y += short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'F':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x = 0%0A%09%09%09csbi.cursorPosition.y -= short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'G':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x = short(n - 1)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'H', 'f':%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09if buf.Len() %3E 0 %7B%0A%09%09%09%09token := strings.Split(buf.String(), %22;%22)%0A%09%09%09%09switch len(token) %7B%0A%09%09%09%09case 1:%0A%09%09%09%09%09n1, err := strconv.Atoi(token%5B0%5D)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09continue%0A%09%09%09%09%09%7D%0A%09%09%09%09%09csbi.cursorPosition.y = short(n1 - 1)%0A%09%09%09%09case 2:%0A%09%09%09%09%09n1, err := strconv.Atoi(token%5B0%5D)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09continue%0A%09%09%09%09%09%7D%0A%09%09%09%09%09n2, err := strconv.Atoi(token%5B1%5D)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09continue%0A%09%09%09%09%09%7D%0A%09%09%09%09%09csbi.cursorPosition.x = short(n2 - 1)%0A%09%09%09%09%09csbi.cursorPosition.y = short(n1 - 1)%0A%09%09%09%09%7D%0A%09%09%09%7D else %7B%0A%09%09%09%09csbi.cursorPosition.y = 0%0A%09%09%09%7D%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'J':%0A%09%09%09n := 0%0A%09%09%09if buf.Len() %3E 0 %7B%0A%09%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09continue%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09var count, written dword%0A%09%09%09var cursor coord%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09switch n %7B%0A%09%09%09case 0:%0A%09%09%09%09cursor = coord%7Bx: csbi.cursorPosition.x, y: csbi.cursorPosition.y%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x + (csbi.size.y-csbi.cursorPosition.y)*csbi.size.x)%0A%09%09%09case 1:%0A%09%09%09%09cursor = coord%7Bx: csbi.window.left, y: csbi.window.top%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x + (csbi.window.top-csbi.cursorPosition.y)*csbi.size.x)%0A%09%09%09case 2:%0A%09%09%09%09cursor = coord%7Bx: csbi.window.left, y: csbi.window.top%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x + (csbi.size.y-csbi.cursorPosition.y)*csbi.size.x)%0A%09%09%09%7D%0A%09%09%09procFillConsoleOutputCharacter.Call(uintptr(w.handle), uintptr(' '), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))%0A%09%09%09procFillConsoleOutputAttribute.Call(uintptr(w.handle), uintptr(csbi.attributes), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))%0A%09%09case 'K':%0A%09%09%09n := 0%0A%09%09%09if buf.Len() %3E 0 %7B%0A%09%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09continue%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09var cursor coord%0A%09%09%09var count, written dword%0A%09%09%09switch n %7B%0A%09%09%09case 0:%0A%09%09%09%09cursor = coord%7Bx: csbi.cursorPosition.x + 1, y: csbi.cursorPosition.y%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x - 1)%0A%09%09%09case 1:%0A%09%09%09%09cursor = coord%7Bx: csbi.window.left, y: csbi.window.top + csbi.cursorPosition.y%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x)%0A%09%09%09case 2:%0A%09%09%09%09cursor = coord%7Bx: csbi.window.left, y: csbi.window.top + csbi.cursorPosition.y%7D%0A%09%09%09%09count = dword(csbi.size.x)%0A%09%09%09%7D%0A%09%09%09procFillConsoleOutputCharacter.Call(uintptr(w.handle), uintptr(' '), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))%0A%09%09%09procFillConsoleOutputAttribute.Call(uintptr(w.handle), uintptr(csbi.attributes), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))%0A%09%09case 'm':%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09attr := csbi.attributes%0A%09%09%09cs := buf.String()%0A%09%09%09if cs == %22%22 %7B%0A%09%09%09%09procSetConsoleTextAttribute.Call(uintptr(w.handle), uintptr(w.oldattr))%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09token := strings.Split(cs, %22;%22)%0A%09%09%09for i := 0; i %3C len(token); i++ %7B%0A%09%09%09%09ns := token%5Bi%5D%0A%09%09%09%09if n, err = strconv.Atoi(ns); err == nil %7B%0A%09%09%09%09%09switch %7B%0A%09%09%09%09%09case n == 0 %7C%7C n == 100:%0A%09%09%09%09%09%09attr = w.oldattr%0A%09%09%09%09%09case 1 %3C= n && n %3C= 5:%0A%09%09%09%09%09%09attr %7C= foregroundIntensity%0A%09%09%09%09%09case n == 7:%0A%09%09%09%09%09%09attr = ((attr & foregroundMask) %3C%3C 4) %7C ((attr & backgroundMask) %3E%3E 4)%0A%09%09%09%09%09case n == 22 %7C%7C n == 25:%0A%09%09%09%09%09%09attr %7C= foregroundIntensity%0A%09%09%09%09%09case n == 27:%0A%09%09%09%09%09%09attr = ((attr & foregroundMask) %3C%3C 4) %7C ((attr & backgroundMask) %3E%3E 4)%0A%09%09%09%09%09case 30 %3C= n && n %3C= 37:%0A%09%09%09%09%09%09attr &= backgroundMask%0A%09%09%09%09%09%09if (n-30)&1 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundRed%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-30)&2 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundGreen%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-30)&4 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundBlue%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case n == 38: // set foreground color.%0A%09%09%09%09%09%09if i %3C len(token)-2 && (token%5Bi+1%5D == %225%22 %7C%7C token%5Bi+1%5D == %2205%22) %7B%0A%09%09%09%09%09%09%09if n256, err := strconv.Atoi(token%5Bi+2%5D); err == nil %7B%0A%09%09%09%09%09%09%09%09if n256foreAttr == nil %7B%0A%09%09%09%09%09%09%09%09%09n256setup()%0A%09%09%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09%09%09attr &= backgroundMask%0A%09%09%09%09%09%09%09%09attr %7C= n256foreAttr%5Bn256%5D%0A%09%09%09%09%09%09%09%09i += 2%0A%09%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09%7D else %7B%0A%09%09%09%09%09%09%09attr = attr & (w.oldattr & backgroundMask)%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case n == 39: // reset foreground color.%0A%09%09%09%09%09%09attr &= backgroundMask%0A%09%09%09%09%09%09attr %7C= w.oldattr & foregroundMask%0A%09%09%09%09%09case 40 %3C= n && n %3C= 47:%0A%09%09%09%09%09%09attr &= foregroundMask%0A%09%09%09%09%09%09if (n-40)&1 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundRed%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-40)&2 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundGreen%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-40)&4 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundBlue%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case n == 48: // set background color.%0A%09%09%09%09%09%09if i %3C len(token)-2 && token%5Bi+1%5D == %225%22 %7B%0A%09%09%09%09%09%09%09if n256, err := strconv.Atoi(token%5Bi+2%5D); err == nil %7B%0A%09%09%09%09%09%09%09%09if n256backAttr == nil %7B%0A%09%09%09%09%09%09%09%09%09n256setup()%0A%09%09%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09%09%09attr &= foregroundMask%0A%09%09%09%09%09%09%09%09attr %7C= n256backAttr%5Bn256%5D%0A%09%09%09%09%09%09%09%09i += 2%0A%09%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09%7D else %7B%0A%09%09%09%09%09%09%09attr = attr & (w.oldattr & foregroundMask)%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case n == 49: // reset foreground color.%0A%09%09%09%09%09%09attr &= foregroundMask%0A%09%09%09%09%09%09attr %7C= w.oldattr & backgroundMask%0A%09%09%09%09%09case 90 %3C= n && n %3C= 97:%0A%09%09%09%09%09%09attr = (attr & backgroundMask)%0A%09%09%09%09%09%09attr %7C= foregroundIntensity%0A%09%09%09%09%09%09if (n-90)&1 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundRed%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-90)&2 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundGreen%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-90)&4 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundBlue%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case 100 %3C= n && n %3C= 107:%0A%09%09%09%09%09%09attr = (attr & foregroundMask)%0A%09%09%09%09%09%09attr %7C= backgroundIntensity%0A%09%09%09%09%09%09if (n-100)&1 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundRed%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-100)&2 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundGreen%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-100)&4 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundBlue%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%7D%0A%09%09%09%09%09procSetConsoleTextAttribute.Call(uintptr(w.handle), uintptr(attr))%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09case 'h':%0A%09%09%09var ci consoleCursorInfo%0A%09%09%09cs := buf.String()%0A%09%09%09if cs == %225%3E%22 %7B%0A%09%09%09%09procGetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%09ci.visible = 0%0A%09%09%09%09procSetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%7D else if cs == %22?25%22 %7B%0A%09%09%09%09procGetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%09ci.visible = 1%0A%09%09%09%09procSetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%7D%0A%09%09case 'l':%0A%09%09%09var ci consoleCursorInfo%0A%09%09%09cs := buf.String()%0A%09%09%09if cs == %225%3E%22 %7B%0A%09%09%09%09procGetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%09ci.visible = 1%0A%09%09%09%09procSetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%7D else if cs == %22?25%22 %7B%0A%09%09%09%09procGetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%09ci.visible = 0%0A%09%09%09%09procSetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%7D%0A%09%09case 's':%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09w.oldpos = csbi.cursorPosition%0A%09%09case 'u':%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&w.oldpos)))%0A%09%09%7D%0A%09%7D%0A%0A%09return len(data), nil%0A%7D%0A%0Atype consoleColor struct %7B%0A%09rgb       int%0A%09red       bool%0A%09green     bool%0A%09blue      bool%0A%09intensity bool%0A%7D%0A%0Afunc (c consoleColor) foregroundAttr() (attr word) %7B%0A%09if c.red %7B%0A%09%09attr %7C= foregroundRed%0A%09%7D%0A%09if c.green %7B%0A%09%09attr %7C= foregroundGreen%0A%09%7D%0A%09if c.blue %7B%0A%09%09attr %7C= foregroundBlue%0A%09%7D%0A%09if c.intensity %7B%0A%09%09attr %7C= foregroundIntensity%0A%09%7D%0A%09return%0A%7D%0A%0Afunc (c consoleColor) backgroundAttr() (attr word) %7B%0A%09if c.red %7B%0A%09%09attr %7C= backgroundRed%0A%09%7D%0A%09if c.green %7B%0A%09%09attr %7C= backgroundGreen%0A%09%7D%0A%09if c.blue %7B%0A%09%09attr %7C= backgroundBlue%0A%09%7D%0A%09if c.intensity %7B%0A%09%09attr %7C= backgroundIntensity%0A%09%7D%0A%09return%0A%7D%0A%0Avar color16 = %5B%5DconsoleColor%7B%0A%09%7B0x000000, false, false, false, false%7D,%0A%09%7B0x000080, false, false, true, false%7D,%0A%09%7B0x008000, false, true, false, false%7D,%0A%09%7B0x008080, false, true, true, false%7D,%0A%09%7B0x800000, true, false, false, false%7D,%0A%09%7B0x800080, true, false, true, false%7D,%0A%09%7B0x808000, true, true, false, false%7D,%0A%09%7B0xc0c0c0, true, true, true, false%7D,%0A%09%7B0x808080, false, false, false, true%7D,%0A%09%7B0x0000ff, false, false, true, true%7D,%0A%09%7B0x00ff00, false, true, false, true%7D,%0A%09%7B0x00ffff, false, true, true, true%7D,%0A%09%7B0xff0000, true, false, false, true%7D,%0A%09%7B0xff00ff, true, false, true, true%7D,%0A%09%7B0xffff00, true, true, false, true%7D,%0A%09%7B0xffffff, true, true, true, true%7D,%0A%7D%0A%0Atype hsv struct %7B%0A%09h, s, v float32%0A%7D%0A%0Afunc (a hsv) dist(b hsv) float32 %7B%0A%09dh := a.h - b.h%0A%09switch %7B%0A%09case dh %3E 0.5:%0A%09%09dh = 1 - dh%0A%09case dh %3C -0.5:%0A%09%09dh = -1 - dh%0A%09%7D%0A%09ds := a.s - b.s%0A%09dv := a.v - b.v%0A%09return float32(math.Sqrt(float64(dh*dh + ds*ds + dv*dv)))%0A%7D%0A%0Afunc toHSV(rgb int) hsv %7B%0A%09r, g, b := float32((rgb&0xFF0000)%3E%3E16)/256.0,%0A%09%09float32((rgb&0x00FF00)%3E%3E8)/256.0,%0A%09%09float32(rgb&0x0000FF)/256.0%0A%09min, max := minmax3f(r, g, b)%0A%09h := max - min%0A%09if h %3E 0 %7B%0A%09%09if max == r %7B%0A%09%09%09h = (g - b) / h%0A%09%09%09if h %3C 0 %7B%0A%09%09%09%09h += 6%0A%09%09%09%7D%0A%09%09%7D else if max == g %7B%0A%09%09%09h = 2 + (b-r)/h%0A%09%09%7D else %7B%0A%09%09%09h = 4 + (r-g)/h%0A%09%09%7D%0A%09%7D%0A%09h /= 6.0%0A%09s := max - min%0A%09if max != 0 %7B%0A%09%09s /= max%0A%09%7D%0A%09v := max%0A%09return hsv%7Bh: h, s: s, v: v%7D%0A%7D%0A%0Atype hsvTable %5B%5Dhsv%0A%0Afunc toHSVTable(rgbTable %5B%5DconsoleColor) hsvTable %7B%0A%09t := make(hsvTable, len(rgbTable))%0A%09for i, c := range rgbTable %7B%0A%09%09t%5Bi%5D = toHSV(c.rgb)%0A%09%7D%0A%09return t%0A%7D%0A%0Afunc (t hsvTable) find(rgb int) consoleColor %7B%0A%09hsv := toHSV(rgb)%0A%09n := 7%0A%09l := float32(5.0)%0A%09for i, p := range t %7B%0A%09%09d := hsv.dist(p)%0A%09%09if d %3C l %7B%0A%09%09%09l, n = d, i%0A%09%09%7D%0A%09%7D%0A%09return color16%5Bn%5D%0A%7D%0A%0Afunc minmax3f(a, b, c float32) (min, max float32) %7B%0A%09if a %3C b %7B%0A%09%09if b %3C c %7B%0A%09%09%09return a, c%0A%09%09%7D else if a %3C c %7B%0A%09%09%09return a, b%0A%09%09%7D else %7B%0A%09%09%09return c, b%0A%09%09%7D%0A%09%7D else %7B%0A%09%09if a %3C c %7B%0A%09%09%09return b, c%0A%09%09%7D else if b %3C c %7B%0A%09%09%09return b, a%0A%09%09%7D else %7B%0A%09%09%09return c, a%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Avar n256foreAttr %5B%5Dword%0Avar n256backAttr %5B%5Dword%0A%0Afunc n256setup() %7B%0A%09n256foreAttr = make(%5B%5Dword, 256)%0A%09n256backAttr = make(%5B%5Dword, 256)%0A%09t := toHSVTable(color16)%0A%09for i, rgb := range color256 %7B%0A%09%09c := t.find(rgb)%0A%09%09n256foreAttr%5Bi%5D = c.foregroundAttr()%0A%09%09n256backAttr%5Bi%5D = c.backgroundAttr()%0A%09%7D%0A%7D%0A
- f fd2c8c68e345996ff70af73e92e7e9deb8b040f29c77af845362cbec32ff3e82 vendor/github.com/mattn/go-colorable/noncolorable.go
+ f 7c9807557111debadbb3eee5c5fdaaff2b314500e55b89288df2e3190385574b vendor/github.com/mattn/go-colorable/noncolorable.go
dmppatch 3
@@ -15,932 +15,4 @@
 ble%0A
-%0Aimport (%0A%09%22bytes%22%0A%09%22io%22%0A)%0A%0A// NonColorable hold writer but remove escape sequence.%0Atype NonColorable struct %7B%0A%09out io.Writer%0A%7D%0A%0A// NewNonColorable return new instance of Writer which remove escape sequence from Writer.%0Afunc NewNonColorable(w io.Writer) io.Writer %7B%0A%09return &NonColorable%7Bout: w%7D%0A%7D%0A%0A// Write write data on console%0Afunc (w *NonColorable) Write(data %5B%5Dbyte) (n int, err error) %7B%0A%09er := bytes.NewReader(data)%0A%09var bw %5B1%5Dbyte%0Aloop:%0A%09for %7B%0A%09%09c1, err := er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09break loop%0A%09%09%7D%0A%09%09if c1 != 0x1b %7B%0A%09%09%09bw%5B0%5D = c1%0A%09%09%09w.out.Write(bw%5B:%5D)%0A%09%09%09continue%0A%09%09%7D%0A%09%09c2, err := er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09break loop%0A%09%09%7D%0A%09%09if c2 != 0x5b %7B%0A%09%09%09continue%0A%09%09%7D%0A%0A%09%09var buf bytes.Buffer%0A%09%09for %7B%0A%09%09%09c, err := er.ReadByte()%0A%09%09%09if err != nil %7B%0A%09%09%09%09break loop%0A%09%09%09%7D%0A%09%09%09if ('a' %3C= c && c %3C= 'z') %7C%7C ('A' %3C= c && c %3C= 'Z') %7C%7C c == '@' %7B%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%09buf.Write(%5B%5Dbyte(string(c)))%0A%09%09%7D%0A%09%7D%0A%0A%09return len(data), nil%0A%7D%0A
- f 405eba4ed581cc4cd10ebb2c608c539c3beeef8628a45b7a128e7d7305fe296c vendor/github.com/mattn/go-isatty/isatty_windows.go
+ f 1ddbba579f36e77697b08f448dc64d01d690641987bc7227ba46dbd773a3ee6c vendor/github.com/mattn/go-isatty/isatty_windows.go
dmppatch 12
@@ -62,19 +62,8 @@
 t (%0A
-%09%22strings%22%0A
 %09%22sy
@@ -103,375 +103,8 @@
 %0A)%0A%0A
-const (%0A%09fileNameInfo uintptr = 2%0A%09fileTypePipe         = 3%0A)%0A%0Avar (%0A%09kernel32                         = syscall.NewLazyDLL(%22kernel32.dll%22)%0A%09procGetConsoleMode               = kernel32.NewProc(%22GetConsoleMode%22)%0A%09procGetFileInformationByHandleEx = kernel32.NewProc(%22GetFileInformationByHandleEx%22)%0A%09procGetFileType                  = kernel32.NewProc(%22GetFileType%22)%0A)%0A%0A
 func
@@ -505,567 +505,8 @@
 = 0%0A
-%7D%0A%0A// Check pipe name is used for cygwin/msys2 pty.%0A// Cygwin/MSYS2 PTY has a name like:%0A//   %5C%7Bcygwin,msys%7D-XXXXXXXXXXXXXXXX-ptyN-%7Bfrom,to%7D-master%0Afunc isCygwinPipeName(name string) bool %7B%0A%09token := strings.Split(name, %22-%22)%0A%09if len(token) %3C 5 %7B%0A%09%09return false%0A%09%7D%0A%0A%09if token%5B0%5D != %60%5Cmsys%60 && token%5B0%5D != %60%5Ccygwin%60 %7B%0A%09%09return false%0A%09%7D%0A%0A%09if token%5B1%5D == %22%22 %7B%0A%09%09return false%0A%09%7D%0A%0A%09if !strings.HasPrefix(token%5B2%5D, %22pty%22) %7B%0A%09%09return false%0A%09%7D%0A%0A%09if token%5B3%5D != %60from%60 && token%5B3%5D != %60to%60 %7B%0A%09%09return false%0A%09%7D%0A%0A%09if token%5B4%5D != %22master%22 %7B%0A%09%09return false%0A%09%7D%0A%0A%09return true%0A
 %7D%0A%0A/
- f bab37ded6c08ec95dd05f1186b39a74410744e18dcdb6ba9b8b50a0a308c1d46 vendor/github.com/sergi/go-diff/diffmatchpatch/diff.go
+ f 1c5406179e1d6a27a258041fabbb7e6097957edaeaca5659ef3334667a686a3f vendor/github.com/sergi/go-diff/diffmatchpatch/diff.go
dmppatch 36
@@ -386,41 +386,16 @@
 es%22%0A
-%09%22errors%22%0A%09%22fmt%22%0A%09%22html%22%0A
 %09%22math%22%0A
 %09%22ne
@@ -394,19 +394,8 @@
 th%22%0A
-%09%22net/url%22%0A
 %09%22re
@@ -404,19 +404,8 @@
 xp%22%0A
-%09%22strconv%22%0A
 %09%22st
@@ -6555,530 +6555,8 @@
 %0A%7D%0A%0A
-// DiffBisect finds the 'middle snake' of a diff, split the problem in two and return the recursively constructed diff.%0A// If an invalid UTF-8 sequence is encountered, it will be replaced by the Unicode replacement character.%0A// See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.%0Afunc (dmp *DiffMatchPatch) DiffBisect(text1, text2 string, deadline time.Time) %5B%5DDiff %7B%0A%09// Unused in this code, but retained for interface compatibility.%0A%09return dmp.diffBisect(%5B%5Drune(text1), %5B%5Drune(text2), deadline)%0A%7D%0A%0A
 // d
@@ -10144,457 +10144,8 @@
 %0A%7D%0A%0A
-// DiffLinesToChars splits two texts into a list of strings, and educes the texts to a string of hashes where each Unicode character represents one line.%0A// It's slightly faster to call DiffLinesToRunes first, followed by DiffMainRunes.%0Afunc (dmp *DiffMatchPatch) DiffLinesToChars(text1, text2 string) (string, string, %5B%5Dstring) %7B%0A%09chars1, chars2, lineArray := dmp.DiffLinesToRunes(text1, text2)%0A%09return string(chars1), string(chars2), lineArray%0A%7D%0A%0A
 // D
@@ -12449,278 +12449,8 @@
 %0A%7D%0A%0A
-// DiffCommonPrefix determines the common prefix length of two strings.%0Afunc (dmp *DiffMatchPatch) DiffCommonPrefix(text1, text2 string) int %7B%0A%09// Unused in this code, but retained for interface compatibility.%0A%09return commonPrefixLength(%5B%5Drune(text1), %5B%5Drune(text2))%0A%7D%0A%0A
 // D
@@ -15155,534 +15155,8 @@
 est%0A
-%7D%0A%0A// DiffHalfMatch checks whether the two texts share a substring which is at least half the length of the longer text. This speedup can produce non-minimal diffs.%0Afunc (dmp *DiffMatchPatch) DiffHalfMatch(text1, text2 string) %5B%5Dstring %7B%0A%09// Unused in this code, but retained for interface compatibility.%0A%09runeSlices := dmp.diffHalfMatch(%5B%5Drune(text1), %5B%5Drune(text2))%0A%09if runeSlices == nil %7B%0A%09%09return nil%0A%09%7D%0A%0A%09result := make(%5B%5Dstring, len(runeSlices))%0A%09for i, r := range runeSlices %7B%0A%09%09result%5Bi%5D = string(r)%0A%09%7D%0A%09return result%0A
 %7D%0A%0Af
@@ -34244,1405 +34244,8 @@
 %0A%7D%0A%0A
-// DiffPrettyHtml converts a %5B%5DDiff into a pretty HTML report.%0A// It is intended as an example from which to write one's own display functions.%0Afunc (dmp *DiffMatchPatch) DiffPrettyHtml(diffs %5B%5DDiff) string %7B%0A%09var buff bytes.Buffer%0A%09for _, diff := range diffs %7B%0A%09%09text := strings.Replace(html.EscapeString(diff.Text), %22%5Cn%22, %22&para;%3Cbr%3E%22, -1)%0A%09%09switch diff.Type %7B%0A%09%09case DiffInsert:%0A%09%09%09_, _ = buff.WriteString(%22%3Cins style=%5C%22background:#e6ffe6;%5C%22%3E%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%3C/ins%3E%22)%0A%09%09case DiffDelete:%0A%09%09%09_, _ = buff.WriteString(%22%3Cdel style=%5C%22background:#ffe6e6;%5C%22%3E%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%3C/del%3E%22)%0A%09%09case DiffEqual:%0A%09%09%09_, _ = buff.WriteString(%22%3Cspan%3E%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%3C/span%3E%22)%0A%09%09%7D%0A%09%7D%0A%09return buff.String()%0A%7D%0A%0A// DiffPrettyText converts a %5B%5DDiff into a colored text report.%0Afunc (dmp *DiffMatchPatch) DiffPrettyText(diffs %5B%5DDiff) string %7B%0A%09var buff bytes.Buffer%0A%09for _, diff := range diffs %7B%0A%09%09text := diff.Text%0A%0A%09%09switch diff.Type %7B%0A%09%09case DiffInsert:%0A%09%09%09_, _ = buff.WriteString(%22%5Cx1b%5B32m%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%5Cx1b%5B0m%22)%0A%09%09case DiffDelete:%0A%09%09%09_, _ = buff.WriteString(%22%5Cx1b%5B31m%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%5Cx1b%5B0m%22)%0A%09%09case DiffEqual:%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%7D%0A%09%7D%0A%0A%09return buff.String()%0A%7D%0A%0A
 // D
@@ -35511,2940 +35511,4 @@
 n%0A%7D%0A
-%0A// DiffToDelta crushes the diff into an encoded string which describes the operations required to transform text1 into text2.%0A// E.g. =3%5Ct-2%5Ct+ing  -%3E Keep 3 chars, delete 2 chars, insert 'ing'. Operations are tab-separated.  Inserted text is escaped using %25xx notation.%0Afunc (dmp *DiffMatchPatch) DiffToDelta(diffs %5B%5DDiff) string %7B%0A%09var text bytes.Buffer%0A%09for _, aDiff := range diffs %7B%0A%09%09switch aDiff.Type %7B%0A%09%09case DiffInsert:%0A%09%09%09_, _ = text.WriteString(%22+%22)%0A%09%09%09_, _ = text.WriteString(strings.Replace(url.QueryEscape(aDiff.Text), %22+%22, %22 %22, -1))%0A%09%09%09_, _ = text.WriteString(%22%5Ct%22)%0A%09%09%09break%0A%09%09case DiffDelete:%0A%09%09%09_, _ = text.WriteString(%22-%22)%0A%09%09%09_, _ = text.WriteString(strconv.Itoa(utf8.RuneCountInString(aDiff.Text)))%0A%09%09%09_, _ = text.WriteString(%22%5Ct%22)%0A%09%09%09break%0A%09%09case DiffEqual:%0A%09%09%09_, _ = text.WriteString(%22=%22)%0A%09%09%09_, _ = text.WriteString(strconv.Itoa(utf8.RuneCountInString(aDiff.Text)))%0A%09%09%09_, _ = text.WriteString(%22%5Ct%22)%0A%09%09%09break%0A%09%09%7D%0A%09%7D%0A%09delta := text.String()%0A%09if len(delta) != 0 %7B%0A%09%09// Strip off trailing tab character.%0A%09%09delta = delta%5B0 : utf8.RuneCountInString(delta)-1%5D%0A%09%09delta = unescaper.Replace(delta)%0A%09%7D%0A%09return delta%0A%7D%0A%0A// DiffFromDelta given the original text1, and an encoded string which describes the operations required to transform text1 into text2, comAdde the full diff.%0Afunc (dmp *DiffMatchPatch) DiffFromDelta(text1 string, delta string) (diffs %5B%5DDiff, err error) %7B%0A%09i := 0%0A%09runes := %5B%5Drune(text1)%0A%0A%09for _, token := range strings.Split(delta, %22%5Ct%22) %7B%0A%09%09if len(token) == 0 %7B%0A%09%09%09// Blank tokens are ok (from a trailing %5Ct).%0A%09%09%09continue%0A%09%09%7D%0A%0A%09%09// Each token begins with a one character parameter which specifies the operation of this token (delete, insert, equality).%0A%09%09param := token%5B1:%5D%0A%0A%09%09switch op := token%5B0%5D; op %7B%0A%09%09case '+':%0A%09%09%09// Decode would Diff all %22+%22 to %22 %22%0A%09%09%09param = strings.Replace(param, %22+%22, %22%252b%22, -1)%0A%09%09%09param, err = url.QueryUnescape(param)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return nil, err%0A%09%09%09%7D%0A%09%09%09if !utf8.ValidString(param) %7B%0A%09%09%09%09return nil, fmt.Errorf(%22invalid UTF-8 token: %25q%22, param)%0A%09%09%09%7D%0A%0A%09%09%09diffs = append(diffs, Diff%7BDiffInsert, param%7D)%0A%09%09case '=', '-':%0A%09%09%09n, err := strconv.ParseInt(param, 10, 0)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return nil, err%0A%09%09%09%7D else if n %3C 0 %7B%0A%09%09%09%09return nil, errors.New(%22Negative number in DiffFromDelta: %22 + param)%0A%09%09%09%7D%0A%0A%09%09%09i += int(n)%0A%09%09%09// Break out if we are out of bounds, go1.6 can't handle this very well%0A%09%09%09if i %3E len(runes) %7B%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%09// Remember that string slicing is by byte - we want by rune here.%0A%09%09%09text := string(runes%5Bi-int(n) : i%5D)%0A%0A%09%09%09if op == '=' %7B%0A%09%09%09%09diffs = append(diffs, Diff%7BDiffEqual, text%7D)%0A%09%09%09%7D else %7B%0A%09%09%09%09diffs = append(diffs, Diff%7BDiffDelete, text%7D)%0A%09%09%09%7D%0A%09%09default:%0A%09%09%09// Anything else is an error.%0A%09%09%09return nil, errors.New(%22Invalid diff operation in DiffFromDelta: %22 + string(token%5B0%5D))%0A%09%09%7D%0A%09%7D%0A%0A%09if i != len(runes) %7B%0A%09%09return nil, fmt.Errorf(%22Delta length (%25v) is different from source text length (%25v)%22, i, len(text1))%0A%09%7D%0A%0A%09return diffs, nil%0A%7D%0A
- f 700be0003bc2c074dc1af5138554112cebaf57bd2aebe56151d81eef7c02e1ae vendor/golang.org/x/crypto/argon2/argon2.go
+ f 0fad772fd49b66ad4fcc6d18f90d3ff065e7cfb8f3c23126aeca8f245239a5be vendor/golang.org/x/crypto/argon2/argon2.go
dmppatch 4
@@ -1879,1222 +1879,8 @@
 %0A)%0A%0A
-// Key derives a key from the password, salt, and cost parameters using Argon2i%0A// returning a byte slice of length keyLen that can be used as cryptographic%0A// key. The CPU cost and parallelism degree must be greater than zero.%0A//%0A// For example, you can get a derived key for e.g. AES-256 (which needs a%0A// 32-byte key) by doing:%0A//%0A//      key := argon2.Key(%5B%5Dbyte(%22some password%22), salt, 3, 32*1024, 4, 32)%0A//%0A// The draft RFC recommends%5B2%5D time=3, and memory=32*1024 is a sensible number.%0A// If using that amount of memory (32 MB) is not possible in some contexts then%0A// the time parameter can be increased to compensate.%0A//%0A// The time parameter specifies the number of passes over the memory and the%0A// memory parameter specifies the size of the memory in KiB. For example%0A// memory=32*1024 sets the memory cost to ~32 MB. The number of threads can be%0A// adjusted to the number of available CPUs. The cost parameters should be%0A// increased as memory latency and CPU parallelism increases. Remember to get a%0A// good random salt.%0Afunc Key(password, salt %5B%5Dbyte, time, memory uint32, threads uint8, keyLen uint32) %5B%5Dbyte %7B%0A%09return deriveKey(argon2i, password, salt, nil, nil, time, memory, threads, keyLen)%0A%7D%0A%0A
 // I
- f 64fc08ec2dbd617cad784bb742d3533ee14254489f94dea41849aa6e00f6b5ca vendor/golang.org/x/crypto/argon2/blamka_generic.go
+ f fb5febceeb42365ad4eb696992a73c831124111c938dc0e13bb94aae2f9edd3b vendor/golang.org/x/crypto/argon2/blamka_generic.go
dmppatch 4
@@ -191,750 +191,8 @@
 ol%0A%0A
-func processBlockGeneric(out, in1, in2 *block, xor bool) %7B%0A%09var t block%0A%09for i := range t %7B%0A%09%09t%5Bi%5D = in1%5Bi%5D %5E in2%5Bi%5D%0A%09%7D%0A%09for i := 0; i %3C blockLength; i += 16 %7B%0A%09%09blamkaGeneric(%0A%09%09%09&t%5Bi+0%5D, &t%5Bi+1%5D, &t%5Bi+2%5D, &t%5Bi+3%5D,%0A%09%09%09&t%5Bi+4%5D, &t%5Bi+5%5D, &t%5Bi+6%5D, &t%5Bi+7%5D,%0A%09%09%09&t%5Bi+8%5D, &t%5Bi+9%5D, &t%5Bi+10%5D, &t%5Bi+11%5D,%0A%09%09%09&t%5Bi+12%5D, &t%5Bi+13%5D, &t%5Bi+14%5D, &t%5Bi+15%5D,%0A%09%09)%0A%09%7D%0A%09for i := 0; i %3C blockLength/8; i += 2 %7B%0A%09%09blamkaGeneric(%0A%09%09%09&t%5Bi%5D, &t%5Bi+1%5D, &t%5B16+i%5D, &t%5B16+i+1%5D,%0A%09%09%09&t%5B32+i%5D, &t%5B32+i+1%5D, &t%5B48+i%5D, &t%5B48+i+1%5D,%0A%09%09%09&t%5B64+i%5D, &t%5B64+i+1%5D, &t%5B80+i%5D, &t%5B80+i+1%5D,%0A%09%09%09&t%5B96+i%5D, &t%5B96+i+1%5D, &t%5B112+i%5D, &t%5B112+i+1%5D,%0A%09%09)%0A%09%7D%0A%09if xor %7B%0A%09%09for i := range t %7B%0A%09%09%09out%5Bi%5D %5E= in1%5Bi%5D %5E in2%5Bi%5D %5E t%5Bi%5D%0A%09%09%7D%0A%09%7D else %7B%0A%09%09for i := range t %7B%0A%09%09%09out%5Bi%5D = in1%5Bi%5D %5E in2%5Bi%5D %5E t%5Bi%5D%0A%09%09%7D%0A%09%7D%0A%7D%0A%0A
 func
- f 85b588f12c2e75ea71f745fc38ed2ed76f5b8eece67c8b8b8c09f0d742807051 vendor/golang.org/x/crypto/blake2b/blake2b.go
+ f 21145a7fed7e18ee641198bcf693b79394c89a1f91e0403dbf4344207ecb056d vendor/golang.org/x/crypto/blake2b/blake2b.go
dmppatch 15
@@ -1400,613 +1400,8 @@
 %0A%7D%0A%0A
-// Sum512 returns the BLAKE2b-512 checksum of the data.%0Afunc Sum512(data %5B%5Dbyte) %5BSize%5Dbyte %7B%0A%09var sum %5BSize%5Dbyte%0A%09checkSum(&sum, Size, data)%0A%09return sum%0A%7D%0A%0A// Sum384 returns the BLAKE2b-384 checksum of the data.%0Afunc Sum384(data %5B%5Dbyte) %5BSize384%5Dbyte %7B%0A%09var sum %5BSize%5Dbyte%0A%09var sum384 %5BSize384%5Dbyte%0A%09checkSum(&sum, Size384, data)%0A%09copy(sum384%5B:%5D, sum%5B:Size384%5D)%0A%09return sum384%0A%7D%0A%0A// Sum256 returns the BLAKE2b-256 checksum of the data.%0Afunc Sum256(data %5B%5Dbyte) %5BSize256%5Dbyte %7B%0A%09var sum %5BSize%5Dbyte%0A%09var sum256 %5BSize256%5Dbyte%0A%09checkSum(&sum, Size256, data)%0A%09copy(sum256%5B:%5D, sum%5B:Size256%5D)%0A%09return sum256%0A%7D%0A%0A
 // N
@@ -3083,619 +3083,8 @@
 %0A%7D%0A%0A
-func checkSum(sum *%5BSize%5Dbyte, hashSize int, data %5B%5Dbyte) %7B%0A%09h := iv%0A%09h%5B0%5D %5E= uint64(hashSize) %7C (1 %3C%3C 16) %7C (1 %3C%3C 24)%0A%09var c %5B2%5Duint64%0A%0A%09if length := len(data); length %3E BlockSize %7B%0A%09%09n := length &%5E (BlockSize - 1)%0A%09%09if length == n %7B%0A%09%09%09n -= BlockSize%0A%09%09%7D%0A%09%09hashBlocks(&h, &c, 0, data%5B:n%5D)%0A%09%09data = data%5Bn:%5D%0A%09%7D%0A%0A%09var block %5BBlockSize%5Dbyte%0A%09offset := copy(block%5B:%5D, data)%0A%09remaining := uint64(BlockSize - offset)%0A%09if c%5B0%5D %3C remaining %7B%0A%09%09c%5B1%5D--%0A%09%7D%0A%09c%5B0%5D -= remaining%0A%0A%09hashBlocks(&h, &c, 0xFFFFFFFFFFFFFFFF, block%5B:%5D)%0A%0A%09for i, v := range h%5B:(hashSize+7)/8%5D %7B%0A%09%09binary.LittleEndian.PutUint64(sum%5B8*i:%5D, v)%0A%09%7D%0A%7D%0A%0A
 type
@@ -3228,1100 +3228,8 @@
 %0A%7D%0A%0A
-const (%0A%09magic         = %22b2b%22%0A%09marshaledSize = len(magic) + 8*8 + 2*8 + 1 + BlockSize + 1%0A)%0A%0Afunc (d *digest) MarshalBinary() (%5B%5Dbyte, error) %7B%0A%09if d.keyLen != 0 %7B%0A%09%09return nil, errors.New(%22crypto/blake2b: cannot marshal MACs%22)%0A%09%7D%0A%09b := make(%5B%5Dbyte, 0, marshaledSize)%0A%09b = append(b, magic...)%0A%09for i := 0; i %3C 8; i++ %7B%0A%09%09b = appendUint64(b, d.h%5Bi%5D)%0A%09%7D%0A%09b = appendUint64(b, d.c%5B0%5D)%0A%09b = appendUint64(b, d.c%5B1%5D)%0A%09// Maximum value for size is 64%0A%09b = append(b, byte(d.size))%0A%09b = append(b, d.block%5B:%5D...)%0A%09b = append(b, byte(d.offset))%0A%09return b, nil%0A%7D%0A%0Afunc (d *digest) UnmarshalBinary(b %5B%5Dbyte) error %7B%0A%09if len(b) %3C len(magic) %7C%7C string(b%5B:len(magic)%5D) != magic %7B%0A%09%09return errors.New(%22crypto/blake2b: invalid hash state identifier%22)%0A%09%7D%0A%09if len(b) != marshaledSize %7B%0A%09%09return errors.New(%22crypto/blake2b: invalid hash state size%22)%0A%09%7D%0A%09b = b%5Blen(magic):%5D%0A%09for i := 0; i %3C 8; i++ %7B%0A%09%09b, d.h%5Bi%5D = consumeUint64(b)%0A%09%7D%0A%09b, d.c%5B0%5D = consumeUint64(b)%0A%09b, d.c%5B1%5D = consumeUint64(b)%0A%09d.size = int(b%5B0%5D)%0A%09b = b%5B1:%5D%0A%09copy(d.block%5B:%5D, b%5B:BlockSize%5D)%0A%09b = b%5BBlockSize:%5D%0A%09d.offset = int(b%5B0%5D)%0A%09return nil%0A%7D%0A%0A
 func
@@ -4583,464 +4583,4 @@
 %7D%0A%7D%0A
-%0Afunc appendUint64(b %5B%5Dbyte, x uint64) %5B%5Dbyte %7B%0A%09var a %5B8%5Dbyte%0A%09binary.BigEndian.PutUint64(a%5B:%5D, x)%0A%09return append(b, a%5B:%5D...)%0A%7D%0A%0Afunc appendUint32(b %5B%5Dbyte, x uint32) %5B%5Dbyte %7B%0A%09var a %5B4%5Dbyte%0A%09binary.BigEndian.PutUint32(a%5B:%5D, x)%0A%09return append(b, a%5B:%5D...)%0A%7D%0A%0Afunc consumeUint64(b %5B%5Dbyte) (%5B%5Dbyte, uint64) %7B%0A%09x := binary.BigEndian.Uint64(b)%0A%09return b%5B8:%5D, x%0A%7D%0A%0Afunc consumeUint32(b %5B%5Dbyte) (%5B%5Dbyte, uint32) %7B%0A%09x := binary.BigEndian.Uint32(b)%0A%09return b%5B4:%5D, x%0A%7D%0A
- f fbe4a83f26990628538a61b7eebb9e90b20ee66b917e40145b3215eaaa1a1e55 vendor/golang.org/x/crypto/blake2b/blake2x.go
+ f 8c97ceb877b924869456010cd0fe50baf18015589019ae7e5fd3fc19606cb7d5 vendor/golang.org/x/crypto/blake2b/blake2x.go
dmppatch 17
@@ -202,639 +202,11 @@
 ry%22%0A
-%09%22errors%22%0A%09%22io%22%0A
 )%0A%0A
-// XOF defines the interface to hash functions that%0A// support arbitrary-length output.%0Atype XOF interface %7B%0A%09// Write absorbs more data into the hash's state. It panics if called%0A%09// after Read.%0A%09io.Writer%0A%0A%09// Read reads more output from the hash. It returns io.EOF if the limit%0A%09// has been reached.%0A%09io.Reader%0A%0A%09// Clone returns a copy of the XOF in its current state.%0A%09Clone() XOF%0A%0A%09// Reset resets the XOF to its initial state.%0A%09Reset()%0A%7D%0A%0A// OutputLengthUnknown can be used as the size argument to NewXOF to indicate%0A// the the length of the output is not known in advance.%0Aconst OutputLengthUnknown = 0%0A%0A
 // m
@@ -528,851 +528,8 @@
 64%0A%0A
-// NewXOF creates a new variable-output-length hash. The hash either produce a%0A// known number of bytes (1 %3C= size %3C 2**32-1), or an unknown number of bytes%0A// (size == OutputLengthUnknown). In the latter case, an absolute limit of%0A// 256GiB applies.%0A//%0A// A non-nil key turns the hash into a MAC. The key must between%0A// zero and 32 bytes long.%0Afunc NewXOF(size uint32, key %5B%5Dbyte) (XOF, error) %7B%0A%09if len(key) %3E Size %7B%0A%09%09return nil, errKeySize%0A%09%7D%0A%09if size == magicUnknownOutputLength %7B%0A%09%09// 2%5E32-1 indicates an unknown number of bytes and thus isn't a%0A%09%09// valid length.%0A%09%09return nil, errors.New(%22blake2b: XOF length too large%22)%0A%09%7D%0A%09if size == OutputLengthUnknown %7B%0A%09%09size = magicUnknownOutputLength%0A%09%7D%0A%09x := &xof%7B%0A%09%09d: digest%7B%0A%09%09%09size:   Size,%0A%09%09%09keyLen: len(key),%0A%09%09%7D,%0A%09%09length: size,%0A%09%7D%0A%09copy(x.d.key%5B:%5D, key)%0A%09x.Reset()%0A%09return x, nil%0A%7D%0A%0A
 type
@@ -862,67 +862,8 @@
 %0A%7D%0A%0A
-func (x *xof) Clone() XOF %7B%0A%09clone := *x%0A%09return &clone%0A%7D%0A%0A
 func
@@ -1342,1268 +1342,4 @@
 e%0A%7D%0A
-%0Afunc (x *xof) Read(p %5B%5Dbyte) (n int, err error) %7B%0A%09if !x.readMode %7B%0A%09%09x.d.finalize(&x.root)%0A%09%09x.readMode = true%0A%09%7D%0A%0A%09if x.remaining == 0 %7B%0A%09%09return 0, io.EOF%0A%09%7D%0A%0A%09n = len(p)%0A%09if uint64(n) %3E x.remaining %7B%0A%09%09n = int(x.remaining)%0A%09%09p = p%5B:n%5D%0A%09%7D%0A%0A%09if x.offset %3E 0 %7B%0A%09%09blockRemaining := Size - x.offset%0A%09%09if n %3C blockRemaining %7B%0A%09%09%09x.offset += copy(p, x.block%5Bx.offset:%5D)%0A%09%09%09x.remaining -= uint64(n)%0A%09%09%09return%0A%09%09%7D%0A%09%09copy(p, x.block%5Bx.offset:%5D)%0A%09%09p = p%5BblockRemaining:%5D%0A%09%09x.offset = 0%0A%09%09x.remaining -= uint64(blockRemaining)%0A%09%7D%0A%0A%09for len(p) %3E= Size %7B%0A%09%09binary.LittleEndian.PutUint32(x.cfg%5B8:%5D, x.nodeOffset)%0A%09%09x.nodeOffset++%0A%0A%09%09x.d.initConfig(&x.cfg)%0A%09%09x.d.Write(x.root%5B:%5D)%0A%09%09x.d.finalize(&x.block)%0A%0A%09%09copy(p, x.block%5B:%5D)%0A%09%09p = p%5BSize:%5D%0A%09%09x.remaining -= uint64(Size)%0A%09%7D%0A%0A%09if todo := len(p); todo %3E 0 %7B%0A%09%09if x.remaining %3C uint64(Size) %7B%0A%09%09%09x.cfg%5B0%5D = byte(x.remaining)%0A%09%09%7D%0A%09%09binary.LittleEndian.PutUint32(x.cfg%5B8:%5D, x.nodeOffset)%0A%09%09x.nodeOffset++%0A%0A%09%09x.d.initConfig(&x.cfg)%0A%09%09x.d.Write(x.root%5B:%5D)%0A%09%09x.d.finalize(&x.block)%0A%0A%09%09x.offset = copy(p, x.block%5B:todo%5D)%0A%09%09x.remaining -= uint64(todo)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc (d *digest) initConfig(cfg *%5BSize%5Dbyte) %7B%0A%09d.offset, d.c%5B0%5D, d.c%5B1%5D = 0, 0, 0%0A%09for i := range d.h %7B%0A%09%09d.h%5Bi%5D = iv%5Bi%5D %5E binary.LittleEndian.Uint64(cfg%5Bi*8:%5D)%0A%09%7D%0A%7D%0A
- f bf3d1442dfaef56b4bbe8bfd6fd65d52912ec38991dc14170afe7df73f759873 vendor/golang.org/x/crypto/ed25519/ed25519.go
+ f 98b172afdf7343e21f5a32659f9560a4a3fa17dee220e8d8838c371c313df31f vendor/golang.org/x/crypto/ed25519/ed25519.go
dmppatch 39
@@ -339,21 +339,278 @@
  in%0A
-// RFC 8032.%0A
+// RFC 8032. However, unlike RFC 8032's formulation, this package's private key%0A// representation includes a public key suffix to make multiple signing%0A// operations with the same key more efficient. This package refers to the RFC%0A// 8032 private key as the %E2%80%9Cseed%E2%80%9D.%0A
 pack
@@ -1207,16 +1207,149 @@
 ze = 64%0A
+%09// SeedSize is the size, in bytes, of private key seeds. These are the private key representations used by RFC 8032.%0A%09SeedSize = 32%0A
 )%0A%0A// Pu
@@ -1523,216 +1523,8 @@
 te%0A%0A
-// Public returns the PublicKey corresponding to priv.%0Afunc (priv PrivateKey) Public() crypto.PublicKey %7B%0A%09publicKey := make(%5B%5Dbyte, PublicKeySize)%0A%09copy(publicKey, priv%5B32:%5D)%0A%09return PublicKey(publicKey)%0A%7D%0A%0A
 // S
@@ -2222,99 +2222,74 @@
 ed.%0A
-func GenerateKey(rand io.Reader) (publicKey PublicKey, privateKey PrivateKey, err error) %7B%0A
+func GenerateKey(rand io.Reader) (PublicKey, PrivateKey, error) %7B%0A
 %09if 
@@ -2337,154 +2337,92 @@
 %09%7D%0A%0A
-%09privateKey = make(%5B%5Dbyte, PrivateKeySize)%0A%09publicKey = make(%5B%5Dbyte, PublicKeySize)%0A%09_, err = io.ReadFull(rand, privateKey%5B:32%5D)%0A%09if err != nil %7B%0A
+%09seed := make(%5B%5Dbyte, SeedSize)%0A%09if _, err := io.ReadFull(rand, seed); err != nil %7B%0A
 %09%09re
@@ -2448,50 +2448,564 @@
 %09%7D%0A%0A
-%09digest := sha512.Sum512(privateKey%5B:32%5D)%0A
+%09privateKey := NewKeyFromSeed(seed)%0A%09publicKey := make(%5B%5Dbyte, PublicKeySize)%0A%09copy(publicKey, privateKey%5B32:%5D)%0A%0A%09return publicKey, privateKey, nil%0A%7D%0A%0A// NewKeyFromSeed calculates a private key from a seed. It will panic if%0A// len(seed) is not SeedSize. This function is provided for interoperability%0A// with RFC 8032. RFC 8032's private keys correspond to seeds in this%0A// package.%0Afunc NewKeyFromSeed(seed %5B%5Dbyte) PrivateKey %7B%0A%09if l := len(seed); l != SeedSize %7B%0A%09%09panic(%22ed25519: bad seed length: %22 + strconv.Itoa(l))%0A%09%7D%0A%0A%09digest := sha512.Sum512(seed)%0A
 %09dig
@@ -3248,16 +3248,84 @@
 Bytes)%0A%0A
+%09privateKey := make(%5B%5Dbyte, PrivateKeySize)%0A%09copy(privateKey, seed)%0A
 %09copy(pr
@@ -3362,80 +3362,28 @@
 :%5D)%0A
-%09copy(publicKey, publicKeyBytes%5B:%5D)%0A
 %0A
-%09return publicKey, privateKey, nil%0A
+%09return privateKey%0A
 %7D%0A%0A/
- f bb43c357b9bc26c3f8f010e5dffcb69590683b627642f0ca03933e4598145b6e vendor/golang.org/x/crypto/ed25519/internal/edwards25519/const.go
+ f 17c6ee3fe6f13dbfe28260b40c5503c50e2131f3c0fe497abae0ae9b1db9c721 vendor/golang.org/x/crypto/ed25519/internal/edwards25519/const.go
dmppatch 4
@@ -775,126 +775,8 @@
 %0A%7D%0A%0A
-// A is a constant in the Montgomery-form of curve25519.%0Avar A = FieldElement%7B%0A%09486662, 0, 0, 0, 0, 0, 0, 0, 0, 0,%0A%7D%0A%0A
 // b
+ f c63c4ad72acb641eae36f01ed60755fb60987d8842e98e13a835a28b595f2076 vendor/golang.org/x/crypto/internal/subtle/aliasing.go
dmppatch 2
@@ -0,0 +1,767 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build !appengine%0A%0A// Package subtle implements functions that are often useful in cryptographic%0A// code but require careful thought to use correctly.%0Apackage subtle // import %22golang.org/x/crypto/internal/subtle%22%0A%0Aimport %22unsafe%22%0A%0A// AnyOverlap reports whether x and y share memory at any (not necessarily%0A// corresponding) index. The memory beyond the slice length is ignored.%0Afunc AnyOverlap(x, y %5B%5Dbyte) bool %7B%0A%09return len(x) %3E 0 && len(y) %3E 0 &&%0A%09%09uintptr(unsafe.Pointer(&x%5B0%5D)) %3C= uintptr(unsafe.Pointer(&y%5Blen(y)-1%5D)) &&%0A%09%09uintptr(unsafe.Pointer(&y%5B0%5D)) %3C= uintptr(unsafe.Pointer(&x%5Blen(x)-1%5D))%0A%7D%0A
+ f 0aa29b1f36e73f505f88ba169e2a4cb8fdfb580e4b1e91b2450b6af80a910ae0 vendor/golang.org/x/crypto/internal/subtle/aliasing_appengine.go
dmppatch 2
@@ -0,0 +1,897 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build appengine%0A%0A// Package subtle implements functions that are often useful in cryptographic%0A// code but require careful thought to use correctly.%0Apackage subtle // import %22golang.org/x/crypto/internal/subtle%22%0A%0A// This is the Google App Engine standard variant based on reflect%0A// because the unsafe package and cgo are disallowed.%0A%0Aimport %22reflect%22%0A%0A// AnyOverlap reports whether x and y share memory at any (not necessarily%0A// corresponding) index. The memory beyond the slice length is ignored.%0Afunc AnyOverlap(x, y %5B%5Dbyte) bool %7B%0A%09return len(x) %3E 0 && len(y) %3E 0 &&%0A%09%09reflect.ValueOf(&x%5B0%5D).Pointer() %3C= reflect.ValueOf(&y%5Blen(y)-1%5D).Pointer() &&%0A%09%09reflect.ValueOf(&y%5B0%5D).Pointer() %3C= reflect.ValueOf(&x%5Blen(x)-1%5D).Pointer()%0A%7D%0A
- f 1063ee381dd2a3396da6b2363de13f9135349c412226f80e2fd200d67d238c1f vendor/golang.org/x/crypto/nacl/secretbox/secretbox.go
+ f cdfe9638276aeaa95f9f69d8c31e2aa078da2aa3985eac2b00f0d15b7f427eb3 vendor/golang.org/x/crypto/nacl/secretbox/secretbox.go
dmppatch 17
@@ -1490,16 +1490,55 @@
 mport (%0A
+%09%22golang.org/x/crypto/internal/subtle%22%0A
 %09%22golang
@@ -3468,16 +3468,97 @@
 agSize)%0A
+%09if subtle.AnyOverlap(out, message) %7B%0A%09%09panic(%22nacl: invalid buffer overlap%22)%0A%09%7D%0A
 %0A%09// We 
@@ -4366,91 +4366,84 @@
 ox.%0A
-func Open(out %5B%5Dbyte, box %5B%5Dbyte, nonce *%5B24%5Dbyte, key *%5B32%5Dbyte) (%5B%5Dbyte, bool) %7B%0A
+func Open(out, box %5B%5Dbyte, nonce *%5B24%5Dbyte, key *%5B32%5Dbyte) (%5B%5Dbyte, bool) %7B%0A
 %09if 
@@ -5096,16 +5096,93 @@
 erhead)%0A
+%09if subtle.AnyOverlap(out, box) %7B%0A%09%09panic(%22nacl: invalid buffer overlap%22)%0A%09%7D%0A
 %0A%09// We 
- f 5da9fa06a7dab609c8c21fb8b4971342c9ab6d1bd74a427368662614541673a4 vendor/golang.org/x/crypto/poly1305/sum_arm.go
+ f e116d09071dc1de5b22ae5841afb676f275d8e70a8e39f80c807be4da23240c3 vendor/golang.org/x/crypto/poly1305/sum_arm.go
dmppatch 4
@@ -214,145 +214,8 @@
 05%0A%0A
-// This function is implemented in sum_arm.s%0A//go:noescape%0Afunc poly1305_auth_armv6(out *%5B16%5Dbyte, m *byte, mlen uint32, key *%5B32%5Dbyte)%0A%0A
 // S
- f 5b172acfbfdb395da9ebc317b048eb4dc1acf44a2dce7110c29f9f6b619685f5 vendor/golang.org/x/crypto/poly1305/sum_ref.go
+ f 19a3c38ea5e01615170bdb4d4879ec41f123291a1fc1276468213e6611642dbb vendor/golang.org/x/crypto/poly1305/sum_ref.go
dmppatch 3
@@ -174,4629 +174,4 @@
 305%0A
-%0Aimport %22encoding/binary%22%0A%0A// sumGeneric generates an authenticator for msg using a one-time key and%0A// puts the 16-byte result into out. This is the generic implementation of%0A// Sum and should be called if no assembly implementation is available.%0Afunc sumGeneric(out *%5BTagSize%5Dbyte, msg %5B%5Dbyte, key *%5B32%5Dbyte) %7B%0A%09var (%0A%09%09h0, h1, h2, h3, h4 uint32 // the hash accumulators%0A%09%09r0, r1, r2, r3, r4 uint64 // the r part of the key%0A%09)%0A%0A%09r0 = uint64(binary.LittleEndian.Uint32(key%5B0:%5D) & 0x3ffffff)%0A%09r1 = uint64((binary.LittleEndian.Uint32(key%5B3:%5D) %3E%3E 2) & 0x3ffff03)%0A%09r2 = uint64((binary.LittleEndian.Uint32(key%5B6:%5D) %3E%3E 4) & 0x3ffc0ff)%0A%09r3 = uint64((binary.LittleEndian.Uint32(key%5B9:%5D) %3E%3E 6) & 0x3f03fff)%0A%09r4 = uint64((binary.LittleEndian.Uint32(key%5B12:%5D) %3E%3E 8) & 0x00fffff)%0A%0A%09R1, R2, R3, R4 := r1*5, r2*5, r3*5, r4*5%0A%0A%09for len(msg) %3E= TagSize %7B%0A%09%09// h += msg%0A%09%09h0 += binary.LittleEndian.Uint32(msg%5B0:%5D) & 0x3ffffff%0A%09%09h1 += (binary.LittleEndian.Uint32(msg%5B3:%5D) %3E%3E 2) & 0x3ffffff%0A%09%09h2 += (binary.LittleEndian.Uint32(msg%5B6:%5D) %3E%3E 4) & 0x3ffffff%0A%09%09h3 += (binary.LittleEndian.Uint32(msg%5B9:%5D) %3E%3E 6) & 0x3ffffff%0A%09%09h4 += (binary.LittleEndian.Uint32(msg%5B12:%5D) %3E%3E 8) %7C (1 %3C%3C 24)%0A%0A%09%09// h *= r%0A%09%09d0 := (uint64(h0) * r0) + (uint64(h1) * R4) + (uint64(h2) * R3) + (uint64(h3) * R2) + (uint64(h4) * R1)%0A%09%09d1 := (d0 %3E%3E 26) + (uint64(h0) * r1) + (uint64(h1) * r0) + (uint64(h2) * R4) + (uint64(h3) * R3) + (uint64(h4) * R2)%0A%09%09d2 := (d1 %3E%3E 26) + (uint64(h0) * r2) + (uint64(h1) * r1) + (uint64(h2) * r0) + (uint64(h3) * R4) + (uint64(h4) * R3)%0A%09%09d3 := (d2 %3E%3E 26) + (uint64(h0) * r3) + (uint64(h1) * r2) + (uint64(h2) * r1) + (uint64(h3) * r0) + (uint64(h4) * R4)%0A%09%09d4 := (d3 %3E%3E 26) + (uint64(h0) * r4) + (uint64(h1) * r3) + (uint64(h2) * r2) + (uint64(h3) * r1) + (uint64(h4) * r0)%0A%0A%09%09// h %25= p%0A%09%09h0 = uint32(d0) & 0x3ffffff%0A%09%09h1 = uint32(d1) & 0x3ffffff%0A%09%09h2 = uint32(d2) & 0x3ffffff%0A%09%09h3 = uint32(d3) & 0x3ffffff%0A%09%09h4 = uint32(d4) & 0x3ffffff%0A%0A%09%09h0 += uint32(d4%3E%3E26) * 5%0A%09%09h1 += h0 %3E%3E 26%0A%09%09h0 = h0 & 0x3ffffff%0A%0A%09%09msg = msg%5BTagSize:%5D%0A%09%7D%0A%0A%09if len(msg) %3E 0 %7B%0A%09%09var block %5BTagSize%5Dbyte%0A%09%09off := copy(block%5B:%5D, msg)%0A%09%09block%5Boff%5D = 0x01%0A%0A%09%09// h += msg%0A%09%09h0 += binary.LittleEndian.Uint32(block%5B0:%5D) & 0x3ffffff%0A%09%09h1 += (binary.LittleEndian.Uint32(block%5B3:%5D) %3E%3E 2) & 0x3ffffff%0A%09%09h2 += (binary.LittleEndian.Uint32(block%5B6:%5D) %3E%3E 4) & 0x3ffffff%0A%09%09h3 += (binary.LittleEndian.Uint32(block%5B9:%5D) %3E%3E 6) & 0x3ffffff%0A%09%09h4 += (binary.LittleEndian.Uint32(block%5B12:%5D) %3E%3E 8)%0A%0A%09%09// h *= r%0A%09%09d0 := (uint64(h0) * r0) + (uint64(h1) * R4) + (uint64(h2) * R3) + (uint64(h3) * R2) + (uint64(h4) * R1)%0A%09%09d1 := (d0 %3E%3E 26) + (uint64(h0) * r1) + (uint64(h1) * r0) + (uint64(h2) * R4) + (uint64(h3) * R3) + (uint64(h4) * R2)%0A%09%09d2 := (d1 %3E%3E 26) + (uint64(h0) * r2) + (uint64(h1) * r1) + (uint64(h2) * r0) + (uint64(h3) * R4) + (uint64(h4) * R3)%0A%09%09d3 := (d2 %3E%3E 26) + (uint64(h0) * r3) + (uint64(h1) * r2) + (uint64(h2) * r1) + (uint64(h3) * r0) + (uint64(h4) * R4)%0A%09%09d4 := (d3 %3E%3E 26) + (uint64(h0) * r4) + (uint64(h1) * r3) + (uint64(h2) * r2) + (uint64(h3) * r1) + (uint64(h4) * r0)%0A%0A%09%09// h %25= p%0A%09%09h0 = uint32(d0) & 0x3ffffff%0A%09%09h1 = uint32(d1) & 0x3ffffff%0A%09%09h2 = uint32(d2) & 0x3ffffff%0A%09%09h3 = uint32(d3) & 0x3ffffff%0A%09%09h4 = uint32(d4) & 0x3ffffff%0A%0A%09%09h0 += uint32(d4%3E%3E26) * 5%0A%09%09h1 += h0 %3E%3E 26%0A%09%09h0 = h0 & 0x3ffffff%0A%09%7D%0A%0A%09// h %25= p reduction%0A%09h2 += h1 %3E%3E 26%0A%09h1 &= 0x3ffffff%0A%09h3 += h2 %3E%3E 26%0A%09h2 &= 0x3ffffff%0A%09h4 += h3 %3E%3E 26%0A%09h3 &= 0x3ffffff%0A%09h0 += 5 * (h4 %3E%3E 26)%0A%09h4 &= 0x3ffffff%0A%09h1 += h0 %3E%3E 26%0A%09h0 &= 0x3ffffff%0A%0A%09// h - p%0A%09t0 := h0 + 5%0A%09t1 := h1 + (t0 %3E%3E 26)%0A%09t2 := h2 + (t1 %3E%3E 26)%0A%09t3 := h3 + (t2 %3E%3E 26)%0A%09t4 := h4 + (t3 %3E%3E 26) - (1 %3C%3C 26)%0A%09t0 &= 0x3ffffff%0A%09t1 &= 0x3ffffff%0A%09t2 &= 0x3ffffff%0A%09t3 &= 0x3ffffff%0A%0A%09// select h if h %3C p else h - p%0A%09t_mask := (t4 %3E%3E 31) - 1%0A%09h_mask := %5Et_mask%0A%09h0 = (h0 & h_mask) %7C (t0 & t_mask)%0A%09h1 = (h1 & h_mask) %7C (t1 & t_mask)%0A%09h2 = (h2 & h_mask) %7C (t2 & t_mask)%0A%09h3 = (h3 & h_mask) %7C (t3 & t_mask)%0A%09h4 = (h4 & h_mask) %7C (t4 & t_mask)%0A%0A%09// h %25= 2%5E128%0A%09h0 %7C= h1 %3C%3C 26%0A%09h1 = ((h1 %3E%3E 6) %7C (h2 %3C%3C 20))%0A%09h2 = ((h2 %3E%3E 12) %7C (h3 %3C%3C 14))%0A%09h3 = ((h3 %3E%3E 18) %7C (h4 %3C%3C 8))%0A%0A%09// s: the s part of the key%0A%09// tag = (h + s) %25 (2%5E128)%0A%09t := uint64(h0) + uint64(binary.LittleEndian.Uint32(key%5B16:%5D))%0A%09h0 = uint32(t)%0A%09t = uint64(h1) + uint64(binary.LittleEndian.Uint32(key%5B20:%5D)) + (t %3E%3E 32)%0A%09h1 = uint32(t)%0A%09t = uint64(h2) + uint64(binary.LittleEndian.Uint32(key%5B24:%5D)) + (t %3E%3E 32)%0A%09h2 = uint32(t)%0A%09t = uint64(h3) + uint64(binary.LittleEndian.Uint32(key%5B28:%5D)) + (t %3E%3E 32)%0A%09h3 = uint32(t)%0A%0A%09binary.LittleEndian.PutUint32(out%5B0:%5D, h0)%0A%09binary.LittleEndian.PutUint32(out%5B4:%5D, h1)%0A%09binary.LittleEndian.PutUint32(out%5B8:%5D, h2)%0A%09binary.LittleEndian.PutUint32(out%5B12:%5D, h3)%0A%7D%0A
- f 60768a98b4fe6fc8982fe50a0f2408b7abfaa3253ec3a003045f5e44d30a3f5a vendor/golang.org/x/crypto/poly1305/sum_s390x.go
+ f 253615c13fa52b506ae7073a68d9231af388b9167751d780abb128919390a314 vendor/golang.org/x/crypto/poly1305/sum_s390x.go
dmppatch 4
@@ -217,842 +217,8 @@
 05%0A%0A
-// hasVectorFacility reports whether the machine supports%0A// the vector facility (vx).%0Afunc hasVectorFacility() bool%0A%0A// hasVMSLFacility reports whether the machine supports%0A// Vector Multiply Sum Logical (VMSL).%0Afunc hasVMSLFacility() bool%0A%0Avar hasVX = hasVectorFacility()%0Avar hasVMSL = hasVMSLFacility()%0A%0A// poly1305vx is an assembly implementation of Poly1305 that uses vector%0A// instructions. It must only be called if the vector facility (vx) is%0A// available.%0A//go:noescape%0Afunc poly1305vx(out *%5B16%5Dbyte, m *byte, mlen uint64, key *%5B32%5Dbyte)%0A%0A// poly1305vmsl is an assembly implementation of Poly1305 that uses vector%0A// instructions, including VMSL. It must only be called if the vector facility (vx) is%0A// available and if VMSL is supported.%0A//go:noescape%0Afunc poly1305vmsl(out *%5B16%5Dbyte, m *byte, mlen uint64, key *%5B32%5Dbyte)%0A%0A
 // S
- f a59ddd01915d7260b1e26fd652ce29879a39cfaa87afde06e65754d7ec1717b6 vendor/golang.org/x/crypto/salsa20/salsa/salsa208.go
+ f 2c860eecee01e9ab072f72d76daa6060704a5354e0576bff5d185a61455c1c3c vendor/golang.org/x/crypto/salsa20/salsa/salsa208.go
dmppatch 3
@@ -171,4813 +171,4 @@
 lsa%0A
-%0A// Core208 applies the Salsa20/8 core function to the 64-byte array in and puts%0A// the result into the 64-byte array out. The input and output may be the same array.%0Afunc Core208(out *%5B64%5Dbyte, in *%5B64%5Dbyte) %7B%0A%09j0 := uint32(in%5B0%5D) %7C uint32(in%5B1%5D)%3C%3C8 %7C uint32(in%5B2%5D)%3C%3C16 %7C uint32(in%5B3%5D)%3C%3C24%0A%09j1 := uint32(in%5B4%5D) %7C uint32(in%5B5%5D)%3C%3C8 %7C uint32(in%5B6%5D)%3C%3C16 %7C uint32(in%5B7%5D)%3C%3C24%0A%09j2 := uint32(in%5B8%5D) %7C uint32(in%5B9%5D)%3C%3C8 %7C uint32(in%5B10%5D)%3C%3C16 %7C uint32(in%5B11%5D)%3C%3C24%0A%09j3 := uint32(in%5B12%5D) %7C uint32(in%5B13%5D)%3C%3C8 %7C uint32(in%5B14%5D)%3C%3C16 %7C uint32(in%5B15%5D)%3C%3C24%0A%09j4 := uint32(in%5B16%5D) %7C uint32(in%5B17%5D)%3C%3C8 %7C uint32(in%5B18%5D)%3C%3C16 %7C uint32(in%5B19%5D)%3C%3C24%0A%09j5 := uint32(in%5B20%5D) %7C uint32(in%5B21%5D)%3C%3C8 %7C uint32(in%5B22%5D)%3C%3C16 %7C uint32(in%5B23%5D)%3C%3C24%0A%09j6 := uint32(in%5B24%5D) %7C uint32(in%5B25%5D)%3C%3C8 %7C uint32(in%5B26%5D)%3C%3C16 %7C uint32(in%5B27%5D)%3C%3C24%0A%09j7 := uint32(in%5B28%5D) %7C uint32(in%5B29%5D)%3C%3C8 %7C uint32(in%5B30%5D)%3C%3C16 %7C uint32(in%5B31%5D)%3C%3C24%0A%09j8 := uint32(in%5B32%5D) %7C uint32(in%5B33%5D)%3C%3C8 %7C uint32(in%5B34%5D)%3C%3C16 %7C uint32(in%5B35%5D)%3C%3C24%0A%09j9 := uint32(in%5B36%5D) %7C uint32(in%5B37%5D)%3C%3C8 %7C uint32(in%5B38%5D)%3C%3C16 %7C uint32(in%5B39%5D)%3C%3C24%0A%09j10 := uint32(in%5B40%5D) %7C uint32(in%5B41%5D)%3C%3C8 %7C uint32(in%5B42%5D)%3C%3C16 %7C uint32(in%5B43%5D)%3C%3C24%0A%09j11 := uint32(in%5B44%5D) %7C uint32(in%5B45%5D)%3C%3C8 %7C uint32(in%5B46%5D)%3C%3C16 %7C uint32(in%5B47%5D)%3C%3C24%0A%09j12 := uint32(in%5B48%5D) %7C uint32(in%5B49%5D)%3C%3C8 %7C uint32(in%5B50%5D)%3C%3C16 %7C uint32(in%5B51%5D)%3C%3C24%0A%09j13 := uint32(in%5B52%5D) %7C uint32(in%5B53%5D)%3C%3C8 %7C uint32(in%5B54%5D)%3C%3C16 %7C uint32(in%5B55%5D)%3C%3C24%0A%09j14 := uint32(in%5B56%5D) %7C uint32(in%5B57%5D)%3C%3C8 %7C uint32(in%5B58%5D)%3C%3C16 %7C uint32(in%5B59%5D)%3C%3C24%0A%09j15 := uint32(in%5B60%5D) %7C uint32(in%5B61%5D)%3C%3C8 %7C uint32(in%5B62%5D)%3C%3C16 %7C uint32(in%5B63%5D)%3C%3C24%0A%0A%09x0, x1, x2, x3, x4, x5, x6, x7, x8 := j0, j1, j2, j3, j4, j5, j6, j7, j8%0A%09x9, x10, x11, x12, x13, x14, x15 := j9, j10, j11, j12, j13, j14, j15%0A%0A%09for i := 0; i %3C 8; i += 2 %7B%0A%09%09u := x0 + x12%0A%09%09x4 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x4 + x0%0A%09%09x8 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x8 + x4%0A%09%09x12 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x12 + x8%0A%09%09x0 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x5 + x1%0A%09%09x9 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x9 + x5%0A%09%09x13 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x13 + x9%0A%09%09x1 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x1 + x13%0A%09%09x5 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x10 + x6%0A%09%09x14 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x14 + x10%0A%09%09x2 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x2 + x14%0A%09%09x6 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x6 + x2%0A%09%09x10 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x15 + x11%0A%09%09x3 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x3 + x15%0A%09%09x7 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x7 + x3%0A%09%09x11 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x11 + x7%0A%09%09x15 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x0 + x3%0A%09%09x1 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x1 + x0%0A%09%09x2 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x2 + x1%0A%09%09x3 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x3 + x2%0A%09%09x0 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x5 + x4%0A%09%09x6 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x6 + x5%0A%09%09x7 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x7 + x6%0A%09%09x4 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x4 + x7%0A%09%09x5 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x10 + x9%0A%09%09x11 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x11 + x10%0A%09%09x8 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x8 + x11%0A%09%09x9 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x9 + x8%0A%09%09x10 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x15 + x14%0A%09%09x12 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x12 + x15%0A%09%09x13 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x13 + x12%0A%09%09x14 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x14 + x13%0A%09%09x15 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%09%7D%0A%09x0 += j0%0A%09x1 += j1%0A%09x2 += j2%0A%09x3 += j3%0A%09x4 += j4%0A%09x5 += j5%0A%09x6 += j6%0A%09x7 += j7%0A%09x8 += j8%0A%09x9 += j9%0A%09x10 += j10%0A%09x11 += j11%0A%09x12 += j12%0A%09x13 += j13%0A%09x14 += j14%0A%09x15 += j15%0A%0A%09out%5B0%5D = byte(x0)%0A%09out%5B1%5D = byte(x0 %3E%3E 8)%0A%09out%5B2%5D = byte(x0 %3E%3E 16)%0A%09out%5B3%5D = byte(x0 %3E%3E 24)%0A%0A%09out%5B4%5D = byte(x1)%0A%09out%5B5%5D = byte(x1 %3E%3E 8)%0A%09out%5B6%5D = byte(x1 %3E%3E 16)%0A%09out%5B7%5D = byte(x1 %3E%3E 24)%0A%0A%09out%5B8%5D = byte(x2)%0A%09out%5B9%5D = byte(x2 %3E%3E 8)%0A%09out%5B10%5D = byte(x2 %3E%3E 16)%0A%09out%5B11%5D = byte(x2 %3E%3E 24)%0A%0A%09out%5B12%5D = byte(x3)%0A%09out%5B13%5D = byte(x3 %3E%3E 8)%0A%09out%5B14%5D = byte(x3 %3E%3E 16)%0A%09out%5B15%5D = byte(x3 %3E%3E 24)%0A%0A%09out%5B16%5D = byte(x4)%0A%09out%5B17%5D = byte(x4 %3E%3E 8)%0A%09out%5B18%5D = byte(x4 %3E%3E 16)%0A%09out%5B19%5D = byte(x4 %3E%3E 24)%0A%0A%09out%5B20%5D = byte(x5)%0A%09out%5B21%5D = byte(x5 %3E%3E 8)%0A%09out%5B22%5D = byte(x5 %3E%3E 16)%0A%09out%5B23%5D = byte(x5 %3E%3E 24)%0A%0A%09out%5B24%5D = byte(x6)%0A%09out%5B25%5D = byte(x6 %3E%3E 8)%0A%09out%5B26%5D = byte(x6 %3E%3E 16)%0A%09out%5B27%5D = byte(x6 %3E%3E 24)%0A%0A%09out%5B28%5D = byte(x7)%0A%09out%5B29%5D = byte(x7 %3E%3E 8)%0A%09out%5B30%5D = byte(x7 %3E%3E 16)%0A%09out%5B31%5D = byte(x7 %3E%3E 24)%0A%0A%09out%5B32%5D = byte(x8)%0A%09out%5B33%5D = byte(x8 %3E%3E 8)%0A%09out%5B34%5D = byte(x8 %3E%3E 16)%0A%09out%5B35%5D = byte(x8 %3E%3E 24)%0A%0A%09out%5B36%5D = byte(x9)%0A%09out%5B37%5D = byte(x9 %3E%3E 8)%0A%09out%5B38%5D = byte(x9 %3E%3E 16)%0A%09out%5B39%5D = byte(x9 %3E%3E 24)%0A%0A%09out%5B40%5D = byte(x10)%0A%09out%5B41%5D = byte(x10 %3E%3E 8)%0A%09out%5B42%5D = byte(x10 %3E%3E 16)%0A%09out%5B43%5D = byte(x10 %3E%3E 24)%0A%0A%09out%5B44%5D = byte(x11)%0A%09out%5B45%5D = byte(x11 %3E%3E 8)%0A%09out%5B46%5D = byte(x11 %3E%3E 16)%0A%09out%5B47%5D = byte(x11 %3E%3E 24)%0A%0A%09out%5B48%5D = byte(x12)%0A%09out%5B49%5D = byte(x12 %3E%3E 8)%0A%09out%5B50%5D = byte(x12 %3E%3E 16)%0A%09out%5B51%5D = byte(x12 %3E%3E 24)%0A%0A%09out%5B52%5D = byte(x13)%0A%09out%5B53%5D = byte(x13 %3E%3E 8)%0A%09out%5B54%5D = byte(x13 %3E%3E 16)%0A%09out%5B55%5D = byte(x13 %3E%3E 24)%0A%0A%09out%5B56%5D = byte(x14)%0A%09out%5B57%5D = byte(x14 %3E%3E 8)%0A%09out%5B58%5D = byte(x14 %3E%3E 16)%0A%09out%5B59%5D = byte(x14 %3E%3E 24)%0A%0A%09out%5B60%5D = byte(x15)%0A%09out%5B61%5D = byte(x15 %3E%3E 8)%0A%09out%5B62%5D = byte(x15 %3E%3E 16)%0A%09out%5B63%5D = byte(x15 %3E%3E 24)%0A%7D%0A
- f 8f3bf841ea60048812524ec693ce2d97506ef511287ff5de5547ba71f733eaa4 vendor/golang.org/x/crypto/salsa20/salsa/salsa20_ref.go
+ f 9b7d8a1cee11301a51b3db2973d43fb46596a3a8f8efa2eb337344d9de216894 vendor/golang.org/x/crypto/salsa20/salsa/salsa20_ref.go
dmppatch 4
@@ -206,4779 +206,8 @@
 sa%0A%0A
-const rounds = 20%0A%0A// core applies the Salsa20 core function to 16-byte input in, 32-byte key k,%0A// and 16-byte constant c, and puts the result into 64-byte array out.%0Afunc core(out *%5B64%5Dbyte, in *%5B16%5Dbyte, k *%5B32%5Dbyte, c *%5B16%5Dbyte) %7B%0A%09j0 := uint32(c%5B0%5D) %7C uint32(c%5B1%5D)%3C%3C8 %7C uint32(c%5B2%5D)%3C%3C16 %7C uint32(c%5B3%5D)%3C%3C24%0A%09j1 := uint32(k%5B0%5D) %7C uint32(k%5B1%5D)%3C%3C8 %7C uint32(k%5B2%5D)%3C%3C16 %7C uint32(k%5B3%5D)%3C%3C24%0A%09j2 := uint32(k%5B4%5D) %7C uint32(k%5B5%5D)%3C%3C8 %7C uint32(k%5B6%5D)%3C%3C16 %7C uint32(k%5B7%5D)%3C%3C24%0A%09j3 := uint32(k%5B8%5D) %7C uint32(k%5B9%5D)%3C%3C8 %7C uint32(k%5B10%5D)%3C%3C16 %7C uint32(k%5B11%5D)%3C%3C24%0A%09j4 := uint32(k%5B12%5D) %7C uint32(k%5B13%5D)%3C%3C8 %7C uint32(k%5B14%5D)%3C%3C16 %7C uint32(k%5B15%5D)%3C%3C24%0A%09j5 := uint32(c%5B4%5D) %7C uint32(c%5B5%5D)%3C%3C8 %7C uint32(c%5B6%5D)%3C%3C16 %7C uint32(c%5B7%5D)%3C%3C24%0A%09j6 := uint32(in%5B0%5D) %7C uint32(in%5B1%5D)%3C%3C8 %7C uint32(in%5B2%5D)%3C%3C16 %7C uint32(in%5B3%5D)%3C%3C24%0A%09j7 := uint32(in%5B4%5D) %7C uint32(in%5B5%5D)%3C%3C8 %7C uint32(in%5B6%5D)%3C%3C16 %7C uint32(in%5B7%5D)%3C%3C24%0A%09j8 := uint32(in%5B8%5D) %7C uint32(in%5B9%5D)%3C%3C8 %7C uint32(in%5B10%5D)%3C%3C16 %7C uint32(in%5B11%5D)%3C%3C24%0A%09j9 := uint32(in%5B12%5D) %7C uint32(in%5B13%5D)%3C%3C8 %7C uint32(in%5B14%5D)%3C%3C16 %7C uint32(in%5B15%5D)%3C%3C24%0A%09j10 := uint32(c%5B8%5D) %7C uint32(c%5B9%5D)%3C%3C8 %7C uint32(c%5B10%5D)%3C%3C16 %7C uint32(c%5B11%5D)%3C%3C24%0A%09j11 := uint32(k%5B16%5D) %7C uint32(k%5B17%5D)%3C%3C8 %7C uint32(k%5B18%5D)%3C%3C16 %7C uint32(k%5B19%5D)%3C%3C24%0A%09j12 := uint32(k%5B20%5D) %7C uint32(k%5B21%5D)%3C%3C8 %7C uint32(k%5B22%5D)%3C%3C16 %7C uint32(k%5B23%5D)%3C%3C24%0A%09j13 := uint32(k%5B24%5D) %7C uint32(k%5B25%5D)%3C%3C8 %7C uint32(k%5B26%5D)%3C%3C16 %7C uint32(k%5B27%5D)%3C%3C24%0A%09j14 := uint32(k%5B28%5D) %7C uint32(k%5B29%5D)%3C%3C8 %7C uint32(k%5B30%5D)%3C%3C16 %7C uint32(k%5B31%5D)%3C%3C24%0A%09j15 := uint32(c%5B12%5D) %7C uint32(c%5B13%5D)%3C%3C8 %7C uint32(c%5B14%5D)%3C%3C16 %7C uint32(c%5B15%5D)%3C%3C24%0A%0A%09x0, x1, x2, x3, x4, x5, x6, x7, x8 := j0, j1, j2, j3, j4, j5, j6, j7, j8%0A%09x9, x10, x11, x12, x13, x14, x15 := j9, j10, j11, j12, j13, j14, j15%0A%0A%09for i := 0; i %3C rounds; i += 2 %7B%0A%09%09u := x0 + x12%0A%09%09x4 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x4 + x0%0A%09%09x8 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x8 + x4%0A%09%09x12 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x12 + x8%0A%09%09x0 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x5 + x1%0A%09%09x9 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x9 + x5%0A%09%09x13 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x13 + x9%0A%09%09x1 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x1 + x13%0A%09%09x5 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x10 + x6%0A%09%09x14 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x14 + x10%0A%09%09x2 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x2 + x14%0A%09%09x6 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x6 + x2%0A%09%09x10 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x15 + x11%0A%09%09x3 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x3 + x15%0A%09%09x7 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x7 + x3%0A%09%09x11 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x11 + x7%0A%09%09x15 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x0 + x3%0A%09%09x1 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x1 + x0%0A%09%09x2 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x2 + x1%0A%09%09x3 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x3 + x2%0A%09%09x0 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x5 + x4%0A%09%09x6 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x6 + x5%0A%09%09x7 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x7 + x6%0A%09%09x4 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x4 + x7%0A%09%09x5 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x10 + x9%0A%09%09x11 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x11 + x10%0A%09%09x8 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x8 + x11%0A%09%09x9 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x9 + x8%0A%09%09x10 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x15 + x14%0A%09%09x12 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x12 + x15%0A%09%09x13 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x13 + x12%0A%09%09x14 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x14 + x13%0A%09%09x15 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%09%7D%0A%09x0 += j0%0A%09x1 += j1%0A%09x2 += j2%0A%09x3 += j3%0A%09x4 += j4%0A%09x5 += j5%0A%09x6 += j6%0A%09x7 += j7%0A%09x8 += j8%0A%09x9 += j9%0A%09x10 += j10%0A%09x11 += j11%0A%09x12 += j12%0A%09x13 += j13%0A%09x14 += j14%0A%09x15 += j15%0A%0A%09out%5B0%5D = byte(x0)%0A%09out%5B1%5D = byte(x0 %3E%3E 8)%0A%09out%5B2%5D = byte(x0 %3E%3E 16)%0A%09out%5B3%5D = byte(x0 %3E%3E 24)%0A%0A%09out%5B4%5D = byte(x1)%0A%09out%5B5%5D = byte(x1 %3E%3E 8)%0A%09out%5B6%5D = byte(x1 %3E%3E 16)%0A%09out%5B7%5D = byte(x1 %3E%3E 24)%0A%0A%09out%5B8%5D = byte(x2)%0A%09out%5B9%5D = byte(x2 %3E%3E 8)%0A%09out%5B10%5D = byte(x2 %3E%3E 16)%0A%09out%5B11%5D = byte(x2 %3E%3E 24)%0A%0A%09out%5B12%5D = byte(x3)%0A%09out%5B13%5D = byte(x3 %3E%3E 8)%0A%09out%5B14%5D = byte(x3 %3E%3E 16)%0A%09out%5B15%5D = byte(x3 %3E%3E 24)%0A%0A%09out%5B16%5D = byte(x4)%0A%09out%5B17%5D = byte(x4 %3E%3E 8)%0A%09out%5B18%5D = byte(x4 %3E%3E 16)%0A%09out%5B19%5D = byte(x4 %3E%3E 24)%0A%0A%09out%5B20%5D = byte(x5)%0A%09out%5B21%5D = byte(x5 %3E%3E 8)%0A%09out%5B22%5D = byte(x5 %3E%3E 16)%0A%09out%5B23%5D = byte(x5 %3E%3E 24)%0A%0A%09out%5B24%5D = byte(x6)%0A%09out%5B25%5D = byte(x6 %3E%3E 8)%0A%09out%5B26%5D = byte(x6 %3E%3E 16)%0A%09out%5B27%5D = byte(x6 %3E%3E 24)%0A%0A%09out%5B28%5D = byte(x7)%0A%09out%5B29%5D = byte(x7 %3E%3E 8)%0A%09out%5B30%5D = byte(x7 %3E%3E 16)%0A%09out%5B31%5D = byte(x7 %3E%3E 24)%0A%0A%09out%5B32%5D = byte(x8)%0A%09out%5B33%5D = byte(x8 %3E%3E 8)%0A%09out%5B34%5D = byte(x8 %3E%3E 16)%0A%09out%5B35%5D = byte(x8 %3E%3E 24)%0A%0A%09out%5B36%5D = byte(x9)%0A%09out%5B37%5D = byte(x9 %3E%3E 8)%0A%09out%5B38%5D = byte(x9 %3E%3E 16)%0A%09out%5B39%5D = byte(x9 %3E%3E 24)%0A%0A%09out%5B40%5D = byte(x10)%0A%09out%5B41%5D = byte(x10 %3E%3E 8)%0A%09out%5B42%5D = byte(x10 %3E%3E 16)%0A%09out%5B43%5D = byte(x10 %3E%3E 24)%0A%0A%09out%5B44%5D = byte(x11)%0A%09out%5B45%5D = byte(x11 %3E%3E 8)%0A%09out%5B46%5D = byte(x11 %3E%3E 16)%0A%09out%5B47%5D = byte(x11 %3E%3E 24)%0A%0A%09out%5B48%5D = byte(x12)%0A%09out%5B49%5D = byte(x12 %3E%3E 8)%0A%09out%5B50%5D = byte(x12 %3E%3E 16)%0A%09out%5B51%5D = byte(x12 %3E%3E 24)%0A%0A%09out%5B52%5D = byte(x13)%0A%09out%5B53%5D = byte(x13 %3E%3E 8)%0A%09out%5B54%5D = byte(x13 %3E%3E 16)%0A%09out%5B55%5D = byte(x13 %3E%3E 24)%0A%0A%09out%5B56%5D = byte(x14)%0A%09out%5B57%5D = byte(x14 %3E%3E 8)%0A%09out%5B58%5D = byte(x14 %3E%3E 16)%0A%09out%5B59%5D = byte(x14 %3E%3E 24)%0A%0A%09out%5B60%5D = byte(x15)%0A%09out%5B61%5D = byte(x15 %3E%3E 8)%0A%09out%5B62%5D = byte(x15 %3E%3E 16)%0A%09out%5B63%5D = byte(x15 %3E%3E 24)%0A%7D%0A%0A
 // X
- f 3747adee7740c61bfc65b275c7acb33735e8fb34e7d9c62317eff1918eca577c vendor/golang.org/x/crypto/ssh/terminal/terminal.go
+ f ae18df5f10874adfc8587bcb2cb9dfd97fbc04e6bacc2283a0b851da68de83ef vendor/golang.org/x/crypto/ssh/terminal/terminal.go
dmppatch 32
@@ -505,482 +505,8 @@
 %0A%7D%0A%0A
-var vt100EscapeCodes = EscapeCodes%7B%0A%09Black:   %5B%5Dbyte%7BkeyEscape, '%5B', '3', '0', 'm'%7D,%0A%09Red:     %5B%5Dbyte%7BkeyEscape, '%5B', '3', '1', 'm'%7D,%0A%09Green:   %5B%5Dbyte%7BkeyEscape, '%5B', '3', '2', 'm'%7D,%0A%09Yellow:  %5B%5Dbyte%7BkeyEscape, '%5B', '3', '3', 'm'%7D,%0A%09Blue:    %5B%5Dbyte%7BkeyEscape, '%5B', '3', '4', 'm'%7D,%0A%09Magenta: %5B%5Dbyte%7BkeyEscape, '%5B', '3', '5', 'm'%7D,%0A%09Cyan:    %5B%5Dbyte%7BkeyEscape, '%5B', '3', '6', 'm'%7D,%0A%09White:   %5B%5Dbyte%7BkeyEscape, '%5B', '3', '7', 'm'%7D,%0A%0A%09Reset: %5B%5Dbyte%7BkeyEscape, '%5B', '0', 'm'%7D,%0A%7D%0A%0A
 // T
@@ -2653,506 +2653,8 @@
 %0A%7D%0A%0A
-// NewTerminal runs a VT100 terminal on the given ReadWriter. If the ReadWriter is%0A// a local terminal, that terminal must first have been put into raw mode.%0A// prompt is a string that is written at the start of each input line (i.e.%0A// %22%3E %22).%0Afunc NewTerminal(c io.ReadWriter, prompt string) *Terminal %7B%0A%09return &Terminal%7B%0A%09%09Escape:       &vt100EscapeCodes,%0A%09%09c:            c,%0A%09%09prompt:       %5B%5Drune(prompt),%0A%09%09termWidth:    80,%0A%09%09termHeight:   24,%0A%09%09echo:         true,%0A%09%09historyIndex: -1,%0A%09%7D%0A%7D%0A%0A
 cons
@@ -5124,64 +5124,8 @@
 %0A%7D%0A%0A
-var eraseUnderCursor = %5B%5Drune%7B' ', keyEscape, '%5B', 'D'%7D%0A
 var 
@@ -6336,99 +6336,8 @@
 nt)%0A
-%7D%0A%0Afunc (t *Terminal) clearLineToRight() %7B%0A%09op := %5B%5Drune%7BkeyEscape, '%5B', 'K'%7D%0A%09t.queue(op)%0A
 %7D%0A%0Ac
@@ -12553,1398 +12553,8 @@
 %0A%7D%0A%0A
-// writeWithCRLF writes buf to w but replaces all occurrences of %5Cn with %5Cr%5Cn.%0Afunc writeWithCRLF(w io.Writer, buf %5B%5Dbyte) (n int, err error) %7B%0A%09for len(buf) %3E 0 %7B%0A%09%09i := bytes.IndexByte(buf, '%5Cn')%0A%09%09todo := len(buf)%0A%09%09if i %3E= 0 %7B%0A%09%09%09todo = i%0A%09%09%7D%0A%0A%09%09var nn int%0A%09%09nn, err = w.Write(buf%5B:todo%5D)%0A%09%09n += nn%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09buf = buf%5Btodo:%5D%0A%0A%09%09if i %3E= 0 %7B%0A%09%09%09if _, err = w.Write(crlf); err != nil %7B%0A%09%09%09%09return n, err%0A%09%09%09%7D%0A%09%09%09n++%0A%09%09%09buf = buf%5B1:%5D%0A%09%09%7D%0A%09%7D%0A%0A%09return n, nil%0A%7D%0A%0Afunc (t *Terminal) Write(buf %5B%5Dbyte) (n int, err error) %7B%0A%09t.lock.Lock()%0A%09defer t.lock.Unlock()%0A%0A%09if t.cursorX == 0 && t.cursorY == 0 %7B%0A%09%09// This is the easy case: there's nothing on the screen that we%0A%09%09// have to move out of the way.%0A%09%09return writeWithCRLF(t.c, buf)%0A%09%7D%0A%0A%09// We have a prompt and possibly user input on the screen. We%0A%09// have to clear it first.%0A%09t.move(0 /* up */, 0 /* down */, t.cursorX /* left */, 0 /* right */)%0A%09t.cursorX = 0%0A%09t.clearLineToRight()%0A%0A%09for t.cursorY %3E 0 %7B%0A%09%09t.move(1 /* up */, 0, 0, 0)%0A%09%09t.cursorY--%0A%09%09t.clearLineToRight()%0A%09%7D%0A%0A%09if _, err = t.c.Write(t.outBuf); err != nil %7B%0A%09%09return%0A%09%7D%0A%09t.outBuf = t.outBuf%5B:0%5D%0A%0A%09if n, err = writeWithCRLF(t.c, buf); err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09t.writeLine(t.prompt)%0A%09if t.echo %7B%0A%09%09t.writeLine(t.line)%0A%09%7D%0A%0A%09t.moveCursorToPos(t.pos)%0A%0A%09if _, err = t.c.Write(t.outBuf); err != nil %7B%0A%09%09return%0A%09%7D%0A%09t.outBuf = t.outBuf%5B:0%5D%0A%09return%0A%7D%0A%0A
 // R
@@ -12911,183 +12911,8 @@
 urn%0A
-%7D%0A%0A// ReadLine returns a line of input from the terminal.%0Afunc (t *Terminal) ReadLine() (line string, err error) %7B%0A%09t.lock.Lock()%0A%09defer t.lock.Unlock()%0A%0A%09return t.readLine()%0A
 %7D%0A%0Af
@@ -14358,2469 +14358,8 @@
 %0A%7D%0A%0A
-// SetPrompt sets the prompt to be used when reading subsequent lines.%0Afunc (t *Terminal) SetPrompt(prompt string) %7B%0A%09t.lock.Lock()%0A%09defer t.lock.Unlock()%0A%0A%09t.prompt = %5B%5Drune(prompt)%0A%7D%0A%0Afunc (t *Terminal) clearAndRepaintLinePlusNPrevious(numPrevLines int) %7B%0A%09// Move cursor to column zero at the start of the line.%0A%09t.move(t.cursorY, 0, t.cursorX, 0)%0A%09t.cursorX, t.cursorY = 0, 0%0A%09t.clearLineToRight()%0A%09for t.cursorY %3C numPrevLines %7B%0A%09%09// Move down a line%0A%09%09t.move(0, 1, 0, 0)%0A%09%09t.cursorY++%0A%09%09t.clearLineToRight()%0A%09%7D%0A%09// Move back to beginning.%0A%09t.move(t.cursorY, 0, 0, 0)%0A%09t.cursorX, t.cursorY = 0, 0%0A%0A%09t.queue(t.prompt)%0A%09t.advanceCursor(visualLength(t.prompt))%0A%09t.writeLine(t.line)%0A%09t.moveCursorToPos(t.pos)%0A%7D%0A%0Afunc (t *Terminal) SetSize(width, height int) error %7B%0A%09t.lock.Lock()%0A%09defer t.lock.Unlock()%0A%0A%09if width == 0 %7B%0A%09%09width = 1%0A%09%7D%0A%0A%09oldWidth := t.termWidth%0A%09t.termWidth, t.termHeight = width, height%0A%0A%09switch %7B%0A%09case width == oldWidth:%0A%09%09// If the width didn't change then nothing else needs to be%0A%09%09// done.%0A%09%09return nil%0A%09case len(t.line) == 0 && t.cursorX == 0 && t.cursorY == 0:%0A%09%09// If there is nothing on current line and no prompt printed,%0A%09%09// just do nothing%0A%09%09return nil%0A%09case width %3C oldWidth:%0A%09%09// Some terminals (e.g. xterm) will truncate lines that were%0A%09%09// too long when shinking. Others, (e.g. gnome-terminal) will%0A%09%09// attempt to wrap them. For the former, repainting t.maxLine%0A%09%09// works great, but that behaviour goes badly wrong in the case%0A%09%09// of the latter because they have doubled every full line.%0A%0A%09%09// We assume that we are working on a terminal that wraps lines%0A%09%09// and adjust the cursor position based on every previous line%0A%09%09// wrapping and turning into two. This causes the prompt on%0A%09%09// xterms to move upwards, which isn't great, but it avoids a%0A%09%09// huge mess with gnome-terminal.%0A%09%09if t.cursorX %3E= t.termWidth %7B%0A%09%09%09t.cursorX = t.termWidth - 1%0A%09%09%7D%0A%09%09t.cursorY *= 2%0A%09%09t.clearAndRepaintLinePlusNPrevious(t.maxLine * 2)%0A%09case width %3E oldWidth:%0A%09%09// If the terminal expands then our position calculations will%0A%09%09// be wrong in the future because we think the cursor is%0A%09%09// %7Ct.pos%7C chars into the string, but there will be a gap at%0A%09%09// the end of any wrapped line.%0A%09%09//%0A%09%09// But the position will actually be correct until we move, so%0A%09%09// we can move back to the beginning and repaint everything.%0A%09%09t.clearAndRepaintLinePlusNPrevious(t.maxLine)%0A%09%7D%0A%0A%09_, err := t.c.Write(t.outBuf)%0A%09t.outBuf = t.outBuf%5B:0%5D%0A%09return err%0A%7D%0A%0A
 type
@@ -14834,529 +14834,8 @@
 r%7B%7D%0A
-%0A// SetBracketedPasteMode requests that the terminal bracket paste operations%0A// with markers. Not all terminals support this but, if it is supported, then%0A// enabling this mode will stop any autocomplete callback from running due to%0A// pastes. Additionally, any lines that are completely pasted will be returned%0A// from ReadLine with the error set to ErrPasteIndicator.%0Afunc (t *Terminal) SetBracketedPasteMode(on bool) %7B%0A%09if on %7B%0A%09%09io.WriteString(t.c, %22%5Cx1b%5B?2004h%22)%0A%09%7D else %7B%0A%09%09io.WriteString(t.c, %22%5Cx1b%5B?2004l%22)%0A%09%7D%0A%7D%0A
 %0A// 
- f 513a5ef9bc1727048280de2f593c881d948c558a8277c883a3bf8e89c2cffc56 vendor/golang.org/x/crypto/ssh/terminal/util.go
+ f e6267436512841a548d36ef8845d75574d6f7da763a187ab1bbb971df26dac26 vendor/golang.org/x/crypto/ssh/terminal/util.go
dmppatch 8
@@ -642,96 +642,8 @@
 %0A)%0A%0A
-// State contains the state of a terminal.%0Atype State struct %7B%0A%09termios unix.Termios%0A%7D%0A%0A
 // I
@@ -817,1690 +817,8 @@
 nil%0A
-%7D%0A%0A// MakeRaw put the terminal connected to the given file descriptor into raw%0A// mode and returns the previous state of the terminal so that it can be%0A// restored.%0Afunc MakeRaw(fd int) (*State, error) %7B%0A%09termios, err := unix.IoctlGetTermios(fd, ioctlReadTermios)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09oldState := State%7Btermios: *termios%7D%0A%0A%09// This attempts to replicate the behaviour documented for cfmakeraw in%0A%09// the termios(3) manpage.%0A%09termios.Iflag &%5E= unix.IGNBRK %7C unix.BRKINT %7C unix.PARMRK %7C unix.ISTRIP %7C unix.INLCR %7C unix.IGNCR %7C unix.ICRNL %7C unix.IXON%0A%09termios.Oflag &%5E= unix.OPOST%0A%09termios.Lflag &%5E= unix.ECHO %7C unix.ECHONL %7C unix.ICANON %7C unix.ISIG %7C unix.IEXTEN%0A%09termios.Cflag &%5E= unix.CSIZE %7C unix.PARENB%0A%09termios.Cflag %7C= unix.CS8%0A%09termios.Cc%5Bunix.VMIN%5D = 1%0A%09termios.Cc%5Bunix.VTIME%5D = 0%0A%09if err := unix.IoctlSetTermios(fd, ioctlWriteTermios, termios); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return &oldState, nil%0A%7D%0A%0A// GetState returns the current state of a terminal which may be useful to%0A// restore the terminal after a signal.%0Afunc GetState(fd int) (*State, error) %7B%0A%09termios, err := unix.IoctlGetTermios(fd, ioctlReadTermios)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return &State%7Btermios: *termios%7D, nil%0A%7D%0A%0A// Restore restores the terminal connected to the given file descriptor to a%0A// previous state.%0Afunc Restore(fd int, state *State) error %7B%0A%09return unix.IoctlSetTermios(fd, ioctlWriteTermios, &state.termios)%0A%7D%0A%0A// GetSize returns the dimensions of the given terminal.%0Afunc GetSize(fd int) (width, height int, err error) %7B%0A%09ws, err := unix.IoctlGetWinsize(fd, unix.TIOCGWINSZ)%0A%09if err != nil %7B%0A%09%09return -1, -1, err%0A%09%7D%0A%09return int(ws.Col), int(ws.Row), nil%0A
 %7D%0A%0A/
- f 7aa624ee81675e4bccfcc2267d38492afa6e0a816b62b0a57a9385e5cc0628a3 vendor/golang.org/x/crypto/ssh/terminal/util_plan9.go
+ f c4b5fe6279a13825af5529fa241e312358a08282c7acb1074aed02d81f94923b vendor/golang.org/x/crypto/ssh/terminal/util_plan9.go
dmppatch 8
@@ -522,29 +522,8 @@
 %0A)%0A%0A
-type State struct%7B%7D%0A%0A
 // I
@@ -638,1023 +638,8 @@
 lse%0A
-%7D%0A%0A// MakeRaw put the terminal connected to the given file descriptor into raw%0A// mode and returns the previous state of the terminal so that it can be%0A// restored.%0Afunc MakeRaw(fd int) (*State, error) %7B%0A%09return nil, fmt.Errorf(%22terminal: MakeRaw not implemented on %25s/%25s%22, runtime.GOOS, runtime.GOARCH)%0A%7D%0A%0A// GetState returns the current state of a terminal which may be useful to%0A// restore the terminal after a signal.%0Afunc GetState(fd int) (*State, error) %7B%0A%09return nil, fmt.Errorf(%22terminal: GetState not implemented on %25s/%25s%22, runtime.GOOS, runtime.GOARCH)%0A%7D%0A%0A// Restore restores the terminal connected to the given file descriptor to a%0A// previous state.%0Afunc Restore(fd int, state *State) error %7B%0A%09return fmt.Errorf(%22terminal: Restore not implemented on %25s/%25s%22, runtime.GOOS, runtime.GOARCH)%0A%7D%0A%0A// GetSize returns the dimensions of the given terminal.%0Afunc GetSize(fd int) (width, height int, err error) %7B%0A%09return 0, 0, fmt.Errorf(%22terminal: GetSize not implemented on %25s/%25s%22, runtime.GOOS, runtime.GOARCH)%0A
 %7D%0A%0A/
- f 40ad0ee2d8359ce17390a9eeb62cfee0fbced86e06e9a71564dc5f22f4286dda vendor/golang.org/x/crypto/ssh/terminal/util_solaris.go
+ f cd284cdd21bc2f51b1d2373aa81e03fe8e52f49b7064a1418314245e671b0556 vendor/golang.org/x/crypto/ssh/terminal/util_solaris.go
dmppatch 14
@@ -248,33 +248,8 @@
 t (%0A
-%09%22golang.org/x/sys/unix%22%0A
 %09%22io
@@ -265,98 +265,36 @@
 ll%22%0A
-)%0A
 %0A
-// State contains the state of a terminal.%0Atype State struct %7B%0A%09termios unix.Termios%0A%7D%0A
+%09%22golang.org/x/sys/unix%22%0A)%0A
 %0A// 
@@ -1526,1620 +1526,4 @@
 l%0A%7D%0A
-%0A// MakeRaw puts the terminal connected to the given file descriptor into raw%0A// mode and returns the previous state of the terminal so that it can be%0A// restored.%0A// see http://cr.illumos.org/~webrev/andy_js/1060/%0Afunc MakeRaw(fd int) (*State, error) %7B%0A%09termios, err := unix.IoctlGetTermios(fd, unix.TCGETS)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09oldState := State%7Btermios: *termios%7D%0A%0A%09termios.Iflag &%5E= unix.IGNBRK %7C unix.BRKINT %7C unix.PARMRK %7C unix.ISTRIP %7C unix.INLCR %7C unix.IGNCR %7C unix.ICRNL %7C unix.IXON%0A%09termios.Oflag &%5E= unix.OPOST%0A%09termios.Lflag &%5E= unix.ECHO %7C unix.ECHONL %7C unix.ICANON %7C unix.ISIG %7C unix.IEXTEN%0A%09termios.Cflag &%5E= unix.CSIZE %7C unix.PARENB%0A%09termios.Cflag %7C= unix.CS8%0A%09termios.Cc%5Bunix.VMIN%5D = 1%0A%09termios.Cc%5Bunix.VTIME%5D = 0%0A%0A%09if err := unix.IoctlSetTermios(fd, unix.TCSETS, termios); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return &oldState, nil%0A%7D%0A%0A// Restore restores the terminal connected to the given file descriptor to a%0A// previous state.%0Afunc Restore(fd int, oldState *State) error %7B%0A%09return unix.IoctlSetTermios(fd, unix.TCSETS, &oldState.termios)%0A%7D%0A%0A// GetState returns the current state of a terminal which may be useful to%0A// restore the terminal after a signal.%0Afunc GetState(fd int) (*State, error) %7B%0A%09termios, err := unix.IoctlGetTermios(fd, unix.TCGETS)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return &State%7Btermios: *termios%7D, nil%0A%7D%0A%0A// GetSize returns the dimensions of the given terminal.%0Afunc GetSize(fd int) (width, height int, err error) %7B%0A%09ws, err := unix.IoctlGetWinsize(fd, unix.TIOCGWINSZ)%0A%09if err != nil %7B%0A%09%09return 0, 0, err%0A%09%7D%0A%09return int(ws.Col), int(ws.Row), nil%0A%7D%0A
- f ea6477d201bcd31283ea3b6df583534625e96c25eaa18414f20fa059dc306980 vendor/golang.org/x/crypto/ssh/terminal/util_windows.go
+ f b28bfe2c7af717cbb3baa0cea9fb2ec9c83fdbdd82c51bd44c70ea95aabad7e0 vendor/golang.org/x/crypto/ssh/terminal/util_windows.go
dmppatch 8
@@ -558,44 +558,8 @@
 %0A)%0A%0A
-type State struct %7B%0A%09mode uint32%0A%7D%0A%0A
 // I
@@ -750,1385 +750,8 @@
 nil%0A
-%7D%0A%0A// MakeRaw put the terminal connected to the given file descriptor into raw%0A// mode and returns the previous state of the terminal so that it can be%0A// restored.%0Afunc MakeRaw(fd int) (*State, error) %7B%0A%09var st uint32%0A%09if err := windows.GetConsoleMode(windows.Handle(fd), &st); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09raw := st &%5E (windows.ENABLE_ECHO_INPUT %7C windows.ENABLE_PROCESSED_INPUT %7C windows.ENABLE_LINE_INPUT %7C windows.ENABLE_PROCESSED_OUTPUT)%0A%09if err := windows.SetConsoleMode(windows.Handle(fd), raw); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &State%7Bst%7D, nil%0A%7D%0A%0A// GetState returns the current state of a terminal which may be useful to%0A// restore the terminal after a signal.%0Afunc GetState(fd int) (*State, error) %7B%0A%09var st uint32%0A%09if err := windows.GetConsoleMode(windows.Handle(fd), &st); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &State%7Bst%7D, nil%0A%7D%0A%0A// Restore restores the terminal connected to the given file descriptor to a%0A// previous state.%0Afunc Restore(fd int, state *State) error %7B%0A%09return windows.SetConsoleMode(windows.Handle(fd), state.mode)%0A%7D%0A%0A// GetSize returns the dimensions of the given terminal.%0Afunc GetSize(fd int) (width, height int, err error) %7B%0A%09var info windows.ConsoleScreenBufferInfo%0A%09if err := windows.GetConsoleScreenBufferInfo(windows.Handle(fd), &info); err != nil %7B%0A%09%09return 0, 0, err%0A%09%7D%0A%09return int(info.Size.X), int(info.Size.Y), nil%0A
 %7D%0A%0A/
- f f7fe086a84ecd9094c7b6271f748256ecb7bb20931dfa74ec164d4e63e9797cd vendor/golang.org/x/sys/cpu/cpu.go
+ f 2e629156240ca24f9b3bab65a79d6636ef4647457fdc54dba3938628494b19b7 vendor/golang.org/x/sys/cpu/cpu.go
dmppatch 14
@@ -254,16 +254,130 @@
 ge cpu%0A%0A
+// CacheLinePad is used to pad structs to avoid false sharing.%0Atype CacheLinePad struct%7B _ %5BcacheLineSize%5Dbyte %7D%0A%0A
 // X86 c
@@ -731,42 +731,35 @@
 t %7B%0A
-%09_            %5BcacheLineSize%5Dbyte%0A
+%09_            CacheLinePad%0A
 %09Has
@@ -1726,40 +1726,33 @@
 4.2%0A
-%09_            %5BcacheLineSize%5Dbyte%0A
+%09_            CacheLinePad%0A
 %7D%0A
+ f 6fc774c3f7ecf49f39efb02f10f1e555e328a34404643910fae532e44c2550a0 vendor/golang.org/x/sys/cpu/cpu_gc_x86.go
dmppatch 2
@@ -0,0 +1,501 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build 386 amd64 amd64p32%0A// +build !gccgo%0A%0Apackage cpu%0A%0A// cpuid is implemented in cpu_x86.s for gc compiler%0A// and in cpu_gccgo.c for gccgo.%0Afunc cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32)%0A%0A// xgetbv with ecx = 0 is implemented in cpu_x86.s for gc compiler%0A// and in cpu_gccgo.c for gccgo.%0Afunc xgetbv() (eax, edx uint32)%0A
+ f 949fb3fb19310e131e4b9ace39546965dcfdef017b28edf65b92c714acd32e19 vendor/golang.org/x/sys/cpu/cpu_gccgo.c
dmppatch 2
@@ -0,0 +1,1203 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build 386 amd64 amd64p32%0A// +build gccgo%0A%0A#include %3Ccpuid.h%3E%0A#include %3Cstdint.h%3E%0A%0A// Need to wrap __get_cpuid_count because it's declared as static.%0Aint%0AgccgoGetCpuidCount(uint32_t leaf, uint32_t subleaf,%0A                   uint32_t *eax, uint32_t *ebx,%0A                   uint32_t *ecx, uint32_t *edx)%0A%7B%0A%09return __get_cpuid_count(leaf, subleaf, eax, ebx, ecx, edx);%0A%7D%0A%0A// xgetbv reads the contents of an XCR (Extended Control Register)%0A// specified in the ECX register into registers EDX:EAX.%0A// Currently, the only supported value for XCR is 0.%0A//%0A// TODO: Replace with a better alternative:%0A//%0A//     #include %3Cxsaveintrin.h%3E%0A//%0A//     #pragma GCC target(%22xsave%22)%0A//%0A//     void gccgoXgetbv(uint32_t *eax, uint32_t *edx) %7B%0A//       unsigned long long x = _xgetbv(0);%0A//       *eax = x & 0xffffffff;%0A//       *edx = (x %3E%3E 32) & 0xffffffff;%0A//     %7D%0A//%0A// Note that _xgetbv is defined starting with GCC 8.%0Avoid%0AgccgoXgetbv(uint32_t *eax, uint32_t *edx)%0A%7B%0A%09__asm(%22  xorl %25%25ecx, %25%25ecx%5Cn%22%0A%09      %22  xgetbv%22%0A%09    : %22=a%22(*eax), %22=d%22(*edx));%0A%7D%0A
+ f d94f089f80133e7ff1428a9b547ad535048b9a5097befa920550bc705a7f6c22 vendor/golang.org/x/sys/cpu/cpu_gccgo.go
dmppatch 2
@@ -0,0 +1,467 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build 386 amd64 amd64p32%0A// +build gccgo%0A%0Apackage cpu%0A%0Afunc cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32) %7B%0A%09var a, b, c, d uint32%0A%09gccgoGetCpuidCount(eaxArg, ecxArg, &a, &b, &c, &d)%0A%09return a, b, c, d%0A%7D%0A%0Afunc xgetbv() (eax, edx uint32) %7B%0A%09var a, d uint32%0A%09gccgoXgetbv(&a, &d)%0A%09return a, d%0A%7D%0A
- f 1d355a7ae42cbd2c5530bd0cdadaad34ca62733d698f928e801cba98bac3eac8 vendor/golang.org/x/sys/cpu/cpu_x86.go
+ f 6720a7f70c6904942c193948d3ce24168d7e3fcc8555865e883bf7b7a28fdfa8 vendor/golang.org/x/sys/cpu/cpu_x86.go
dmppatch 4
@@ -226,194 +226,8 @@
 64%0A%0A
-// cpuid is implemented in cpu_x86.s.%0Afunc cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32)%0A%0A// xgetbv with ecx = 0 is implemented in cpu_x86.s.%0Afunc xgetbv() (eax, edx uint32)%0A%0A
 func
- f 4ac887490fd8a2e6c277c98e0c2372163fabbed01b57ceb4f9cc2903c10e77f2 vendor/golang.org/x/sys/cpu/cpu_x86.s
+ f 5ae0471e439f6a906450f72ca46cc2a503253588940d0c935392705b7ad732f2 vendor/golang.org/x/sys/cpu/cpu_x86.s
dmppatch 4
@@ -182,16 +182,33 @@
 md64p32%0A
+// +build !gccgo%0A
 %0A#includ
- f 430f118c29bb27ee715f7a781876fb4d0f98ad8e8a71d07d4bd6e1bb8aa33f91 vendor/golang.org/x/sys/unix/affinity_linux.go
+ f 632f32382f04c4a56968fa45ffd85eef6d40704588f78e9e03c4e44854945b05 vendor/golang.org/x/sys/unix/affinity_linux.go
dmppatch 3
@@ -197,3081 +197,4 @@
 nix%0A
-%0Aimport (%0A%09%22unsafe%22%0A)%0A%0Aconst cpuSetSize = _CPU_SETSIZE / _NCPUBITS%0A%0A// CPUSet represents a CPU affinity mask.%0Atype CPUSet %5BcpuSetSize%5DcpuMask%0A%0Afunc schedAffinity(trap uintptr, pid int, set *CPUSet) error %7B%0A%09_, _, e := RawSyscall(trap, uintptr(pid), uintptr(unsafe.Sizeof(*set)), uintptr(unsafe.Pointer(set)))%0A%09if e != 0 %7B%0A%09%09return errnoErr(e)%0A%09%7D%0A%09return nil%0A%7D%0A%0A// SchedGetaffinity gets the CPU affinity mask of the thread specified by pid.%0A// If pid is 0 the calling thread is used.%0Afunc SchedGetaffinity(pid int, set *CPUSet) error %7B%0A%09return schedAffinity(SYS_SCHED_GETAFFINITY, pid, set)%0A%7D%0A%0A// SchedSetaffinity sets the CPU affinity mask of the thread specified by pid.%0A// If pid is 0 the calling thread is used.%0Afunc SchedSetaffinity(pid int, set *CPUSet) error %7B%0A%09return schedAffinity(SYS_SCHED_SETAFFINITY, pid, set)%0A%7D%0A%0A// Zero clears the set s, so that it contains no CPUs.%0Afunc (s *CPUSet) Zero() %7B%0A%09for i := range s %7B%0A%09%09s%5Bi%5D = 0%0A%09%7D%0A%7D%0A%0Afunc cpuBitsIndex(cpu int) int %7B%0A%09return cpu / _NCPUBITS%0A%7D%0A%0Afunc cpuBitsMask(cpu int) cpuMask %7B%0A%09return cpuMask(1 %3C%3C (uint(cpu) %25 _NCPUBITS))%0A%7D%0A%0A// Set adds cpu to the set s.%0Afunc (s *CPUSet) Set(cpu int) %7B%0A%09i := cpuBitsIndex(cpu)%0A%09if i %3C len(s) %7B%0A%09%09s%5Bi%5D %7C= cpuBitsMask(cpu)%0A%09%7D%0A%7D%0A%0A// Clear removes cpu from the set s.%0Afunc (s *CPUSet) Clear(cpu int) %7B%0A%09i := cpuBitsIndex(cpu)%0A%09if i %3C len(s) %7B%0A%09%09s%5Bi%5D &%5E= cpuBitsMask(cpu)%0A%09%7D%0A%7D%0A%0A// IsSet reports whether cpu is in the set s.%0Afunc (s *CPUSet) IsSet(cpu int) bool %7B%0A%09i := cpuBitsIndex(cpu)%0A%09if i %3C len(s) %7B%0A%09%09return s%5Bi%5D&cpuBitsMask(cpu) != 0%0A%09%7D%0A%09return false%0A%7D%0A%0A// Count returns the number of CPUs in the set s.%0Afunc (s *CPUSet) Count() int %7B%0A%09c := 0%0A%09for _, b := range s %7B%0A%09%09c += onesCount64(uint64(b))%0A%09%7D%0A%09return c%0A%7D%0A%0A// onesCount64 is a copy of Go 1.9's math/bits.OnesCount64.%0A// Once this package can require Go 1.9, we can delete this%0A// and update the caller to use bits.OnesCount64.%0Afunc onesCount64(x uint64) int %7B%0A%09const m0 = 0x5555555555555555 // 01010101 ...%0A%09const m1 = 0x3333333333333333 // 00110011 ...%0A%09const m2 = 0x0f0f0f0f0f0f0f0f // 00001111 ...%0A%09const m3 = 0x00ff00ff00ff00ff // etc.%0A%09const m4 = 0x0000ffff0000ffff%0A%0A%09// Implementation: Parallel summing of adjacent bits.%0A%09// See %22Hacker's Delight%22, Chap. 5: Counting Bits.%0A%09// The following pattern shows the general approach:%0A%09//%0A%09//   x = x%3E%3E1&(m0&m) + x&(m0&m)%0A%09//   x = x%3E%3E2&(m1&m) + x&(m1&m)%0A%09//   x = x%3E%3E4&(m2&m) + x&(m2&m)%0A%09//   x = x%3E%3E8&(m3&m) + x&(m3&m)%0A%09//   x = x%3E%3E16&(m4&m) + x&(m4&m)%0A%09//   x = x%3E%3E32&(m5&m) + x&(m5&m)%0A%09//   return int(x)%0A%09//%0A%09// Masking (& operations) can be left away when there's no%0A%09// danger that a field's sum will carry over into the next%0A%09// field: Since the result cannot be %3E 64, 8 bits is enough%0A%09// and we can ignore the masks for the shifts by 8 and up.%0A%09// Per %22Hacker's Delight%22, the first line can be simplified%0A%09// more, but it saves at best one instruction, so we leave%0A%09// it alone for clarity.%0A%09const m = 1%3C%3C64 - 1%0A%09x = x%3E%3E1&(m0&m) + x&(m0&m)%0A%09x = x%3E%3E2&(m1&m) + x&(m1&m)%0A%09x = (x%3E%3E4 + x) & (m2 & m)%0A%09x += x %3E%3E 8%0A%09x += x %3E%3E 16%0A%09x += x %3E%3E 32%0A%09return int(x) & (1%3C%3C7 - 1)%0A%7D%0A
+ f fa9a0541bb7261ec1488c613b12934af04e7fe07c759e79d0e0c0d5b21a67349 vendor/golang.org/x/sys/unix/aliases.go
dmppatch 2
@@ -0,0 +1,254 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A// +build go1.9%0A%0Apackage unix%0A
- f 78d49e3efc5dddf1c9a7fe0391cd9343d5e9be3d64f2ff73adebb94909c59aee vendor/golang.org/x/sys/unix/bluetooth_linux.go
+ f 9a429983fa81f3e25ce3af1d56fcfc9a2f56ee8c8937a9f1859504ac19dae5ac vendor/golang.org/x/sys/unix/bluetooth_linux.go
dmppatch 3
@@ -205,451 +205,4 @@
 nix%0A
-%0A// Bluetooth Protocols%0Aconst (%0A%09BTPROTO_L2CAP  = 0%0A%09BTPROTO_HCI    = 1%0A%09BTPROTO_SCO    = 2%0A%09BTPROTO_RFCOMM = 3%0A%09BTPROTO_BNEP   = 4%0A%09BTPROTO_CMTP   = 5%0A%09BTPROTO_HIDP   = 6%0A%09BTPROTO_AVDTP  = 7%0A)%0A%0Aconst (%0A%09HCI_CHANNEL_RAW     = 0%0A%09HCI_CHANNEL_USER    = 1%0A%09HCI_CHANNEL_MONITOR = 2%0A%09HCI_CHANNEL_CONTROL = 3%0A)%0A%0A// Socketoption Level%0Aconst (%0A%09SOL_BLUETOOTH = 0x112%0A%09SOL_HCI       = 0x0%0A%09SOL_L2CAP     = 0x6%0A%09SOL_RFCOMM    = 0x12%0A%09SOL_SCO       = 0x11%0A)%0A
- f fae1a8af18386a11fb86bdb212bd64198fe63209524919d5ddbe560d582a4003 vendor/golang.org/x/sys/unix/cap_freebsd.go
+ f 4cdb68b7e38ddb3777810c50c8b8cff28bf70d068e35309fc22774ca37b93bdb vendor/golang.org/x/sys/unix/cap_freebsd.go
dmppatch 3
@@ -189,4942 +189,4 @@
 nix%0A
-%0Aimport (%0A%09%22errors%22%0A%09%22fmt%22%0A)%0A%0A// Go implementation of C mostly found in /usr/src/sys/kern/subr_capability.c%0A%0Aconst (%0A%09// This is the version of CapRights this package understands. See C implementation for parallels.%0A%09capRightsGoVersion = CAP_RIGHTS_VERSION_00%0A%09capArSizeMin       = CAP_RIGHTS_VERSION_00 + 2%0A%09capArSizeMax       = capRightsGoVersion + 2%0A)%0A%0Avar (%0A%09bit2idx = %5B%5Dint%7B%0A%09%09-1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1,%0A%09%094, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,%0A%09%7D%0A)%0A%0Afunc capidxbit(right uint64) int %7B%0A%09return int((right %3E%3E 57) & 0x1f)%0A%7D%0A%0Afunc rightToIndex(right uint64) (int, error) %7B%0A%09idx := capidxbit(right)%0A%09if idx %3C 0 %7C%7C idx %3E= len(bit2idx) %7B%0A%09%09return -2, fmt.Errorf(%22index for right 0x%25x out of range%22, right)%0A%09%7D%0A%09return bit2idx%5Bidx%5D, nil%0A%7D%0A%0Afunc caprver(right uint64) int %7B%0A%09return int(right %3E%3E 62)%0A%7D%0A%0Afunc capver(rights *CapRights) int %7B%0A%09return caprver(rights.Rights%5B0%5D)%0A%7D%0A%0Afunc caparsize(rights *CapRights) int %7B%0A%09return capver(rights) + 2%0A%7D%0A%0A// CapRightsSet sets the permissions in setrights in rights.%0Afunc CapRightsSet(rights *CapRights, setrights %5B%5Duint64) error %7B%0A%09// This is essentially a copy of cap_rights_vset()%0A%09if capver(rights) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09return fmt.Errorf(%22bad rights version %25d%22, capver(rights))%0A%09%7D%0A%0A%09n := caparsize(rights)%0A%09if n %3C capArSizeMin %7C%7C n %3E capArSizeMax %7B%0A%09%09return errors.New(%22bad rights size%22)%0A%09%7D%0A%0A%09for _, right := range setrights %7B%0A%09%09if caprver(right) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09%09return errors.New(%22bad right version%22)%0A%09%09%7D%0A%09%09i, err := rightToIndex(right)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09if i %3E= n %7B%0A%09%09%09return errors.New(%22index overflow%22)%0A%09%09%7D%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return errors.New(%22index mismatch%22)%0A%09%09%7D%0A%09%09rights.Rights%5Bi%5D %7C= right%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return errors.New(%22index mismatch (after assign)%22)%0A%09%09%7D%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A// CapRightsClear clears the permissions in clearrights from rights.%0Afunc CapRightsClear(rights *CapRights, clearrights %5B%5Duint64) error %7B%0A%09// This is essentially a copy of cap_rights_vclear()%0A%09if capver(rights) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09return fmt.Errorf(%22bad rights version %25d%22, capver(rights))%0A%09%7D%0A%0A%09n := caparsize(rights)%0A%09if n %3C capArSizeMin %7C%7C n %3E capArSizeMax %7B%0A%09%09return errors.New(%22bad rights size%22)%0A%09%7D%0A%0A%09for _, right := range clearrights %7B%0A%09%09if caprver(right) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09%09return errors.New(%22bad right version%22)%0A%09%09%7D%0A%09%09i, err := rightToIndex(right)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09if i %3E= n %7B%0A%09%09%09return errors.New(%22index overflow%22)%0A%09%09%7D%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return errors.New(%22index mismatch%22)%0A%09%09%7D%0A%09%09rights.Rights%5Bi%5D &= %5E(right & 0x01FFFFFFFFFFFFFF)%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return errors.New(%22index mismatch (after assign)%22)%0A%09%09%7D%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A// CapRightsIsSet checks whether all the permissions in setrights are present in rights.%0Afunc CapRightsIsSet(rights *CapRights, setrights %5B%5Duint64) (bool, error) %7B%0A%09// This is essentially a copy of cap_rights_is_vset()%0A%09if capver(rights) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09return false, fmt.Errorf(%22bad rights version %25d%22, capver(rights))%0A%09%7D%0A%0A%09n := caparsize(rights)%0A%09if n %3C capArSizeMin %7C%7C n %3E capArSizeMax %7B%0A%09%09return false, errors.New(%22bad rights size%22)%0A%09%7D%0A%0A%09for _, right := range setrights %7B%0A%09%09if caprver(right) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09%09return false, errors.New(%22bad right version%22)%0A%09%09%7D%0A%09%09i, err := rightToIndex(right)%0A%09%09if err != nil %7B%0A%09%09%09return false, err%0A%09%09%7D%0A%09%09if i %3E= n %7B%0A%09%09%09return false, errors.New(%22index overflow%22)%0A%09%09%7D%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return false, errors.New(%22index mismatch%22)%0A%09%09%7D%0A%09%09if (rights.Rights%5Bi%5D & right) != right %7B%0A%09%09%09return false, nil%0A%09%09%7D%0A%09%7D%0A%0A%09return true, nil%0A%7D%0A%0Afunc capright(idx uint64, bit uint64) uint64 %7B%0A%09return ((1 %3C%3C (57 + idx)) %7C bit)%0A%7D%0A%0A// CapRightsInit returns a pointer to an initialised CapRights structure filled with rights.%0A// See man cap_rights_init(3) and rights(4).%0Afunc CapRightsInit(rights %5B%5Duint64) (*CapRights, error) %7B%0A%09var r CapRights%0A%09r.Rights%5B0%5D = (capRightsGoVersion %3C%3C 62) %7C capright(0, 0)%0A%09r.Rights%5B1%5D = capright(1, 0)%0A%0A%09err := CapRightsSet(&r, rights)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &r, nil%0A%7D%0A%0A// CapRightsLimit reduces the operations permitted on fd to at most those contained in rights.%0A// The capability rights on fd can never be increased by CapRightsLimit.%0A// See man cap_rights_limit(2) and rights(4).%0Afunc CapRightsLimit(fd uintptr, rights *CapRights) error %7B%0A%09return capRightsLimit(int(fd), rights)%0A%7D%0A%0A// CapRightsGet returns a CapRights structure containing the operations permitted on fd.%0A// See man cap_rights_get(3) and rights(4).%0Afunc CapRightsGet(fd uintptr) (*CapRights, error) %7B%0A%09r, err := CapRightsInit(nil)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09err = capRightsGet(capRightsGoVersion, int(fd), r)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return r, nil%0A%7D%0A
- f 5ab69624200e17bdc60a8b44fbec9017c97fce76d6ad4b49e3665c76d72bcd0d vendor/golang.org/x/sys/unix/constants.go
+ f fc1f821c973ec87ce63f020c8063ce9b67780d5244916bc06a77403cb7c388a5 vendor/golang.org/x/sys/unix/constants.go
dmppatch 3
@@ -235,51 +235,4 @@
 nix%0A
-%0Aconst (%0A%09R_OK = 0x4%0A%09W_OK = 0x2%0A%09X_OK = 0x1%0A)%0A
- f 9a0bc8af77b4325bb10b651e00b8f7974cc972d0e5456a370f2c46a56181ada7 vendor/golang.org/x/sys/unix/dev_darwin.go
+ f e8c574e028fff08d3fed91dc5d2856da6f745c7ee3c34486f55cc8a50548b92c vendor/golang.org/x/sys/unix/dev_darwin.go
dmppatch 3
@@ -294,454 +294,4 @@
 nix%0A
-%0A// Major returns the major component of a Darwin device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev %3E%3E 24) & 0xff)%0A%7D%0A%0A// Minor returns the minor component of a Darwin device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32(dev & 0xffffff)%0A%7D%0A%0A// Mkdev returns a Darwin device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09return (uint64(major) %3C%3C 24) %7C uint64(minor)%0A%7D%0A
- f 125802ffd01c98daddf86bd57960f51f7dadccb15b530c48e6a24f4f1c697fba vendor/golang.org/x/sys/unix/dev_dragonfly.go
+ f 528eaf29c5fa7a3c3fd4f62042cc9d476f947ca0c08f67685d7dc1d60cc54081 vendor/golang.org/x/sys/unix/dev_dragonfly.go
dmppatch 3
@@ -559,472 +559,4 @@
 nix%0A
-%0A// Major returns the major component of a DragonFlyBSD device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev %3E%3E 8) & 0xff)%0A%7D%0A%0A// Minor returns the minor component of a DragonFlyBSD device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32(dev & 0xffff00ff)%0A%7D%0A%0A// Mkdev returns a DragonFlyBSD device number generated from the given major and%0A// minor components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09return (uint64(major) %3C%3C 8) %7C uint64(minor)%0A%7D%0A
- f c246eb43233fd2e714c85e84407a084da2823d5a64e61313fd393d34589ef0f3 vendor/golang.org/x/sys/unix/dev_freebsd.go
+ f 9ae2273463798970e55edabf57fc7456dbbdfd052ea070bfd7df5c52b236395b vendor/golang.org/x/sys/unix/dev_freebsd.go
dmppatch 3
@@ -557,457 +557,4 @@
 nix%0A
-%0A// Major returns the major component of a FreeBSD device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev %3E%3E 8) & 0xff)%0A%7D%0A%0A// Minor returns the minor component of a FreeBSD device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32(dev & 0xffff00ff)%0A%7D%0A%0A// Mkdev returns a FreeBSD device number generated from the given major and%0A// minor components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09return (uint64(major) %3C%3C 8) %7C uint64(minor)%0A%7D%0A
- f eec381cf025f58965728544dae5df9394d6bebc7e68572e429814c87ee6dd284 vendor/golang.org/x/sys/unix/dev_linux.go
+ f c12d7b6fb0ea50420523167b2e5c4dd1d2cc2be4b6ccb7e3a26f31ed763f1ba7 vendor/golang.org/x/sys/unix/dev_linux.go
dmppatch 3
@@ -829,751 +829,4 @@
 nix%0A
-%0A// Major returns the major component of a Linux device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09major := uint32((dev & 0x00000000000fff00) %3E%3E 8)%0A%09major %7C= uint32((dev & 0xfffff00000000000) %3E%3E 32)%0A%09return major%0A%7D%0A%0A// Minor returns the minor component of a Linux device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09minor := uint32((dev & 0x00000000000000ff) %3E%3E 0)%0A%09minor %7C= uint32((dev & 0x00000ffffff00000) %3E%3E 12)%0A%09return minor%0A%7D%0A%0A// Mkdev returns a Linux device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09dev := (uint64(major) & 0x00000fff) %3C%3C 8%0A%09dev %7C= (uint64(major) & 0xfffff000) %3C%3C 32%0A%09dev %7C= (uint64(minor) & 0x000000ff) %3C%3C 0%0A%09dev %7C= (uint64(minor) & 0xffffff00) %3C%3C 12%0A%09return dev%0A%7D%0A
- f f712a720bab3f9598c897c45e389c6666998899b963c05892fc2e12179cf1ca4 vendor/golang.org/x/sys/unix/dev_netbsd.go
+ f 2c5bd95c55012a1200d863c802174d768ec0b962f1f6b88433c1c21517710a69 vendor/golang.org/x/sys/unix/dev_netbsd.go
dmppatch 3
@@ -294,620 +294,4 @@
 nix%0A
-%0A// Major returns the major component of a NetBSD device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev & 0x000fff00) %3E%3E 8)%0A%7D%0A%0A// Minor returns the minor component of a NetBSD device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09minor := uint32((dev & 0x000000ff) %3E%3E 0)%0A%09minor %7C= uint32((dev & 0xfff00000) %3E%3E 12)%0A%09return minor%0A%7D%0A%0A// Mkdev returns a NetBSD device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09dev := (uint64(major) %3C%3C 8) & 0x000fff00%0A%09dev %7C= (uint64(minor) %3C%3C 12) & 0xfff00000%0A%09dev %7C= (uint64(minor) %3C%3C 0) & 0x000000ff%0A%09return dev%0A%7D%0A
- f bc0456ed97d8bb58bed6b4b70959e04215d3393596d92b33a7aa515238349dd1 vendor/golang.org/x/sys/unix/dev_openbsd.go
+ f 604b9a30ca60bc163c083846e94a623dd86d9d489668f71d7f034eab1198295b vendor/golang.org/x/sys/unix/dev_openbsd.go
dmppatch 3
@@ -295,624 +295,4 @@
 nix%0A
-%0A// Major returns the major component of an OpenBSD device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev & 0x0000ff00) %3E%3E 8)%0A%7D%0A%0A// Minor returns the minor component of an OpenBSD device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09minor := uint32((dev & 0x000000ff) %3E%3E 0)%0A%09minor %7C= uint32((dev & 0xffff0000) %3E%3E 8)%0A%09return minor%0A%7D%0A%0A// Mkdev returns an OpenBSD device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09dev := (uint64(major) %3C%3C 8) & 0x0000ff00%0A%09dev %7C= (uint64(minor) %3C%3C 8) & 0xffff0000%0A%09dev %7C= (uint64(minor) %3C%3C 0) & 0x000000ff%0A%09return dev%0A%7D%0A
- f 8214bc5ac22b20ac359dfe54f8f5d9ba7c7ea2de1edbd762126b7d030deeac76 vendor/golang.org/x/sys/unix/dirent.go
+ f e24ffc4bf870b889f8d26caa5af4afc1e3c8b7a9db671d66624fe6b24e77c4bb vendor/golang.org/x/sys/unix/dirent.go
dmppatch 3
@@ -240,381 +240,4 @@
 nix%0A
-%0Aimport %22syscall%22%0A%0A// ParseDirent parses up to max directory entries in buf,%0A// appending the names to names. It returns the number of%0A// bytes consumed from buf, the number of entries added%0A// to names, and the new names slice.%0Afunc ParseDirent(buf %5B%5Dbyte, max int, names %5B%5Dstring) (consumed int, count int, newnames %5B%5Dstring) %7B%0A%09return syscall.ParseDirent(buf, max, names)%0A%7D%0A
- f 07489e8cd37eb6bb970f0cd9aff6102417bfe69554ca45974d2ce7d74dd22c2e vendor/golang.org/x/sys/unix/endian_big.go
+ f 37380b50d3e387c70b6449b305e2d786632e569efefc4a18a1e97a877e7130e9 vendor/golang.org/x/sys/unix/endian_big.go
dmppatch 3
@@ -207,30 +207,4 @@
 nix%0A
-%0Aconst isBigEndian = true%0A
- f 4e495d33e52ee0a56687e3b5c336e33e11f019ed3af271cb8c11f52662843e7a vendor/golang.org/x/sys/unix/endian_little.go
+ f 14ca932669680f38969d5306f258c2d6cea57bec53bc654f9479dc37eba6d0aa vendor/golang.org/x/sys/unix/endian_little.go
dmppatch 3
@@ -236,31 +236,4 @@
 nix%0A
-%0Aconst isBigEndian = false%0A
- f 5dec35e2fdb113415a2de23eda08dd57ba8d499fcc2d9a4605b5b948e85febf3 vendor/golang.org/x/sys/unix/env_unix.go
+ f bce22c907c300bf21cd5f98852d00fce64c1ec1601eb384dd1babcccd9f04073 vendor/golang.org/x/sys/unix/env_unix.go
dmppatch 3
@@ -267,346 +267,4 @@
 nix%0A
-%0Aimport %22syscall%22%0A%0Afunc Getenv(key string) (value string, found bool) %7B%0A%09return syscall.Getenv(key)%0A%7D%0A%0Afunc Setenv(key, value string) error %7B%0A%09return syscall.Setenv(key, value)%0A%7D%0A%0Afunc Clearenv() %7B%0A%09syscall.Clearenv()%0A%7D%0A%0Afunc Environ() %5B%5Dstring %7B%0A%09return syscall.Environ()%0A%7D%0A%0Afunc Unsetenv(key string) error %7B%0A%09return syscall.Unsetenv(key)%0A%7D%0A
- f c1fb0bf2e2a804523aa39c08268db83456bc7fac89b0acad0dc7d60647fa7698 vendor/golang.org/x/sys/unix/errors_freebsd_386.go
+ f 985a567300adc129e0c6665439e37d0c5855d200873d38e38b5429e152c14a40 vendor/golang.org/x/sys/unix/errors_freebsd_386.go
dmppatch 3
@@ -294,9114 +294,4 @@
 nix%0A
-%0Aconst (%0A%09IFF_SMART                         = 0x20%0A%09IFT_1822                          = 0x2%0A%09IFT_A12MPPSWITCH                  = 0x82%0A%09IFT_AAL2                          = 0xbb%0A%09IFT_AAL5                          = 0x31%0A%09IFT_ADSL                          = 0x5e%0A%09IFT_AFLANE8023                    = 0x3b%0A%09IFT_AFLANE8025                    = 0x3c%0A%09IFT_ARAP                          = 0x58%0A%09IFT_ARCNET                        = 0x23%0A%09IFT_ARCNETPLUS                    = 0x24%0A%09IFT_ASYNC                         = 0x54%0A%09IFT_ATM                           = 0x25%0A%09IFT_ATMDXI                        = 0x69%0A%09IFT_ATMFUNI                       = 0x6a%0A%09IFT_ATMIMA                        = 0x6b%0A%09IFT_ATMLOGICAL                    = 0x50%0A%09IFT_ATMRADIO                      = 0xbd%0A%09IFT_ATMSUBINTERFACE               = 0x86%0A%09IFT_ATMVCIENDPT                   = 0xc2%0A%09IFT_ATMVIRTUAL                    = 0x95%0A%09IFT_BGPPOLICYACCOUNTING           = 0xa2%0A%09IFT_BSC                           = 0x53%0A%09IFT_CCTEMUL                       = 0x3d%0A%09IFT_CEPT                          = 0x13%0A%09IFT_CES                           = 0x85%0A%09IFT_CHANNEL                       = 0x46%0A%09IFT_CNR                           = 0x55%0A%09IFT_COFFEE                        = 0x84%0A%09IFT_COMPOSITELINK                 = 0x9b%0A%09IFT_DCN                           = 0x8d%0A%09IFT_DIGITALPOWERLINE              = 0x8a%0A%09IFT_DIGITALWRAPPEROVERHEADCHANNEL = 0xba%0A%09IFT_DLSW                          = 0x4a%0A%09IFT_DOCSCABLEDOWNSTREAM           = 0x80%0A%09IFT_DOCSCABLEMACLAYER             = 0x7f%0A%09IFT_DOCSCABLEUPSTREAM             = 0x81%0A%09IFT_DS0                           = 0x51%0A%09IFT_DS0BUNDLE                     = 0x52%0A%09IFT_DS1FDL                        = 0xaa%0A%09IFT_DS3                           = 0x1e%0A%09IFT_DTM                           = 0x8c%0A%09IFT_DVBASILN                      = 0xac%0A%09IFT_DVBASIOUT                     = 0xad%0A%09IFT_DVBRCCDOWNSTREAM              = 0x93%0A%09IFT_DVBRCCMACLAYER                = 0x92%0A%09IFT_DVBRCCUPSTREAM                = 0x94%0A%09IFT_ENC                           = 0xf4%0A%09IFT_EON                           = 0x19%0A%09IFT_EPLRS                         = 0x57%0A%09IFT_ESCON                         = 0x49%0A%09IFT_ETHER                         = 0x6%0A%09IFT_FAITH                         = 0xf2%0A%09IFT_FAST                          = 0x7d%0A%09IFT_FASTETHER                     = 0x3e%0A%09IFT_FASTETHERFX                   = 0x45%0A%09IFT_FDDI                          = 0xf%0A%09IFT_FIBRECHANNEL                  = 0x38%0A%09IFT_FRAMERELAYINTERCONNECT        = 0x3a%0A%09IFT_FRAMERELAYMPI                 = 0x5c%0A%09IFT_FRDLCIENDPT                   = 0xc1%0A%09IFT_FRELAY                        = 0x20%0A%09IFT_FRELAYDCE                     = 0x2c%0A%09IFT_FRF16MFRBUNDLE                = 0xa3%0A%09IFT_FRFORWARD                     = 0x9e%0A%09IFT_G703AT2MB                     = 0x43%0A%09IFT_G703AT64K                     = 0x42%0A%09IFT_GIF                           = 0xf0%0A%09IFT_GIGABITETHERNET               = 0x75%0A%09IFT_GR303IDT                      = 0xb2%0A%09IFT_GR303RDT                      = 0xb1%0A%09IFT_H323GATEKEEPER                = 0xa4%0A%09IFT_H323PROXY                     = 0xa5%0A%09IFT_HDH1822                       = 0x3%0A%09IFT_HDLC                          = 0x76%0A%09IFT_HDSL2                         = 0xa8%0A%09IFT_HIPERLAN2                     = 0xb7%0A%09IFT_HIPPI                         = 0x2f%0A%09IFT_HIPPIINTERFACE                = 0x39%0A%09IFT_HOSTPAD                       = 0x5a%0A%09IFT_HSSI                          = 0x2e%0A%09IFT_HY                            = 0xe%0A%09IFT_IBM370PARCHAN                 = 0x48%0A%09IFT_IDSL                          = 0x9a%0A%09IFT_IEEE80211                     = 0x47%0A%09IFT_IEEE80212                     = 0x37%0A%09IFT_IEEE8023ADLAG                 = 0xa1%0A%09IFT_IFGSN                         = 0x91%0A%09IFT_IMT                           = 0xbe%0A%09IFT_INTERLEAVE                    = 0x7c%0A%09IFT_IP                            = 0x7e%0A%09IFT_IPFORWARD                     = 0x8e%0A%09IFT_IPOVERATM                     = 0x72%0A%09IFT_IPOVERCDLC                    = 0x6d%0A%09IFT_IPOVERCLAW                    = 0x6e%0A%09IFT_IPSWITCH                      = 0x4e%0A%09IFT_IPXIP                         = 0xf9%0A%09IFT_ISDN                          = 0x3f%0A%09IFT_ISDNBASIC                     = 0x14%0A%09IFT_ISDNPRIMARY                   = 0x15%0A%09IFT_ISDNS                         = 0x4b%0A%09IFT_ISDNU                         = 0x4c%0A%09IFT_ISO88022LLC                   = 0x29%0A%09IFT_ISO88023                      = 0x7%0A%09IFT_ISO88024                      = 0x8%0A%09IFT_ISO88025                      = 0x9%0A%09IFT_ISO88025CRFPINT               = 0x62%0A%09IFT_ISO88025DTR                   = 0x56%0A%09IFT_ISO88025FIBER                 = 0x73%0A%09IFT_ISO88026                      = 0xa%0A%09IFT_ISUP                          = 0xb3%0A%09IFT_L3IPXVLAN                     = 0x89%0A%09IFT_LAPB                          = 0x10%0A%09IFT_LAPD                          = 0x4d%0A%09IFT_LAPF                          = 0x77%0A%09IFT_LOCALTALK                     = 0x2a%0A%09IFT_LOOP                          = 0x18%0A%09IFT_MEDIAMAILOVERIP               = 0x8b%0A%09IFT_MFSIGLINK                     = 0xa7%0A%09IFT_MIOX25                        = 0x26%0A%09IFT_MODEM                         = 0x30%0A%09IFT_MPC                           = 0x71%0A%09IFT_MPLS                          = 0xa6%0A%09IFT_MPLSTUNNEL                    = 0x96%0A%09IFT_MSDSL                         = 0x8f%0A%09IFT_MVL                           = 0xbf%0A%09IFT_MYRINET                       = 0x63%0A%09IFT_NFAS                          = 0xaf%0A%09IFT_NSIP                          = 0x1b%0A%09IFT_OPTICALCHANNEL                = 0xc3%0A%09IFT_OPTICALTRANSPORT              = 0xc4%0A%09IFT_OTHER                         = 0x1%0A%09IFT_P10                           = 0xc%0A%09IFT_P80                           = 0xd%0A%09IFT_PARA                          = 0x22%0A%09IFT_PFLOG                         = 0xf6%0A%09IFT_PFSYNC                        = 0xf7%0A%09IFT_PLC                           = 0xae%0A%09IFT_POS                           = 0xab%0A%09IFT_PPPMULTILINKBUNDLE            = 0x6c%0A%09IFT_PROPBWAP2MP                   = 0xb8%0A%09IFT_PROPCNLS                      = 0x59%0A%09IFT_PROPDOCSWIRELESSDOWNSTREAM    = 0xb5%0A%09IFT_PROPDOCSWIRELESSMACLAYER      = 0xb4%0A%09IFT_PROPDOCSWIRELESSUPSTREAM      = 0xb6%0A%09IFT_PROPMUX                       = 0x36%0A%09IFT_PROPWIRELESSP2P               = 0x9d%0A%09IFT_PTPSERIAL                     = 0x16%0A%09IFT_PVC                           = 0xf1%0A%09IFT_QLLC                          = 0x44%0A%09IFT_RADIOMAC                      = 0xbc%0A%09IFT_RADSL                         = 0x5f%0A%09IFT_REACHDSL                      = 0xc0%0A%09IFT_RFC1483                       = 0x9f%0A%09IFT_RS232                         = 0x21%0A%09IFT_RSRB                          = 0x4f%0A%09IFT_SDLC                          = 0x11%0A%09IFT_SDSL                          = 0x60%0A%09IFT_SHDSL                         = 0xa9%0A%09IFT_SIP                           = 0x1f%0A%09IFT_SLIP                          = 0x1c%0A%09IFT_SMDSDXI                       = 0x2b%0A%09IFT_SMDSICIP                      = 0x34%0A%09IFT_SONET                         = 0x27%0A%09IFT_SONETOVERHEADCHANNEL          = 0xb9%0A%09IFT_SONETPATH                     = 0x32%0A%09IFT_SONETVT                       = 0x33%0A%09IFT_SRP                           = 0x97%0A%09IFT_SS7SIGLINK                    = 0x9c%0A%09IFT_STACKTOSTACK                  = 0x6f%0A%09IFT_STARLAN                       = 0xb%0A%09IFT_STF                           = 0xd7%0A%09IFT_T1                            = 0x12%0A%09IFT_TDLC                          = 0x74%0A%09IFT_TERMPAD                       = 0x5b%0A%09IFT_TR008                         = 0xb0%0A%09IFT_TRANSPHDLC                    = 0x7b%0A%09IFT_TUNNEL                        = 0x83%0A%09IFT_ULTRA                         = 0x1d%0A%09IFT_USB                           = 0xa0%0A%09IFT_V11                           = 0x40%0A%09IFT_V35                           = 0x2d%0A%09IFT_V36                           = 0x41%0A%09IFT_V37                           = 0x78%0A%09IFT_VDSL                          = 0x61%0A%09IFT_VIRTUALIPADDRESS              = 0x70%0A%09IFT_VOICEEM                       = 0x64%0A%09IFT_VOICEENCAP                    = 0x67%0A%09IFT_VOICEFXO                      = 0x65%0A%09IFT_VOICEFXS                      = 0x66%0A%09IFT_VOICEOVERATM                  = 0x98%0A%09IFT_VOICEOVERFRAMERELAY           = 0x99%0A%09IFT_VOICEOVERIP                   = 0x68%0A%09IFT_X213                          = 0x5d%0A%09IFT_X25                           = 0x5%0A%09IFT_X25DDN                        = 0x4%0A%09IFT_X25HUNTGROUP                  = 0x7a%0A%09IFT_X25MLP                        = 0x79%0A%09IFT_X25PLE                        = 0x28%0A%09IFT_XETHER                        = 0x1a%0A%09IPPROTO_MAXID                     = 0x34%0A%09IPV6_FAITH                        = 0x1d%0A%09IP_FAITH                          = 0x16%0A%09MAP_NORESERVE                     = 0x40%0A%09MAP_RENAME                        = 0x20%0A%09NET_RT_MAXID                      = 0x6%0A%09RTF_PRCLONING                     = 0x10000%0A%09RTM_OLDADD                        = 0x9%0A%09RTM_OLDDEL                        = 0xa%0A%09SIOCADDRT                         = 0x8030720a%0A%09SIOCALIFADDR                      = 0x8118691b%0A%09SIOCDELRT                         = 0x8030720b%0A%09SIOCDLIFADDR                      = 0x8118691d%0A%09SIOCGLIFADDR                      = 0xc118691c%0A%09SIOCGLIFPHYADDR                   = 0xc118694b%0A%09SIOCSLIFPHYADDR                   = 0x8118694a%0A)%0A
- f de71ca04c23dc02b252f1adda6dd9104f326f74dbbb3fb014b67ce68fc8f1fb8 vendor/golang.org/x/sys/unix/errors_freebsd_amd64.go
+ f 985a567300adc129e0c6665439e37d0c5855d200873d38e38b5429e152c14a40 vendor/golang.org/x/sys/unix/errors_freebsd_amd64.go
dmppatch 3
@@ -294,9114 +294,4 @@
 nix%0A
-%0Aconst (%0A%09IFF_SMART                         = 0x20%0A%09IFT_1822                          = 0x2%0A%09IFT_A12MPPSWITCH                  = 0x82%0A%09IFT_AAL2                          = 0xbb%0A%09IFT_AAL5                          = 0x31%0A%09IFT_ADSL                          = 0x5e%0A%09IFT_AFLANE8023                    = 0x3b%0A%09IFT_AFLANE8025                    = 0x3c%0A%09IFT_ARAP                          = 0x58%0A%09IFT_ARCNET                        = 0x23%0A%09IFT_ARCNETPLUS                    = 0x24%0A%09IFT_ASYNC                         = 0x54%0A%09IFT_ATM                           = 0x25%0A%09IFT_ATMDXI                        = 0x69%0A%09IFT_ATMFUNI                       = 0x6a%0A%09IFT_ATMIMA                        = 0x6b%0A%09IFT_ATMLOGICAL                    = 0x50%0A%09IFT_ATMRADIO                      = 0xbd%0A%09IFT_ATMSUBINTERFACE               = 0x86%0A%09IFT_ATMVCIENDPT                   = 0xc2%0A%09IFT_ATMVIRTUAL                    = 0x95%0A%09IFT_BGPPOLICYACCOUNTING           = 0xa2%0A%09IFT_BSC                           = 0x53%0A%09IFT_CCTEMUL                       = 0x3d%0A%09IFT_CEPT                          = 0x13%0A%09IFT_CES                           = 0x85%0A%09IFT_CHANNEL                       = 0x46%0A%09IFT_CNR                           = 0x55%0A%09IFT_COFFEE                        = 0x84%0A%09IFT_COMPOSITELINK                 = 0x9b%0A%09IFT_DCN                           = 0x8d%0A%09IFT_DIGITALPOWERLINE              = 0x8a%0A%09IFT_DIGITALWRAPPEROVERHEADCHANNEL = 0xba%0A%09IFT_DLSW                          = 0x4a%0A%09IFT_DOCSCABLEDOWNSTREAM           = 0x80%0A%09IFT_DOCSCABLEMACLAYER             = 0x7f%0A%09IFT_DOCSCABLEUPSTREAM             = 0x81%0A%09IFT_DS0                           = 0x51%0A%09IFT_DS0BUNDLE                     = 0x52%0A%09IFT_DS1FDL                        = 0xaa%0A%09IFT_DS3                           = 0x1e%0A%09IFT_DTM                           = 0x8c%0A%09IFT_DVBASILN                      = 0xac%0A%09IFT_DVBASIOUT                     = 0xad%0A%09IFT_DVBRCCDOWNSTREAM              = 0x93%0A%09IFT_DVBRCCMACLAYER                = 0x92%0A%09IFT_DVBRCCUPSTREAM                = 0x94%0A%09IFT_ENC                           = 0xf4%0A%09IFT_EON                           = 0x19%0A%09IFT_EPLRS                         = 0x57%0A%09IFT_ESCON                         = 0x49%0A%09IFT_ETHER                         = 0x6%0A%09IFT_FAITH                         = 0xf2%0A%09IFT_FAST                          = 0x7d%0A%09IFT_FASTETHER                     = 0x3e%0A%09IFT_FASTETHERFX                   = 0x45%0A%09IFT_FDDI                          = 0xf%0A%09IFT_FIBRECHANNEL                  = 0x38%0A%09IFT_FRAMERELAYINTERCONNECT        = 0x3a%0A%09IFT_FRAMERELAYMPI                 = 0x5c%0A%09IFT_FRDLCIENDPT                   = 0xc1%0A%09IFT_FRELAY                        = 0x20%0A%09IFT_FRELAYDCE                     = 0x2c%0A%09IFT_FRF16MFRBUNDLE                = 0xa3%0A%09IFT_FRFORWARD                     = 0x9e%0A%09IFT_G703AT2MB                     = 0x43%0A%09IFT_G703AT64K                     = 0x42%0A%09IFT_GIF                           = 0xf0%0A%09IFT_GIGABITETHERNET               = 0x75%0A%09IFT_GR303IDT                      = 0xb2%0A%09IFT_GR303RDT                      = 0xb1%0A%09IFT_H323GATEKEEPER                = 0xa4%0A%09IFT_H323PROXY                     = 0xa5%0A%09IFT_HDH1822                       = 0x3%0A%09IFT_HDLC                          = 0x76%0A%09IFT_HDSL2                         = 0xa8%0A%09IFT_HIPERLAN2                     = 0xb7%0A%09IFT_HIPPI                         = 0x2f%0A%09IFT_HIPPIINTERFACE                = 0x39%0A%09IFT_HOSTPAD                       = 0x5a%0A%09IFT_HSSI                          = 0x2e%0A%09IFT_HY                            = 0xe%0A%09IFT_IBM370PARCHAN                 = 0x48%0A%09IFT_IDSL                          = 0x9a%0A%09IFT_IEEE80211                     = 0x47%0A%09IFT_IEEE80212                     = 0x37%0A%09IFT_IEEE8023ADLAG                 = 0xa1%0A%09IFT_IFGSN                         = 0x91%0A%09IFT_IMT                           = 0xbe%0A%09IFT_INTERLEAVE                    = 0x7c%0A%09IFT_IP                            = 0x7e%0A%09IFT_IPFORWARD                     = 0x8e%0A%09IFT_IPOVERATM                     = 0x72%0A%09IFT_IPOVERCDLC                    = 0x6d%0A%09IFT_IPOVERCLAW                    = 0x6e%0A%09IFT_IPSWITCH                      = 0x4e%0A%09IFT_IPXIP                         = 0xf9%0A%09IFT_ISDN                          = 0x3f%0A%09IFT_ISDNBASIC                     = 0x14%0A%09IFT_ISDNPRIMARY                   = 0x15%0A%09IFT_ISDNS                         = 0x4b%0A%09IFT_ISDNU                         = 0x4c%0A%09IFT_ISO88022LLC                   = 0x29%0A%09IFT_ISO88023                      = 0x7%0A%09IFT_ISO88024                      = 0x8%0A%09IFT_ISO88025                      = 0x9%0A%09IFT_ISO88025CRFPINT               = 0x62%0A%09IFT_ISO88025DTR                   = 0x56%0A%09IFT_ISO88025FIBER                 = 0x73%0A%09IFT_ISO88026                      = 0xa%0A%09IFT_ISUP                          = 0xb3%0A%09IFT_L3IPXVLAN                     = 0x89%0A%09IFT_LAPB                          = 0x10%0A%09IFT_LAPD                          = 0x4d%0A%09IFT_LAPF                          = 0x77%0A%09IFT_LOCALTALK                     = 0x2a%0A%09IFT_LOOP                          = 0x18%0A%09IFT_MEDIAMAILOVERIP               = 0x8b%0A%09IFT_MFSIGLINK                     = 0xa7%0A%09IFT_MIOX25                        = 0x26%0A%09IFT_MODEM                         = 0x30%0A%09IFT_MPC                           = 0x71%0A%09IFT_MPLS                          = 0xa6%0A%09IFT_MPLSTUNNEL                    = 0x96%0A%09IFT_MSDSL                         = 0x8f%0A%09IFT_MVL                           = 0xbf%0A%09IFT_MYRINET                       = 0x63%0A%09IFT_NFAS                          = 0xaf%0A%09IFT_NSIP                          = 0x1b%0A%09IFT_OPTICALCHANNEL                = 0xc3%0A%09IFT_OPTICALTRANSPORT              = 0xc4%0A%09IFT_OTHER                         = 0x1%0A%09IFT_P10                           = 0xc%0A%09IFT_P80                           = 0xd%0A%09IFT_PARA                          = 0x22%0A%09IFT_PFLOG                         = 0xf6%0A%09IFT_PFSYNC                        = 0xf7%0A%09IFT_PLC                           = 0xae%0A%09IFT_POS                           = 0xab%0A%09IFT_PPPMULTILINKBUNDLE            = 0x6c%0A%09IFT_PROPBWAP2MP                   = 0xb8%0A%09IFT_PROPCNLS                      = 0x59%0A%09IFT_PROPDOCSWIRELESSDOWNSTREAM    = 0xb5%0A%09IFT_PROPDOCSWIRELESSMACLAYER      = 0xb4%0A%09IFT_PROPDOCSWIRELESSUPSTREAM      = 0xb6%0A%09IFT_PROPMUX                       = 0x36%0A%09IFT_PROPWIRELESSP2P               = 0x9d%0A%09IFT_PTPSERIAL                     = 0x16%0A%09IFT_PVC                           = 0xf1%0A%09IFT_QLLC                          = 0x44%0A%09IFT_RADIOMAC                      = 0xbc%0A%09IFT_RADSL                         = 0x5f%0A%09IFT_REACHDSL                      = 0xc0%0A%09IFT_RFC1483                       = 0x9f%0A%09IFT_RS232                         = 0x21%0A%09IFT_RSRB                          = 0x4f%0A%09IFT_SDLC                          = 0x11%0A%09IFT_SDSL                          = 0x60%0A%09IFT_SHDSL                         = 0xa9%0A%09IFT_SIP                           = 0x1f%0A%09IFT_SLIP                          = 0x1c%0A%09IFT_SMDSDXI                       = 0x2b%0A%09IFT_SMDSICIP                      = 0x34%0A%09IFT_SONET                         = 0x27%0A%09IFT_SONETOVERHEADCHANNEL          = 0xb9%0A%09IFT_SONETPATH                     = 0x32%0A%09IFT_SONETVT                       = 0x33%0A%09IFT_SRP                           = 0x97%0A%09IFT_SS7SIGLINK                    = 0x9c%0A%09IFT_STACKTOSTACK                  = 0x6f%0A%09IFT_STARLAN                       = 0xb%0A%09IFT_STF                           = 0xd7%0A%09IFT_T1                            = 0x12%0A%09IFT_TDLC                          = 0x74%0A%09IFT_TERMPAD                       = 0x5b%0A%09IFT_TR008                         = 0xb0%0A%09IFT_TRANSPHDLC                    = 0x7b%0A%09IFT_TUNNEL                        = 0x83%0A%09IFT_ULTRA                         = 0x1d%0A%09IFT_USB                           = 0xa0%0A%09IFT_V11                           = 0x40%0A%09IFT_V35                           = 0x2d%0A%09IFT_V36                           = 0x41%0A%09IFT_V37                           = 0x78%0A%09IFT_VDSL                          = 0x61%0A%09IFT_VIRTUALIPADDRESS              = 0x70%0A%09IFT_VOICEEM                       = 0x64%0A%09IFT_VOICEENCAP                    = 0x67%0A%09IFT_VOICEFXO                      = 0x65%0A%09IFT_VOICEFXS                      = 0x66%0A%09IFT_VOICEOVERATM                  = 0x98%0A%09IFT_VOICEOVERFRAMERELAY           = 0x99%0A%09IFT_VOICEOVERIP                   = 0x68%0A%09IFT_X213                          = 0x5d%0A%09IFT_X25                           = 0x5%0A%09IFT_X25DDN                        = 0x4%0A%09IFT_X25HUNTGROUP                  = 0x7a%0A%09IFT_X25MLP                        = 0x79%0A%09IFT_X25PLE                        = 0x28%0A%09IFT_XETHER                        = 0x1a%0A%09IPPROTO_MAXID                     = 0x34%0A%09IPV6_FAITH                        = 0x1d%0A%09IP_FAITH                          = 0x16%0A%09MAP_NORESERVE                     = 0x40%0A%09MAP_RENAME                        = 0x20%0A%09NET_RT_MAXID                      = 0x6%0A%09RTF_PRCLONING                     = 0x10000%0A%09RTM_OLDADD                        = 0x9%0A%09RTM_OLDDEL                        = 0xa%0A%09SIOCADDRT                         = 0x8040720a%0A%09SIOCALIFADDR                      = 0x8118691b%0A%09SIOCDELRT                         = 0x8040720b%0A%09SIOCDLIFADDR                      = 0x8118691d%0A%09SIOCGLIFADDR                      = 0xc118691c%0A%09SIOCGLIFPHYADDR                   = 0xc118694b%0A%09SIOCSLIFPHYADDR                   = 0x8118694a%0A)%0A
- f 06b313cc0ecad484868d8d940a6a2b50ae5bc122f2907fa5cd9bba44e27382fb vendor/golang.org/x/sys/unix/errors_freebsd_arm.go
+ f 0f842d7683103c125db1d1d7372a7bbcf00277f3e85a4b209273ccc3834835d7 vendor/golang.org/x/sys/unix/errors_freebsd_arm.go
dmppatch 3
@@ -170,8868 +170,4 @@
 nix%0A
-%0Aconst (%0A%09IFT_1822                          = 0x2%0A%09IFT_A12MPPSWITCH                  = 0x82%0A%09IFT_AAL2                          = 0xbb%0A%09IFT_AAL5                          = 0x31%0A%09IFT_ADSL                          = 0x5e%0A%09IFT_AFLANE8023                    = 0x3b%0A%09IFT_AFLANE8025                    = 0x3c%0A%09IFT_ARAP                          = 0x58%0A%09IFT_ARCNET                        = 0x23%0A%09IFT_ARCNETPLUS                    = 0x24%0A%09IFT_ASYNC                         = 0x54%0A%09IFT_ATM                           = 0x25%0A%09IFT_ATMDXI                        = 0x69%0A%09IFT_ATMFUNI                       = 0x6a%0A%09IFT_ATMIMA                        = 0x6b%0A%09IFT_ATMLOGICAL                    = 0x50%0A%09IFT_ATMRADIO                      = 0xbd%0A%09IFT_ATMSUBINTERFACE               = 0x86%0A%09IFT_ATMVCIENDPT                   = 0xc2%0A%09IFT_ATMVIRTUAL                    = 0x95%0A%09IFT_BGPPOLICYACCOUNTING           = 0xa2%0A%09IFT_BSC                           = 0x53%0A%09IFT_CCTEMUL                       = 0x3d%0A%09IFT_CEPT                          = 0x13%0A%09IFT_CES                           = 0x85%0A%09IFT_CHANNEL                       = 0x46%0A%09IFT_CNR                           = 0x55%0A%09IFT_COFFEE                        = 0x84%0A%09IFT_COMPOSITELINK                 = 0x9b%0A%09IFT_DCN                           = 0x8d%0A%09IFT_DIGITALPOWERLINE              = 0x8a%0A%09IFT_DIGITALWRAPPEROVERHEADCHANNEL = 0xba%0A%09IFT_DLSW                          = 0x4a%0A%09IFT_DOCSCABLEDOWNSTREAM           = 0x80%0A%09IFT_DOCSCABLEMACLAYER             = 0x7f%0A%09IFT_DOCSCABLEUPSTREAM             = 0x81%0A%09IFT_DS0                           = 0x51%0A%09IFT_DS0BUNDLE                     = 0x52%0A%09IFT_DS1FDL                        = 0xaa%0A%09IFT_DS3                           = 0x1e%0A%09IFT_DTM                           = 0x8c%0A%09IFT_DVBASILN                      = 0xac%0A%09IFT_DVBASIOUT                     = 0xad%0A%09IFT_DVBRCCDOWNSTREAM              = 0x93%0A%09IFT_DVBRCCMACLAYER                = 0x92%0A%09IFT_DVBRCCUPSTREAM                = 0x94%0A%09IFT_ENC                           = 0xf4%0A%09IFT_EON                           = 0x19%0A%09IFT_EPLRS                         = 0x57%0A%09IFT_ESCON                         = 0x49%0A%09IFT_ETHER                         = 0x6%0A%09IFT_FAST                          = 0x7d%0A%09IFT_FASTETHER                     = 0x3e%0A%09IFT_FASTETHERFX                   = 0x45%0A%09IFT_FDDI                          = 0xf%0A%09IFT_FIBRECHANNEL                  = 0x38%0A%09IFT_FRAMERELAYINTERCONNECT        = 0x3a%0A%09IFT_FRAMERELAYMPI                 = 0x5c%0A%09IFT_FRDLCIENDPT                   = 0xc1%0A%09IFT_FRELAY                        = 0x20%0A%09IFT_FRELAYDCE                     = 0x2c%0A%09IFT_FRF16MFRBUNDLE                = 0xa3%0A%09IFT_FRFORWARD                     = 0x9e%0A%09IFT_G703AT2MB                     = 0x43%0A%09IFT_G703AT64K                     = 0x42%0A%09IFT_GIF                           = 0xf0%0A%09IFT_GIGABITETHERNET               = 0x75%0A%09IFT_GR303IDT                      = 0xb2%0A%09IFT_GR303RDT                      = 0xb1%0A%09IFT_H323GATEKEEPER                = 0xa4%0A%09IFT_H323PROXY                     = 0xa5%0A%09IFT_HDH1822                       = 0x3%0A%09IFT_HDLC                          = 0x76%0A%09IFT_HDSL2                         = 0xa8%0A%09IFT_HIPERLAN2                     = 0xb7%0A%09IFT_HIPPI                         = 0x2f%0A%09IFT_HIPPIINTERFACE                = 0x39%0A%09IFT_HOSTPAD                       = 0x5a%0A%09IFT_HSSI                          = 0x2e%0A%09IFT_HY                            = 0xe%0A%09IFT_IBM370PARCHAN                 = 0x48%0A%09IFT_IDSL                          = 0x9a%0A%09IFT_IEEE80211                     = 0x47%0A%09IFT_IEEE80212                     = 0x37%0A%09IFT_IEEE8023ADLAG                 = 0xa1%0A%09IFT_IFGSN                         = 0x91%0A%09IFT_IMT                           = 0xbe%0A%09IFT_INTERLEAVE                    = 0x7c%0A%09IFT_IP                            = 0x7e%0A%09IFT_IPFORWARD                     = 0x8e%0A%09IFT_IPOVERATM                     = 0x72%0A%09IFT_IPOVERCDLC                    = 0x6d%0A%09IFT_IPOVERCLAW                    = 0x6e%0A%09IFT_IPSWITCH                      = 0x4e%0A%09IFT_ISDN                          = 0x3f%0A%09IFT_ISDNBASIC                     = 0x14%0A%09IFT_ISDNPRIMARY                   = 0x15%0A%09IFT_ISDNS                         = 0x4b%0A%09IFT_ISDNU                         = 0x4c%0A%09IFT_ISO88022LLC                   = 0x29%0A%09IFT_ISO88023                      = 0x7%0A%09IFT_ISO88024                      = 0x8%0A%09IFT_ISO88025                      = 0x9%0A%09IFT_ISO88025CRFPINT               = 0x62%0A%09IFT_ISO88025DTR                   = 0x56%0A%09IFT_ISO88025FIBER                 = 0x73%0A%09IFT_ISO88026                      = 0xa%0A%09IFT_ISUP                          = 0xb3%0A%09IFT_L3IPXVLAN                     = 0x89%0A%09IFT_LAPB                          = 0x10%0A%09IFT_LAPD                          = 0x4d%0A%09IFT_LAPF                          = 0x77%0A%09IFT_LOCALTALK                     = 0x2a%0A%09IFT_LOOP                          = 0x18%0A%09IFT_MEDIAMAILOVERIP               = 0x8b%0A%09IFT_MFSIGLINK                     = 0xa7%0A%09IFT_MIOX25                        = 0x26%0A%09IFT_MODEM                         = 0x30%0A%09IFT_MPC                           = 0x71%0A%09IFT_MPLS                          = 0xa6%0A%09IFT_MPLSTUNNEL                    = 0x96%0A%09IFT_MSDSL                         = 0x8f%0A%09IFT_MVL                           = 0xbf%0A%09IFT_MYRINET                       = 0x63%0A%09IFT_NFAS                          = 0xaf%0A%09IFT_NSIP                          = 0x1b%0A%09IFT_OPTICALCHANNEL                = 0xc3%0A%09IFT_OPTICALTRANSPORT              = 0xc4%0A%09IFT_OTHER                         = 0x1%0A%09IFT_P10                           = 0xc%0A%09IFT_P80                           = 0xd%0A%09IFT_PARA                          = 0x22%0A%09IFT_PFLOG                         = 0xf6%0A%09IFT_PFSYNC                        = 0xf7%0A%09IFT_PLC                           = 0xae%0A%09IFT_POS                           = 0xab%0A%09IFT_PPPMULTILINKBUNDLE            = 0x6c%0A%09IFT_PROPBWAP2MP                   = 0xb8%0A%09IFT_PROPCNLS                      = 0x59%0A%09IFT_PROPDOCSWIRELESSDOWNSTREAM    = 0xb5%0A%09IFT_PROPDOCSWIRELESSMACLAYER      = 0xb4%0A%09IFT_PROPDOCSWIRELESSUPSTREAM      = 0xb6%0A%09IFT_PROPMUX                       = 0x36%0A%09IFT_PROPWIRELESSP2P               = 0x9d%0A%09IFT_PTPSERIAL                     = 0x16%0A%09IFT_PVC                           = 0xf1%0A%09IFT_QLLC                          = 0x44%0A%09IFT_RADIOMAC                      = 0xbc%0A%09IFT_RADSL                         = 0x5f%0A%09IFT_REACHDSL                      = 0xc0%0A%09IFT_RFC1483                       = 0x9f%0A%09IFT_RS232                         = 0x21%0A%09IFT_RSRB                          = 0x4f%0A%09IFT_SDLC                          = 0x11%0A%09IFT_SDSL                          = 0x60%0A%09IFT_SHDSL                         = 0xa9%0A%09IFT_SIP                           = 0x1f%0A%09IFT_SLIP                          = 0x1c%0A%09IFT_SMDSDXI                       = 0x2b%0A%09IFT_SMDSICIP                      = 0x34%0A%09IFT_SONET                         = 0x27%0A%09IFT_SONETOVERHEADCHANNEL          = 0xb9%0A%09IFT_SONETPATH                     = 0x32%0A%09IFT_SONETVT                       = 0x33%0A%09IFT_SRP                           = 0x97%0A%09IFT_SS7SIGLINK                    = 0x9c%0A%09IFT_STACKTOSTACK                  = 0x6f%0A%09IFT_STARLAN                       = 0xb%0A%09IFT_STF                           = 0xd7%0A%09IFT_T1                            = 0x12%0A%09IFT_TDLC                          = 0x74%0A%09IFT_TERMPAD                       = 0x5b%0A%09IFT_TR008                         = 0xb0%0A%09IFT_TRANSPHDLC                    = 0x7b%0A%09IFT_TUNNEL                        = 0x83%0A%09IFT_ULTRA                         = 0x1d%0A%09IFT_USB                           = 0xa0%0A%09IFT_V11                           = 0x40%0A%09IFT_V35                           = 0x2d%0A%09IFT_V36                           = 0x41%0A%09IFT_V37                           = 0x78%0A%09IFT_VDSL                          = 0x61%0A%09IFT_VIRTUALIPADDRESS              = 0x70%0A%09IFT_VOICEEM                       = 0x64%0A%09IFT_VOICEENCAP                    = 0x67%0A%09IFT_VOICEFXO                      = 0x65%0A%09IFT_VOICEFXS                      = 0x66%0A%09IFT_VOICEOVERATM                  = 0x98%0A%09IFT_VOICEOVERFRAMERELAY           = 0x99%0A%09IFT_VOICEOVERIP                   = 0x68%0A%09IFT_X213                          = 0x5d%0A%09IFT_X25                           = 0x5%0A%09IFT_X25DDN                        = 0x4%0A%09IFT_X25HUNTGROUP                  = 0x7a%0A%09IFT_X25MLP                        = 0x79%0A%09IFT_X25PLE                        = 0x28%0A%09IFT_XETHER                        = 0x1a%0A%0A%09// missing constants on FreeBSD-11.1-RELEASE, copied from old values in ztypes_freebsd_arm.go%0A%09IFF_SMART       = 0x20%0A%09IFT_FAITH       = 0xf2%0A%09IFT_IPXIP       = 0xf9%0A%09IPPROTO_MAXID   = 0x34%0A%09IPV6_FAITH      = 0x1d%0A%09IP_FAITH        = 0x16%0A%09MAP_NORESERVE   = 0x40%0A%09MAP_RENAME      = 0x20%0A%09NET_RT_MAXID    = 0x6%0A%09RTF_PRCLONING   = 0x10000%0A%09RTM_OLDADD      = 0x9%0A%09RTM_OLDDEL      = 0xa%0A%09SIOCADDRT       = 0x8030720a%0A%09SIOCALIFADDR    = 0x8118691b%0A%09SIOCDELRT       = 0x8030720b%0A%09SIOCDLIFADDR    = 0x8118691d%0A%09SIOCGLIFADDR    = 0xc118691c%0A%09SIOCGLIFPHYADDR = 0xc118694b%0A%09SIOCSLIFPHYADDR = 0x8118694a%0A)%0A
- f 2ca874cdb1ccae4312ff8e2c09470d168d9e925b39613637d2ab45b0620376c6 vendor/golang.org/x/sys/unix/fcntl.go
+ f 7ca4758ccd5fe2f1fd39249cbe8ce35d0086857d9082fac5b79f3a44e141d1f9 vendor/golang.org/x/sys/unix/fcntl.go
dmppatch 3
@@ -227,710 +227,4 @@
 nix%0A
-%0Aimport %22unsafe%22%0A%0A// fcntl64Syscall is usually SYS_FCNTL, but is overridden on 32-bit Linux%0A// systems by flock_linux_32bit.go to be SYS_FCNTL64.%0Avar fcntl64Syscall uintptr = SYS_FCNTL%0A%0A// FcntlInt performs a fcntl syscall on fd with the provided command and argument.%0Afunc FcntlInt(fd uintptr, cmd, arg int) (int, error) %7B%0A%09valptr, _, err := Syscall(fcntl64Syscall, fd, uintptr(cmd), uintptr(arg))%0A%09return int(valptr), err%0A%7D%0A%0A// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.%0Afunc FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error %7B%0A%09_, _, errno := Syscall(fcntl64Syscall, fd, uintptr(cmd), uintptr(unsafe.Pointer(lk)))%0A%09if errno == 0 %7B%0A%09%09return nil%0A%09%7D%0A%09return errno%0A%7D%0A
- f 9e3b5db6c66bbb3b042c6c9adf6c25776eb3d1b616e2e1d7662cb2fe4e8d26d7 vendor/golang.org/x/sys/unix/gccgo.go
+ f 5bb3a51468ee90f80dcbe339093f2b9cd74db146efdbe4a36a6f224935547807 vendor/golang.org/x/sys/unix/gccgo.go
dmppatch 7
@@ -206,558 +206,8 @@
 l%22%0A%0A
-// We can't use the gc-syntax .s files for gccgo. On the plus side%0A// much of the functionality can be written directly in Go.%0A%0A//extern gccgoRealSyscallNoError%0Afunc realSyscallNoError(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r uintptr)%0A%0A//extern gccgoRealSyscall%0Afunc realSyscall(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r, errno uintptr)%0A%0Afunc SyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr) %7B%0A%09syscall.Entersyscall()%0A%09r := realSyscallNoError(trap, a1, a2, a3, 0, 0, 0, 0, 0, 0)%0A%09syscall.Exitsyscall()%0A%09return r, 0%0A%7D%0A%0A
 func
@@ -428,1016 +428,4 @@
 )%0A%7D%0A
-%0Afunc Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno) %7B%0A%09syscall.Entersyscall()%0A%09r, errno := realSyscall(trap, a1, a2, a3, a4, a5, a6, 0, 0, 0)%0A%09syscall.Exitsyscall()%0A%09return r, 0, syscall.Errno(errno)%0A%7D%0A%0Afunc Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno) %7B%0A%09syscall.Entersyscall()%0A%09r, errno := realSyscall(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)%0A%09syscall.Exitsyscall()%0A%09return r, 0, syscall.Errno(errno)%0A%7D%0A%0Afunc RawSyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr) %7B%0A%09r := realSyscallNoError(trap, a1, a2, a3, 0, 0, 0, 0, 0, 0)%0A%09return r, 0%0A%7D%0A%0Afunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno) %7B%0A%09r, errno := realSyscall(trap, a1, a2, a3, 0, 0, 0, 0, 0, 0)%0A%09return r, 0, syscall.Errno(errno)%0A%7D%0A%0Afunc RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno) %7B%0A%09r, errno := realSyscall(trap, a1, a2, a3, a4, a5, a6, 0, 0, 0)%0A%09return r, 0, syscall.Errno(errno)%0A%7D%0A
- f b1f709a9f84a0f7ac7c54c32e6b35fdea64ef13ee91e120c8f165df95e3e798d vendor/golang.org/x/sys/unix/gccgo_c.c
+ f 548adaa1b0276f12a64fde689ef9893addf9eba9215dfe2a86b8ad851703af6d vendor/golang.org/x/sys/unix/gccgo_c.c
dmppatch 3
@@ -1050,204 +1050,4 @@
 ;%0A%7D%0A
-%0A// Define the use function in C so that it is not inlined.%0A%0Aextern void use(void *) __asm__ (GOSYM_PREFIX GOPKGPATH %22.use%22) __attribute__((noinline));%0A%0Avoid%0Ause(void *p __attribute__ ((unused)))%0A%7B%0A%7D%0A
- f 743d504a2e0b8f36ffb9618c184b518c6bf45302f9b01a9d5b269bd22d7aba10 vendor/golang.org/x/sys/unix/gccgo_linux_amd64.go
+ f 326ce7701ed9eeba853c492c833765bc99fa1091ba909df5b3588f81b17aa413 vendor/golang.org/x/sys/unix/gccgo_linux_amd64.go
dmppatch 3
@@ -199,231 +199,4 @@
 nix%0A
-%0Aimport %22syscall%22%0A%0A//extern gettimeofday%0Afunc realGettimeofday(*Timeval, *byte) int32%0A%0Afunc gettimeofday(tv *Timeval) (err syscall.Errno) %7B%0A%09r := realGettimeofday(tv, nil)%0A%09if r %3C 0 %7B%0A%09%09return syscall.GetErrno()%0A%09%7D%0A%09return 0%0A%7D%0A
+ f 6e2f76cfa24736b83c40d5e6d9211d39cc13f21280cab23c9761a1e43e5660ac vendor/golang.org/x/sys/unix/ioctl.go
dmppatch 2
@@ -0,0 +1,574 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A%0Apackage unix%0A%0Aimport %22runtime%22%0A%0A// IoctlSetTermios performs an ioctl on fd with a *Termios.%0A//%0A// The req value will usually be TCSETA or TIOCSETA.%0Afunc IoctlSetTermios(fd int, req uint, value *Termios) error %7B%0A%09// TODO: if we get the chance, remove the req parameter.%0A%09err := ioctlSetTermios(fd, req, value)%0A%09runtime.KeepAlive(value)%0A%09return err%0A%7D%0A
- x dc34e51f6a3923183e3cbe7316c77b664c7eabea14ccf44d9c5021ecb9637fb6 vendor/golang.org/x/sys/unix/mkerrors.sh
+ x e14e040f5256064bdf88e7d3056b44b27bdaeb5714a9f5458fd9a4cc6300ac17 vendor/golang.org/x/sys/unix/mkerrors.sh
dmppatch 54
@@ -1272,32 +1272,55 @@
 de %3Csys/wait.h%3E%0A
+#include %3Csys/xattr.h%3E%0A
 #include %3Cnet/bp
@@ -4106,24 +4106,63 @@
 ux/magic.h%3E%0A
+#include %3Clinux/netfilter/nfnetlink.h%3E%0A
 #include %3Cli
@@ -4168,32 +4168,65 @@
 inux/netlink.h%3E%0A
+#include %3Clinux/net_namespace.h%3E%0A
 #include %3Clinux/
@@ -4616,32 +4616,8 @@
 .h%3E%0A
-#include %3Clinux/stat.h%3E%0A
 #inc
@@ -4661,24 +4661,47 @@
 ux/hdreg.h%3E%0A
+#include %3Clinux/rtc.h%3E%0A
 #include %3Cne
@@ -5409,32 +5409,57 @@
 e %3Csys/event.h%3E%0A
+#include %3Csys/extattr.h%3E%0A
 #include %3Csys/mm
@@ -6055,32 +6055,54 @@
  %3Csys/sockio.h%3E%0A
+#include %3Csys/stat.h%3E%0A
 #include %3Csys/sy
@@ -6150,32 +6150,56 @@
  %3Csys/ttycom.h%3E%0A
+#include %3Csys/unistd.h%3E%0A
 #include %3Csys/wa
@@ -9890,92 +9890,103 @@
  &&%0A
-%09%09$2 ~ /%5E(NETLINK%7CNLM%7CNLMSG%7CNLA%7CIFA%7CIFAN%7CRT%7CRTCF%7CRTN%7CRTPROT%7CRTNH%7CARPHRD%7CETH_P)_/ %7C%7C%0A
+%09%09$2 ~ /%5E(NETLINK%7CNLM%7CNLMSG%7CNLA%7CIFA%7CIFAN%7CRT%7CRTC%7CRTCF%7CRTN%7CRTPROT%7CRTNH%7CARPHRD%7CETH_P%7CNETNSA)_/ %7C%7C%0A
 %09%09$2
@@ -10803,24 +10803,57 @@
 SPLICE_/ %7C%7C%0A
+%09%09$2 !~ /%5EAUDIT_RECORD_MAGIC/ &&%0A
 %09%09$2 ~ /%5E%5BA-
@@ -11020,24 +11020,44 @@
 %5ESTATX_/ %7C%7C%0A
+%09%09$2 ~ /%5ERENAME/ %7C%7C%0A
 %09%09$2 ~ /%5EUTI
@@ -11068,44 +11068,88 @@
  %7C%7C%0A
-%09%09$2 ~ /%5EXATTR_(CREATE%7CREPLACE)/ %7C%7C%0A
+%09%09$2 ~ /%5EXATTR_(CREATE%7CREPLACE%7CNO(DEFAULT%7CFOLLOW%7CSECURITY)%7CSHOWCOMPRESSION)/ %7C%7C%0A
 %09%09$2
@@ -11226,32 +11226,49 @@
  ~ /%5EWDIOC_/ %7C%7C%0A
+%09%09$2 ~ /%5ENFN/ %7C%7C%0A
 %09%09$2 ~ /%5E(HDIO%7CW
- x 8077e80ebf8777418bad340dc3c44f22de432acd9f9af0094aed6ca21caa3076 vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl
+ x cf1feccd0bbad9100f93be41fff04fb169e0464b362e04cbc58994aed5789b69 vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl
dmppatch 5
@@ -4957,63 +4957,61 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0A// 
- f 643c4bfc244dcd33b5df9f8d7f2760b3f1a7c0904cf731d40d005a7f96c5d6af vendor/golang.org/x/sys/unix/openbsd_pledge.go
+ f 73cef153f42a96b37a335ca369aaad3f7941b7b7b708f06ca0e28a337fc6f039 vendor/golang.org/x/sys/unix/openbsd_pledge.go
dmppatch 3
@@ -213,677 +213,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Aconst (%0A%09SYS_PLEDGE = 108%0A)%0A%0A// Pledge implements the pledge syscall. For more information see pledge(2).%0Afunc Pledge(promises string, paths %5B%5Dstring) error %7B%0A%09promisesPtr, err := syscall.BytePtrFromString(promises)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09promisesUnsafe, pathsUnsafe := unsafe.Pointer(promisesPtr), unsafe.Pointer(nil)%0A%09if paths != nil %7B%0A%09%09var pathsPtr %5B%5D*byte%0A%09%09if pathsPtr, err = syscall.SlicePtrFromStrings(paths); err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09pathsUnsafe = unsafe.Pointer(&pathsPtr%5B0%5D)%0A%09%7D%0A%09_, _, e := syscall.Syscall(SYS_PLEDGE, uintptr(promisesUnsafe), uintptr(pathsUnsafe), 0)%0A%09if e != 0 %7B%0A%09%09return e%0A%09%7D%0A%09return nil%0A%7D%0A
- f 8eee70f121d034a37088f795d5508ac9a02895f6293e4d30550fdf0b01061f17 vendor/golang.org/x/sys/unix/pagesize_unix.go
+ f 9b22298a2373aaaca3de3ab8a7380beec95c973b8bd8c4ca0184f76deedbbce2 vendor/golang.org/x/sys/unix/pagesize_unix.go
dmppatch 3
@@ -284,80 +284,4 @@
 nix%0A
-%0Aimport %22syscall%22%0A%0Afunc Getpagesize() int %7B%0A%09return syscall.Getpagesize()%0A%7D%0A
- f 2b7d22204270835d550741a4d1e143d7fcaf7b624070eaf0bc3db43af02db178 vendor/golang.org/x/sys/unix/race.go
+ f f65de6dc7ea28b9a6c791519440d8d731ca4a89cab3db3c41e342b0762d2f169 vendor/golang.org/x/sys/unix/race.go
dmppatch 4
@@ -347,176 +347,8 @@
 %0A%7D%0A%0A
-func raceReleaseMerge(addr unsafe.Pointer) %7B%0A%09runtime.RaceReleaseMerge(addr)%0A%7D%0A%0Afunc raceReadRange(addr unsafe.Pointer, len int) %7B%0A%09runtime.RaceReadRange(addr, len)%0A%7D%0A%0A
 func
- f 5cc7fe5cb00087e60f99c0df00478fc00feb9e295d112b421f6b221b19a32064 vendor/golang.org/x/sys/unix/race0.go
+ f 6b45a95193f69ce7ae2ed3eb030087981c7d4a964a7271b31ce7ed9473a8b4c4 vendor/golang.org/x/sys/unix/race0.go
dmppatch 4
@@ -346,110 +346,8 @@
 %0A%7D%0A%0A
-func raceReleaseMerge(addr unsafe.Pointer) %7B%0A%7D%0A%0Afunc raceReadRange(addr unsafe.Pointer, len int) %7B%0A%7D%0A%0A
 func
- f af158b5f4a3a069a11f95c789628544f9f0c09f961e36c204f34eb9bc1eb8144 vendor/golang.org/x/sys/unix/sockcmsg_linux.go
+ f d9f35e6b5cefd654e0a3fe2f89cf77ec946e16e06e96b04a70c53a73592b05a1 vendor/golang.org/x/sys/unix/sockcmsg_linux.go
dmppatch 3
@@ -198,874 +198,4 @@
 nix%0A
-%0Aimport %22unsafe%22%0A%0A// UnixCredentials encodes credentials into a socket control message%0A// for sending to another process. This can be used for%0A// authentication.%0Afunc UnixCredentials(ucred *Ucred) %5B%5Dbyte %7B%0A%09b := make(%5B%5Dbyte, CmsgSpace(SizeofUcred))%0A%09h := (*Cmsghdr)(unsafe.Pointer(&b%5B0%5D))%0A%09h.Level = SOL_SOCKET%0A%09h.Type = SCM_CREDENTIALS%0A%09h.SetLen(CmsgLen(SizeofUcred))%0A%09*((*Ucred)(cmsgData(h))) = *ucred%0A%09return b%0A%7D%0A%0A// ParseUnixCredentials decodes a socket control message that contains%0A// credentials in a Ucred structure. To receive such a message, the%0A// SO_PASSCRED option must be enabled on the socket.%0Afunc ParseUnixCredentials(m *SocketControlMessage) (*Ucred, error) %7B%0A%09if m.Header.Level != SOL_SOCKET %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09if m.Header.Type != SCM_CREDENTIALS %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09ucred := *(*Ucred)(unsafe.Pointer(&m.Data%5B0%5D))%0A%09return &ucred, nil%0A%7D%0A
- f ecf2e45f87beaf1ff59ce6c8e622569081c3235b77c64bcfe5b960e0dcd62db3 vendor/golang.org/x/sys/unix/sockcmsg_unix.go
+ f d79d5b4a28307466235bf632057b837d1d0890093f725d342599277f562aa1db vendor/golang.org/x/sys/unix/sockcmsg_unix.go
dmppatch 3
@@ -263,2742 +263,4 @@
 nix%0A
-%0Aimport %22unsafe%22%0A%0A// Round the length of a raw sockaddr up to align it properly.%0Afunc cmsgAlignOf(salen int) int %7B%0A%09salign := sizeofPtr%0A%09// NOTE: It seems like 64-bit Darwin, DragonFly BSD and%0A%09// Solaris kernels still require 32-bit aligned access to%0A%09// network subsystem.%0A%09if darwin64Bit %7C%7C dragonfly64Bit %7C%7C solaris64Bit %7B%0A%09%09salign = 4%0A%09%7D%0A%09return (salen + salign - 1) & %5E(salign - 1)%0A%7D%0A%0A// CmsgLen returns the value to store in the Len field of the Cmsghdr%0A// structure, taking into account any necessary alignment.%0Afunc CmsgLen(datalen int) int %7B%0A%09return cmsgAlignOf(SizeofCmsghdr) + datalen%0A%7D%0A%0A// CmsgSpace returns the number of bytes an ancillary element with%0A// payload of the passed data length occupies.%0Afunc CmsgSpace(datalen int) int %7B%0A%09return cmsgAlignOf(SizeofCmsghdr) + cmsgAlignOf(datalen)%0A%7D%0A%0Afunc cmsgData(h *Cmsghdr) unsafe.Pointer %7B%0A%09return unsafe.Pointer(uintptr(unsafe.Pointer(h)) + uintptr(cmsgAlignOf(SizeofCmsghdr)))%0A%7D%0A%0A// SocketControlMessage represents a socket control message.%0Atype SocketControlMessage struct %7B%0A%09Header Cmsghdr%0A%09Data   %5B%5Dbyte%0A%7D%0A%0A// ParseSocketControlMessage parses b as an array of socket control%0A// messages.%0Afunc ParseSocketControlMessage(b %5B%5Dbyte) (%5B%5DSocketControlMessage, error) %7B%0A%09var msgs %5B%5DSocketControlMessage%0A%09i := 0%0A%09for i+CmsgLen(0) %3C= len(b) %7B%0A%09%09h, dbuf, err := socketControlMessageHeaderAndData(b%5Bi:%5D)%0A%09%09if err != nil %7B%0A%09%09%09return nil, err%0A%09%09%7D%0A%09%09m := SocketControlMessage%7BHeader: *h, Data: dbuf%7D%0A%09%09msgs = append(msgs, m)%0A%09%09i += cmsgAlignOf(int(h.Len))%0A%09%7D%0A%09return msgs, nil%0A%7D%0A%0Afunc socketControlMessageHeaderAndData(b %5B%5Dbyte) (*Cmsghdr, %5B%5Dbyte, error) %7B%0A%09h := (*Cmsghdr)(unsafe.Pointer(&b%5B0%5D))%0A%09if h.Len %3C SizeofCmsghdr %7C%7C uint64(h.Len) %3E uint64(len(b)) %7B%0A%09%09return nil, nil, EINVAL%0A%09%7D%0A%09return h, b%5BcmsgAlignOf(SizeofCmsghdr):h.Len%5D, nil%0A%7D%0A%0A// UnixRights encodes a set of open file descriptors into a socket%0A// control message for sending to another process.%0Afunc UnixRights(fds ...int) %5B%5Dbyte %7B%0A%09datalen := len(fds) * 4%0A%09b := make(%5B%5Dbyte, CmsgSpace(datalen))%0A%09h := (*Cmsghdr)(unsafe.Pointer(&b%5B0%5D))%0A%09h.Level = SOL_SOCKET%0A%09h.Type = SCM_RIGHTS%0A%09h.SetLen(CmsgLen(datalen))%0A%09data := cmsgData(h)%0A%09for _, fd := range fds %7B%0A%09%09*(*int32)(data) = int32(fd)%0A%09%09data = unsafe.Pointer(uintptr(data) + 4)%0A%09%7D%0A%09return b%0A%7D%0A%0A// ParseUnixRights decodes a socket control message that contains an%0A// integer array of open file descriptors from another process.%0Afunc ParseUnixRights(m *SocketControlMessage) (%5B%5Dint, error) %7B%0A%09if m.Header.Level != SOL_SOCKET %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09if m.Header.Type != SCM_RIGHTS %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09fds := make(%5B%5Dint, len(m.Data)%3E%3E2)%0A%09for i, j := 0, 0; i %3C len(m.Data); i += 4 %7B%0A%09%09fds%5Bj%5D = int(*(*int32)(unsafe.Pointer(&m.Data%5Bi%5D)))%0A%09%09j++%0A%09%7D%0A%09return fds, nil%0A%7D%0A
- f c4170c0ccf45204deb76a46410fb27e4d8a76a45c333de04449f137e7a4a1c1a vendor/golang.org/x/sys/unix/str.go
+ f 2d02a0676e9c504b468c5637d14b56852364a2dff3915f24ea06a369f47e7b73 vendor/golang.org/x/sys/unix/str.go
dmppatch 3
@@ -235,377 +235,4 @@
 nix%0A
-%0Afunc itoa(val int) string %7B // do it here rather than with fmt to avoid dependency%0A%09if val %3C 0 %7B%0A%09%09return %22-%22 + uitoa(uint(-val))%0A%09%7D%0A%09return uitoa(uint(val))%0A%7D%0A%0Afunc uitoa(val uint) string %7B%0A%09var buf %5B32%5Dbyte // big enough for int64%0A%09i := len(buf) - 1%0A%09for val %3E= 10 %7B%0A%09%09buf%5Bi%5D = byte(val%2510 + '0')%0A%09%09i--%0A%09%09val /= 10%0A%09%7D%0A%09buf%5Bi%5D = byte(val + '0')%0A%09return string(buf%5Bi:%5D)%0A%7D%0A
- f 82c6ec140ff98f71e0140bda10a7781f99ba7eb9e281ab2857d48f9bc03980b6 vendor/golang.org/x/sys/unix/syscall.go
+ f 449f8cd5f363d829aa1352021c59d94bd59dd01dfe541eb0ca6fa022aafb88fb vendor/golang.org/x/sys/unix/syscall.go
dmppatch 4
@@ -1253,679 +1253,8 @@
 x%22%0A%0A
-import %22strings%22%0A%0A// ByteSliceFromString returns a NUL-terminated slice of bytes%0A// containing the text of s. If s contains a NUL byte at any%0A// location, it returns (nil, EINVAL).%0Afunc ByteSliceFromString(s string) (%5B%5Dbyte, error) %7B%0A%09if strings.IndexByte(s, 0) != -1 %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09a := make(%5B%5Dbyte, len(s)+1)%0A%09copy(a, s)%0A%09return a, nil%0A%7D%0A%0A// BytePtrFromString returns a pointer to a NUL-terminated array of%0A// bytes containing the text of s. If s contains a NUL byte at any%0A// location, it returns (nil, EINVAL).%0Afunc BytePtrFromString(s string) (*byte, error) %7B%0A%09a, err := ByteSliceFromString(s)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &a%5B0%5D, nil%0A%7D%0A%0A
 // S
- f 8f7247e5835323e240c841935e12d6c6f80b41c19a20a397f0c25f0ad5c3be88 vendor/golang.org/x/sys/unix/syscall_bsd.go
+ f f0a144a5444fa685418379a03e1d79986007a30e17199e85b06c25c66d2a806d vendor/golang.org/x/sys/unix/syscall_bsd.go
dmppatch 3
@@ -487,15510 +487,4 @@
 nix%0A
-%0Aimport (%0A%09%22runtime%22%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0A/*%0A * Wrapped%0A */%0A%0A//sysnb%09getgroups(ngid int, gid *_Gid_t) (n int, err error)%0A//sysnb%09setgroups(ngid int, gid *_Gid_t) (err error)%0A%0Afunc Getgroups() (gids %5B%5Dint, err error) %7B%0A%09n, err := getgroups(0, nil)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n == 0 %7B%0A%09%09return nil, nil%0A%09%7D%0A%0A%09// Sanity check group count. Max is 16 on BSD.%0A%09if n %3C 0 %7C%7C n %3E 1000 %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, n)%0A%09n, err = getgroups(n, &a%5B0%5D)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09gids = make(%5B%5Dint, n)%0A%09for i, v := range a%5B0:n%5D %7B%0A%09%09gids%5Bi%5D = int(v)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setgroups(gids %5B%5Dint) (err error) %7B%0A%09if len(gids) == 0 %7B%0A%09%09return setgroups(0, nil)%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, len(gids))%0A%09for i, v := range gids %7B%0A%09%09a%5Bi%5D = _Gid_t(v)%0A%09%7D%0A%09return setgroups(len(a), &a%5B0%5D)%0A%7D%0A%0Afunc ReadDirent(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09// Final argument is (basep *uintptr) and the syscall doesn't take nil.%0A%09// 64 bits should be enough. (32 bits isn't even on 386). Since the%0A%09// actual system call is getdirentries64, 64 is a good guess.%0A%09// TODO(rsc): Can we use a single global basep for all calls?%0A%09var base = (*uintptr)(unsafe.Pointer(new(uint64)))%0A%09return Getdirentries(fd, buf, base)%0A%7D%0A%0A// Wait status is 7 bits at bottom, either 0 (exited),%0A// 0x7F (stopped), or a signal number that caused an exit.%0A// The 0x80 bit is whether there was a core dump.%0A// An extra number (exit code, signal causing a stop)%0A// is in the high bits.%0A%0Atype WaitStatus uint32%0A%0Aconst (%0A%09mask  = 0x7F%0A%09core  = 0x80%0A%09shift = 8%0A%0A%09exited  = 0%0A%09stopped = 0x7F%0A)%0A%0Afunc (w WaitStatus) Exited() bool %7B return w&mask == exited %7D%0A%0Afunc (w WaitStatus) ExitStatus() int %7B%0A%09if w&mask != exited %7B%0A%09%09return -1%0A%09%7D%0A%09return int(w %3E%3E shift)%0A%7D%0A%0Afunc (w WaitStatus) Signaled() bool %7B return w&mask != stopped && w&mask != 0 %7D%0A%0Afunc (w WaitStatus) Signal() syscall.Signal %7B%0A%09sig := syscall.Signal(w & mask)%0A%09if sig == stopped %7C%7C sig == 0 %7B%0A%09%09return -1%0A%09%7D%0A%09return sig%0A%7D%0A%0Afunc (w WaitStatus) CoreDump() bool %7B return w.Signaled() && w&core != 0 %7D%0A%0Afunc (w WaitStatus) Stopped() bool %7B return w&mask == stopped && syscall.Signal(w%3E%3Eshift) != SIGSTOP %7D%0A%0Afunc (w WaitStatus) Continued() bool %7B return w&mask == stopped && syscall.Signal(w%3E%3Eshift) == SIGSTOP %7D%0A%0Afunc (w WaitStatus) StopSignal() syscall.Signal %7B%0A%09if !w.Stopped() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w%3E%3Eshift) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) TrapCause() int %7B return -1 %7D%0A%0A//sys%09wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error)%0A%0Afunc Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09var status _C_int%0A%09wpid, err = wait4(pid, &status, options, rusage)%0A%09if wstatus != nil %7B%0A%09%09*wstatus = WaitStatus(status)%0A%09%7D%0A%09return%0A%7D%0A%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09Shutdown(s int, how int) (err error)%0A%0Afunc (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Len = SizeofSockaddrInet4%0A%09sa.raw.Family = AF_INET%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), _Socklen(sa.raw.Len), nil%0A%7D%0A%0Afunc (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Len = SizeofSockaddrInet6%0A%09sa.raw.Family = AF_INET6%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09sa.raw.Scope_id = sa.ZoneId%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), _Socklen(sa.raw.Len), nil%0A%7D%0A%0Afunc (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09name := sa.Name%0A%09n := len(name)%0A%09if n %3E= len(sa.raw.Path) %7C%7C n == 0 %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Len = byte(3 + n) // 2 for Family, Len; 1 for NUL%0A%09sa.raw.Family = AF_UNIX%0A%09for i := 0; i %3C n; i++ %7B%0A%09%09sa.raw.Path%5Bi%5D = int8(name%5Bi%5D)%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), _Socklen(sa.raw.Len), nil%0A%7D%0A%0Afunc (sa *SockaddrDatalink) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Index == 0 %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Len = sa.Len%0A%09sa.raw.Family = AF_LINK%0A%09sa.raw.Index = sa.Index%0A%09sa.raw.Type = sa.Type%0A%09sa.raw.Nlen = sa.Nlen%0A%09sa.raw.Alen = sa.Alen%0A%09sa.raw.Slen = sa.Slen%0A%09for i := 0; i %3C len(sa.raw.Data); i++ %7B%0A%09%09sa.raw.Data%5Bi%5D = sa.Data%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrDatalink, nil%0A%7D%0A%0Afunc anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, error) %7B%0A%09switch rsa.Addr.Family %7B%0A%09case AF_LINK:%0A%09%09pp := (*RawSockaddrDatalink)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrDatalink)%0A%09%09sa.Len = pp.Len%0A%09%09sa.Family = pp.Family%0A%09%09sa.Index = pp.Index%0A%09%09sa.Type = pp.Type%0A%09%09sa.Nlen = pp.Nlen%0A%09%09sa.Alen = pp.Alen%0A%09%09sa.Slen = pp.Slen%0A%09%09for i := 0; i %3C len(sa.Data); i++ %7B%0A%09%09%09sa.Data%5Bi%5D = pp.Data%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_UNIX:%0A%09%09pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))%0A%09%09if pp.Len %3C 2 %7C%7C pp.Len %3E SizeofSockaddrUnix %7B%0A%09%09%09return nil, EINVAL%0A%09%09%7D%0A%09%09sa := new(SockaddrUnix)%0A%0A%09%09// Some BSDs include the trailing NUL in the length, whereas%0A%09%09// others do not. Work around this by subtracting the leading%0A%09%09// family and len. The path is then scanned to see if a NUL%0A%09%09// terminator still exists within the length.%0A%09%09n := int(pp.Len) - 2 // subtract leading Family, Len%0A%09%09for i := 0; i %3C n; i++ %7B%0A%09%09%09if pp.Path%5Bi%5D == 0 %7B%0A%09%09%09%09// found early NUL; assume Len included the NUL%0A%09%09%09%09// or was overestimating.%0A%09%09%09%09n = i%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%7D%0A%09%09bytes := (*%5B10000%5Dbyte)(unsafe.Pointer(&pp.Path%5B0%5D))%5B0:n%5D%0A%09%09sa.Name = string(bytes)%0A%09%09return sa, nil%0A%0A%09case AF_INET:%0A%09%09pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet4)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_INET6:%0A%09%09pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet6)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09sa.ZoneId = pp.Scope_id%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%09%7D%0A%09return nil, EAFNOSUPPORT%0A%7D%0A%0Afunc Accept(fd int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept(fd, &rsa, &len)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09if runtime.GOOS == %22darwin%22 && len == 0 %7B%0A%09%09// Accepted socket has no address.%0A%09%09// This is likely due to a bug in xnu kernels,%0A%09%09// where instead of ECONNABORTED error socket%0A%09%09// is accepted, but has no address.%0A%09%09Close(nfd)%0A%09%09return 0, nil, ECONNABORTED%0A%09%7D%0A%09sa, err = anyToSockaddr(&rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getsockname(fd int) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if err = getsockname(fd, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09// TODO(jsing): DragonFly has a %22bug%22 (see issue 3349), which should be%0A%09// reported upstream.%0A%09if runtime.GOOS == %22dragonfly%22 && rsa.Addr.Family == AF_UNSPEC && rsa.Addr.Len == 0 %7B%0A%09%09rsa.Addr.Family = AF_UNIX%0A%09%09rsa.Addr.Len = SizeofSockaddrUnix%0A%09%7D%0A%09return anyToSockaddr(&rsa)%0A%7D%0A%0A//sysnb socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A%0A// GetsockoptString returns the string value of the socket option opt for the%0A// socket associated with fd at the given socket level.%0Afunc GetsockoptString(fd, level, opt int) (string, error) %7B%0A%09buf := make(%5B%5Dbyte, 256)%0A%09vallen := _Socklen(len(buf))%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&buf%5B0%5D), &vallen)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09return string(buf%5B:vallen-1%5D), nil%0A%7D%0A%0A//sys   recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys   sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A%0Afunc Recvmsg(fd int, p, oob %5B%5Dbyte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) %7B%0A%09var msg Msghdr%0A%09var rsa RawSockaddrAny%0A%09msg.Name = (*byte)(unsafe.Pointer(&rsa))%0A%09msg.Namelen = uint32(SizeofSockaddrAny)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = (*byte)(unsafe.Pointer(&p%5B0%5D))%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy byte%0A%09if len(oob) %3E 0 %7B%0A%09%09// receive at least one normal byte%0A%09%09if len(p) == 0 %7B%0A%09%09%09iov.Base = &dummy%0A%09%09%09iov.SetLen(1)%0A%09%09%7D%0A%09%09msg.Control = (*byte)(unsafe.Pointer(&oob%5B0%5D))%0A%09%09msg.SetControllen(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = recvmsg(fd, &msg, flags); err != nil %7B%0A%09%09return%0A%09%7D%0A%09oobn = int(msg.Controllen)%0A%09recvflags = int(msg.Flags)%0A%09// source address is only specified if the socket is unconnected%0A%09if rsa.Addr.Family != AF_UNSPEC %7B%0A%09%09from, err = anyToSockaddr(&rsa)%0A%09%7D%0A%09return%0A%7D%0A%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A%0Afunc Sendmsg(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (err error) %7B%0A%09_, err = SendmsgN(fd, p, oob, to, flags)%0A%09return%0A%7D%0A%0Afunc SendmsgN(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (n int, err error) %7B%0A%09var ptr unsafe.Pointer%0A%09var salen _Socklen%0A%09if to != nil %7B%0A%09%09ptr, salen, err = to.sockaddr()%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%7D%0A%09var msg Msghdr%0A%09msg.Name = (*byte)(unsafe.Pointer(ptr))%0A%09msg.Namelen = uint32(salen)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = (*byte)(unsafe.Pointer(&p%5B0%5D))%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy byte%0A%09if len(oob) %3E 0 %7B%0A%09%09// send at least one normal byte%0A%09%09if len(p) == 0 %7B%0A%09%09%09iov.Base = &dummy%0A%09%09%09iov.SetLen(1)%0A%09%09%7D%0A%09%09msg.Control = (*byte)(unsafe.Pointer(&oob%5B0%5D))%0A%09%09msg.SetControllen(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = sendmsg(fd, &msg, flags); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if len(oob) %3E 0 && len(p) == 0 %7B%0A%09%09n = 0%0A%09%7D%0A%09return n, nil%0A%7D%0A%0A//sys%09kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error)%0A%0Afunc Kevent(kq int, changes, events %5B%5DKevent_t, timeout *Timespec) (n int, err error) %7B%0A%09var change, event unsafe.Pointer%0A%09if len(changes) %3E 0 %7B%0A%09%09change = unsafe.Pointer(&changes%5B0%5D)%0A%09%7D%0A%09if len(events) %3E 0 %7B%0A%09%09event = unsafe.Pointer(&events%5B0%5D)%0A%09%7D%0A%09return kevent(kq, change, len(changes), event, len(events), timeout)%0A%7D%0A%0A//sys%09sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL%0A%0A// sysctlmib translates name to mib number and appends any additional args.%0Afunc sysctlmib(name string, args ...int) (%5B%5D_C_int, error) %7B%0A%09// Translate name to mib number.%0A%09mib, err := nametomib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09for _, a := range args %7B%0A%09%09mib = append(mib, _C_int(a))%0A%09%7D%0A%0A%09return mib, nil%0A%7D%0A%0Afunc Sysctl(name string) (string, error) %7B%0A%09return SysctlArgs(name)%0A%7D%0A%0Afunc SysctlArgs(name string, args ...int) (string, error) %7B%0A%09buf, err := SysctlRaw(name, args...)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := len(buf)%0A%0A%09// Throw away terminating NUL.%0A%09if n %3E 0 && buf%5Bn-1%5D == '%5Cx00' %7B%0A%09%09n--%0A%09%7D%0A%09return string(buf%5B0:n%5D), nil%0A%7D%0A%0Afunc SysctlUint32(name string) (uint32, error) %7B%0A%09return SysctlUint32Args(name)%0A%7D%0A%0Afunc SysctlUint32Args(name string, args ...int) (uint32, error) %7B%0A%09mib, err := sysctlmib(name, args...)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%0A%09n := uintptr(4)%0A%09buf := make(%5B%5Dbyte, 4)%0A%09if err := sysctl(mib, &buf%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if n != 4 %7B%0A%09%09return 0, EIO%0A%09%7D%0A%09return *(*uint32)(unsafe.Pointer(&buf%5B0%5D)), nil%0A%7D%0A%0Afunc SysctlUint64(name string, args ...int) (uint64, error) %7B%0A%09mib, err := sysctlmib(name, args...)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%0A%09n := uintptr(8)%0A%09buf := make(%5B%5Dbyte, 8)%0A%09if err := sysctl(mib, &buf%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if n != 8 %7B%0A%09%09return 0, EIO%0A%09%7D%0A%09return *(*uint64)(unsafe.Pointer(&buf%5B0%5D)), nil%0A%7D%0A%0Afunc SysctlRaw(name string, args ...int) (%5B%5Dbyte, error) %7B%0A%09mib, err := sysctlmib(name, args...)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Find size.%0A%09n := uintptr(0)%0A%09if err := sysctl(mib, nil, &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n == 0 %7B%0A%09%09return nil, nil%0A%09%7D%0A%0A%09// Read into buffer of that size.%0A%09buf := make(%5B%5Dbyte, n)%0A%09if err := sysctl(mib, &buf%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// The actual call may return less than the original reported required%0A%09// size so ensure we deal with that.%0A%09return buf%5B:n%5D, nil%0A%7D%0A%0A//sys%09utimes(path string, timeval *%5B2%5DTimeval) (err error)%0A%0Afunc Utimes(path string, tv %5B%5DTimeval) error %7B%0A%09if tv == nil %7B%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc UtimesNano(path string, ts %5B%5DTimespec) error %7B%0A%09if ts == nil %7B%0A%09%09err := utimensat(AT_FDCWD, path, nil, 0)%0A%09%09if err != ENOSYS %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09// Darwin setattrlist can set nanosecond timestamps%0A%09err := setattrlistTimes(path, ts, 0)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09err = utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09// Not as efficient as it could be because Timespec and%0A%09// Timeval have different types in the different OSes%0A%09tv := %5B2%5DTimeval%7B%0A%09%09NsecToTimeval(TimespecToNsec(ts%5B0%5D)),%0A%09%09NsecToTimeval(TimespecToNsec(ts%5B1%5D)),%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc UtimesNanoAt(dirfd int, path string, ts %5B%5DTimespec, flags int) error %7B%0A%09if ts == nil %7B%0A%09%09return utimensat(dirfd, path, nil, flags)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09err := setattrlistTimes(path, ts, flags)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09return utimensat(dirfd, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), flags)%0A%7D%0A%0A//sys%09futimes(fd int, timeval *%5B2%5DTimeval) (err error)%0A%0Afunc Futimes(fd int, tv %5B%5DTimeval) error %7B%0A%09if tv == nil %7B%0A%09%09return futimes(fd, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return futimes(fd, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0A//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A%0A//sys   poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A%0A// TODO: wrap%0A//%09Acct(name nil-string) (err error)%0A//%09Gethostuuid(uuid *byte, timeout *Timespec) (err error)%0A//%09Ptrace(req int, pid int, addr uintptr, data int) (ret uintptr, err error)%0A%0Avar mapper = &mmapper%7B%0A%09active: make(map%5B*byte%5D%5B%5Dbyte),%0A%09mmap:   mmap,%0A%09munmap: munmap,%0A%7D%0A%0Afunc Mmap(fd int, offset int64, length int, prot int, flags int) (data %5B%5Dbyte, err error) %7B%0A%09return mapper.Mmap(fd, offset, length, prot, flags)%0A%7D%0A%0Afunc Munmap(b %5B%5Dbyte) (err error) %7B%0A%09return mapper.Munmap(b)%0A%7D%0A%0A//sys%09Madvise(b %5B%5Dbyte, behav int) (err error)%0A//sys%09Mlock(b %5B%5Dbyte) (err error)%0A//sys%09Mlockall(flags int) (err error)%0A//sys%09Mprotect(b %5B%5Dbyte, prot int) (err error)%0A//sys%09Msync(b %5B%5Dbyte, flags int) (err error)%0A//sys%09Munlock(b %5B%5Dbyte) (err error)%0A//sys%09Munlockall() (err error)%0A
- f 1b0ead5123cb79322d537316f1808242d21d38a0bf57e97025a34bcdb663e331 vendor/golang.org/x/sys/unix/syscall_darwin.go
+ f 80f51fbe92fe4d1368dbdb79be20b90edc41346d1b214b52800ef3c44a1376e5 vendor/golang.org/x/sys/unix/syscall_darwin.go
dmppatch 16
@@ -516,29 +516,8 @@
 t (%0A
-%09%22errors%22%0A%09%22syscall%22%0A
 %09%22un
@@ -529,5563 +529,71 @@
 %0A)%0A%0A
-const ImplementsGetwd = true%0A%0Afunc Getwd() (string, error) %7B%0A%09buf := make(%5B%5Dbyte, 2048)%0A%09attrs, err := getAttrList(%22.%22, attrList%7BCommonAttr: attrCmnFullpath%7D, buf, 0)%0A%09if err == nil && len(attrs) == 1 && len(attrs%5B0%5D) %3E= 2 %7B%0A%09%09wd := string(attrs%5B0%5D)%0A%09%09// Sanity check that it's an absolute path and ends%0A%09%09// in a null byte, which we then strip.%0A%09%09if wd%5B0%5D == '/' && wd%5Blen(wd)-1%5D == 0 %7B%0A%09%09%09return wd%5B:len(wd)-1%5D, nil%0A%09%09%7D%0A%09%7D%0A%09// If pkg/os/getwd.go gets ENOTSUP, it will fall back to the%0A%09// slow algorithm.%0A%09return %22%22, ENOTSUP%0A%7D%0A%0A// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0A// Translate %22kern.hostname%22 to %5B%5D_C_int%7B0,1,2,3%7D.%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09const siz = unsafe.Sizeof(mib%5B0%5D)%0A%0A%09// NOTE(rsc): It seems strange to set the buffer to have%0A%09// size CTL_MAXNAME+2 but use only CTL_MAXNAME%0A%09// as the size. I don't know why the +2 is here, but the%0A%09// kernel uses +2 for its own implementation of this function.%0A%09// I am scared that if we don't include the +2 here, the kernel%0A%09// will silently write 2 words farther than we specify%0A%09// and we'll get memory corruption.%0A%09var buf %5BCTL_MAXNAME + 2%5D_C_int%0A%09n := uintptr(CTL_MAXNAME) * siz%0A%0A%09p := (*byte)(unsafe.Pointer(&buf%5B0%5D))%0A%09bytes, err := ByteSliceFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Magic sysctl: %22setting%22 0.3 to a string name%0A%09// lets you read back the array of integers form.%0A%09if err = sysctl(%5B%5D_C_int%7B0, 3%7D, p, &n, &bytes%5B0%5D, uintptr(len(name))); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return buf%5B0 : n/siz%5D, nil%0A%7D%0A%0A//sys   ptrace(request int, pid int, addr uintptr, data uintptr) (err error)%0Afunc PtraceAttach(pid int) (err error) %7B return ptrace(PT_ATTACH, pid, 0, 0) %7D%0Afunc PtraceDetach(pid int) (err error) %7B return ptrace(PT_DETACH, pid, 0, 0) %7D%0A%0Aconst (%0A%09attrBitMapCount = 5%0A%09attrCmnFullpath = 0x08000000%0A)%0A%0Atype attrList struct %7B%0A%09bitmapCount uint16%0A%09_           uint16%0A%09CommonAttr  uint32%0A%09VolAttr     uint32%0A%09DirAttr     uint32%0A%09FileAttr    uint32%0A%09Forkattr    uint32%0A%7D%0A%0Afunc getAttrList(path string, attrList attrList, attrBuf %5B%5Dbyte, options uint) (attrs %5B%5D%5B%5Dbyte, err error) %7B%0A%09if len(attrBuf) %3C 4 %7B%0A%09%09return nil, errors.New(%22attrBuf too small%22)%0A%09%7D%0A%09attrList.bitmapCount = attrBitMapCount%0A%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09_, _, e1 := Syscall6(%0A%09%09SYS_GETATTRLIST,%0A%09%09uintptr(unsafe.Pointer(_p0)),%0A%09%09uintptr(unsafe.Pointer(&attrList)),%0A%09%09uintptr(unsafe.Pointer(&attrBuf%5B0%5D)),%0A%09%09uintptr(len(attrBuf)),%0A%09%09uintptr(options),%0A%09%090,%0A%09)%0A%09if e1 != 0 %7B%0A%09%09return nil, e1%0A%09%7D%0A%09size := *(*uint32)(unsafe.Pointer(&attrBuf%5B0%5D))%0A%0A%09// dat is the section of attrBuf that contains valid data,%0A%09// without the 4 byte length header. All attribute offsets%0A%09// are relative to dat.%0A%09dat := attrBuf%0A%09if int(size) %3C len(attrBuf) %7B%0A%09%09dat = dat%5B:size%5D%0A%09%7D%0A%09dat = dat%5B4:%5D // remove length prefix%0A%0A%09for i := uint32(0); int(i) %3C len(dat); %7B%0A%09%09header := dat%5Bi:%5D%0A%09%09if len(header) %3C 8 %7B%0A%09%09%09return attrs, errors.New(%22truncated attribute header%22)%0A%09%09%7D%0A%09%09datOff := *(*int32)(unsafe.Pointer(&header%5B0%5D))%0A%09%09attrLen := *(*uint32)(unsafe.Pointer(&header%5B4%5D))%0A%09%09if datOff %3C 0 %7C%7C uint32(datOff)+attrLen %3E uint32(len(dat)) %7B%0A%09%09%09return attrs, errors.New(%22truncated results; attrBuf too small%22)%0A%09%09%7D%0A%09%09end := uint32(datOff) + attrLen%0A%09%09attrs = append(attrs, dat%5BdatOff:end%5D)%0A%09%09i = end%0A%09%09if r := i %25 4; r != 0 %7B%0A%09%09%09i += (4 - r)%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0A//sysnb pipe() (r int, w int, err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09p%5B0%5D, p%5B1%5D, err = pipe()%0A%09return%0A%7D%0A%0Afunc Getfsstat(buf %5B%5DStatfs_t, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09var bufsize uintptr%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%09bufsize = unsafe.Sizeof(Statfs_t%7B%7D) * uintptr(len(buf))%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETFSSTAT64, uintptr(_p0), bufsize, uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09_p0, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09var attrList attrList%0A%09attrList.bitmapCount = ATTR_BIT_MAP_COUNT%0A%09attrList.CommonAttr = ATTR_CMN_MODTIME %7C ATTR_CMN_ACCTIME%0A%0A%09// order is mtime, atime: the opposite of Chtimes%0A%09attributes := %5B2%5DTimespec%7Btimes%5B1%5D, times%5B0%5D%7D%0A%09options := 0%0A%09if flags&AT_SYMLINK_NOFOLLOW != 0 %7B%0A%09%09options %7C= FSOPT_NOFOLLOW%0A%09%7D%0A%09_, _, e1 := Syscall6(%0A%09%09SYS_SETATTRLIST,%0A%09%09uintptr(unsafe.Pointer(_p0)),%0A%09%09uintptr(unsafe.Pointer(&attrList)),%0A%09%09uintptr(unsafe.Pointer(&attributes)),%0A%09%09uintptr(unsafe.Sizeof(attributes)),%0A%09%09uintptr(options),%0A%09%090,%0A%09)%0A%09if e1 != 0 %7B%0A%09%09return e1%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) error %7B%0A%09// Darwin doesn't support SYS_UTIMENSAT%0A%09return ENOSYS%0A%7D%0A%0A/*%0A * Wrapped%0A */%0A%0A//sys%09kill(pid int, signum int, posix int) (err error)%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B return kill(pid, int(signum), 1) %7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc IoctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A
+func ioctlSetTermios(fd int, req uint, value *Termios) error %7B%0A
 %09ret
@@ -650,548 +650,8 @@
 %0A%7D%0A%0A
-func IoctlSetTermios(fd int, req uint, value *Termios) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func
@@ -806,9095 +806,4 @@
 r%0A%7D%0A
-%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctl(mib, &uname.Sysname%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctl(mib, &uname.Nodename%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctl(mib, &uname.Release%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctl(mib, &uname.Version%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctl(mib, &uname.Machine%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exchangedata(path1 string, path2 string, options int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Faccessat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sys%09Fstatfs(fd int, stat *Statfs_t) (err error) = SYS_FSTATFS64%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sys%09Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) = SYS_GETDIRENTRIES64%0A//sys%09Getdtablesize() (size int)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09Issetugid() (tainted bool)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkdirat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Renameat(fromfd int, from string, tofd int, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sys%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Setlogin(name string) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sys%09Setprivexec(flag int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error) = SYS_STAT64%0A//sys%09Statfs(path string, stat *Statfs_t) (err error) = SYS_STATFS64%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Symlinkat(oldpath string, newdirfd int, newpath string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Undelete(path string) (err error)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unlinkat(dirfd int, path string, flags int) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys   mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys   munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A%0A/*%0A * Unimplemented%0A */%0A// Profil%0A// Sigaction%0A// Sigprocmask%0A// Getlogin%0A// Sigpending%0A// Sigaltstack%0A// Ioctl%0A// Reboot%0A// Execve%0A// Vfork%0A// Sbrk%0A// Sstk%0A// Ovadvise%0A// Mincore%0A// Setitimer%0A// Swapon%0A// Select%0A// Sigsuspend%0A// Readv%0A// Writev%0A// Nfssvc%0A// Getfh%0A// Quotactl%0A// Mount%0A// Csops%0A// Waitid%0A// Add_profil%0A// Kdebug_trace%0A// Sigreturn%0A// Atsocket%0A// Kqueue_from_portset_np%0A// Kqueue_portset%0A// Getattrlist%0A// Setattrlist%0A// Getdirentriesattr%0A// Searchfs%0A// Delete%0A// Copyfile%0A// Watchevent%0A// Waitevent%0A// Modwatch%0A// Getxattr%0A// Fgetxattr%0A// Setxattr%0A// Fsetxattr%0A// Removexattr%0A// Fremovexattr%0A// Listxattr%0A// Flistxattr%0A// Fsctl%0A// Initgroups%0A// Posix_spawn%0A// Nfsclnt%0A// Fhopen%0A// Minherit%0A// Semsys%0A// Msgsys%0A// Shmsys%0A// Semctl%0A// Semget%0A// Semop%0A// Msgctl%0A// Msgget%0A// Msgsnd%0A// Msgrcv%0A// Shmat%0A// Shmctl%0A// Shmdt%0A// Shmget%0A// Shm_open%0A// Shm_unlink%0A// Sem_open%0A// Sem_close%0A// Sem_unlink%0A// Sem_wait%0A// Sem_trywait%0A// Sem_post%0A// Sem_getvalue%0A// Sem_init%0A// Sem_destroy%0A// Open_extended%0A// Umask_extended%0A// Stat_extended%0A// Lstat_extended%0A// Fstat_extended%0A// Chmod_extended%0A// Fchmod_extended%0A// Access_extended%0A// Settid%0A// Gettid%0A// Setsgroups%0A// Getsgroups%0A// Setwgroups%0A// Getwgroups%0A// Mkfifo_extended%0A// Mkdir_extended%0A// Identitysvc%0A// Shared_region_check_np%0A// Shared_region_map_np%0A// __pthread_mutex_destroy%0A// __pthread_mutex_init%0A// __pthread_mutex_lock%0A// __pthread_mutex_trylock%0A// __pthread_mutex_unlock%0A// __pthread_cond_init%0A// __pthread_cond_destroy%0A// __pthread_cond_broadcast%0A// __pthread_cond_signal%0A// Setsid_with_pid%0A// __pthread_cond_timedwait%0A// Aio_fsync%0A// Aio_return%0A// Aio_suspend%0A// Aio_cancel%0A// Aio_error%0A// Aio_read%0A// Aio_write%0A// Lio_listio%0A// __pthread_cond_wait%0A// Iopolicysys%0A// __pthread_kill%0A// __pthread_sigmask%0A// __sigwait%0A// __disable_threadsignal%0A// __pthread_markcancel%0A// __pthread_canceled%0A// __semwait_signal%0A// Proc_info%0A// sendfile%0A// Stat64_extended%0A// Lstat64_extended%0A// Fstat64_extended%0A// __pthread_chdir%0A// __pthread_fchdir%0A// Audit%0A// Auditon%0A// Getauid%0A// Setauid%0A// Getaudit%0A// Setaudit%0A// Getaudit_addr%0A// Setaudit_addr%0A// Auditctl%0A// Bsdthread_create%0A// Bsdthread_terminate%0A// Stack_snapshot%0A// Bsdthread_register%0A// Workq_open%0A// Workq_ops%0A// __mac_execve%0A// __mac_syscall%0A// __mac_get_file%0A// __mac_set_file%0A// __mac_get_link%0A// __mac_set_link%0A// __mac_get_proc%0A// __mac_set_proc%0A// __mac_get_fd%0A// __mac_set_fd%0A// __mac_get_pid%0A// __mac_get_lcid%0A// __mac_get_lctx%0A// __mac_set_lctx%0A// Setlcid%0A// Read_nocancel%0A// Write_nocancel%0A// Open_nocancel%0A// Close_nocancel%0A// Wait4_nocancel%0A// Recvmsg_nocancel%0A// Sendmsg_nocancel%0A// Recvfrom_nocancel%0A// Accept_nocancel%0A// Fcntl_nocancel%0A// Select_nocancel%0A// Fsync_nocancel%0A// Connect_nocancel%0A// Sigsuspend_nocancel%0A// Readv_nocancel%0A// Writev_nocancel%0A// Sendto_nocancel%0A// Pread_nocancel%0A// Pwrite_nocancel%0A// Waitid_nocancel%0A// Poll_nocancel%0A// Msgsnd_nocancel%0A// Msgrcv_nocancel%0A// Sem_wait_nocancel%0A// Aio_suspend_nocancel%0A// __sigwait_nocancel%0A// __semwait_signal_nocancel%0A// __mac_mount%0A// __mac_get_mount%0A// __mac_getfsstat%0A
- f 395021048a759f7303d722dba61a5e015308b990c0c3d2d0ae15c5081fbc193c vendor/golang.org/x/sys/unix/syscall_darwin_386.go
+ f f8e68826c636141b2520bd1ef89b4e029994751f9e4a981ccd89f4feff99192a vendor/golang.org/x/sys/unix/syscall_darwin_386.go
dmppatch 3
@@ -192,1539 +192,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09gettimeofday(tp *Timeval) (sec int32, usec int32, err error)%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09// The tv passed to gettimeofday must be non-nil%0A%09// but is otherwise unused. The answers come back%0A%09// in the two registers.%0A%09sec, usec, err := gettimeofday(tv)%0A%09tv.Sec = int32(sec)%0A%09tv.Usec = int32(usec)%0A%09return err%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var length = uint64(count)%0A%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(*offset%3E%3E32), uintptr(unsafe.Pointer(&length)), 0, 0, 0, 0)%0A%0A%09written = int(length)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0A// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions%0A// of darwin/386 the syscall is called sysctl instead of __sysctl.%0Aconst SYS___SYSCTL = SYS_SYSCTL%0A
- f 1ffa9e27faa404a7506ea1358ae69333c001323c582f2afe6e18e5582ade0a60 vendor/golang.org/x/sys/unix/syscall_darwin_amd64.go
+ f b423cadba8f15723f8eefae05d919fddbf91bb34c2ef88c7e257292c3e8bf83c vendor/golang.org/x/sys/unix/syscall_darwin_amd64.go
dmppatch 3
@@ -194,1478 +194,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09gettimeofday(tp *Timeval) (sec int64, usec int32, err error)%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09// The tv passed to gettimeofday must be non-nil%0A%09// but is otherwise unused. The answers come back%0A%09// in the two registers.%0A%09sec, usec, err := gettimeofday(tv)%0A%09tv.Sec = sec%0A%09tv.Usec = usec%0A%09return err%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var length = uint64(count)%0A%0A%09_, _, e1 := Syscall6(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(unsafe.Pointer(&length)), 0, 0)%0A%0A%09written = int(length)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0A// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions%0A// of darwin/amd64 the syscall is called sysctl instead of __sysctl.%0Aconst SYS___SYSCTL = SYS_SYSCTL%0A
- f e3007635e9c073e8d69e47879f9daeec216836fe9eae382038b726b6aa9ed243 vendor/golang.org/x/sys/unix/syscall_darwin_arm.go
+ f 4a21088d9836ce36d1b091d5a51d2c2d91302b0f270a8d923b857cb95f12730a vendor/golang.org/x/sys/unix/syscall_darwin_arm.go
dmppatch 3
@@ -170,1546 +170,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09gettimeofday(tp *Timeval) (sec int32, usec int32, err error)%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09// The tv passed to gettimeofday must be non-nil%0A%09// but is otherwise unused. The answers come back%0A%09// in the two registers.%0A%09sec, usec, err := gettimeofday(tv)%0A%09tv.Sec = int32(sec)%0A%09tv.Usec = int32(usec)%0A%09return err%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var length = uint64(count)%0A%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(*offset%3E%3E32), uintptr(unsafe.Pointer(&length)), 0, 0, 0, 0)%0A%0A%09written = int(length)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno) // sic%0A%0A// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions%0A// of darwin/arm the syscall is called sysctl instead of __sysctl.%0Aconst SYS___SYSCTL = SYS_SYSCTL%0A
- f 3ff0176780fe143c878e633f13d9b464d764f860f19d77d719b45777deaafa51 vendor/golang.org/x/sys/unix/syscall_darwin_arm64.go
+ f b4247f13543c30b1db978356df9b335110b2e034793850b1aea1d9b6c8792e60 vendor/golang.org/x/sys/unix/syscall_darwin_arm64.go
dmppatch 3
@@ -194,1485 +194,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09gettimeofday(tp *Timeval) (sec int64, usec int32, err error)%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09// The tv passed to gettimeofday must be non-nil%0A%09// but is otherwise unused. The answers come back%0A%09// in the two registers.%0A%09sec, usec, err := gettimeofday(tv)%0A%09tv.Sec = sec%0A%09tv.Usec = usec%0A%09return err%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var length = uint64(count)%0A%0A%09_, _, e1 := Syscall6(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(unsafe.Pointer(&length)), 0, 0)%0A%0A%09written = int(length)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno) // sic%0A%0A// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions%0A// of darwin/arm64 the syscall is called sysctl instead of __sysctl.%0Aconst SYS___SYSCTL = SYS_SYSCTL%0A
- f 1020b175a10885ed35f908dece24ab2087a80f6d52a982e6cbba5044528fa701 vendor/golang.org/x/sys/unix/syscall_dragonfly.go
+ f 194707e3dc851b21f0b2715aa66a53857a38ce2e67070a53a7f24f845ee3486b vendor/golang.org/x/sys/unix/syscall_dragonfly.go
dmppatch 12
@@ -526,3454 +526,71 @@
 e%22%0A%0A
-// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%09Rcf    uint16%0A%09Route  %5B16%5Duint16%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0A// Translate %22kern.hostname%22 to %5B%5D_C_int%7B0,1,2,3%7D.%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09const siz = unsafe.Sizeof(mib%5B0%5D)%0A%0A%09// NOTE(rsc): It seems strange to set the buffer to have%0A%09// size CTL_MAXNAME+2 but use only CTL_MAXNAME%0A%09// as the size. I don't know why the +2 is here, but the%0A%09// kernel uses +2 for its own implementation of this function.%0A%09// I am scared that if we don't include the +2 here, the kernel%0A%09// will silently write 2 words farther than we specify%0A%09// and we'll get memory corruption.%0A%09var buf %5BCTL_MAXNAME + 2%5D_C_int%0A%09n := uintptr(CTL_MAXNAME) * siz%0A%0A%09p := (*byte)(unsafe.Pointer(&buf%5B0%5D))%0A%09bytes, err := ByteSliceFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Magic sysctl: %22setting%22 0.3 to a string name%0A%09// lets you read back the array of integers form.%0A%09if err = sysctl(%5B%5D_C_int%7B0, 3%7D, p, &n, &bytes%5B0%5D, uintptr(len(name))); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return buf%5B0 : n/siz%5D, nil%0A%7D%0A%0A//sysnb pipe() (r int, w int, err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09p%5B0%5D, p%5B1%5D, err = pipe()%0A%09return%0A%7D%0A%0A//sys%09extpread(fd int, p %5B%5Dbyte, flags int, offset int64) (n int, err error)%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09return extpread(fd, p, 0, offset)%0A%7D%0A%0A//sys%09extpwrite(fd int, p %5B%5Dbyte, flags int, offset int64) (n int, err error)%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09return extpwrite(fd, p, 0, offset)%0A%7D%0A%0Afunc Accept4(fd, flags int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept4(fd, &rsa, &len, flags)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09if len %3E SizeofSockaddrAny %7B%0A%09%09panic(%22RawSockaddrAny too small%22)%0A%09%7D%0A%09sa, err = anyToSockaddr(&rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error) = SYS___GETCWD%0A%0Afunc Getwd() (string, error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09_, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0Afunc Getfsstat(buf %5B%5DStatfs_t, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09var bufsize uintptr%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%09bufsize = unsafe.Sizeof(Statfs_t%7B%7D) * uintptr(len(buf))%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(_p0), bufsize, uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09// used on Darwin for UtimesNano%0A%09return ENOSYS%0A%7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc IoctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0Afunc IoctlSetTermios(fd int, req uint, value *Termios) error %7B%0A
+func ioctlSetTermios(fd int, req uint, value *Termios) error %7B%0A
 %09ret
@@ -647,427 +647,8 @@
 %0A%7D%0A%0A
-// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func
@@ -803,9053 +803,4 @@
 r%0A%7D%0A
-%0Afunc sysctlUname(mib %5B%5D_C_int, old *byte, oldlen *uintptr) error %7B%0A%09err := sysctl(mib, old, oldlen, nil, 0)%0A%09if err != nil %7B%0A%09%09// Utsname members on Dragonfly are only 32 bytes and%0A%09%09// the syscall returns ENOMEM in case the actual value%0A%09%09// is longer.%0A%09%09if err == ENOMEM %7B%0A%09%09%09err = nil%0A%09%09%7D%0A%09%7D%0A%09return err%0A%7D%0A%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctlUname(mib, &uname.Sysname%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09uname.Sysname%5Bunsafe.Sizeof(uname.Sysname)-1%5D = 0%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctlUname(mib, &uname.Nodename%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09uname.Nodename%5Bunsafe.Sizeof(uname.Nodename)-1%5D = 0%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctlUname(mib, &uname.Release%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09uname.Release%5Bunsafe.Sizeof(uname.Release)-1%5D = 0%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctlUname(mib, &uname.Version%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctlUname(mib, &uname.Machine%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09uname.Machine%5Bunsafe.Sizeof(uname.Machine)-1%5D = 0%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatfs(fd int, stat *Statfs_t) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sys%09Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error)%0A//sys%09Getdtablesize() (size int)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Issetugid() (tainted bool)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Setlogin(name string) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, stat *Statfs_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Undelete(path string) (err error)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys   mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys   munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A//sys%09accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error)%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0A/*%0A * Unimplemented%0A * TODO(jsing): Update this list for DragonFly.%0A */%0A// Profil%0A// Sigaction%0A// Sigprocmask%0A// Getlogin%0A// Sigpending%0A// Sigaltstack%0A// Reboot%0A// Execve%0A// Vfork%0A// Sbrk%0A// Sstk%0A// Ovadvise%0A// Mincore%0A// Setitimer%0A// Swapon%0A// Select%0A// Sigsuspend%0A// Readv%0A// Writev%0A// Nfssvc%0A// Getfh%0A// Quotactl%0A// Mount%0A// Csops%0A// Waitid%0A// Add_profil%0A// Kdebug_trace%0A// Sigreturn%0A// Atsocket%0A// Kqueue_from_portset_np%0A// Kqueue_portset%0A// Getattrlist%0A// Setattrlist%0A// Getdirentriesattr%0A// Searchfs%0A// Delete%0A// Copyfile%0A// Watchevent%0A// Waitevent%0A// Modwatch%0A// Getxattr%0A// Fgetxattr%0A// Setxattr%0A// Fsetxattr%0A// Removexattr%0A// Fremovexattr%0A// Listxattr%0A// Flistxattr%0A// Fsctl%0A// Initgroups%0A// Posix_spawn%0A// Nfsclnt%0A// Fhopen%0A// Minherit%0A// Semsys%0A// Msgsys%0A// Shmsys%0A// Semctl%0A// Semget%0A// Semop%0A// Msgctl%0A// Msgget%0A// Msgsnd%0A// Msgrcv%0A// Shmat%0A// Shmctl%0A// Shmdt%0A// Shmget%0A// Shm_open%0A// Shm_unlink%0A// Sem_open%0A// Sem_close%0A// Sem_unlink%0A// Sem_wait%0A// Sem_trywait%0A// Sem_post%0A// Sem_getvalue%0A// Sem_init%0A// Sem_destroy%0A// Open_extended%0A// Umask_extended%0A// Stat_extended%0A// Lstat_extended%0A// Fstat_extended%0A// Chmod_extended%0A// Fchmod_extended%0A// Access_extended%0A// Settid%0A// Gettid%0A// Setsgroups%0A// Getsgroups%0A// Setwgroups%0A// Getwgroups%0A// Mkfifo_extended%0A// Mkdir_extended%0A// Identitysvc%0A// Shared_region_check_np%0A// Shared_region_map_np%0A// __pthread_mutex_destroy%0A// __pthread_mutex_init%0A// __pthread_mutex_lock%0A// __pthread_mutex_trylock%0A// __pthread_mutex_unlock%0A// __pthread_cond_init%0A// __pthread_cond_destroy%0A// __pthread_cond_broadcast%0A// __pthread_cond_signal%0A// Setsid_with_pid%0A// __pthread_cond_timedwait%0A// Aio_fsync%0A// Aio_return%0A// Aio_suspend%0A// Aio_cancel%0A// Aio_error%0A// Aio_read%0A// Aio_write%0A// Lio_listio%0A// __pthread_cond_wait%0A// Iopolicysys%0A// __pthread_kill%0A// __pthread_sigmask%0A// __sigwait%0A// __disable_threadsignal%0A// __pthread_markcancel%0A// __pthread_canceled%0A// __semwait_signal%0A// Proc_info%0A// Stat64_extended%0A// Lstat64_extended%0A// Fstat64_extended%0A// __pthread_chdir%0A// __pthread_fchdir%0A// Audit%0A// Auditon%0A// Getauid%0A// Setauid%0A// Getaudit%0A// Setaudit%0A// Getaudit_addr%0A// Setaudit_addr%0A// Auditctl%0A// Bsdthread_create%0A// Bsdthread_terminate%0A// Stack_snapshot%0A// Bsdthread_register%0A// Workq_open%0A// Workq_ops%0A// __mac_execve%0A// __mac_syscall%0A// __mac_get_file%0A// __mac_set_file%0A// __mac_get_link%0A// __mac_set_link%0A// __mac_get_proc%0A// __mac_set_proc%0A// __mac_get_fd%0A// __mac_set_fd%0A// __mac_get_pid%0A// __mac_get_lcid%0A// __mac_get_lctx%0A// __mac_set_lctx%0A// Setlcid%0A// Read_nocancel%0A// Write_nocancel%0A// Open_nocancel%0A// Close_nocancel%0A// Wait4_nocancel%0A// Recvmsg_nocancel%0A// Sendmsg_nocancel%0A// Recvfrom_nocancel%0A// Accept_nocancel%0A// Fcntl_nocancel%0A// Select_nocancel%0A// Fsync_nocancel%0A// Connect_nocancel%0A// Sigsuspend_nocancel%0A// Readv_nocancel%0A// Writev_nocancel%0A// Sendto_nocancel%0A// Pread_nocancel%0A// Pwrite_nocancel%0A// Waitid_nocancel%0A// Msgsnd_nocancel%0A// Msgrcv_nocancel%0A// Sem_wait_nocancel%0A// Aio_suspend_nocancel%0A// __sigwait_nocancel%0A// __semwait_signal_nocancel%0A// __mac_mount%0A// __mac_get_mount%0A// __mac_getfsstat%0A
- f f9bf6375f05a9c574048563c659cb0a8de466efc794a51ead3033b0f60344c2d vendor/golang.org/x/sys/unix/syscall_dragonfly_amd64.go
+ f 4525ee4331f0819d238b182fcfc69a8790596c65d01862c77d5210620cca9e48 vendor/golang.org/x/sys/unix/syscall_dragonfly_amd64.go
dmppatch 3
@@ -197,996 +197,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var writtenOut uint64 = 0%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(count), 0, uintptr(unsafe.Pointer(&writtenOut)), 0, 0, 0)%0A%0A%09written = int(writtenOut)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f cc64aa42c21c13e91253b49e2d58f90b13ab780345c76513a7f636e0195ef6c1 vendor/golang.org/x/sys/unix/syscall_freebsd.go
+ f 582d72a1c3a7b7d88ca3ab1a53dc6303572d102074191cb6867029addb2c624a vendor/golang.org/x/sys/unix/syscall_freebsd.go
dmppatch 16
@@ -517,19 +517,8 @@
 t (%0A
-%09%22strings%22%0A
 %09%22un
@@ -530,8020 +530,71 @@
 %0A)%0A%0A
-// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B46%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0A// Translate %22kern.hostname%22 to %5B%5D_C_int%7B0,1,2,3%7D.%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09const siz = unsafe.Sizeof(mib%5B0%5D)%0A%0A%09// NOTE(rsc): It seems strange to set the buffer to have%0A%09// size CTL_MAXNAME+2 but use only CTL_MAXNAME%0A%09// as the size. I don't know why the +2 is here, but the%0A%09// kernel uses +2 for its own implementation of this function.%0A%09// I am scared that if we don't include the +2 here, the kernel%0A%09// will silently write 2 words farther than we specify%0A%09// and we'll get memory corruption.%0A%09var buf %5BCTL_MAXNAME + 2%5D_C_int%0A%09n := uintptr(CTL_MAXNAME) * siz%0A%0A%09p := (*byte)(unsafe.Pointer(&buf%5B0%5D))%0A%09bytes, err := ByteSliceFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Magic sysctl: %22setting%22 0.3 to a string name%0A%09// lets you read back the array of integers form.%0A%09if err = sysctl(%5B%5D_C_int%7B0, 3%7D, p, &n, &bytes%5B0%5D, uintptr(len(name))); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return buf%5B0 : n/siz%5D, nil%0A%7D%0A%0A//sysnb pipe() (r int, w int, err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09p%5B0%5D, p%5B1%5D, err = pipe()%0A%09return%0A%7D%0A%0Afunc GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error) %7B%0A%09var value IPMreqn%0A%09vallen := _Socklen(SizeofIPMreqn)%0A%09errno := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, errno%0A%7D%0A%0Afunc SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(mreq), unsafe.Sizeof(*mreq))%0A%7D%0A%0Afunc Accept4(fd, flags int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept4(fd, &rsa, &len, flags)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09if len %3E SizeofSockaddrAny %7B%0A%09%09panic(%22RawSockaddrAny too small%22)%0A%09%7D%0A%09sa, err = anyToSockaddr(&rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error) = SYS___GETCWD%0A%0Afunc Getwd() (string, error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09_, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0Afunc Getfsstat(buf %5B%5DStatfs_t, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09var bufsize uintptr%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%09bufsize = unsafe.Sizeof(Statfs_t%7B%7D) * uintptr(len(buf))%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(_p0), bufsize, uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09// used on Darwin for UtimesNano%0A%09return ENOSYS%0A%7D%0A%0A// Derive extattr namespace and attribute name%0A%0Afunc xattrnamespace(fullattr string) (ns int, attr string, err error) %7B%0A%09s := strings.IndexByte(fullattr, '.')%0A%09if s == -1 %7B%0A%09%09return -1, %22%22, ENOATTR%0A%09%7D%0A%0A%09namespace := fullattr%5B0:s%5D%0A%09attr = fullattr%5Bs+1:%5D%0A%0A%09switch namespace %7B%0A%09case %22user%22:%0A%09%09return EXTATTR_NAMESPACE_USER, attr, nil%0A%09case %22system%22:%0A%09%09return EXTATTR_NAMESPACE_SYSTEM, attr, nil%0A%09default:%0A%09%09return -1, %22%22, ENOATTR%0A%09%7D%0A%7D%0A%0Afunc initxattrdest(dest %5B%5Dbyte, idx int) (d unsafe.Pointer) %7B%0A%09if len(dest) %3E idx %7B%0A%09%09return unsafe.Pointer(&dest%5Bidx%5D)%0A%09%7D else %7B%0A%09%09return unsafe.Pointer(_zero)%0A%09%7D%0A%7D%0A%0A// FreeBSD implements its own syscalls to handle extended attributes%0A%0Afunc Getxattr(file string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsize := len(dest)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%0A%09return ExtattrGetFile(file, nsid, a, uintptr(d), destsize)%0A%7D%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsize := len(dest)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%0A%09return ExtattrGetFd(fd, nsid, a, uintptr(d), destsize)%0A%7D%0A%0Afunc Lgetxattr(link string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsize := len(dest)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%0A%09return ExtattrGetLink(link, nsid, a, uintptr(d), destsize)%0A%7D%0A%0A// flags are unused on FreeBSD%0A%0Afunc Fsetxattr(fd int, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09d := unsafe.Pointer(&data%5B0%5D)%0A%09datasiz := len(data)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09_, err = ExtattrSetFd(fd, nsid, a, uintptr(d), datasiz)%0A%09return%0A%7D%0A%0Afunc Setxattr(file string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09d := unsafe.Pointer(&data%5B0%5D)%0A%09datasiz := len(data)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09_, err = ExtattrSetFile(file, nsid, a, uintptr(d), datasiz)%0A%09return%0A%7D%0A%0Afunc Lsetxattr(link string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09d := unsafe.Pointer(&data%5B0%5D)%0A%09datasiz := len(data)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09_, err = ExtattrSetLink(link, nsid, a, uintptr(d), datasiz)%0A%09return%0A%7D%0A%0Afunc Removexattr(file string, attr string) (err error) %7B%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09err = ExtattrDeleteFile(file, nsid, a)%0A%09return%0A%7D%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09err = ExtattrDeleteFd(fd, nsid, a)%0A%09return%0A%7D%0A%0Afunc Lremovexattr(link string, attr string) (err error) %7B%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09err = ExtattrDeleteLink(link, nsid, a)%0A%09return%0A%7D%0A%0Afunc Listxattr(file string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsiz := len(dest)%0A%0A%09// FreeBSD won't allow you to list xattrs from multiple namespaces%0A%09s := 0%0A%09for _, nsid := range %5B...%5Dint%7BEXTATTR_NAMESPACE_USER, EXTATTR_NAMESPACE_SYSTEM%7D %7B%0A%09%09stmp, e := ExtattrListFile(file, nsid, uintptr(d), destsiz)%0A%0A%09%09/* Errors accessing system attrs are ignored so that%0A%09%09 * we can implement the Linux-like behavior of omitting errors that%0A%09%09 * we don't have read permissions on%0A%09%09 *%0A%09%09 * Linux will still error if we ask for user attributes on a file that%0A%09%09 * we don't have read permissions on, so don't ignore those errors%0A%09%09 */%0A%09%09if e != nil && e == EPERM && nsid != EXTATTR_NAMESPACE_USER %7B%0A%09%09%09continue%0A%09%09%7D else if e != nil %7B%0A%09%09%09return s, e%0A%09%09%7D%0A%0A%09%09s += stmp%0A%09%09destsiz -= s%0A%09%09if destsiz %3C 0 %7B%0A%09%09%09destsiz = 0%0A%09%09%7D%0A%09%09d = initxattrdest(dest, s)%0A%09%7D%0A%0A%09return s, nil%0A%7D%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsiz := len(dest)%0A%0A%09s := 0%0A%09for _, nsid := range %5B...%5Dint%7BEXTATTR_NAMESPACE_USER, EXTATTR_NAMESPACE_SYSTEM%7D %7B%0A%09%09stmp, e := ExtattrListFd(fd, nsid, uintptr(d), destsiz)%0A%09%09if e != nil && e == EPERM && nsid != EXTATTR_NAMESPACE_USER %7B%0A%09%09%09continue%0A%09%09%7D else if e != nil %7B%0A%09%09%09return s, e%0A%09%09%7D%0A%0A%09%09s += stmp%0A%09%09destsiz -= s%0A%09%09if destsiz %3C 0 %7B%0A%09%09%09destsiz = 0%0A%09%09%7D%0A%09%09d = initxattrdest(dest, s)%0A%09%7D%0A%0A%09return s, nil%0A%7D%0A%0Afunc Llistxattr(link string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsiz := len(dest)%0A%0A%09s := 0%0A%09for _, nsid := range %5B...%5Dint%7BEXTATTR_NAMESPACE_USER, EXTATTR_NAMESPACE_SYSTEM%7D %7B%0A%09%09stmp, e := ExtattrListLink(link, nsid, uintptr(d), destsiz)%0A%09%09if e != nil && e == EPERM && nsid != EXTATTR_NAMESPACE_USER %7B%0A%09%09%09continue%0A%09%09%7D else if e != nil %7B%0A%09%09%09return s, e%0A%09%09%7D%0A%0A%09%09s += stmp%0A%09%09destsiz -= s%0A%09%09if destsiz %3C 0 %7B%0A%09%09%09destsiz = 0%0A%09%09%7D%0A%09%09d = initxattrdest(dest, s)%0A%09%7D%0A%0A%09return s, nil%0A%7D%0A%0A//sys   ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc IoctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A
+func ioctlSetTermios(fd int, req uint, value *Termios) error %7B%0A
 %09ret
@@ -651,548 +651,8 @@
 %0A%7D%0A%0A
-func IoctlSetTermios(fd int, req uint, value *Termios) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func
@@ -807,10887 +807,4 @@
 r%0A%7D%0A
-%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctl(mib, &uname.Sysname%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctl(mib, &uname.Nodename%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctl(mib, &uname.Release%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctl(mib, &uname.Version%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctl(mib, &uname.Machine%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09CapEnter() (err error)%0A//sys%09capRightsGet(version int, fd int, rightsp *CapRights) (err error) = SYS___CAP_RIGHTS_GET%0A//sys%09capRightsLimit(fd int, rightsp *CapRights) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exit(code int)%0A//sys%09ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error)%0A//sys%09ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error)%0A//sys%09ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error)%0A//sys%09ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_POSIX_FADVISE%0A//sys%09Faccessat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatfs(fd int, stat *Statfs_t) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sys%09Getdents(fd int, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error)%0A//sys%09Getdtablesize() (size int)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Issetugid() (tainted bool)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkdirat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Openat(fdat int, path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Renameat(fromfd int, from string, tofd int, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Setlogin(name string) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, stat *Statfs_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Symlinkat(oldpath string, newdirfd int, newpath string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Undelete(path string) (err error)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unlinkat(dirfd int, path string, flags int) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys   mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys   munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A//sys%09accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error)%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0A/*%0A * Unimplemented%0A */%0A// Profil%0A// Sigaction%0A// Sigprocmask%0A// Getlogin%0A// Sigpending%0A// Sigaltstack%0A// Ioctl%0A// Reboot%0A// Execve%0A// Vfork%0A// Sbrk%0A// Sstk%0A// Ovadvise%0A// Mincore%0A// Setitimer%0A// Swapon%0A// Select%0A// Sigsuspend%0A// Readv%0A// Writev%0A// Nfssvc%0A// Getfh%0A// Quotactl%0A// Mount%0A// Csops%0A// Waitid%0A// Add_profil%0A// Kdebug_trace%0A// Sigreturn%0A// Atsocket%0A// Kqueue_from_portset_np%0A// Kqueue_portset%0A// Getattrlist%0A// Setattrlist%0A// Getdirentriesattr%0A// Searchfs%0A// Delete%0A// Copyfile%0A// Watchevent%0A// Waitevent%0A// Modwatch%0A// Getxattr%0A// Fgetxattr%0A// Setxattr%0A// Fsetxattr%0A// Removexattr%0A// Fremovexattr%0A// Listxattr%0A// Flistxattr%0A// Fsctl%0A// Initgroups%0A// Posix_spawn%0A// Nfsclnt%0A// Fhopen%0A// Minherit%0A// Semsys%0A// Msgsys%0A// Shmsys%0A// Semctl%0A// Semget%0A// Semop%0A// Msgctl%0A// Msgget%0A// Msgsnd%0A// Msgrcv%0A// Shmat%0A// Shmctl%0A// Shmdt%0A// Shmget%0A// Shm_open%0A// Shm_unlink%0A// Sem_open%0A// Sem_close%0A// Sem_unlink%0A// Sem_wait%0A// Sem_trywait%0A// Sem_post%0A// Sem_getvalue%0A// Sem_init%0A// Sem_destroy%0A// Open_extended%0A// Umask_extended%0A// Stat_extended%0A// Lstat_extended%0A// Fstat_extended%0A// Chmod_extended%0A// Fchmod_extended%0A// Access_extended%0A// Settid%0A// Gettid%0A// Setsgroups%0A// Getsgroups%0A// Setwgroups%0A// Getwgroups%0A// Mkfifo_extended%0A// Mkdir_extended%0A// Identitysvc%0A// Shared_region_check_np%0A// Shared_region_map_np%0A// __pthread_mutex_destroy%0A// __pthread_mutex_init%0A// __pthread_mutex_lock%0A// __pthread_mutex_trylock%0A// __pthread_mutex_unlock%0A// __pthread_cond_init%0A// __pthread_cond_destroy%0A// __pthread_cond_broadcast%0A// __pthread_cond_signal%0A// Setsid_with_pid%0A// __pthread_cond_timedwait%0A// Aio_fsync%0A// Aio_return%0A// Aio_suspend%0A// Aio_cancel%0A// Aio_error%0A// Aio_read%0A// Aio_write%0A// Lio_listio%0A// __pthread_cond_wait%0A// Iopolicysys%0A// __pthread_kill%0A// __pthread_sigmask%0A// __sigwait%0A// __disable_threadsignal%0A// __pthread_markcancel%0A// __pthread_canceled%0A// __semwait_signal%0A// Proc_info%0A// Stat64_extended%0A// Lstat64_extended%0A// Fstat64_extended%0A// __pthread_chdir%0A// __pthread_fchdir%0A// Audit%0A// Auditon%0A// Getauid%0A// Setauid%0A// Getaudit%0A// Setaudit%0A// Getaudit_addr%0A// Setaudit_addr%0A// Auditctl%0A// Bsdthread_create%0A// Bsdthread_terminate%0A// Stack_snapshot%0A// Bsdthread_register%0A// Workq_open%0A// Workq_ops%0A// __mac_execve%0A// __mac_syscall%0A// __mac_get_file%0A// __mac_set_file%0A// __mac_get_link%0A// __mac_set_link%0A// __mac_get_proc%0A// __mac_set_proc%0A// __mac_get_fd%0A// __mac_set_fd%0A// __mac_get_pid%0A// __mac_get_lcid%0A// __mac_get_lctx%0A// __mac_set_lctx%0A// Setlcid%0A// Read_nocancel%0A// Write_nocancel%0A// Open_nocancel%0A// Close_nocancel%0A// Wait4_nocancel%0A// Recvmsg_nocancel%0A// Sendmsg_nocancel%0A// Recvfrom_nocancel%0A// Accept_nocancel%0A// Fcntl_nocancel%0A// Select_nocancel%0A// Fsync_nocancel%0A// Connect_nocancel%0A// Sigsuspend_nocancel%0A// Readv_nocancel%0A// Writev_nocancel%0A// Sendto_nocancel%0A// Pread_nocancel%0A// Pwrite_nocancel%0A// Waitid_nocancel%0A// Poll_nocancel%0A// Msgsnd_nocancel%0A// Msgrcv_nocancel%0A// Sem_wait_nocancel%0A// Aio_suspend_nocancel%0A// __sigwait_nocancel%0A// __semwait_signal_nocancel%0A// __mac_mount%0A// __mac_get_mount%0A// __mac_getfsstat%0A
- f c8b06c4db0d2073dd8a464624a99252506cd9c4fedf4ea0567d2c1309c3bc23d vendor/golang.org/x/sys/unix/syscall_freebsd_386.go
+ f d18f59e7c62c1b738cf10a92ccdaf3b667843eee41e173d4bc5ae644adf34602 vendor/golang.org/x/sys/unix/syscall_freebsd_386.go
dmppatch 3
@@ -193,1045 +193,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var writtenOut uint64 = 0%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr((*offset)%3E%3E32), uintptr(count), 0, uintptr(unsafe.Pointer(&writtenOut)), 0, 0)%0A%0A%09written = int(writtenOut)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f 042258a5988192f1af6e708c7ee3d253164093760bda50e033eb9b8d48e113cb vendor/golang.org/x/sys/unix/syscall_freebsd_amd64.go
+ f b17c6a9fc27f71b5f68c3f385789786fc0c1091e13d5f32120b30995e13ea1db vendor/golang.org/x/sys/unix/syscall_freebsd_amd64.go
dmppatch 3
@@ -195,996 +195,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var writtenOut uint64 = 0%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(count), 0, uintptr(unsafe.Pointer(&writtenOut)), 0, 0, 0)%0A%0A%09written = int(writtenOut)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f 9be12b4c28b4451faa8be73f2a1ffa10dd7d6d4bf5d5ed9f6a47c448deaf63f6 vendor/golang.org/x/sys/unix/syscall_freebsd_arm.go
+ f b9fd66cbbd7262d7b9fa8b5a2ea7d40de429baf5c5bc67c5dbac03e57604becd vendor/golang.org/x/sys/unix/syscall_freebsd_arm.go
dmppatch 3
@@ -193,1031 +193,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var writtenOut uint64 = 0%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr((*offset)%3E%3E32), uintptr(count), 0, uintptr(unsafe.Pointer(&writtenOut)), 0, 0)%0A%0A%09written = int(writtenOut)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f 3463694563b46130a1afc641e9a4c3cd0473f7293d576a5377abf689d07e73c7 vendor/golang.org/x/sys/unix/syscall_linux.go
+ f 647bf4107088cf00e1b63d64841d472467bf517b57001bd2a90a81cf6f4e8509 vendor/golang.org/x/sys/unix/syscall_linux.go
dmppatch 16
@@ -454,19 +454,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -467,1401 +467,71 @@
 %0A)%0A%0A
-/*%0A * Wrapped%0A */%0A%0Afunc Access(path string, mode uint32) (err error) %7B%0A%09return Faccessat(AT_FDCWD, path, mode, 0)%0A%7D%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09return Fchmodat(AT_FDCWD, path, mode, 0)%0A%7D%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09return Fchownat(AT_FDCWD, path, uid, gid, 0)%0A%7D%0A%0Afunc Creat(path string, mode uint32) (fd int, err error) %7B%0A%09return Open(path, O_CREAT%7CO_WRONLY%7CO_TRUNC, mode)%0A%7D%0A%0A//sys%09fchmodat(dirfd int, path string, mode uint32) (err error)%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09// Linux fchmodat doesn't support the flags parameter. Mimick glibc's behavior%0A%09// and check the flags. Otherwise the mode would be applied to the symlink%0A%09// destination which is not what the user expects.%0A%09if flags&%5EAT_SYMLINK_NOFOLLOW != 0 %7B%0A%09%09return EINVAL%0A%09%7D else if flags&AT_SYMLINK_NOFOLLOW != 0 %7B%0A%09%09return EOPNOTSUPP%0A%09%7D%0A%09return fchmodat(dirfd, path, mode)%0A%7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc IoctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A
+func ioctlSetTermios(fd int, req uint, value *Termios) error %7B%0A
 %09ret
@@ -588,548 +588,8 @@
 %0A%7D%0A%0A
-func IoctlSetTermios(fd int, req uint, value *Termios) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func
@@ -744,39934 +744,4 @@
 r%0A%7D%0A
-%0A//sys%09Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error)%0A%0Afunc Link(oldpath string, newpath string) (err error) %7B%0A%09return Linkat(AT_FDCWD, oldpath, AT_FDCWD, newpath, 0)%0A%7D%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09return Mkdirat(AT_FDCWD, path, mode)%0A%7D%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09return Mknodat(AT_FDCWD, path, mode, dev)%0A%7D%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09return openat(AT_FDCWD, path, mode%7CO_LARGEFILE, perm)%0A%7D%0A%0A//sys%09openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)%0A%0Afunc Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09return openat(dirfd, path, flags%7CO_LARGEFILE, mode)%0A%7D%0A%0A//sys%09ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error)%0A%0Afunc Ppoll(fds %5B%5DPollFd, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return ppoll(nil, 0, timeout, sigmask)%0A%09%7D%0A%09return ppoll(&fds%5B0%5D, len(fds), timeout, sigmask)%0A%7D%0A%0A//sys%09Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error)%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09return Readlinkat(AT_FDCWD, path, buf)%0A%7D%0A%0Afunc Rename(oldpath string, newpath string) (err error) %7B%0A%09return Renameat(AT_FDCWD, oldpath, AT_FDCWD, newpath)%0A%7D%0A%0Afunc Rmdir(path string) error %7B%0A%09return Unlinkat(AT_FDCWD, path, AT_REMOVEDIR)%0A%7D%0A%0A//sys%09Symlinkat(oldpath string, newdirfd int, newpath string) (err error)%0A%0Afunc Symlink(oldpath string, newpath string) (err error) %7B%0A%09return Symlinkat(oldpath, AT_FDCWD, newpath)%0A%7D%0A%0Afunc Unlink(path string) error %7B%0A%09return Unlinkat(AT_FDCWD, path, 0)%0A%7D%0A%0A//sys%09Unlinkat(dirfd int, path string, flags int) (err error)%0A%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0Afunc Utimes(path string, tv %5B%5DTimeval) error %7B%0A%09if tv == nil %7B%0A%09%09err := utimensat(AT_FDCWD, path, nil, 0)%0A%09%09if err != ENOSYS %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var ts %5B2%5DTimespec%0A%09ts%5B0%5D = NsecToTimespec(TimevalToNsec(tv%5B0%5D))%0A%09ts%5B1%5D = NsecToTimespec(TimevalToNsec(tv%5B1%5D))%0A%09err := utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0Afunc UtimesNano(path string, ts %5B%5DTimespec) error %7B%0A%09if ts == nil %7B%0A%09%09err := utimensat(AT_FDCWD, path, nil, 0)%0A%09%09if err != ENOSYS %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09err := utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09// If the utimensat syscall isn't available (utimensat was added to Linux%0A%09// in 2.6.22, Released, 8 July 2007) then fall back to utimes%0A%09var tv %5B2%5DTimeval%0A%09for i := 0; i %3C 2; i++ %7B%0A%09%09tv%5Bi%5D = NsecToTimeval(TimespecToNsec(ts%5Bi%5D))%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc UtimesNanoAt(dirfd int, path string, ts %5B%5DTimespec, flags int) error %7B%0A%09if ts == nil %7B%0A%09%09return utimensat(dirfd, path, nil, flags)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimensat(dirfd, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), flags)%0A%7D%0A%0A//sys%09futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error)%0A%0Afunc Futimesat(dirfd int, path string, tv %5B%5DTimeval) error %7B%0A%09pathp, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if tv == nil %7B%0A%09%09return futimesat(dirfd, pathp, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return futimesat(dirfd, pathp, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc Futimes(fd int, tv %5B%5DTimeval) (err error) %7B%0A%09// Believe it or not, this is the best we can do on Linux%0A%09// (and is what glibc does).%0A%09return Utimes(%22/proc/self/fd/%22+itoa(fd), tv)%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error)%0A%0Afunc Getwd() (wd string, err error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09n, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09// Getcwd returns the number of bytes written to buf, including the NUL.%0A%09if n %3C 1 %7C%7C n %3E len(buf) %7C%7C buf%5Bn-1%5D != 0 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B0 : n-1%5D), nil%0A%7D%0A%0Afunc Getgroups() (gids %5B%5Dint, err error) %7B%0A%09n, err := getgroups(0, nil)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n == 0 %7B%0A%09%09return nil, nil%0A%09%7D%0A%0A%09// Sanity check group count. Max is 1%3C%3C16 on Linux.%0A%09if n %3C 0 %7C%7C n %3E 1%3C%3C20 %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, n)%0A%09n, err = getgroups(n, &a%5B0%5D)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09gids = make(%5B%5Dint, n)%0A%09for i, v := range a%5B0:n%5D %7B%0A%09%09gids%5Bi%5D = int(v)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setgroups(gids %5B%5Dint) (err error) %7B%0A%09if len(gids) == 0 %7B%0A%09%09return setgroups(0, nil)%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, len(gids))%0A%09for i, v := range gids %7B%0A%09%09a%5Bi%5D = _Gid_t(v)%0A%09%7D%0A%09return setgroups(len(a), &a%5B0%5D)%0A%7D%0A%0Atype WaitStatus uint32%0A%0A// Wait status is 7 bits at bottom, either 0 (exited),%0A// 0x7F (stopped), or a signal number that caused an exit.%0A// The 0x80 bit is whether there was a core dump.%0A// An extra number (exit code, signal causing a stop)%0A// is in the high bits. At least that's the idea.%0A// There are various irregularities. For example, the%0A// %22continued%22 status is 0xFFFF, distinguishing itself%0A// from stopped via the core dump bit.%0A%0Aconst (%0A%09mask    = 0x7F%0A%09core    = 0x80%0A%09exited  = 0x00%0A%09stopped = 0x7F%0A%09shift   = 8%0A)%0A%0Afunc (w WaitStatus) Exited() bool %7B return w&mask == exited %7D%0A%0Afunc (w WaitStatus) Signaled() bool %7B return w&mask != stopped && w&mask != exited %7D%0A%0Afunc (w WaitStatus) Stopped() bool %7B return w&0xFF == stopped %7D%0A%0Afunc (w WaitStatus) Continued() bool %7B return w == 0xFFFF %7D%0A%0Afunc (w WaitStatus) CoreDump() bool %7B return w.Signaled() && w&core != 0 %7D%0A%0Afunc (w WaitStatus) ExitStatus() int %7B%0A%09if !w.Exited() %7B%0A%09%09return -1%0A%09%7D%0A%09return int(w%3E%3Eshift) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) Signal() syscall.Signal %7B%0A%09if !w.Signaled() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w & mask)%0A%7D%0A%0Afunc (w WaitStatus) StopSignal() syscall.Signal %7B%0A%09if !w.Stopped() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w%3E%3Eshift) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) TrapCause() int %7B%0A%09if w.StopSignal() != SIGTRAP %7B%0A%09%09return -1%0A%09%7D%0A%09return int(w%3E%3Eshift) %3E%3E 8%0A%7D%0A%0A//sys%09wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error)%0A%0Afunc Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09var status _C_int%0A%09wpid, err = wait4(pid, &status, options, rusage)%0A%09if wstatus != nil %7B%0A%09%09*wstatus = WaitStatus(status)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkfifo(path string, mode uint32) error %7B%0A%09return Mknod(path, mode%7CS_IFIFO, 0)%0A%7D%0A%0Afunc Mkfifoat(dirfd int, path string, mode uint32) error %7B%0A%09return Mknodat(dirfd, path, mode%7CS_IFIFO, 0)%0A%7D%0A%0Afunc (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet4, nil%0A%7D%0A%0Afunc (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET6%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09sa.raw.Scope_id = sa.ZoneId%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet6, nil%0A%7D%0A%0Afunc (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09name := sa.Name%0A%09n := len(name)%0A%09if n %3E= len(sa.raw.Path) %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_UNIX%0A%09for i := 0; i %3C n; i++ %7B%0A%09%09sa.raw.Path%5Bi%5D = int8(name%5Bi%5D)%0A%09%7D%0A%09// length is family (uint16), name, NUL.%0A%09sl := _Socklen(2)%0A%09if n %3E 0 %7B%0A%09%09sl += _Socklen(n) + 1%0A%09%7D%0A%09if sa.raw.Path%5B0%5D == '@' %7B%0A%09%09sa.raw.Path%5B0%5D = 0%0A%09%09// Don't count trailing NUL for abstract address.%0A%09%09sl--%0A%09%7D%0A%0A%09return unsafe.Pointer(&sa.raw), sl, nil%0A%7D%0A%0A// SockaddrLinklayer implements the Sockaddr interface for AF_PACKET type sockets.%0Atype SockaddrLinklayer struct %7B%0A%09Protocol uint16%0A%09Ifindex  int%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Dbyte%0A%09raw      RawSockaddrLinklayer%0A%7D%0A%0Afunc (sa *SockaddrLinklayer) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Ifindex %3C 0 %7C%7C sa.Ifindex %3E 0x7fffffff %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_PACKET%0A%09sa.raw.Protocol = sa.Protocol%0A%09sa.raw.Ifindex = int32(sa.Ifindex)%0A%09sa.raw.Hatype = sa.Hatype%0A%09sa.raw.Pkttype = sa.Pkttype%0A%09sa.raw.Halen = sa.Halen%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrLinklayer, nil%0A%7D%0A%0A// SockaddrNetlink implements the Sockaddr interface for AF_NETLINK type sockets.%0Atype SockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%09raw    RawSockaddrNetlink%0A%7D%0A%0Afunc (sa *SockaddrNetlink) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_NETLINK%0A%09sa.raw.Pad = sa.Pad%0A%09sa.raw.Pid = sa.Pid%0A%09sa.raw.Groups = sa.Groups%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrNetlink, nil%0A%7D%0A%0A// SockaddrHCI implements the Sockaddr interface for AF_BLUETOOTH type sockets%0A// using the HCI protocol.%0Atype SockaddrHCI struct %7B%0A%09Dev     uint16%0A%09Channel uint16%0A%09raw     RawSockaddrHCI%0A%7D%0A%0Afunc (sa *SockaddrHCI) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_BLUETOOTH%0A%09sa.raw.Dev = sa.Dev%0A%09sa.raw.Channel = sa.Channel%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrHCI, nil%0A%7D%0A%0A// SockaddrL2 implements the Sockaddr interface for AF_BLUETOOTH type sockets%0A// using the L2CAP protocol.%0Atype SockaddrL2 struct %7B%0A%09PSM      uint16%0A%09CID      uint16%0A%09Addr     %5B6%5Duint8%0A%09AddrType uint8%0A%09raw      RawSockaddrL2%0A%7D%0A%0Afunc (sa *SockaddrL2) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_BLUETOOTH%0A%09psm := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Psm))%0A%09psm%5B0%5D = byte(sa.PSM)%0A%09psm%5B1%5D = byte(sa.PSM %3E%3E 8)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Bdaddr%5Bi%5D = sa.Addr%5Blen(sa.Addr)-1-i%5D%0A%09%7D%0A%09cid := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Cid))%0A%09cid%5B0%5D = byte(sa.CID)%0A%09cid%5B1%5D = byte(sa.CID %3E%3E 8)%0A%09sa.raw.Bdaddr_type = sa.AddrType%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrL2, nil%0A%7D%0A%0A// SockaddrCAN implements the Sockaddr interface for AF_CAN type sockets.%0A// The RxID and TxID fields are used for transport protocol addressing in%0A// (CAN_TP16, CAN_TP20, CAN_MCNET, and CAN_ISOTP), they can be left with%0A// zero values for CAN_RAW and CAN_BCM sockets as they have no meaning.%0A//%0A// The SockaddrCAN struct must be bound to the socket file descriptor%0A// using Bind before the CAN socket can be used.%0A//%0A//      // Read one raw CAN frame%0A//      fd, _ := Socket(AF_CAN, SOCK_RAW, CAN_RAW)%0A//      addr := &SockaddrCAN%7BIfindex: index%7D%0A//      Bind(fd, addr)%0A//      frame := make(%5B%5Dbyte, 16)%0A//      Read(fd, frame)%0A//%0A// The full SocketCAN documentation can be found in the linux kernel%0A// archives at: https://www.kernel.org/doc/Documentation/networking/can.txt%0Atype SockaddrCAN struct %7B%0A%09Ifindex int%0A%09RxID    uint32%0A%09TxID    uint32%0A%09raw     RawSockaddrCAN%0A%7D%0A%0Afunc (sa *SockaddrCAN) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Ifindex %3C 0 %7C%7C sa.Ifindex %3E 0x7fffffff %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_CAN%0A%09sa.raw.Ifindex = int32(sa.Ifindex)%0A%09rx := (*%5B4%5Dbyte)(unsafe.Pointer(&sa.RxID))%0A%09for i := 0; i %3C 4; i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = rx%5Bi%5D%0A%09%7D%0A%09tx := (*%5B4%5Dbyte)(unsafe.Pointer(&sa.TxID))%0A%09for i := 0; i %3C 4; i++ %7B%0A%09%09sa.raw.Addr%5Bi+4%5D = tx%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrCAN, nil%0A%7D%0A%0A// SockaddrALG implements the Sockaddr interface for AF_ALG type sockets.%0A// SockaddrALG enables userspace access to the Linux kernel's cryptography%0A// subsystem. The Type and Name fields specify which type of hash or cipher%0A// should be used with a given socket.%0A//%0A// To create a file descriptor that provides access to a hash or cipher, both%0A// Bind and Accept must be used. Once the setup process is complete, input%0A// data can be written to the socket, processed by the kernel, and then read%0A// back as hash output or ciphertext.%0A//%0A// Here is an example of using an AF_ALG socket with SHA1 hashing.%0A// The initial socket setup process is as follows:%0A//%0A//      // Open a socket to perform SHA1 hashing.%0A//      fd, _ := unix.Socket(unix.AF_ALG, unix.SOCK_SEQPACKET, 0)%0A//      addr := &unix.SockaddrALG%7BType: %22hash%22, Name: %22sha1%22%7D%0A//      unix.Bind(fd, addr)%0A//      // Note: unix.Accept does not work at this time; must invoke accept()%0A//      // manually using unix.Syscall.%0A//      hashfd, _, _ := unix.Syscall(unix.SYS_ACCEPT, uintptr(fd), 0, 0)%0A//%0A// Once a file descriptor has been returned from Accept, it may be used to%0A// perform SHA1 hashing. The descriptor is not safe for concurrent use, but%0A// may be re-used repeatedly with subsequent Write and Read operations.%0A//%0A// When hashing a small byte slice or string, a single Write and Read may%0A// be used:%0A//%0A//      // Assume hashfd is already configured using the setup process.%0A//      hash := os.NewFile(hashfd, %22sha1%22)%0A//      // Hash an input string and read the results. Each Write discards%0A//      // previous hash state. Read always reads the current state.%0A//      b := make(%5B%5Dbyte, 20)%0A//      for i := 0; i %3C 2; i++ %7B%0A//          io.WriteString(hash, %22Hello, world.%22)%0A//          hash.Read(b)%0A//          fmt.Println(hex.EncodeToString(b))%0A//      %7D%0A//      // Output:%0A//      // 2ae01472317d1935a84797ec1983ae243fc6aa28%0A//      // 2ae01472317d1935a84797ec1983ae243fc6aa28%0A//%0A// For hashing larger byte slices, or byte streams such as those read from%0A// a file or socket, use Sendto with MSG_MORE to instruct the kernel to update%0A// the hash digest instead of creating a new one for a given chunk and finalizing it.%0A//%0A//      // Assume hashfd and addr are already configured using the setup process.%0A//      hash := os.NewFile(hashfd, %22sha1%22)%0A//      // Hash the contents of a file.%0A//      f, _ := os.Open(%22/tmp/linux-4.10-rc7.tar.xz%22)%0A//      b := make(%5B%5Dbyte, 4096)%0A//      for %7B%0A//          n, err := f.Read(b)%0A//          if err == io.EOF %7B%0A//              break%0A//          %7D%0A//          unix.Sendto(hashfd, b%5B:n%5D, unix.MSG_MORE, addr)%0A//      %7D%0A//      hash.Read(b)%0A//      fmt.Println(hex.EncodeToString(b))%0A//      // Output: 85cdcad0c06eef66f805ecce353bec9accbeecc5%0A//%0A// For more information, see: http://www.chronox.de/crypto-API/crypto/userspace-if.html.%0Atype SockaddrALG struct %7B%0A%09Type    string%0A%09Name    string%0A%09Feature uint32%0A%09Mask    uint32%0A%09raw     RawSockaddrALG%0A%7D%0A%0Afunc (sa *SockaddrALG) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09// Leave room for NUL byte terminator.%0A%09if len(sa.Type) %3E 13 %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09if len(sa.Name) %3E 63 %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%0A%09sa.raw.Family = AF_ALG%0A%09sa.raw.Feat = sa.Feature%0A%09sa.raw.Mask = sa.Mask%0A%0A%09typ, err := ByteSliceFromString(sa.Type)%0A%09if err != nil %7B%0A%09%09return nil, 0, err%0A%09%7D%0A%09name, err := ByteSliceFromString(sa.Name)%0A%09if err != nil %7B%0A%09%09return nil, 0, err%0A%09%7D%0A%0A%09copy(sa.raw.Type%5B:%5D, typ)%0A%09copy(sa.raw.Name%5B:%5D, name)%0A%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrALG, nil%0A%7D%0A%0A// SockaddrVM implements the Sockaddr interface for AF_VSOCK type sockets.%0A// SockaddrVM provides access to Linux VM sockets: a mechanism that enables%0A// bidirectional communication between a hypervisor and its guest virtual%0A// machines.%0Atype SockaddrVM struct %7B%0A%09// CID and Port specify a context ID and port address for a VM socket.%0A%09// Guests have a unique CID, and hosts may have a well-known CID of:%0A%09//  - VMADDR_CID_HYPERVISOR: refers to the hypervisor process.%0A%09//  - VMADDR_CID_HOST: refers to other processes on the host.%0A%09CID  uint32%0A%09Port uint32%0A%09raw  RawSockaddrVM%0A%7D%0A%0Afunc (sa *SockaddrVM) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_VSOCK%0A%09sa.raw.Port = sa.Port%0A%09sa.raw.Cid = sa.CID%0A%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrVM, nil%0A%7D%0A%0Afunc anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, error) %7B%0A%09switch rsa.Addr.Family %7B%0A%09case AF_NETLINK:%0A%09%09pp := (*RawSockaddrNetlink)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrNetlink)%0A%09%09sa.Family = pp.Family%0A%09%09sa.Pad = pp.Pad%0A%09%09sa.Pid = pp.Pid%0A%09%09sa.Groups = pp.Groups%0A%09%09return sa, nil%0A%0A%09case AF_PACKET:%0A%09%09pp := (*RawSockaddrLinklayer)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrLinklayer)%0A%09%09sa.Protocol = pp.Protocol%0A%09%09sa.Ifindex = int(pp.Ifindex)%0A%09%09sa.Hatype = pp.Hatype%0A%09%09sa.Pkttype = pp.Pkttype%0A%09%09sa.Halen = pp.Halen%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_UNIX:%0A%09%09pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrUnix)%0A%09%09if pp.Path%5B0%5D == 0 %7B%0A%09%09%09// %22Abstract%22 Unix domain socket.%0A%09%09%09// Rewrite leading NUL as @ for textual display.%0A%09%09%09// (This is the standard convention.)%0A%09%09%09// Not friendly to overwrite in place,%0A%09%09%09// but the callers below don't care.%0A%09%09%09pp.Path%5B0%5D = '@'%0A%09%09%7D%0A%0A%09%09// Assume path ends at NUL.%0A%09%09// This is not technically the Linux semantics for%0A%09%09// abstract Unix domain sockets--they are supposed%0A%09%09// to be uninterpreted fixed-size binary blobs--but%0A%09%09// everyone uses this convention.%0A%09%09n := 0%0A%09%09for n %3C len(pp.Path) && pp.Path%5Bn%5D != 0 %7B%0A%09%09%09n++%0A%09%09%7D%0A%09%09bytes := (*%5B10000%5Dbyte)(unsafe.Pointer(&pp.Path%5B0%5D))%5B0:n%5D%0A%09%09sa.Name = string(bytes)%0A%09%09return sa, nil%0A%0A%09case AF_INET:%0A%09%09pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet4)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_INET6:%0A%09%09pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet6)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09sa.ZoneId = pp.Scope_id%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_VSOCK:%0A%09%09pp := (*RawSockaddrVM)(unsafe.Pointer(rsa))%0A%09%09sa := &SockaddrVM%7B%0A%09%09%09CID:  pp.Cid,%0A%09%09%09Port: pp.Port,%0A%09%09%7D%0A%09%09return sa, nil%0A%09%7D%0A%09return nil, EAFNOSUPPORT%0A%7D%0A%0Afunc Accept(fd int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept(fd, &rsa, &len)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09sa, err = anyToSockaddr(&rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept4(fd, &rsa, &len, flags)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09if len %3E SizeofSockaddrAny %7B%0A%09%09panic(%22RawSockaddrAny too small%22)%0A%09%7D%0A%09sa, err = anyToSockaddr(&rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getsockname(fd int) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if err = getsockname(fd, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return anyToSockaddr(&rsa)%0A%7D%0A%0Afunc GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error) %7B%0A%09var value IPMreqn%0A%09vallen := _Socklen(SizeofIPMreqn)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptUcred(fd, level, opt int) (*Ucred, error) %7B%0A%09var value Ucred%0A%09vallen := _Socklen(SizeofUcred)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptTCPInfo(fd, level, opt int) (*TCPInfo, error) %7B%0A%09var value TCPInfo%0A%09vallen := _Socklen(SizeofTCPInfo)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0A// GetsockoptString returns the string value of the socket option opt for the%0A// socket associated with fd at the given socket level.%0Afunc GetsockoptString(fd, level, opt int) (string, error) %7B%0A%09buf := make(%5B%5Dbyte, 256)%0A%09vallen := _Socklen(len(buf))%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&buf%5B0%5D), &vallen)%0A%09if err != nil %7B%0A%09%09if err == ERANGE %7B%0A%09%09%09buf = make(%5B%5Dbyte, vallen)%0A%09%09%09err = getsockopt(fd, level, opt, unsafe.Pointer(&buf%5B0%5D), &vallen)%0A%09%09%7D%0A%09%09if err != nil %7B%0A%09%09%09return %22%22, err%0A%09%09%7D%0A%09%7D%0A%09return string(buf%5B:vallen-1%5D), nil%0A%7D%0A%0Afunc SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(mreq), unsafe.Sizeof(*mreq))%0A%7D%0A%0A// Keyctl Commands (http://man7.org/linux/man-pages/man2/keyctl.2.html)%0A%0A// KeyctlInt calls keyctl commands in which each argument is an int.%0A// These commands are KEYCTL_REVOKE, KEYCTL_CHOWN, KEYCTL_CLEAR, KEYCTL_LINK,%0A// KEYCTL_UNLINK, KEYCTL_NEGATE, KEYCTL_SET_REQKEY_KEYRING, KEYCTL_SET_TIMEOUT,%0A// KEYCTL_ASSUME_AUTHORITY, KEYCTL_SESSION_TO_PARENT, KEYCTL_REJECT,%0A// KEYCTL_INVALIDATE, and KEYCTL_GET_PERSISTENT.%0A//sys%09KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlBuffer calls keyctl commands in which the third and fourth%0A// arguments are a buffer and its length, respectively.%0A// These commands are KEYCTL_UPDATE, KEYCTL_READ, and KEYCTL_INSTANTIATE.%0A//sys%09KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlString calls keyctl commands which return a string.%0A// These commands are KEYCTL_DESCRIBE and KEYCTL_GET_SECURITY.%0Afunc KeyctlString(cmd int, id int) (string, error) %7B%0A%09// We must loop as the string data may change in between the syscalls.%0A%09// We could allocate a large buffer here to reduce the chance that the%0A%09// syscall needs to be called twice; however, this is unnecessary as%0A%09// the performance loss is negligible.%0A%09var buffer %5B%5Dbyte%0A%09for %7B%0A%09%09// Try to fill the buffer with data%0A%09%09length, err := KeyctlBuffer(cmd, id, buffer, 0)%0A%09%09if err != nil %7B%0A%09%09%09return %22%22, err%0A%09%09%7D%0A%0A%09%09// Check if the data was written%0A%09%09if length %3C= len(buffer) %7B%0A%09%09%09// Exclude the null terminator%0A%09%09%09return string(buffer%5B:length-1%5D), nil%0A%09%09%7D%0A%0A%09%09// Make a bigger buffer if needed%0A%09%09buffer = make(%5B%5Dbyte, length)%0A%09%7D%0A%7D%0A%0A// Keyctl commands with special signatures.%0A%0A// KeyctlGetKeyringID implements the KEYCTL_GET_KEYRING_ID command.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_get_keyring_ID.3.html%0Afunc KeyctlGetKeyringID(id int, create bool) (ringid int, err error) %7B%0A%09createInt := 0%0A%09if create %7B%0A%09%09createInt = 1%0A%09%7D%0A%09return KeyctlInt(KEYCTL_GET_KEYRING_ID, id, createInt, 0, 0)%0A%7D%0A%0A// KeyctlSetperm implements the KEYCTL_SETPERM command. The perm value is the%0A// key handle permission mask as described in the %22keyctl setperm%22 section of%0A// http://man7.org/linux/man-pages/man1/keyctl.1.html.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_setperm.3.html%0Afunc KeyctlSetperm(id int, perm uint32) error %7B%0A%09_, err := KeyctlInt(KEYCTL_SETPERM, id, int(perm), 0, 0)%0A%09return err%0A%7D%0A%0A//sys%09keyctlJoin(cmd int, arg2 string) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlJoinSessionKeyring implements the KEYCTL_JOIN_SESSION_KEYRING command.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_join_session_keyring.3.html%0Afunc KeyctlJoinSessionKeyring(name string) (ringid int, err error) %7B%0A%09return keyctlJoin(KEYCTL_JOIN_SESSION_KEYRING, name)%0A%7D%0A%0A//sys%09keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlSearch implements the KEYCTL_SEARCH command.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_search.3.html%0Afunc KeyctlSearch(ringid int, keyType, description string, destRingid int) (id int, err error) %7B%0A%09return keyctlSearch(KEYCTL_SEARCH, ringid, keyType, description, destRingid)%0A%7D%0A%0A//sys%09keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) = SYS_KEYCTL%0A%0A// KeyctlInstantiateIOV implements the KEYCTL_INSTANTIATE_IOV command. This%0A// command is similar to KEYCTL_INSTANTIATE, except that the payload is a slice%0A// of Iovec (each of which represents a buffer) instead of a single buffer.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_instantiate_iov.3.html%0Afunc KeyctlInstantiateIOV(id int, payload %5B%5DIovec, ringid int) error %7B%0A%09return keyctlIOV(KEYCTL_INSTANTIATE_IOV, id, payload, ringid)%0A%7D%0A%0A//sys%09keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlDHCompute implements the KEYCTL_DH_COMPUTE command. This command%0A// computes a Diffie-Hellman shared secret based on the provide params. The%0A// secret is written to the provided buffer and the returned size is the number%0A// of bytes written (returning an error if there is insufficient space in the%0A// buffer). If a nil buffer is passed in, this function returns the minimum%0A// buffer length needed to store the appropriate data. Note that this differs%0A// from KEYCTL_READ's behavior which always returns the requested payload size.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_dh_compute.3.html%0Afunc KeyctlDHCompute(params *KeyctlDHParams, buffer %5B%5Dbyte) (size int, err error) %7B%0A%09return keyctlDH(KEYCTL_DH_COMPUTE, params, buffer)%0A%7D%0A%0Afunc Recvmsg(fd int, p, oob %5B%5Dbyte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) %7B%0A%09var msg Msghdr%0A%09var rsa RawSockaddrAny%0A%09msg.Name = (*byte)(unsafe.Pointer(&rsa))%0A%09msg.Namelen = uint32(SizeofSockaddrAny)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = &p%5B0%5D%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy byte%0A%09if len(oob) %3E 0 %7B%0A%09%09if len(p) == 0 %7B%0A%09%09%09var sockType int%0A%09%09%09sockType, err = GetsockoptInt(fd, SOL_SOCKET, SO_TYPE)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return%0A%09%09%09%7D%0A%09%09%09// receive at least one normal byte%0A%09%09%09if sockType != SOCK_DGRAM %7B%0A%09%09%09%09iov.Base = &dummy%0A%09%09%09%09iov.SetLen(1)%0A%09%09%09%7D%0A%09%09%7D%0A%09%09msg.Control = &oob%5B0%5D%0A%09%09msg.SetControllen(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = recvmsg(fd, &msg, flags); err != nil %7B%0A%09%09return%0A%09%7D%0A%09oobn = int(msg.Controllen)%0A%09recvflags = int(msg.Flags)%0A%09// source address is only specified if the socket is unconnected%0A%09if rsa.Addr.Family != AF_UNSPEC %7B%0A%09%09from, err = anyToSockaddr(&rsa)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sendmsg(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (err error) %7B%0A%09_, err = SendmsgN(fd, p, oob, to, flags)%0A%09return%0A%7D%0A%0Afunc SendmsgN(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (n int, err error) %7B%0A%09var ptr unsafe.Pointer%0A%09var salen _Socklen%0A%09if to != nil %7B%0A%09%09var err error%0A%09%09ptr, salen, err = to.sockaddr()%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%7D%0A%09var msg Msghdr%0A%09msg.Name = (*byte)(ptr)%0A%09msg.Namelen = uint32(salen)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = &p%5B0%5D%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy byte%0A%09if len(oob) %3E 0 %7B%0A%09%09if len(p) == 0 %7B%0A%09%09%09var sockType int%0A%09%09%09sockType, err = GetsockoptInt(fd, SOL_SOCKET, SO_TYPE)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return 0, err%0A%09%09%09%7D%0A%09%09%09// send at least one normal byte%0A%09%09%09if sockType != SOCK_DGRAM %7B%0A%09%09%09%09iov.Base = &dummy%0A%09%09%09%09iov.SetLen(1)%0A%09%09%09%7D%0A%09%09%7D%0A%09%09msg.Control = &oob%5B0%5D%0A%09%09msg.SetControllen(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = sendmsg(fd, &msg, flags); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if len(oob) %3E 0 && len(p) == 0 %7B%0A%09%09n = 0%0A%09%7D%0A%09return n, nil%0A%7D%0A%0A// BindToDevice binds the socket associated with fd to device.%0Afunc BindToDevice(fd int, device string) (err error) %7B%0A%09return SetsockoptString(fd, SOL_SOCKET, SO_BINDTODEVICE, device)%0A%7D%0A%0A//sys%09ptrace(request int, pid int, addr uintptr, data uintptr) (err error)%0A%0Afunc ptracePeek(req int, pid int, addr uintptr, out %5B%5Dbyte) (count int, err error) %7B%0A%09// The peek requests are machine-size oriented, so we wrap it%0A%09// to retrieve arbitrary-length data.%0A%0A%09// The ptrace syscall differs from glibc's ptrace.%0A%09// Peeks returns the word in *data, not as the return value.%0A%0A%09var buf %5BsizeofPtr%5Dbyte%0A%0A%09// Leading edge. PEEKTEXT/PEEKDATA don't require aligned%0A%09// access (PEEKUSER warns that it might), but if we don't%0A%09// align our reads, we might straddle an unmapped page%0A%09// boundary and not get the bytes leading up to the page%0A%09// boundary.%0A%09n := 0%0A%09if addr%25sizeofPtr != 0 %7B%0A%09%09err = ptrace(req, pid, addr-addr%25sizeofPtr, uintptr(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%09n += copy(out, buf%5Baddr%25sizeofPtr:%5D)%0A%09%09out = out%5Bn:%5D%0A%09%7D%0A%0A%09// Remainder.%0A%09for len(out) %3E 0 %7B%0A%09%09// We use an internal buffer to guarantee alignment.%0A%09%09// It's not documented if this is necessary, but we're paranoid.%0A%09%09err = ptrace(req, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09copied := copy(out, buf%5B0:%5D)%0A%09%09n += copied%0A%09%09out = out%5Bcopied:%5D%0A%09%7D%0A%0A%09return n, nil%0A%7D%0A%0Afunc PtracePeekText(pid int, addr uintptr, out %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePeek(PTRACE_PEEKTEXT, pid, addr, out)%0A%7D%0A%0Afunc PtracePeekData(pid int, addr uintptr, out %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePeek(PTRACE_PEEKDATA, pid, addr, out)%0A%7D%0A%0Afunc PtracePeekUser(pid int, addr uintptr, out %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePeek(PTRACE_PEEKUSR, pid, addr, out)%0A%7D%0A%0Afunc ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data %5B%5Dbyte) (count int, err error) %7B%0A%09// As for ptracePeek, we need to align our accesses to deal%0A%09// with the possibility of straddling an invalid page.%0A%0A%09// Leading edge.%0A%09n := 0%0A%09if addr%25sizeofPtr != 0 %7B%0A%09%09var buf %5BsizeofPtr%5Dbyte%0A%09%09err = ptrace(peekReq, pid, addr-addr%25sizeofPtr, uintptr(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%09n += copy(buf%5Baddr%25sizeofPtr:%5D, data)%0A%09%09word := *((*uintptr)(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09err = ptrace(pokeReq, pid, addr-addr%25sizeofPtr, word)%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%09data = data%5Bn:%5D%0A%09%7D%0A%0A%09// Interior.%0A%09for len(data) %3E sizeofPtr %7B%0A%09%09word := *((*uintptr)(unsafe.Pointer(&data%5B0%5D)))%0A%09%09err = ptrace(pokeReq, pid, addr+uintptr(n), word)%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09n += sizeofPtr%0A%09%09data = data%5BsizeofPtr:%5D%0A%09%7D%0A%0A%09// Trailing edge.%0A%09if len(data) %3E 0 %7B%0A%09%09var buf %5BsizeofPtr%5Dbyte%0A%09%09err = ptrace(peekReq, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09copy(buf%5B0:%5D, data)%0A%09%09word := *((*uintptr)(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09err = ptrace(pokeReq, pid, addr+uintptr(n), word)%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09n += len(data)%0A%09%7D%0A%0A%09return n, nil%0A%7D%0A%0Afunc PtracePokeText(pid int, addr uintptr, data %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePoke(PTRACE_POKETEXT, PTRACE_PEEKTEXT, pid, addr, data)%0A%7D%0A%0Afunc PtracePokeData(pid int, addr uintptr, data %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePoke(PTRACE_POKEDATA, PTRACE_PEEKDATA, pid, addr, data)%0A%7D%0A%0Afunc PtracePokeUser(pid int, addr uintptr, data %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePoke(PTRACE_POKEUSR, PTRACE_PEEKUSR, pid, addr, data)%0A%7D%0A%0Afunc PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0Afunc PtraceSetRegs(pid int, regs *PtraceRegs) (err error) %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0Afunc PtraceSetOptions(pid int, options int) (err error) %7B%0A%09return ptrace(PTRACE_SETOPTIONS, pid, 0, uintptr(options))%0A%7D%0A%0Afunc PtraceGetEventMsg(pid int) (msg uint, err error) %7B%0A%09var data _C_long%0A%09err = ptrace(PTRACE_GETEVENTMSG, pid, 0, uintptr(unsafe.Pointer(&data)))%0A%09msg = uint(data)%0A%09return%0A%7D%0A%0Afunc PtraceCont(pid int, signal int) (err error) %7B%0A%09return ptrace(PTRACE_CONT, pid, 0, uintptr(signal))%0A%7D%0A%0Afunc PtraceSyscall(pid int, signal int) (err error) %7B%0A%09return ptrace(PTRACE_SYSCALL, pid, 0, uintptr(signal))%0A%7D%0A%0Afunc PtraceSingleStep(pid int) (err error) %7B return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) %7D%0A%0Afunc PtraceAttach(pid int) (err error) %7B return ptrace(PTRACE_ATTACH, pid, 0, 0) %7D%0A%0Afunc PtraceDetach(pid int) (err error) %7B return ptrace(PTRACE_DETACH, pid, 0, 0) %7D%0A%0A//sys%09reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error)%0A%0Afunc Reboot(cmd int) (err error) %7B%0A%09return reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, cmd, %22%22)%0A%7D%0A%0Afunc ReadDirent(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09return Getdents(fd, buf)%0A%7D%0A%0A//sys%09mount(source string, target string, fstype string, flags uintptr, data *byte) (err error)%0A%0Afunc Mount(source string, target string, fstype string, flags uintptr, data string) (err error) %7B%0A%09// Certain file systems get rather angry and EINVAL if you give%0A%09// them an empty string of data, rather than NULL.%0A%09if data == %22%22 %7B%0A%09%09return mount(source, target, fstype, flags, nil)%0A%09%7D%0A%09datap, err := BytePtrFromString(data)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return mount(source, target, fstype, flags, datap)%0A%7D%0A%0A// Sendto%0A// Recvfrom%0A// Socketpair%0A%0A/*%0A * Direct access%0A */%0A//sys%09Acct(path string) (err error)%0A//sys%09AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error)%0A//sys%09Adjtimex(buf *Timex) (state int, err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09ClockGettime(clockid int32, time *Timespec) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)%0A//sys%09Dup(oldfd int) (fd int, err error)%0A//sys%09Dup3(oldfd int, newfd int, flags int) (err error)%0A//sysnb%09EpollCreate(size int) (fd int, err error)%0A//sysnb%09EpollCreate1(flag int) (fd int, err error)%0A//sysnb%09EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)%0A//sys%09Eventfd(initval uint, flags int) (fd int, err error) = SYS_EVENTFD2%0A//sys%09Exit(code int) = SYS_EXIT_GROUP%0A//sys%09Faccessat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fallocate(fd int, mode uint32, off int64, len int64) (err error)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)%0A//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A//sys%09Fdatasync(fd int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Getdents(fd int, buf %5B%5Dbyte) (n int, err error) = SYS_GETDENTS64%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A%0Afunc Getpgrp() (pid int) %7B%0A%09pid, _ = Getpgid(0)%0A%09return%0A%7D%0A%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sys%09Getrandom(buf %5B%5Dbyte, flags int) (n int, err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettid() (tid int)%0A//sys%09Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)%0A//sysnb%09InotifyInit1(flags int) (fd int, err error)%0A//sysnb%09InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)%0A//sysnb%09Kill(pid int, sig syscall.Signal) (err error)%0A//sys%09Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) = SYS_SYSLOG%0A//sys%09Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09Listxattr(path string, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09Lremovexattr(path string, attr string) (err error)%0A//sys%09Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error)%0A//sys%09Mkdirat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mknodat(dirfd int, path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error)%0A//sys%09PivotRoot(newroot string, putold string) (err error) = SYS_PIVOT_ROOT%0A//sysnb prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) = SYS_PRLIMIT64%0A//sys   Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error)%0A//sys%09Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) = SYS_PSELECT6%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Removexattr(path string, attr string) (err error)%0A//sys%09Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)%0A//sys%09RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error)%0A//sys%09Setdomainname(p %5B%5Dbyte) (err error)%0A//sys%09Sethostname(p %5B%5Dbyte) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tv *Timeval) (err error)%0A//sys%09Setns(fd int, nstype int) (err error)%0A%0A// issue 1435.%0A// On linux Setuid and Setgid only affects the current thread, not the process.%0A// This does not match what most callers expect so we must return an error%0A// here rather than letting the caller think that the call succeeded.%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09return EOPNOTSUPP%0A%7D%0A%0Afunc Setgid(uid int) (err error) %7B%0A%09return EOPNOTSUPP%0A%7D%0A%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sys%09Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error)%0A//sys%09Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error)%0A//sys%09Sync()%0A//sys%09Syncfs(fd int) (err error)%0A//sysnb%09Sysinfo(info *Sysinfo_t) (err error)%0A//sys%09Tee(rfd int, wfd int, len int, flags int) (n int64, err error)%0A//sysnb%09Tgkill(tgid int, tid int, sig syscall.Signal) (err error)%0A//sysnb%09Times(tms *Tms) (ticks uintptr, err error)%0A//sysnb%09Umask(mask int) (oldmask int)%0A//sysnb%09Uname(buf *Utsname) (err error)%0A//sys%09Unmount(target string, flags int) (err error) = SYS_UMOUNT2%0A//sys%09Unshare(flags int) (err error)%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09exitThread(code int) (err error) = SYS_EXIT%0A//sys%09readlen(fd int, p *byte, np int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, p *byte, np int) (n int, err error) = SYS_WRITE%0A%0A// mmap varies by architecture; see syscall_linux_*.go.%0A//sys%09munmap(addr uintptr, length uintptr) (err error)%0A%0Avar mapper = &mmapper%7B%0A%09active: make(map%5B*byte%5D%5B%5Dbyte),%0A%09mmap:   mmap,%0A%09munmap: munmap,%0A%7D%0A%0Afunc Mmap(fd int, offset int64, length int, prot int, flags int) (data %5B%5Dbyte, err error) %7B%0A%09return mapper.Mmap(fd, offset, length, prot, flags)%0A%7D%0A%0Afunc Munmap(b %5B%5Dbyte) (err error) %7B%0A%09return mapper.Munmap(b)%0A%7D%0A%0A//sys%09Madvise(b %5B%5Dbyte, advice int) (err error)%0A//sys%09Mprotect(b %5B%5Dbyte, prot int) (err error)%0A//sys%09Mlock(b %5B%5Dbyte) (err error)%0A//sys%09Mlockall(flags int) (err error)%0A//sys%09Msync(b %5B%5Dbyte, flags int) (err error)%0A//sys%09Munlock(b %5B%5Dbyte) (err error)%0A//sys%09Munlockall() (err error)%0A%0A// Vmsplice splices user pages from a slice of Iovecs into a pipe specified by fd,%0A// using the specified flags.%0Afunc Vmsplice(fd int, iovs %5B%5DIovec, flags int) (int, error) %7B%0A%09n, _, errno := Syscall6(%0A%09%09SYS_VMSPLICE,%0A%09%09uintptr(fd),%0A%09%09uintptr(unsafe.Pointer(&iovs%5B0%5D)),%0A%09%09uintptr(len(iovs)),%0A%09%09uintptr(flags),%0A%09%090,%0A%09%090,%0A%09)%0A%09if errno != 0 %7B%0A%09%09return 0, syscall.Errno(errno)%0A%09%7D%0A%0A%09return int(n), nil%0A%7D%0A%0A/*%0A * Unimplemented%0A */%0A// AfsSyscall%0A// Alarm%0A// ArchPrctl%0A// Brk%0A// Capget%0A// Capset%0A// ClockGetres%0A// ClockNanosleep%0A// ClockSettime%0A// Clone%0A// CreateModule%0A// DeleteModule%0A// EpollCtlOld%0A// EpollPwait%0A// EpollWaitOld%0A// Execve%0A// Fgetxattr%0A// Flistxattr%0A// Fork%0A// Fremovexattr%0A// Fsetxattr%0A// Futex%0A// GetKernelSyms%0A// GetMempolicy%0A// GetRobustList%0A// GetThreadArea%0A// Getitimer%0A// Getpmsg%0A// IoCancel%0A// IoDestroy%0A// IoGetevents%0A// IoSetup%0A// IoSubmit%0A// IoprioGet%0A// IoprioSet%0A// KexecLoad%0A// LookupDcookie%0A// Mbind%0A// MigratePages%0A// Mincore%0A// ModifyLdt%0A// Mount%0A// MovePages%0A// MqGetsetattr%0A// MqNotify%0A// MqOpen%0A// MqTimedreceive%0A// MqTimedsend%0A// MqUnlink%0A// Mremap%0A// Msgctl%0A// Msgget%0A// Msgrcv%0A// Msgsnd%0A// Nfsservctl%0A// Personality%0A// Pselect6%0A// Ptrace%0A// Putpmsg%0A// QueryModule%0A// Quotactl%0A// Readahead%0A// Readv%0A// RemapFilePages%0A// RestartSyscall%0A// RtSigaction%0A// RtSigpending%0A// RtSigprocmask%0A// RtSigqueueinfo%0A// RtSigreturn%0A// RtSigsuspend%0A// RtSigtimedwait%0A// SchedGetPriorityMax%0A// SchedGetPriorityMin%0A// SchedGetparam%0A// SchedGetscheduler%0A// SchedRrGetInterval%0A// SchedSetparam%0A// SchedYield%0A// Security%0A// Semctl%0A// Semget%0A// Semop%0A// Semtimedop%0A// SetMempolicy%0A// SetRobustList%0A// SetThreadArea%0A// SetTidAddress%0A// Shmat%0A// Shmctl%0A// Shmdt%0A// Shmget%0A// Sigaltstack%0A// Signalfd%0A// Swapoff%0A// Swapon%0A// Sysfs%0A// TimerCreate%0A// TimerDelete%0A// TimerGetoverrun%0A// TimerGettime%0A// TimerSettime%0A// Timerfd%0A// Tkill (obsolete)%0A// Tuxcall%0A// Umount2%0A// Uselib%0A// Utimensat%0A// Vfork%0A// Vhangup%0A// Vserver%0A// Waitid%0A// _Sysctl%0A
- f f376de62816441238e74f47d1cd032ca6436dad503d3b6429ca50abc35768b03 vendor/golang.org/x/sys/unix/syscall_linux_386.go
+ f 95bd961a24c17e2daa7b52bf348cfb0e784577d3dbac1032855d12cbe8f2354d vendor/golang.org/x/sys/unix/syscall_linux_386.go
dmppatch 3
@@ -308,10645 +308,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09pipe(p *%5B2%5D_C_int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A// 64-bit file system and 32-bit uid calls%0A// (386 default is 32-bit file system and 16-bit uid).%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64_64%0A//sys%09Fchown(fd int, uid int, gid int) (err error) = SYS_FCHOWN32%0A//sys%09Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sys%09Ftruncate(fd int, length int64) (err error) = SYS_FTRUNCATE64%0A//sysnb%09Getegid() (egid int) = SYS_GETEGID32%0A//sysnb%09Geteuid() (euid int) = SYS_GETEUID32%0A//sysnb%09Getgid() (gid int) = SYS_GETGID32%0A//sysnb%09Getuid() (uid int) = SYS_GETUID32%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Ioperm(from int, num int, on int) (err error)%0A//sys%09Iopl(level int) (err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error) = SYS_LCHOWN32%0A//sys%09Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64%0A//sys%09Setfsgid(gid int) (err error) = SYS_SETFSGID32%0A//sys%09Setfsuid(uid int) (err error) = SYS_SETFSUID32%0A//sysnb%09Setregid(rgid int, egid int) (err error) = SYS_SETREGID32%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error) = SYS_SETRESGID32%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error) = SYS_SETRESUID32%0A//sysnb%09Setreuid(ruid int, euid int) (err error) = SYS_SETREUID32%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error) = SYS_STAT64%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error) = SYS_TRUNCATE64%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error) = SYS_GETGROUPS32%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error) = SYS_SETGROUPS32%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT%0A%0A//sys%09mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Pause() (err error)%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09page := uintptr(offset / 4096)%0A%09if offset != int64(page)*4096 %7B%0A%09%09return 0, EINVAL%0A%09%7D%0A%09return mmap2(addr, length, prot, flags, fd, page)%0A%7D%0A%0Atype rlimit32 struct %7B%0A%09Cur uint32%0A%09Max uint32%0A%7D%0A%0A//sysnb getrlimit(resource int, rlim *rlimit32) (err error) = SYS_GETRLIMIT%0A%0Aconst rlimInf32 = %5Euint32(0)%0Aconst rlimInf64 = %5Euint64(0)%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, nil, rlim)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09err = getrlimit(resource, &rl)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09if rl.Cur == rlimInf32 %7B%0A%09%09rlim.Cur = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Cur = uint64(rl.Cur)%0A%09%7D%0A%0A%09if rl.Max == rlimInf32 %7B%0A%09%09rlim.Max = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Max = uint64(rl.Max)%0A%09%7D%0A%09return%0A%7D%0A%0A//sysnb setrlimit(resource int, rlim *rlimit32) (err error) = SYS_SETRLIMIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, rlim, nil)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09if rlim.Cur == rlimInf64 %7B%0A%09%09rl.Cur = rlimInf32%0A%09%7D else if rlim.Cur %3C uint64(rlimInf32) %7B%0A%09%09rl.Cur = uint32(rlim.Cur)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%09if rlim.Max == rlimInf64 %7B%0A%09%09rl.Max = rlimInf32%0A%09%7D else if rlim.Max %3C uint64(rlimInf32) %7B%0A%09%09rl.Max = uint32(rlim.Max)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09return setrlimit(resource, &rl)%0A%7D%0A%0A// Underlying system call writes to newoffset via pointer.%0A// Implemented in assembly to avoid allocation.%0Afunc seek(fd int, offset int64, whence int) (newoffset int64, err syscall.Errno)%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09newoffset, errno := seek(fd, offset, whence)%0A%09if errno != 0 %7B%0A%09%09return 0, errno%0A%09%7D%0A%09return newoffset, nil%0A%7D%0A%0A// Vsyscalls on amd64.%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Time(t *Time_t) (tt Time_t, err error)%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A%0A// On x86 Linux, all the socket calls go through an extra indirection,%0A// I think because the 5-register system call interface can't handle%0A// the 6-argument calls like sendto and recvfrom. Instead the%0A// arguments to the underlying system call are the number below%0A// and a pointer to an array of uintptr. We hide the pointer in the%0A// socketcall assembly to avoid allocation on every system call.%0A%0Aconst (%0A%09// see linux/net.h%0A%09_SOCKET      = 1%0A%09_BIND        = 2%0A%09_CONNECT     = 3%0A%09_LISTEN      = 4%0A%09_ACCEPT      = 5%0A%09_GETSOCKNAME = 6%0A%09_GETPEERNAME = 7%0A%09_SOCKETPAIR  = 8%0A%09_SEND        = 9%0A%09_RECV        = 10%0A%09_SENDTO      = 11%0A%09_RECVFROM    = 12%0A%09_SHUTDOWN    = 13%0A%09_SETSOCKOPT  = 14%0A%09_GETSOCKOPT  = 15%0A%09_SENDMSG     = 16%0A%09_RECVMSG     = 17%0A%09_ACCEPT4     = 18%0A%09_RECVMMSG    = 19%0A%09_SENDMMSG    = 20%0A)%0A%0Afunc socketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (n int, err syscall.Errno)%0Afunc rawsocketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (n int, err syscall.Errno)%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09fd, e := socketcall(_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09fd, e := socketcall(_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockname(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, e := rawsocketcall(_GETSOCKNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getpeername(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, e := rawsocketcall(_GETPEERNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socketpair(domain int, typ int, flags int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, e := rawsocketcall(_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(flags), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, e := socketcall(_BIND, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, e := socketcall(_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09fd, e := rawsocketcall(_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, e := socketcall(_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, e := socketcall(_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), vallen, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc recvfrom(s int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var base uintptr%0A%09if len(p) %3E 0 %7B%0A%09%09base = uintptr(unsafe.Pointer(&p%5B0%5D))%0A%09%7D%0A%09n, e := socketcall(_RECVFROM, uintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendto(s int, p %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var base uintptr%0A%09if len(p) %3E 0 %7B%0A%09%09base = uintptr(unsafe.Pointer(&p%5B0%5D))%0A%09%7D%0A%09_, e := socketcall(_SENDTO, uintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09n, e := socketcall(_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09n, e := socketcall(_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, e := socketcall(_LISTEN, uintptr(s), uintptr(n), 0, 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Shutdown(s, how int) (err error) %7B%0A%09_, e := socketcall(_SHUTDOWN, uintptr(s), uintptr(how), 0, 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e := Syscall(SYS_FSTATFS64, uintptr(fd), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09pathp, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09_, _, e := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(pathp)), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return uint64(uint32(r.Eip)) %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Eip = int32(pc) %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 9108f14e713112c65a423b512674860164e75653d38e94dacec930a7d1dfaeed vendor/golang.org/x/sys/unix/syscall_linux_amd64.go
+ f 9286c57c303a4efad3ed9aab8d5cecee89766851a809bb025ae72144fbea6b9a vendor/golang.org/x/sys/unix/syscall_linux_amd64.go
dmppatch 3
@@ -193,5232 +193,4 @@
 nix%0A
-%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_NEWFSTATAT%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Ioperm(from int, num int, on int) (err error)%0A//sys%09Iopl(level int) (err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout != nil %7B%0A%09%09ts = &Timespec%7BSec: timeout.Sec, Nsec: timeout.Usec * 1000%7D%0A%09%7D%0A%09return Pselect(nfd, r, w, e, ts, nil)%0A%7D%0A%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09// Use fstatat, because Android's seccomp policy blocks stat.%0A%09return Fstatat(AT_FDCWD, path, stat, 0)%0A%7D%0A%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09errno := gettimeofday(tv)%0A%09if errno != 0 %7B%0A%09%09return errno%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09var tv Timeval%0A%09errno := gettimeofday(&tv)%0A%09if errno != 0 %7B%0A%09%09return 0, errno%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0A//sysnb%09pipe(p *%5B2%5D_C_int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Rip %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Rip = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 8b643c0f69d3b05c3a365bdf68f03d3b3fa73270a6cfe1c13dab86397edc968a vendor/golang.org/x/sys/unix/syscall_linux_amd64_gc.go
+ f 859b81608f7f5a054126310ac19905df48098711ec0b8781c42cb39a7cb62df7 vendor/golang.org/x/sys/unix/syscall_linux_amd64_gc.go
dmppatch 3
@@ -210,88 +210,4 @@
 nix%0A
-%0Aimport %22syscall%22%0A%0A//go:noescape%0Afunc gettimeofday(tv *Timeval) (err syscall.Errno)%0A
- f d38a45d94a3045605ac65a07bbf85d9b6333867c70988982bd41d125e755a96f vendor/golang.org/x/sys/unix/syscall_linux_arm.go
+ f 40c7d74ce70c97b61767bbff4417c615d60b35e10d359fe61b39a224de46fedf vendor/golang.org/x/sys/unix/syscall_linux_arm.go
dmppatch 3
@@ -191,7486 +191,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A// Underlying system call writes to newoffset via pointer.%0A// Implemented in assembly to avoid allocation.%0Afunc seek(fd int, offset int64, whence int) (newoffset int64, err syscall.Errno)%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09newoffset, errno := seek(fd, offset, whence)%0A%09if errno != 0 %7B%0A%09%09return 0, errno%0A%09%7D%0A%09return newoffset, nil%0A%7D%0A%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error) = SYS_GETGROUPS32%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error) = SYS_SETGROUPS32%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09socketpair(domain int, typ int, flags int, fd *%5B2%5Dint32) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A%0A// 64-bit file system and 32-bit uid calls%0A// (16-bit uid calls are not always supported in newer kernels)%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error) = SYS_FCHOWN32%0A//sys%09Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sysnb%09Getegid() (egid int) = SYS_GETEGID32%0A//sysnb%09Geteuid() (euid int) = SYS_GETEUID32%0A//sysnb%09Getgid() (gid int) = SYS_GETGID32%0A//sysnb%09Getuid() (uid int) = SYS_GETUID32%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error) = SYS_LCHOWN32%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT%0A//sys%09Setfsgid(gid int) (err error) = SYS_SETFSGID32%0A//sys%09Setfsuid(uid int) (err error) = SYS_SETFSUID32%0A//sysnb%09Setregid(rgid int, egid int) (err error) = SYS_SETREGID32%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error) = SYS_SETRESGID32%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error) = SYS_SETRESUID32%0A//sysnb%09Setreuid(ruid int, euid int) (err error) = SYS_SETREUID32%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error) = SYS_STAT64%0A%0A// Vsyscalls on amd64.%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Pause() (err error)%0A%0Afunc Time(t *Time_t) (Time_t, error) %7B%0A%09var tv Timeval%0A%09err := Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0Afunc Utime(path string, buf *Utimbuf) error %7B%0A%09tv := %5B%5DTimeval%7B%0A%09%09%7BSec: buf.Actime%7D,%0A%09%09%7BSec: buf.Modtime%7D,%0A%09%7D%0A%09return Utimes(path, tv)%0A%7D%0A%0A//sys   Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys   Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Truncate(path string, length int64) (err error) = SYS_TRUNCATE64%0A//sys%09Ftruncate(fd int, length int64) (err error) = SYS_FTRUNCATE64%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_ARM_FADVISE64_64, uintptr(fd), uintptr(advice), uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A//sys%09mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error)%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e := Syscall(SYS_FSTATFS64, uintptr(fd), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09pathp, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09_, _, e := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(pathp)), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09page := uintptr(offset / 4096)%0A%09if offset != int64(page)*4096 %7B%0A%09%09return 0, EINVAL%0A%09%7D%0A%09return mmap2(addr, length, prot, flags, fd, page)%0A%7D%0A%0Atype rlimit32 struct %7B%0A%09Cur uint32%0A%09Max uint32%0A%7D%0A%0A//sysnb getrlimit(resource int, rlim *rlimit32) (err error) = SYS_UGETRLIMIT%0A%0Aconst rlimInf32 = %5Euint32(0)%0Aconst rlimInf64 = %5Euint64(0)%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, nil, rlim)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09err = getrlimit(resource, &rl)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09if rl.Cur == rlimInf32 %7B%0A%09%09rlim.Cur = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Cur = uint64(rl.Cur)%0A%09%7D%0A%0A%09if rl.Max == rlimInf32 %7B%0A%09%09rlim.Max = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Max = uint64(rl.Max)%0A%09%7D%0A%09return%0A%7D%0A%0A//sysnb setrlimit(resource int, rlim *rlimit32) (err error) = SYS_SETRLIMIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, rlim, nil)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09if rlim.Cur == rlimInf64 %7B%0A%09%09rl.Cur = rlimInf32%0A%09%7D else if rlim.Cur %3C uint64(rlimInf32) %7B%0A%09%09rl.Cur = uint32(rlim.Cur)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%09if rlim.Max == rlimInf64 %7B%0A%09%09rl.Max = rlimInf32%0A%09%7D else if rlim.Max %3C uint64(rlimInf32) %7B%0A%09%09rl.Max = uint32(rlim.Max)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09return setrlimit(resource, &rl)%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return uint64(r.Uregs%5B15%5D) %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Uregs%5B15%5D = uint32(pc) %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 696009af3f8c1f6fa60fc9d87ce94c5e5bd102377135182471c0c523b9ab3484 vendor/golang.org/x/sys/unix/syscall_linux_arm64.go
+ f 0b9fb5c7a7ae5d791299c60ee527208e4f053ee1b2d525bb8ab58dd0c47d93d5 vendor/golang.org/x/sys/unix/syscall_linux_arm64.go
dmppatch 3
@@ -193,5799 +193,4 @@
 nix%0A
-%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) = SYS_EPOLL_PWAIT%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout != nil %7B%0A%09%09ts = &Timespec%7BSec: timeout.Sec, Nsec: timeout.Usec * 1000%7D%0A%09%7D%0A%09return Pselect(nfd, r, w, e, ts, nil)%0A%7D%0A%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09return Fstatat(AT_FDCWD, path, stat, 0)%0A%7D%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09return Fchownat(AT_FDCWD, path, uid, gid, AT_SYMLINK_NOFOLLOW)%0A%7D%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09return Fstatat(AT_FDCWD, path, stat, AT_SYMLINK_NOFOLLOW)%0A%7D%0A%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc Time(t *Time_t) (Time_t, error) %7B%0A%09var tv Timeval%0A%09err := Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0Afunc Utime(path string, buf *Utimbuf) error %7B%0A%09tv := %5B%5DTimeval%7B%0A%09%09%7BSec: buf.Actime%7D,%0A%09%09%7BSec: buf.Modtime%7D,%0A%09%7D%0A%09return Utimes(path, tv)%0A%7D%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Pc %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Pc = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09return InotifyInit1(0)%0A%7D%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09return Dup3(oldfd, newfd, 0)%0A%7D%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PPOLL, 0, 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// TODO(dfc): constants that should be in zsysnum_linux_arm64.go, remove%0A// these when the deprecated syscalls that the syscall package relies on%0A// are removed.%0Aconst (%0A%09SYS_GETPGRP      = 1060%0A%09SYS_UTIMES       = 1037%0A%09SYS_FUTIMESAT    = 1066%0A%09SYS_PAUSE        = 1061%0A%09SYS_USTAT        = 1070%0A%09SYS_UTIME        = 1063%0A%09SYS_LCHOWN       = 1032%0A%09SYS_TIME         = 1062%0A%09SYS_EPOLL_CREATE = 1042%0A%09SYS_EPOLL_WAIT   = 1069%0A)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout %3E= 0 %7B%0A%09%09ts = new(Timespec)%0A%09%09*ts = NsecToTimespec(int64(timeout) * 1e6)%0A%09%7D%0A%09if len(fds) == 0 %7B%0A%09%09return ppoll(nil, 0, ts, nil)%0A%09%7D%0A%09return ppoll(&fds%5B0%5D, len(fds), ts, nil)%0A%7D%0A
- f 9b9137cc0e38dc5452969dc2ea5937d090827e008cbe192b6d74f383003a2b35 vendor/golang.org/x/sys/unix/syscall_linux_gc.go
+ f dcd409c7e9f17b1f8f93b0e5c191e73f9dda84746ed3883af4bf3a35904e1003 vendor/golang.org/x/sys/unix/syscall_linux_gc.go
dmppatch 3
@@ -194,302 +194,4 @@
 nix%0A
-%0A// SyscallNoError may be used instead of Syscall for syscalls that don't fail.%0Afunc SyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr)%0A%0A// RawSyscallNoError may be used instead of RawSyscall for syscalls that don't%0A// fail.%0Afunc RawSyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr)%0A
+ f 84feb3b7960c8db2af1fc6dac01a74e9078bd9fad2e31f53585e3e8c304adfd6 vendor/golang.org/x/sys/unix/syscall_linux_gc_386.go
dmppatch 2
@@ -0,0 +1,201 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build linux,!gccgo,386%0A%0Apackage unix%0A
- f d1420444f03ff8c3f0d07c7d2a6711a5d79f3323590e2b1690ba054f8486bb1a vendor/golang.org/x/sys/unix/syscall_linux_gccgo.go
+ f a72f5ac504c5f5895badaecea44f4fe02f000a503fba5524b34aa7ca857dfa92 vendor/golang.org/x/sys/unix/syscall_linux_gccgo_386.go
dmppatch 2
@@ -0,0 +1,200 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build linux,gccgo,386%0A%0Apackage unix%0A
+ f 0f8708ce7e3fb3462d4e4cb282c0a75eb1a1d3ed835540da9804c41b853f2674 vendor/golang.org/x/sys/unix/syscall_linux_gccgo_arm.go
dmppatch 2
@@ -0,0 +1,200 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build linux,gccgo,arm%0A%0Apackage unix%0A
- f 2da46e87b3d30156f35738d52540dc1ca4cba36e0d982bbacf7cdb6927ddffa8 vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go
+ f 7b3f0d4478ea66e52a9dbb6ac03968eaf3ac42caa0618f5a5b0f8c8b5261004e vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go
dmppatch 3
@@ -213,6136 +213,4 @@
 nix%0A
-%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_NEWFSTATAT%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout != nil %7B%0A%09%09ts = &Timespec%7BSec: timeout.Sec, Nsec: timeout.Usec * 1000%7D%0A%09%7D%0A%09return Pselect(nfd, r, w, e, ts, nil)%0A%7D%0A%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09var tv Timeval%0A%09err = Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Afunc Iopl(level int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Atype stat_t struct %7B%0A%09Dev        uint32%0A%09Pad0       %5B3%5Dint32%0A%09Ino        uint64%0A%09Mode       uint32%0A%09Nlink      uint32%0A%09Uid        uint32%0A%09Gid        uint32%0A%09Rdev       uint32%0A%09Pad1       %5B3%5Duint32%0A%09Size       int64%0A%09Atime      uint32%0A%09Atime_nsec uint32%0A%09Mtime      uint32%0A%09Mtime_nsec uint32%0A%09Ctime      uint32%0A%09Ctime_nsec uint32%0A%09Blksize    uint32%0A%09Pad2       uint32%0A%09Blocks     int64%0A%7D%0A%0A//sys%09fstat(fd int, st *stat_t) (err error)%0A//sys%09lstat(path string, st *stat_t) (err error)%0A//sys%09stat(path string, st *stat_t) (err error)%0A%0Afunc Fstat(fd int, s *Stat_t) (err error) %7B%0A%09st := &stat_t%7B%7D%0A%09err = fstat(fd, st)%0A%09fillStat_t(s, st)%0A%09return%0A%7D%0A%0Afunc Lstat(path string, s *Stat_t) (err error) %7B%0A%09st := &stat_t%7B%7D%0A%09err = lstat(path, st)%0A%09fillStat_t(s, st)%0A%09return%0A%7D%0A%0Afunc Stat(path string, s *Stat_t) (err error) %7B%0A%09st := &stat_t%7B%7D%0A%09err = stat(path, st)%0A%09fillStat_t(s, st)%0A%09return%0A%7D%0A%0Afunc fillStat_t(s *Stat_t, st *stat_t) %7B%0A%09s.Dev = st.Dev%0A%09s.Ino = st.Ino%0A%09s.Mode = st.Mode%0A%09s.Nlink = st.Nlink%0A%09s.Uid = st.Uid%0A%09s.Gid = st.Gid%0A%09s.Rdev = st.Rdev%0A%09s.Size = st.Size%0A%09s.Atim = Timespec%7Bint64(st.Atime), int64(st.Atime_nsec)%7D%0A%09s.Mtim = Timespec%7Bint64(st.Mtime), int64(st.Mtime_nsec)%7D%0A%09s.Ctim = Timespec%7Bint64(st.Ctime), int64(st.Ctime_nsec)%7D%0A%09s.Blksize = st.Blksize%0A%09s.Blocks = st.Blocks%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Epc %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Epc = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 7b517e7c9499453786818d0a2f5eb18aeb02d6322a6392e83bf545b1c7da17ec vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go
+ f e553ff7b8e7b6d8628e8f6aa1578fde79fe4579b0f5dfc75a81882b5e5f50e41 vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go
dmppatch 3
@@ -209,6830 +209,4 @@
 nix%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error) = SYS_FTRUNCATE64%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)%0A%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error) = SYS_TRUNCATE64%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Ioperm(from int, num int, on int) (err error)%0A//sys%09Iopl(level int) (err error)%0A%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Time(t *Time_t) (tt Time_t, err error)%0A%0A//sys%09Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64%0A//sys%09Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sys%09Stat(path string, stat *Stat_t) (err error) = SYS_STAT64%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Pause() (err error)%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e := Syscall(SYS_FSTATFS64, uintptr(fd), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = errnoErr(e)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09p, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09_, _, e := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(p)), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = errnoErr(e)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09_, _, e := Syscall6(SYS__LLSEEK, uintptr(fd), uintptr(offset%3E%3E32), uintptr(offset), uintptr(unsafe.Pointer(&off)), uintptr(whence), 0)%0A%09if e != 0 %7B%0A%09%09err = errnoErr(e)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sys%09mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error)%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09page := uintptr(offset / 4096)%0A%09if offset != int64(page)*4096 %7B%0A%09%09return 0, EINVAL%0A%09%7D%0A%09return mmap2(addr, length, prot, flags, fd, page)%0A%7D%0A%0Aconst rlimInf32 = %5Euint32(0)%0Aconst rlimInf64 = %5Euint64(0)%0A%0Atype rlimit32 struct %7B%0A%09Cur uint32%0A%09Max uint32%0A%7D%0A%0A//sysnb getrlimit(resource int, rlim *rlimit32) (err error) = SYS_GETRLIMIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, nil, rlim)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09err = getrlimit(resource, &rl)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09if rl.Cur == rlimInf32 %7B%0A%09%09rlim.Cur = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Cur = uint64(rl.Cur)%0A%09%7D%0A%0A%09if rl.Max == rlimInf32 %7B%0A%09%09rlim.Max = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Max = uint64(rl.Max)%0A%09%7D%0A%09return%0A%7D%0A%0A//sysnb setrlimit(resource int, rlim *rlimit32) (err error) = SYS_SETRLIMIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, rlim, nil)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09if rlim.Cur == rlimInf64 %7B%0A%09%09rl.Cur = rlimInf32%0A%09%7D else if rlim.Cur %3C uint64(rlimInf32) %7B%0A%09%09rl.Cur = uint32(rlim.Cur)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%09if rlim.Max == rlimInf64 %7B%0A%09%09rl.Max = rlimInf32%0A%09%7D else if rlim.Max %3C uint64(rlimInf32) %7B%0A%09%09rl.Max = uint32(rlim.Max)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09return setrlimit(resource, &rl)%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Epc %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Epc = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f a0383ebfc12cd14b3864359f96ec027a7ebaa446bfac1f0021324bbbf716ddc3 vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go
+ f 0127c79405fd6f3d87b9bc46a6c1f6518fe31d5e18fe92484f961827fa50d617 vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go
dmppatch 3
@@ -211,4805 +211,4 @@
 nix%0A
-%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_NEWFSTATAT%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error) = SYS_UGETRLIMIT%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Ioperm(from int, num int, on int) (err error)%0A//sys%09Iopl(level int) (err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error) = SYS_SYNC_FILE_RANGE2%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Time(t *Time_t) (tt Time_t, err error)%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Nip %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Nip = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A//sysnb pipe(p *%5B2%5D_C_int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 21129304bfa33e9994425bfdeb6009553bf3fd6b580125e45fc4cea5fd42ac0a vendor/golang.org/x/sys/unix/syscall_linux_s390x.go
+ f 58702bfddf11ccfc5748c73bb3c9c4b0f49608c0d5055f79c0b24b37e2930fe8 vendor/golang.org/x/sys/unix/syscall_linux_s390x.go
dmppatch 3
@@ -193,9688 +193,4 @@
 nix%0A
-%0Aimport (%0A%09%22unsafe%22%0A)%0A%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_NEWFSTATAT%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09var tv Timeval%0A%09err = Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0) // pipe2 is the same as pipe when flags are set to 0.%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Afunc Iopl(level int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Psw.Addr %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Psw.Addr = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A// Linux on s390x uses the old mmap interface, which requires arguments to be passed in a struct.%0A// mmap2 also requires arguments to be passed in a struct; it is currently not exposed in %3Casm/unistd.h%3E.%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09mmap_args := %5B6%5Duintptr%7Baddr, length, uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset)%7D%0A%09r0, _, e1 := Syscall(SYS_MMAP, uintptr(unsafe.Pointer(&mmap_args%5B0%5D)), 0, 0)%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// On s390x Linux, all the socket calls go through an extra indirection.%0A// The arguments to the underlying system call (SYS_SOCKETCALL) are the%0A// number below and a pointer to an array of uintptr.%0Aconst (%0A%09// see linux/net.h%0A%09netSocket      = 1%0A%09netBind        = 2%0A%09netConnect     = 3%0A%09netListen      = 4%0A%09netAccept      = 5%0A%09netGetSockName = 6%0A%09netGetPeerName = 7%0A%09netSocketPair  = 8%0A%09netSend        = 9%0A%09netRecv        = 10%0A%09netSendTo      = 11%0A%09netRecvFrom    = 12%0A%09netShutdown    = 13%0A%09netSetSockOpt  = 14%0A%09netGetSockOpt  = 15%0A%09netSendMsg     = 16%0A%09netRecvMsg     = 17%0A%09netAccept4     = 18%0A%09netRecvMMsg    = 19%0A%09netSendMMsg    = 20%0A)%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (int, error) %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen))%7D%0A%09fd, _, err := Syscall(SYS_SOCKETCALL, netAccept, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(fd), nil%0A%7D%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (int, error) %7B%0A%09args := %5B4%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags)%7D%0A%09fd, _, err := Syscall(SYS_SOCKETCALL, netAccept4, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(fd), nil%0A%7D%0A%0Afunc getsockname(s int, rsa *RawSockaddrAny, addrlen *_Socklen) error %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen))%7D%0A%09_, _, err := RawSyscall(SYS_SOCKETCALL, netGetSockName, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc getpeername(s int, rsa *RawSockaddrAny, addrlen *_Socklen) error %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen))%7D%0A%09_, _, err := RawSyscall(SYS_SOCKETCALL, netGetPeerName, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc socketpair(domain int, typ int, flags int, fd *%5B2%5Dint32) error %7B%0A%09args := %5B4%5Duintptr%7Buintptr(domain), uintptr(typ), uintptr(flags), uintptr(unsafe.Pointer(fd))%7D%0A%09_, _, err := RawSyscall(SYS_SOCKETCALL, netSocketPair, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) error %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(addr), uintptr(addrlen)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netBind, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) error %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(addr), uintptr(addrlen)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netConnect, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc socket(domain int, typ int, proto int) (int, error) %7B%0A%09args := %5B3%5Duintptr%7Buintptr(domain), uintptr(typ), uintptr(proto)%7D%0A%09fd, _, err := RawSyscall(SYS_SOCKETCALL, netSocket, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(fd), nil%0A%7D%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) error %7B%0A%09args := %5B5%5Duintptr%7Buintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen))%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netGetSockOpt, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) error %7B%0A%09args := %5B4%5Duintptr%7Buintptr(s), uintptr(level), uintptr(name), uintptr(val)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netSetSockOpt, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc recvfrom(s int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (int, error) %7B%0A%09var base uintptr%0A%09if len(p) %3E 0 %7B%0A%09%09base = uintptr(unsafe.Pointer(&p%5B0%5D))%0A%09%7D%0A%09args := %5B6%5Duintptr%7Buintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen))%7D%0A%09n, _, err := Syscall(SYS_SOCKETCALL, netRecvFrom, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(n), nil%0A%7D%0A%0Afunc sendto(s int, p %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) error %7B%0A%09var base uintptr%0A%09if len(p) %3E 0 %7B%0A%09%09base = uintptr(unsafe.Pointer(&p%5B0%5D))%0A%09%7D%0A%09args := %5B6%5Duintptr%7Buintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(to), uintptr(addrlen)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netSendTo, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (int, error) %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags)%7D%0A%09n, _, err := Syscall(SYS_SOCKETCALL, netRecvMsg, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(n), nil%0A%7D%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (int, error) %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags)%7D%0A%09n, _, err := Syscall(SYS_SOCKETCALL, netSendMsg, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(n), nil%0A%7D%0A%0Afunc Listen(s int, n int) error %7B%0A%09args := %5B2%5Duintptr%7Buintptr(s), uintptr(n)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netListen, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc Shutdown(s, how int) error %7B%0A%09args := %5B2%5Duintptr%7Buintptr(s), uintptr(how)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netShutdown, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 146a666dcdc410e4e2d42146599c92062f3029d34548c040a18a85093ea5c430 vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go
+ f b563153960d2b6724c6f79ed0a64f2531687e68c84af4929282d49157cb8ff1b vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go
dmppatch 3
@@ -195,4939 +195,4 @@
 nix%0A
-%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Afunc Iopl(level int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09var tv Timeval%0A%09err = Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Tpc %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Tpc = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A//sysnb pipe(p *%5B2%5D_C_int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 57994e3553c6ced210e424cb2c03625440d1e69d9fb3cf6195ca253bbaf10cbe vendor/golang.org/x/sys/unix/syscall_netbsd.go
+ f cd458b5e34dac9e84ef3784925462d237cdfb4920d33c687972beb2cb2605c8d vendor/golang.org/x/sys/unix/syscall_netbsd.go
dmppatch 16
@@ -516,19 +516,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -529,3083 +529,71 @@
 %0A)%0A%0A
-// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0Afunc Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0Afunc sysctlNodes(mib %5B%5D_C_int) (nodes %5B%5DSysctlnode, err error) %7B%0A%09var olen uintptr%0A%0A%09// Get a list of all sysctl nodes below the given MIB by performing%0A%09// a sysctl for the given MIB with CTL_QUERY appended.%0A%09mib = append(mib, CTL_QUERY)%0A%09qnode := Sysctlnode%7BFlags: SYSCTL_VERS_1%7D%0A%09qp := (*byte)(unsafe.Pointer(&qnode))%0A%09sz := unsafe.Sizeof(qnode)%0A%09if err = sysctl(mib, nil, &olen, qp, sz); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Now that we know the size, get the actual nodes.%0A%09nodes = make(%5B%5DSysctlnode, olen/sz)%0A%09np := (*byte)(unsafe.Pointer(&nodes%5B0%5D))%0A%09if err = sysctl(mib, np, &olen, qp, sz); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return nodes, nil%0A%7D%0A%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09// Split name into components.%0A%09var parts %5B%5Dstring%0A%09last := 0%0A%09for i := 0; i %3C len(name); i++ %7B%0A%09%09if name%5Bi%5D == '.' %7B%0A%09%09%09parts = append(parts, name%5Blast:i%5D)%0A%09%09%09last = i + 1%0A%09%09%7D%0A%09%7D%0A%09parts = append(parts, name%5Blast:%5D)%0A%0A%09// Discover the nodes and construct the MIB OID.%0A%09for partno, part := range parts %7B%0A%09%09nodes, err := sysctlNodes(mib)%0A%09%09if err != nil %7B%0A%09%09%09return nil, err%0A%09%09%7D%0A%09%09for _, node := range nodes %7B%0A%09%09%09n := make(%5B%5Dbyte, 0)%0A%09%09%09for i := range node.Name %7B%0A%09%09%09%09if node.Name%5Bi%5D != 0 %7B%0A%09%09%09%09%09n = append(n, byte(node.Name%5Bi%5D))%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09if string(n) == part %7B%0A%09%09%09%09mib = append(mib, _C_int(node.Num))%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%7D%0A%09%09if len(mib) != partno+1 %7B%0A%09%09%09return nil, EINVAL%0A%09%09%7D%0A%09%7D%0A%0A%09return mib, nil%0A%7D%0A%0A//sysnb pipe() (fd1 int, fd2 int, err error)%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09p%5B0%5D, p%5B1%5D, err = pipe()%0A%09return%0A%7D%0A%0A//sys getdents(fd int, buf %5B%5Dbyte) (n int, err error)%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09return getdents(fd, buf)%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error) = SYS___GETCWD%0A%0Afunc Getwd() (string, error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09_, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0A// TODO%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09return -1, ENOSYS%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09// used on Darwin for UtimesNano%0A%09return ENOSYS%0A%7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc IoctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A
+func ioctlSetTermios(fd int, req uint, value *Termios) error %7B%0A
 %09ret
@@ -650,548 +650,8 @@
 %0A%7D%0A%0A
-func IoctlSetTermios(fd int, req uint, value *Termios) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func
@@ -806,9475 +806,4 @@
 r%0A%7D%0A
-%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctl(mib, &uname.Sysname%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctl(mib, &uname.Nodename%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctl(mib, &uname.Release%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctl(mib, &uname.Version%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctl(mib, &uname.Machine%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_POSIX_FADVISE%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Issetugid() (tainted bool)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys%09munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0A/*%0A * Unimplemented%0A */%0A// ____semctl13%0A// __clone%0A// __fhopen40%0A// __fhstat40%0A// __fhstatvfs140%0A// __fstat30%0A// __getcwd%0A// __getfh30%0A// __getlogin%0A// __lstat30%0A// __mount50%0A// __msgctl13%0A// __msync13%0A// __ntp_gettime30%0A// __posix_chown%0A// __posix_fchown%0A// __posix_lchown%0A// __posix_rename%0A// __setlogin%0A// __shmctl13%0A// __sigaction_sigtramp%0A// __sigaltstack14%0A// __sigpending14%0A// __sigprocmask14%0A// __sigsuspend14%0A// __sigtimedwait%0A// __stat30%0A// __syscall%0A// __vfork14%0A// _ksem_close%0A// _ksem_destroy%0A// _ksem_getvalue%0A// _ksem_init%0A// _ksem_open%0A// _ksem_post%0A// _ksem_trywait%0A// _ksem_unlink%0A// _ksem_wait%0A// _lwp_continue%0A// _lwp_create%0A// _lwp_ctl%0A// _lwp_detach%0A// _lwp_exit%0A// _lwp_getname%0A// _lwp_getprivate%0A// _lwp_kill%0A// _lwp_park%0A// _lwp_self%0A// _lwp_setname%0A// _lwp_setprivate%0A// _lwp_suspend%0A// _lwp_unpark%0A// _lwp_unpark_all%0A// _lwp_wait%0A// _lwp_wakeup%0A// _pset_bind%0A// _sched_getaffinity%0A// _sched_getparam%0A// _sched_setaffinity%0A// _sched_setparam%0A// acct%0A// aio_cancel%0A// aio_error%0A// aio_fsync%0A// aio_read%0A// aio_return%0A// aio_suspend%0A// aio_write%0A// break%0A// clock_getres%0A// clock_gettime%0A// clock_settime%0A// compat_09_ogetdomainname%0A// compat_09_osetdomainname%0A// compat_09_ouname%0A// compat_10_omsgsys%0A// compat_10_osemsys%0A// compat_10_oshmsys%0A// compat_12_fstat12%0A// compat_12_getdirentries%0A// compat_12_lstat12%0A// compat_12_msync%0A// compat_12_oreboot%0A// compat_12_oswapon%0A// compat_12_stat12%0A// compat_13_sigaction13%0A// compat_13_sigaltstack13%0A// compat_13_sigpending13%0A// compat_13_sigprocmask13%0A// compat_13_sigreturn13%0A// compat_13_sigsuspend13%0A// compat_14___semctl%0A// compat_14_msgctl%0A// compat_14_shmctl%0A// compat_16___sigaction14%0A// compat_16___sigreturn14%0A// compat_20_fhstatfs%0A// compat_20_fstatfs%0A// compat_20_getfsstat%0A// compat_20_statfs%0A// compat_30___fhstat30%0A// compat_30___fstat13%0A// compat_30___lstat13%0A// compat_30___stat13%0A// compat_30_fhopen%0A// compat_30_fhstat%0A// compat_30_fhstatvfs1%0A// compat_30_getdents%0A// compat_30_getfh%0A// compat_30_ntp_gettime%0A// compat_30_socket%0A// compat_40_mount%0A// compat_43_fstat43%0A// compat_43_lstat43%0A// compat_43_oaccept%0A// compat_43_ocreat%0A// compat_43_oftruncate%0A// compat_43_ogetdirentries%0A// compat_43_ogetdtablesize%0A// compat_43_ogethostid%0A// compat_43_ogethostname%0A// compat_43_ogetkerninfo%0A// compat_43_ogetpagesize%0A// compat_43_ogetpeername%0A// compat_43_ogetrlimit%0A// compat_43_ogetsockname%0A// compat_43_okillpg%0A// compat_43_olseek%0A// compat_43_ommap%0A// compat_43_oquota%0A// compat_43_orecv%0A// compat_43_orecvfrom%0A// compat_43_orecvmsg%0A// compat_43_osend%0A// compat_43_osendmsg%0A// compat_43_osethostid%0A// compat_43_osethostname%0A// compat_43_osetrlimit%0A// compat_43_osigblock%0A// compat_43_osigsetmask%0A// compat_43_osigstack%0A// compat_43_osigvec%0A// compat_43_otruncate%0A// compat_43_owait%0A// compat_43_stat43%0A// execve%0A// extattr_delete_fd%0A// extattr_delete_file%0A// extattr_delete_link%0A// extattr_get_fd%0A// extattr_get_file%0A// extattr_get_link%0A// extattr_list_fd%0A// extattr_list_file%0A// extattr_list_link%0A// extattr_set_fd%0A// extattr_set_file%0A// extattr_set_link%0A// extattrctl%0A// fchroot%0A// fdatasync%0A// fgetxattr%0A// fktrace%0A// flistxattr%0A// fork%0A// fremovexattr%0A// fsetxattr%0A// fstatvfs1%0A// fsync_range%0A// getcontext%0A// getitimer%0A// getvfsstat%0A// getxattr%0A// ktrace%0A// lchflags%0A// lchmod%0A// lfs_bmapv%0A// lfs_markv%0A// lfs_segclean%0A// lfs_segwait%0A// lgetxattr%0A// lio_listio%0A// listxattr%0A// llistxattr%0A// lremovexattr%0A// lseek%0A// lsetxattr%0A// lutimes%0A// madvise%0A// mincore%0A// minherit%0A// modctl%0A// mq_close%0A// mq_getattr%0A// mq_notify%0A// mq_open%0A// mq_receive%0A// mq_send%0A// mq_setattr%0A// mq_timedreceive%0A// mq_timedsend%0A// mq_unlink%0A// mremap%0A// msgget%0A// msgrcv%0A// msgsnd%0A// nfssvc%0A// ntp_adjtime%0A// pmc_control%0A// pmc_get_info%0A// pollts%0A// preadv%0A// profil%0A// pselect%0A// pset_assign%0A// pset_create%0A// pset_destroy%0A// ptrace%0A// pwritev%0A// quotactl%0A// rasctl%0A// readv%0A// reboot%0A// removexattr%0A// sa_enable%0A// sa_preempt%0A// sa_register%0A// sa_setconcurrency%0A// sa_stacks%0A// sa_yield%0A// sbrk%0A// sched_yield%0A// semconfig%0A// semget%0A// semop%0A// setcontext%0A// setitimer%0A// setxattr%0A// shmat%0A// shmdt%0A// shmget%0A// sstk%0A// statvfs1%0A// swapctl%0A// sysarch%0A// syscall%0A// timer_create%0A// timer_delete%0A// timer_getoverrun%0A// timer_gettime%0A// timer_settime%0A// undelete%0A// utrace%0A// uuidgen%0A// vadvise%0A// vfork%0A// writev%0A
- f e9755f98347998d8d9dec7b722469d01144ceb05f9b6c45a14326be89d828de4 vendor/golang.org/x/sys/unix/syscall_netbsd_386.go
+ f 6d7a27c6b56b9df7cc9783eb089e02af0c66f5d111977a04c0dadb31cb810a74 vendor/golang.org/x/sys/unix/syscall_netbsd_386.go
dmppatch 3
@@ -192,544 +192,4 @@
 nix%0A
-%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = uint32(mode)%0A%09k.Flags = uint32(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f 754d0e9b12aa147a7bc0624bc773dce1b4a673ed215dcf2a76424f14b44b5f2e vendor/golang.org/x/sys/unix/syscall_netbsd_amd64.go
+ f 647aa4d6b6066b8594f6db33d2d1f62a5e2c091f4d72131f867dc6b7ba4eaee3 vendor/golang.org/x/sys/unix/syscall_netbsd_amd64.go
dmppatch 3
@@ -194,537 +194,4 @@
 nix%0A
-%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = uint32(mode)%0A%09k.Flags = uint32(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f 39aeec8bf0d4d432931663abac5cf96ec2be31e1bd214aef26dd301f9cbb2d48 vendor/golang.org/x/sys/unix/syscall_netbsd_arm.go
+ f 09bcd53a23d49dfe6dbc9e820b1e91b851e5f2ef759a4678bad8248295d259aa vendor/golang.org/x/sys/unix/syscall_netbsd_arm.go
dmppatch 3
@@ -192,544 +192,4 @@
 nix%0A
-%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = uint32(mode)%0A%09k.Flags = uint32(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f bf734aca2ceaac16db34225af8329fce207eebb9d5ccd4e7d9fb49c3a7ed6c8e vendor/golang.org/x/sys/unix/syscall_openbsd.go
+ f 902e1192fe78ec696be3f435af410b536745eb4cc4746a0c5d1c3d6aefe9c4aa vendor/golang.org/x/sys/unix/syscall_openbsd.go
dmppatch 16
@@ -517,27 +517,8 @@
 t (%0A
-%09%22sort%22%0A%09%22syscall%22%0A
 %09%22un
@@ -530,2324 +530,71 @@
 %0A)%0A%0A
-// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B24%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0Afunc Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09i := sort.Search(len(sysctlMib), func(i int) bool %7B%0A%09%09return sysctlMib%5Bi%5D.ctlname %3E= name%0A%09%7D)%0A%09if i %3C len(sysctlMib) && sysctlMib%5Bi%5D.ctlname == name %7B%0A%09%09return sysctlMib%5Bi%5D.ctloid, nil%0A%09%7D%0A%09return nil, EINVAL%0A%7D%0A%0A//sysnb pipe(p *%5B2%5D_C_int) (err error)%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sys getdents(fd int, buf %5B%5Dbyte) (n int, err error)%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09return getdents(fd, buf)%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error) = SYS___GETCWD%0A%0Afunc Getwd() (string, error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09_, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0A// TODO%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09return -1, ENOSYS%0A%7D%0A%0Afunc Getfsstat(buf %5B%5DStatfs_t, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09var bufsize uintptr%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%09bufsize = unsafe.Sizeof(Statfs_t%7B%7D) * uintptr(len(buf))%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(_p0), bufsize, uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09// used on Darwin for UtimesNano%0A%09return ENOSYS%0A%7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc IoctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A
+func ioctlSetTermios(fd int, req uint, value *Termios) error %7B%0A
 %09ret
@@ -651,548 +651,8 @@
 %0A%7D%0A%0A
-func IoctlSetTermios(fd int, req uint, value *Termios) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func
@@ -807,6443 +807,4 @@
 r%0A%7D%0A
-%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctl(mib, &uname.Sysname%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctl(mib, &uname.Nodename%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctl(mib, &uname.Release%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctl(mib, &uname.Version%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctl(mib, &uname.Machine%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatfs(fd int, stat *Statfs_t) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrtable() (rtable int, err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Issetugid() (tainted bool)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Setlogin(name string) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setrtable(rtable int) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, stat *Statfs_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys%09munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0A/*%0A * Unimplemented%0A */%0A// __getcwd%0A// __semctl%0A// __syscall%0A// __sysctl%0A// adjfreq%0A// break%0A// clock_getres%0A// clock_gettime%0A// clock_settime%0A// closefrom%0A// execve%0A// faccessat%0A// fchmodat%0A// fchownat%0A// fcntl%0A// fhopen%0A// fhstat%0A// fhstatfs%0A// fork%0A// fstatat%0A// futimens%0A// getfh%0A// getgid%0A// getitimer%0A// getlogin%0A// getresgid%0A// getresuid%0A// getthrid%0A// ktrace%0A// lfs_bmapv%0A// lfs_markv%0A// lfs_segclean%0A// lfs_segwait%0A// linkat%0A// mincore%0A// minherit%0A// mkdirat%0A// mkfifoat%0A// mknodat%0A// mount%0A// mquery%0A// msgctl%0A// msgget%0A// msgrcv%0A// msgsnd%0A// nfssvc%0A// nnpfspioctl%0A// openat%0A// preadv%0A// profil%0A// pwritev%0A// quotactl%0A// readlinkat%0A// readv%0A// reboot%0A// renameat%0A// rfork%0A// sched_yield%0A// semget%0A// semop%0A// setgroups%0A// setitimer%0A// setsockopt%0A// shmat%0A// shmctl%0A// shmdt%0A// shmget%0A// sigaction%0A// sigaltstack%0A// sigpending%0A// sigprocmask%0A// sigreturn%0A// sigsuspend%0A// symlinkat%0A// sysarch%0A// syscall%0A// threxit%0A// thrsigdivert%0A// thrsleep%0A// thrwakeup%0A// unlinkat%0A// vfork%0A// writev%0A
- f a241460c7c9f9d6fd94840552f5e90ae4d25cec35ed6292f05a088435a30c352 vendor/golang.org/x/sys/unix/syscall_openbsd_386.go
+ f f24d3e4e70cf48af0718b8a5e705a5f81a609683bcfaab93355137920e584909 vendor/golang.org/x/sys/unix/syscall_openbsd_386.go
dmppatch 3
@@ -193,543 +193,4 @@
 nix%0A
-%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f a215705939fa54c9d82069268156792168b19b4914f1830c90e3b0249214b785 vendor/golang.org/x/sys/unix/syscall_openbsd_amd64.go
+ f b6366ba1c188dd355f85825a335ff7217f0b5d41cdaf590ea6dfb4d3d09a7725 vendor/golang.org/x/sys/unix/syscall_openbsd_amd64.go
dmppatch 3
@@ -195,529 +195,4 @@
 nix%0A
-%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f 2d4efc2a522160f6d70eeb886dfcd1d9199394a93f2c6b570b4a50ca152d046b vendor/golang.org/x/sys/unix/syscall_openbsd_arm.go
+ f 4257b297f03876e43901c38b6b37de45563bf883b398a5452eb4bc0d31452ef5 vendor/golang.org/x/sys/unix/syscall_openbsd_arm.go
dmppatch 3
@@ -193,543 +193,4 @@
 nix%0A
-%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f 0ba488ef661ba4bf27dff142e887e6c12e81e1a1f843911949509b0ebfdefb3d vendor/golang.org/x/sys/unix/syscall_solaris.go
+ f 7b76a190e35094e62f5a27dac83ecd13f5b1144bbf85681ebb91f4dc6a65400a vendor/golang.org/x/sys/unix/syscall_solaris.go
dmppatch 16
@@ -516,19 +516,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -529,12855 +529,77 @@
 %0A)%0A%0A
-// Implemented in runtime/syscall_solaris.go.%0Atype syscallFunc uintptr%0A%0Afunc rawSysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)%0Afunc sysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0A// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Family uint16%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B244%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0A//sysnb%09pipe(p *%5B2%5D_C_int) (n int, err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09n, err := pipe(&pp)%0A%09if n != 0 %7B%0A%09%09return err%0A%09%7D%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return nil%0A%7D%0A%0Afunc (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet4, nil%0A%7D%0A%0Afunc (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET6%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09sa.raw.Scope_id = sa.ZoneId%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet6, nil%0A%7D%0A%0Afunc (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09name := sa.Name%0A%09n := len(name)%0A%09if n %3E= len(sa.raw.Path) %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_UNIX%0A%09for i := 0; i %3C n; i++ %7B%0A%09%09sa.raw.Path%5Bi%5D = int8(name%5Bi%5D)%0A%09%7D%0A%09// length is family (uint16), name, NUL.%0A%09sl := _Socklen(2)%0A%09if n %3E 0 %7B%0A%09%09sl += _Socklen(n) + 1%0A%09%7D%0A%09if sa.raw.Path%5B0%5D == '@' %7B%0A%09%09sa.raw.Path%5B0%5D = 0%0A%09%09// Don't count trailing NUL for abstract address.%0A%09%09sl--%0A%09%7D%0A%0A%09return unsafe.Pointer(&sa.raw), sl, nil%0A%7D%0A%0A//sys%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) = libsocket.getsockname%0A%0Afunc Getsockname(fd int) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if err = getsockname(fd, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return anyToSockaddr(&rsa)%0A%7D%0A%0A// GetsockoptString returns the string value of the socket option opt for the%0A// socket associated with fd at the given socket level.%0Afunc GetsockoptString(fd, level, opt int) (string, error) %7B%0A%09buf := make(%5B%5Dbyte, 256)%0A%09vallen := _Socklen(len(buf))%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&buf%5B0%5D), &vallen)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09return string(buf%5B:vallen-1%5D), nil%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error)%0A%0Afunc Getwd() (wd string, err error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09// Getcwd will return an error if it failed for any reason.%0A%09_, err = Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0A/*%0A * Wrapped%0A */%0A%0A//sysnb%09getgroups(ngid int, gid *_Gid_t) (n int, err error)%0A//sysnb%09setgroups(ngid int, gid *_Gid_t) (err error)%0A%0Afunc Getgroups() (gids %5B%5Dint, err error) %7B%0A%09n, err := getgroups(0, nil)%0A%09// Check for error and sanity check group count. Newer versions of%0A%09// Solaris allow up to 1024 (NGROUPS_MAX).%0A%09if n %3C 0 %7C%7C n %3E 1024 %7B%0A%09%09if err != nil %7B%0A%09%09%09return nil, err%0A%09%09%7D%0A%09%09return nil, EINVAL%0A%09%7D else if n == 0 %7B%0A%09%09return nil, nil%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, n)%0A%09n, err = getgroups(n, &a%5B0%5D)%0A%09if n == -1 %7B%0A%09%09return nil, err%0A%09%7D%0A%09gids = make(%5B%5Dint, n)%0A%09for i, v := range a%5B0:n%5D %7B%0A%09%09gids%5Bi%5D = int(v)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setgroups(gids %5B%5Dint) (err error) %7B%0A%09if len(gids) == 0 %7B%0A%09%09return setgroups(0, nil)%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, len(gids))%0A%09for i, v := range gids %7B%0A%09%09a%5Bi%5D = _Gid_t(v)%0A%09%7D%0A%09return setgroups(len(a), &a%5B0%5D)%0A%7D%0A%0Afunc ReadDirent(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09// Final argument is (basep *uintptr) and the syscall doesn't take nil.%0A%09// TODO(rsc): Can we use a single global basep for all calls?%0A%09return Getdents(fd, buf, new(uintptr))%0A%7D%0A%0A// Wait status is 7 bits at bottom, either 0 (exited),%0A// 0x7F (stopped), or a signal number that caused an exit.%0A// The 0x80 bit is whether there was a core dump.%0A// An extra number (exit code, signal causing a stop)%0A// is in the high bits.%0A%0Atype WaitStatus uint32%0A%0Aconst (%0A%09mask  = 0x7F%0A%09core  = 0x80%0A%09shift = 8%0A%0A%09exited  = 0%0A%09stopped = 0x7F%0A)%0A%0Afunc (w WaitStatus) Exited() bool %7B return w&mask == exited %7D%0A%0Afunc (w WaitStatus) ExitStatus() int %7B%0A%09if w&mask != exited %7B%0A%09%09return -1%0A%09%7D%0A%09return int(w %3E%3E shift)%0A%7D%0A%0Afunc (w WaitStatus) Signaled() bool %7B return w&mask != stopped && w&mask != 0 %7D%0A%0Afunc (w WaitStatus) Signal() syscall.Signal %7B%0A%09sig := syscall.Signal(w & mask)%0A%09if sig == stopped %7C%7C sig == 0 %7B%0A%09%09return -1%0A%09%7D%0A%09return sig%0A%7D%0A%0Afunc (w WaitStatus) CoreDump() bool %7B return w.Signaled() && w&core != 0 %7D%0A%0Afunc (w WaitStatus) Stopped() bool %7B return w&mask == stopped && syscall.Signal(w%3E%3Eshift) != SIGSTOP %7D%0A%0Afunc (w WaitStatus) Continued() bool %7B return w&mask == stopped && syscall.Signal(w%3E%3Eshift) == SIGSTOP %7D%0A%0Afunc (w WaitStatus) StopSignal() syscall.Signal %7B%0A%09if !w.Stopped() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w%3E%3Eshift) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) TrapCause() int %7B return -1 %7D%0A%0A//sys%09wait4(pid int32, statusp *_C_int, options int, rusage *Rusage) (wpid int32, err error)%0A%0Afunc Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (int, error) %7B%0A%09var status _C_int%0A%09rpid, err := wait4(int32(pid), &status, options, rusage)%0A%09wpid := int(rpid)%0A%09if wpid == -1 %7B%0A%09%09return wpid, err%0A%09%7D%0A%09if wstatus != nil %7B%0A%09%09*wstatus = WaitStatus(status)%0A%09%7D%0A%09return wpid, nil%0A%7D%0A%0A//sys%09gethostname(buf %5B%5Dbyte) (n int, err error)%0A%0Afunc Gethostname() (name string, err error) %7B%0A%09var buf %5BMaxHostNameLen%5Dbyte%0A%09n, err := gethostname(buf%5B:%5D)%0A%09if n != 0 %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n = clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EFAULT%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0Afunc Utimes(path string, tv %5B%5DTimeval) (err error) %7B%0A%09if tv == nil %7B%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0A//sys%09utimensat(fd int, path string, times *%5B2%5DTimespec, flag int) (err error)%0A%0Afunc UtimesNano(path string, ts %5B%5DTimespec) error %7B%0A%09if ts == nil %7B%0A%09%09return utimensat(AT_FDCWD, path, nil, 0)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%7D%0A%0Afunc UtimesNanoAt(dirfd int, path string, ts %5B%5DTimespec, flags int) error %7B%0A%09if ts == nil %7B%0A%09%09return utimensat(dirfd, path, nil, flags)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimensat(dirfd, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), flags)%0A%7D%0A%0A//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A%0A// FcntlInt performs a fcntl syscall on fd with the provided command and argument.%0Afunc FcntlInt(fd uintptr, cmd, arg int) (int, error) %7B%0A%09valptr, _, err := sysvicall6(uintptr(unsafe.Pointer(&procfcntl)), 3, uintptr(fd), uintptr(cmd), uintptr(arg), 0, 0, 0)%0A%09return int(valptr), err%0A%7D%0A%0A// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.%0Afunc FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procfcntl)), 3, uintptr(fd), uintptr(cmd), uintptr(unsafe.Pointer(lk)), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09return e1%0A%09%7D%0A%09return nil%0A%7D%0A%0A//sys%09futimesat(fildes int, path *byte, times *%5B2%5DTimeval) (err error)%0A%0Afunc Futimesat(dirfd int, path string, tv %5B%5DTimeval) error %7B%0A%09pathp, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if tv == nil %7B%0A%09%09return futimesat(dirfd, pathp, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return futimesat(dirfd, pathp, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0A// Solaris doesn't have an futimes function because it allows NULL to be%0A// specified as the path for futimesat. However, Go doesn't like%0A// NULL-style string interfaces, so this simple wrapper is provided.%0Afunc Futimes(fd int, tv %5B%5DTimeval) error %7B%0A%09if tv == nil %7B%0A%09%09return futimesat(fd, nil, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return futimesat(fd, nil, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, error) %7B%0A%09switch rsa.Addr.Family %7B%0A%09case AF_UNIX:%0A%09%09pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrUnix)%0A%09%09// Assume path ends at NUL.%0A%09%09// This is not technically the Solaris semantics for%0A%09%09// abstract Unix domain sockets -- they are supposed%0A%09%09// to be uninterpreted fixed-size binary blobs -- but%0A%09%09// everyone uses this convention.%0A%09%09n := 0%0A%09%09for n %3C len(pp.Path) && pp.Path%5Bn%5D != 0 %7B%0A%09%09%09n++%0A%09%09%7D%0A%09%09bytes := (*%5B10000%5Dbyte)(unsafe.Pointer(&pp.Path%5B0%5D))%5B0:n%5D%0A%09%09sa.Name = string(bytes)%0A%09%09return sa, nil%0A%0A%09case AF_INET:%0A%09%09pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet4)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_INET6:%0A%09%09pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet6)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09sa.ZoneId = pp.Scope_id%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%09%7D%0A%09return nil, EAFNOSUPPORT%0A%7D%0A%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) = libsocket.accept%0A%0Afunc Accept(fd int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept(fd, &rsa, &len)%0A%09if nfd == -1 %7B%0A%09%09return%0A%09%7D%0A%09sa, err = anyToSockaddr(&rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error) = libsocket.__xnet_recvmsg%0A%0Afunc Recvmsg(fd int, p, oob %5B%5Dbyte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) %7B%0A%09var msg Msghdr%0A%09var rsa RawSockaddrAny%0A%09msg.Name = (*byte)(unsafe.Pointer(&rsa))%0A%09msg.Namelen = uint32(SizeofSockaddrAny)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = (*int8)(unsafe.Pointer(&p%5B0%5D))%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy int8%0A%09if len(oob) %3E 0 %7B%0A%09%09// receive at least one normal byte%0A%09%09if len(p) == 0 %7B%0A%09%09%09iov.Base = &dummy%0A%09%09%09iov.SetLen(1)%0A%09%09%7D%0A%09%09msg.Accrightslen = int32(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = recvmsg(fd, &msg, flags); n == -1 %7B%0A%09%09return%0A%09%7D%0A%09oobn = int(msg.Accrightslen)%0A%09// source address is only specified if the socket is unconnected%0A%09if rsa.Addr.Family != AF_UNSPEC %7B%0A%09%09from, err = anyToSockaddr(&rsa)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sendmsg(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (err error) %7B%0A%09_, err = SendmsgN(fd, p, oob, to, flags)%0A%09return%0A%7D%0A%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error) = libsocket.__xnet_sendmsg%0A%0Afunc SendmsgN(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (n int, err error) %7B%0A%09var ptr unsafe.Pointer%0A%09var salen _Socklen%0A%09if to != nil %7B%0A%09%09ptr, salen, err = to.sockaddr()%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%7D%0A%09var msg Msghdr%0A%09msg.Name = (*byte)(unsafe.Pointer(ptr))%0A%09msg.Namelen = uint32(salen)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = (*int8)(unsafe.Pointer(&p%5B0%5D))%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy int8%0A%09if len(oob) %3E 0 %7B%0A%09%09// send at least one normal byte%0A%09%09if len(p) == 0 %7B%0A%09%09%09iov.Base = &dummy%0A%09%09%09iov.SetLen(1)%0A%09%09%7D%0A%09%09msg.Accrightslen = int32(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = sendmsg(fd, &msg, flags); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if len(oob) %3E 0 && len(p) == 0 %7B%0A%09%09n = 0%0A%09%7D%0A%09return n, nil%0A%7D%0A%0A//sys%09acct(path *byte) (err error)%0A%0Afunc Acct(path string) (err error) %7B%0A%09if len(path) == 0 %7B%0A%09%09// Assume caller wants to disable accounting.%0A%09%09return acct(nil)%0A%09%7D%0A%0A%09pathp, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return acct(pathp)%0A%7D%0A%0A//sys%09__makedev(version int, major uint, minor uint) (val uint64)%0A%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09return __makedev(NEWDEV, uint(major), uint(minor))%0A%7D%0A%0A//sys%09__major(version int, dev uint64) (val uint)%0A%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32(__major(NEWDEV, dev))%0A%7D%0A%0A//sys%09__minor(version int, dev uint64) (val uint)%0A%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32(__minor(NEWDEV, dev))%0A%7D%0A%0A/*%0A * Expose the ioctl function%0A */%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0Afunc IoctlSetInt(fd int, req uint, value int) (err error) %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc IoctlSetWinsize(fd int, req uint, value *Winsize) (err error) %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0Afunc IoctlSetTermios(fd int, req uint, value *Termios) (err error) %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0Afunc IoctlSetTermio(fd int, req uint, value *Termio) (err error) %7B%0A
+func ioctlSetTermios(fd int, req uint, value *Termios) (err error) %7B%0A
 %09ret
@@ -656,308 +656,8 @@
 %0A%7D%0A%0A
-func IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func
@@ -812,7163 +812,4 @@
 r%0A%7D%0A
-%0Afunc IoctlGetTermio(fd int, req uint) (*Termio, error) %7B%0A%09var value Termio%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A//sys   poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Creat(path string, mode uint32) (fd int, err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)%0A//sys%09Fdatasync(fd int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatvfs(fd int, vfsstat *Statvfs_t) (err error)%0A//sys%09Getdents(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgid int, err error)%0A//sys%09Geteuid() (euid int)%0A//sys%09Getegid() (egid int)%0A//sys%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (n int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Listen(s int, backlog int) (err error) = libsocket.__xnet_llisten%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Madvise(b %5B%5Dbyte, advice int) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkdirat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mkfifoat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Mknodat(dirfd int, path string, mode uint32, dev int) (err error)%0A//sys%09Mlock(b %5B%5Dbyte) (err error)%0A//sys%09Mlockall(flags int) (err error)%0A//sys%09Mprotect(b %5B%5Dbyte, prot int) (err error)%0A//sys%09Msync(b %5B%5Dbyte, flags int) (err error)%0A//sys%09Munlock(b %5B%5Dbyte) (err error)%0A//sys%09Munlockall() (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = lseek%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Sethostname(p %5B%5Dbyte) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Shutdown(s int, how int) (err error) = libsocket.shutdown%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statvfs(path string, vfsstat *Statvfs_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Sync() (err error)%0A//sysnb%09Times(tms *Tms) (ticks uintptr, err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sys%09Umask(mask int) (oldmask int)%0A//sysnb%09Uname(buf *Utsname) (err error)%0A//sys%09Unmount(target string, flags int) (err error) = libc.umount%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unlinkat(dirfd int, path string, flags int) (err error)%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_bind%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_connect%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys%09munmap(addr uintptr, length uintptr) (err error)%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = libsendfile.sendfile%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_sendto%0A//sys%09socket(domain int, typ int, proto int) (fd int, err error) = libsocket.__xnet_socket%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) = libsocket.__xnet_socketpair%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) = libsocket.__xnet_getsockopt%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) = libsocket.getpeername%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) = libsocket.setsockopt%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) = libsocket.recvfrom%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procread)), 3, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procwrite)), 3, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Avar mapper = &mmapper%7B%0A%09active: make(map%5B*byte%5D%5B%5Dbyte),%0A%09mmap:   mmap,%0A%09munmap: munmap,%0A%7D%0A%0Afunc Mmap(fd int, offset int64, length int, prot int, flags int) (data %5B%5Dbyte, err error) %7B%0A%09return mapper.Mmap(fd, offset, length, prot, flags)%0A%7D%0A%0Afunc Munmap(b %5B%5Dbyte) (err error) %7B%0A%09return mapper.Munmap(b)%0A%7D%0A
- f e8ef5fdecd6c09589bd1f6607b4ef43b64a0e79e39214f555a676c1ec7ca6a15 vendor/golang.org/x/sys/unix/syscall_solaris_amd64.go
+ f 559dae0d71511636b654a9a0a32456ab90f2bab65aa2e328c05afdbe8cbcbaeb vendor/golang.org/x/sys/unix/syscall_solaris_amd64.go
dmppatch 3
@@ -195,315 +195,4 @@
 nix%0A
-%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f b37fe7bc76dc4b149aff09dfeb75eef67d0b621b78b65e824fb1e8e7b5d3a889 vendor/golang.org/x/sys/unix/syscall_unix.go
+ f 1cd028aaf5839194c919ff9b6e68e2d76c451f9989424af83e1d383a934dac73 vendor/golang.org/x/sys/unix/syscall_unix.go
dmppatch 19
@@ -245,44 +245,8 @@
 t (%0A
-%09%22bytes%22%0A%09%22runtime%22%0A%09%22sort%22%0A%09%22sync%22%0A
 %09%22sy
@@ -266,312 +266,8 @@
 fe%22%0A
-)%0A%0Avar (%0A%09Stdin  = 0%0A%09Stdout = 1%0A%09Stderr = 2%0A)%0A%0Aconst (%0A%09darwin64Bit    = runtime.GOOS == %22darwin%22 && sizeofPtr == 8%0A%09dragonfly64Bit = runtime.GOOS == %22dragonfly%22 && sizeofPtr == 8%0A%09netbsd32Bit    = runtime.GOOS == %22netbsd%22 && sizeofPtr == 4%0A%09solaris64Bit   = runtime.GOOS == %22solaris%22 && sizeofPtr == 8%0A
 )%0A%0A/
@@ -723,2137 +723,8 @@
 %0A%7D%0A%0A
-// ErrnoName returns the error name for error number e.%0Afunc ErrnoName(e syscall.Errno) string %7B%0A%09i := sort.Search(len(errorList), func(i int) bool %7B%0A%09%09return errorList%5Bi%5D.num %3E= e%0A%09%7D)%0A%09if i %3C len(errorList) && errorList%5Bi%5D.num == e %7B%0A%09%09return errorList%5Bi%5D.name%0A%09%7D%0A%09return %22%22%0A%7D%0A%0A// SignalName returns the signal name for signal number s.%0Afunc SignalName(s syscall.Signal) string %7B%0A%09i := sort.Search(len(signalList), func(i int) bool %7B%0A%09%09return signalList%5Bi%5D.num %3E= s%0A%09%7D)%0A%09if i %3C len(signalList) && signalList%5Bi%5D.num == s %7B%0A%09%09return signalList%5Bi%5D.name%0A%09%7D%0A%09return %22%22%0A%7D%0A%0A// clen returns the index of the first NULL byte in n or len(n) if n contains no NULL byte.%0Afunc clen(n %5B%5Dbyte) int %7B%0A%09i := bytes.IndexByte(n, 0)%0A%09if i == -1 %7B%0A%09%09i = len(n)%0A%09%7D%0A%09return i%0A%7D%0A%0A// Mmap manager, for use by operating system-specific implementations.%0A%0Atype mmapper struct %7B%0A%09sync.Mutex%0A%09active map%5B*byte%5D%5B%5Dbyte // active mappings; key is last byte in mapping%0A%09mmap   func(addr, length uintptr, prot, flags, fd int, offset int64) (uintptr, error)%0A%09munmap func(addr uintptr, length uintptr) error%0A%7D%0A%0Afunc (m *mmapper) Mmap(fd int, offset int64, length int, prot int, flags int) (data %5B%5Dbyte, err error) %7B%0A%09if length %3C= 0 %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%0A%09// Map the requested memory.%0A%09addr, errno := m.mmap(0, uintptr(length), prot, flags, fd, offset)%0A%09if errno != nil %7B%0A%09%09return nil, errno%0A%09%7D%0A%0A%09// Slice memory layout%0A%09var sl = struct %7B%0A%09%09addr uintptr%0A%09%09len  int%0A%09%09cap  int%0A%09%7D%7Baddr, length, length%7D%0A%0A%09// Use unsafe to turn sl into a %5B%5Dbyte.%0A%09b := *(*%5B%5Dbyte)(unsafe.Pointer(&sl))%0A%0A%09// Register mapping in m and return it.%0A%09p := &b%5Bcap(b)-1%5D%0A%09m.Lock()%0A%09defer m.Unlock()%0A%09m.active%5Bp%5D = b%0A%09return b, nil%0A%7D%0A%0Afunc (m *mmapper) Munmap(data %5B%5Dbyte) (err error) %7B%0A%09if len(data) == 0 %7C%7C len(data) != cap(data) %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09// Find the base of the mapping.%0A%09p := &data%5Bcap(data)-1%5D%0A%09m.Lock()%0A%09defer m.Unlock()%0A%09b := m.active%5Bp%5D%0A%09if b == nil %7C%7C &b%5B0%5D != &data%5B0%5D %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09// Unmap the memory and update m.%0A%09if errno := m.munmap(uintptr(unsafe.Pointer(&b%5B0%5D)), uintptr(len(b))); errno != nil %7B%0A%09%09return errno%0A%09%7D%0A%09delete(m.active, p)%0A%09return nil%0A%7D%0A%0A
 func
@@ -949,5693 +949,8 @@
 %0A%7D%0A%0A
-func Write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09if raceenabled %7B%0A%09%09raceReleaseMerge(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09n, err = write(fd, p)%0A%09if raceenabled && n %3E 0 %7B%0A%09%09raceReadRange(unsafe.Pointer(&p%5B0%5D), n)%0A%09%7D%0A%09return%0A%7D%0A%0A// For testing: clients can set this flag to force%0A// creation of IPv6 sockets to return EAFNOSUPPORT.%0Avar SocketDisableIPv6 bool%0A%0A// Sockaddr represents a socket address.%0Atype Sockaddr interface %7B%0A%09sockaddr() (ptr unsafe.Pointer, len _Socklen, err error) // lowercase; only we can define Sockaddrs%0A%7D%0A%0A// SockaddrInet4 implements the Sockaddr interface for AF_INET type sockets.%0Atype SockaddrInet4 struct %7B%0A%09Port int%0A%09Addr %5B4%5Dbyte%0A%09raw  RawSockaddrInet4%0A%7D%0A%0A// SockaddrInet6 implements the Sockaddr interface for AF_INET6 type sockets.%0Atype SockaddrInet6 struct %7B%0A%09Port   int%0A%09ZoneId uint32%0A%09Addr   %5B16%5Dbyte%0A%09raw    RawSockaddrInet6%0A%7D%0A%0A// SockaddrUnix implements the Sockaddr interface for AF_UNIX type sockets.%0Atype SockaddrUnix struct %7B%0A%09Name string%0A%09raw  RawSockaddrUnix%0A%7D%0A%0Afunc Bind(fd int, sa Sockaddr) (err error) %7B%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return bind(fd, ptr, n)%0A%7D%0A%0Afunc Connect(fd int, sa Sockaddr) (err error) %7B%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return connect(fd, ptr, n)%0A%7D%0A%0Afunc Getpeername(fd int) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if err = getpeername(fd, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return anyToSockaddr(&rsa)%0A%7D%0A%0Afunc GetsockoptByte(fd, level, opt int) (value byte, err error) %7B%0A%09var n byte%0A%09vallen := _Socklen(1)%0A%09err = getsockopt(fd, level, opt, unsafe.Pointer(&n), &vallen)%0A%09return n, err%0A%7D%0A%0Afunc GetsockoptInt(fd, level, opt int) (value int, err error) %7B%0A%09var n int32%0A%09vallen := _Socklen(4)%0A%09err = getsockopt(fd, level, opt, unsafe.Pointer(&n), &vallen)%0A%09return int(n), err%0A%7D%0A%0Afunc GetsockoptInet4Addr(fd, level, opt int) (value %5B4%5Dbyte, err error) %7B%0A%09vallen := _Socklen(4)%0A%09err = getsockopt(fd, level, opt, unsafe.Pointer(&value%5B0%5D), &vallen)%0A%09return value, err%0A%7D%0A%0Afunc GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error) %7B%0A%09var value IPMreq%0A%09vallen := _Socklen(SizeofIPMreq)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error) %7B%0A%09var value IPv6Mreq%0A%09vallen := _Socklen(SizeofIPv6Mreq)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error) %7B%0A%09var value IPv6MTUInfo%0A%09vallen := _Socklen(SizeofIPv6MTUInfo)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error) %7B%0A%09var value ICMPv6Filter%0A%09vallen := _Socklen(SizeofICMPv6Filter)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptLinger(fd, level, opt int) (*Linger, error) %7B%0A%09var linger Linger%0A%09vallen := _Socklen(SizeofLinger)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&linger), &vallen)%0A%09return &linger, err%0A%7D%0A%0Afunc GetsockoptTimeval(fd, level, opt int) (*Timeval, error) %7B%0A%09var tv Timeval%0A%09vallen := _Socklen(unsafe.Sizeof(tv))%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&tv), &vallen)%0A%09return &tv, err%0A%7D%0A%0Afunc Recvfrom(fd int, p %5B%5Dbyte, flags int) (n int, from Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if n, err = recvfrom(fd, p, flags, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09if rsa.Addr.Family != AF_UNSPEC %7B%0A%09%09from, err = anyToSockaddr(&rsa)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sendto(fd int, p %5B%5Dbyte, flags int, to Sockaddr) (err error) %7B%0A%09ptr, n, err := to.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return sendto(fd, p, flags, ptr, n)%0A%7D%0A%0Afunc SetsockoptByte(fd, level, opt int, value byte) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(&value), 1)%0A%7D%0A%0Afunc SetsockoptInt(fd, level, opt int, value int) (err error) %7B%0A%09var n = int32(value)%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(&n), 4)%0A%7D%0A%0Afunc SetsockoptInet4Addr(fd, level, opt int, value %5B4%5Dbyte) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(&value%5B0%5D), 4)%0A%7D%0A%0Afunc SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(mreq), SizeofIPMreq)%0A%7D%0A%0Afunc SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(mreq), SizeofIPv6Mreq)%0A%7D%0A%0Afunc SetsockoptICMPv6Filter(fd, level, opt int, filter *ICMPv6Filter) error %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(filter), SizeofICMPv6Filter)%0A%7D%0A%0Afunc SetsockoptLinger(fd, level, opt int, l *Linger) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(l), SizeofLinger)%0A%7D%0A%0Afunc SetsockoptString(fd, level, opt int, s string) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(&%5B%5Dbyte(s)%5B0%5D), uintptr(len(s)))%0A%7D%0A%0Afunc SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(tv), unsafe.Sizeof(*tv))%0A%7D%0A%0Afunc Socket(domain, typ, proto int) (fd int, err error) %7B%0A%09if domain == AF_INET6 && SocketDisableIPv6 %7B%0A%09%09return -1, EAFNOSUPPORT%0A%09%7D%0A%09fd, err = socket(domain, typ, proto)%0A%09return%0A%7D%0A%0Afunc Socketpair(domain, typ, proto int) (fd %5B2%5Dint, err error) %7B%0A%09var fdx %5B2%5Dint32%0A%09err = socketpair(domain, typ, proto, &fdx)%0A%09if err == nil %7B%0A%09%09fd%5B0%5D = int(fdx%5B0%5D)%0A%09%09fd%5B1%5D = int(fdx%5B1%5D)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09if raceenabled %7B%0A%09%09raceReleaseMerge(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09return sendfile(outfd, infd, offset, count)%0A%7D%0A%0A
 var 
@@ -966,760 +966,4 @@
 t64%0A
-%0Afunc CloseOnExec(fd int) %7B fcntl(fd, F_SETFD, FD_CLOEXEC) %7D%0A%0Afunc SetNonblock(fd int, nonblocking bool) (err error) %7B%0A%09flag, err := fcntl(fd, F_GETFL, 0)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if nonblocking %7B%0A%09%09flag %7C= O_NONBLOCK%0A%09%7D else %7B%0A%09%09flag &= %5EO_NONBLOCK%0A%09%7D%0A%09_, err = fcntl(fd, F_SETFL, flag)%0A%09return err%0A%7D%0A%0A// Exec calls execve(2), which replaces the calling executable in the process%0A// tree. argv0 should be the full path to an executable (%22/bin/ls%22) and the%0A// executable name should also be the first argument in argv (%5B%22ls%22, %22-l%22%5D).%0A// envv are the environment variables that should be passed to the new%0A// process (%5B%22USER=go%22, %22PWD=/tmp%22%5D).%0Afunc Exec(argv0 string, argv %5B%5Dstring, envv %5B%5Dstring) error %7B%0A%09return syscall.Exec(argv0, argv, envv)%0A%7D%0A
- f a6ad734e545b34d2e436990b0a62d1aa0e5f1f07fcd188431e55ccd434a087a3 vendor/golang.org/x/sys/unix/syscall_unix_gc.go
+ f 95aa35addff8e88240a81f5fa167f232eee04d64cc537e98677595b9f6e5abde vendor/golang.org/x/sys/unix/syscall_unix_gc.go
dmppatch 3
@@ -346,261 +346,4 @@
 no)%0A
-func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)%0Afunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)%0Afunc RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f 3178fac2e4c0540dd0df7f0cee18052fe12a1005bd93c1dfa9026b6f56d35953 vendor/golang.org/x/sys/unix/timestruct.go
+ f c0e181380978e721960f20eded408c817d07fdcca189cc95e92fd5377571bbae vendor/golang.org/x/sys/unix/timestruct.go
dmppatch 3
@@ -235,2308 +235,4 @@
 nix%0A
-%0Aimport %22time%22%0A%0A// TimespecToNsec converts a Timespec value into a number of%0A// nanoseconds since the Unix epoch.%0Afunc TimespecToNsec(ts Timespec) int64 %7B return int64(ts.Sec)*1e9 + int64(ts.Nsec) %7D%0A%0A// NsecToTimespec takes a number of nanoseconds since the Unix epoch%0A// and returns the corresponding Timespec value.%0Afunc NsecToTimespec(nsec int64) Timespec %7B%0A%09sec := nsec / 1e9%0A%09nsec = nsec %25 1e9%0A%09if nsec %3C 0 %7B%0A%09%09nsec += 1e9%0A%09%09sec--%0A%09%7D%0A%09return setTimespec(sec, nsec)%0A%7D%0A%0A// TimeToTimespec converts t into a Timespec.%0A// On some 32-bit systems the range of valid Timespec values are smaller%0A// than that of time.Time values.  So if t is out of the valid range of%0A// Timespec, it returns a zero Timespec and ERANGE.%0Afunc TimeToTimespec(t time.Time) (Timespec, error) %7B%0A%09sec := t.Unix()%0A%09nsec := int64(t.Nanosecond())%0A%09ts := setTimespec(sec, nsec)%0A%0A%09// Currently all targets have either int32 or int64 for Timespec.Sec.%0A%09// If there were a new target with floating point type for it, we have%0A%09// to consider the rounding error.%0A%09if int64(ts.Sec) != sec %7B%0A%09%09return Timespec%7B%7D, ERANGE%0A%09%7D%0A%09return ts, nil%0A%7D%0A%0A// TimevalToNsec converts a Timeval value into a number of nanoseconds%0A// since the Unix epoch.%0Afunc TimevalToNsec(tv Timeval) int64 %7B return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 %7D%0A%0A// NsecToTimeval takes a number of nanoseconds since the Unix epoch%0A// and returns the corresponding Timeval value.%0Afunc NsecToTimeval(nsec int64) Timeval %7B%0A%09nsec += 999 // round up to microsecond%0A%09usec := nsec %25 1e9 / 1e3%0A%09sec := nsec / 1e9%0A%09if usec %3C 0 %7B%0A%09%09usec += 1e6%0A%09%09sec--%0A%09%7D%0A%09return setTimeval(sec, usec)%0A%7D%0A%0A// Unix returns ts as the number of seconds and nanoseconds elapsed since the%0A// Unix epoch.%0Afunc (ts *Timespec) Unix() (sec int64, nsec int64) %7B%0A%09return int64(ts.Sec), int64(ts.Nsec)%0A%7D%0A%0A// Unix returns tv as the number of seconds and nanoseconds elapsed since the%0A// Unix epoch.%0Afunc (tv *Timeval) Unix() (sec int64, nsec int64) %7B%0A%09return int64(tv.Sec), int64(tv.Usec) * 1000%0A%7D%0A%0A// Nano returns ts as the number of nanoseconds elapsed since the Unix epoch.%0Afunc (ts *Timespec) Nano() int64 %7B%0A%09return int64(ts.Sec)*1e9 + int64(ts.Nsec)%0A%7D%0A%0A// Nano returns tv as the number of nanoseconds elapsed since the Unix epoch.%0Afunc (tv *Timeval) Nano() int64 %7B%0A%09return int64(tv.Sec)*1e9 + int64(tv.Usec)*1000%0A%7D%0A
- f c3a3783a479a812986ef017699be1aa0f2657f4dbb43d07142b62b0c7853f259 vendor/golang.org/x/sys/unix/types_darwin.go
+ f 05c883508833c12e3d3cdc366f588f61373e8513de446ddc46de0668fb9bc52c vendor/golang.org/x/sys/unix/types_darwin.go
dmppatch 7
@@ -1505,3521 +1505,8 @@
 C%22%0A%0A
-// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0Atype Timeval32 C.struct_timeval32%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Atype Stat_t C.struct_stat64%0A%0Atype Statfs_t C.struct_statfs64%0A%0Atype Flock_t C.struct_flock%0A%0Atype Fstore_t C.struct_fstore%0A%0Atype Radvisory_t C.struct_radvisory%0A%0Atype Fbootstraptransfer_t C.struct_fbootstraptransfer%0A%0Atype Log2phys_t C.struct_log2phys%0A%0Atype Fsid C.struct_fsid%0A%0Atype Dirent C.struct_dirent%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet4Pktinfo C.struct_in_pktinfo%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet4Pktinfo     = C.sizeof_struct_in_pktinfo%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr    = C.sizeof_struct_if_msghdr%0A%09SizeofIfData      = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr   = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfmaMsghdr  = C.sizeof_struct_ifma_msghdr%0A%09SizeofIfmaMsghdr2 = C.sizeof_struct_ifma_msghdr2%0A%09SizeofRtMsghdr    = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics   = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfmaMsghdr C.struct_ifma_msghdr%0A%0Atype IfmaMsghdr2 C.struct_ifma_msghdr2%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0A
 // T
@@ -1557,576 +1557,4 @@
 ios%0A
-%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_REMOVEDIR        = C.AT_REMOVEDIR%0A%09AT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A%0A// uname%0A%0Atype Utsname C.struct_utsname%0A
- f 8dd41d5be227bdbee50184035309266f91ba8c93a49664235afb7e1e2756904b vendor/golang.org/x/sys/unix/types_dragonfly.go
+ f c9c2cae01c5185e4276ba92860764637c169ea4d7b5620a0c6daaa9c0e25215e vendor/golang.org/x/sys/unix/types_dragonfly.go
dmppatch 7
@@ -1371,3680 +1371,8 @@
 C%22%0A%0A
-// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Aconst ( // Directory mode bits%0A%09S_IFMT   = C.S_IFMT%0A%09S_IFIFO  = C.S_IFIFO%0A%09S_IFCHR  = C.S_IFCHR%0A%09S_IFDIR  = C.S_IFDIR%0A%09S_IFBLK  = C.S_IFBLK%0A%09S_IFREG  = C.S_IFREG%0A%09S_IFLNK  = C.S_IFLNK%0A%09S_IFSOCK = C.S_IFSOCK%0A%09S_ISUID  = C.S_ISUID%0A%09S_ISGID  = C.S_ISGID%0A%09S_ISVTX  = C.S_ISVTX%0A%09S_IRUSR  = C.S_IRUSR%0A%09S_IWUSR  = C.S_IWUSR%0A%09S_IXUSR  = C.S_IXUSR%0A)%0A%0Atype Stat_t C.struct_stat%0A%0Atype Statfs_t C.struct_statfs%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0Atype Fsid C.struct_fsid%0A%0A// File system limits%0A%0Aconst (%0A%09PathMax = C.PATH_MAX%0A)%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr         = C.sizeof_struct_if_msghdr%0A%09SizeofIfData           = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfmaMsghdr       = C.sizeof_struct_ifma_msghdr%0A%09SizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr%0A%09SizeofRtMsghdr         = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics        = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfmaMsghdr C.struct_ifma_msghdr%0A%0Atype IfAnnounceMsghdr C.struct_if_announcemsghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0A
 // T
@@ -1423,495 +1423,4 @@
 ios%0A
-%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A%0A// Uname%0A%0Atype Utsname C.struct_utsname%0A
- f 420f7a24e2ddf95a445e546ee8e4aafd54b22b8cd2683de77518a8ab73944f7a vendor/golang.org/x/sys/unix/types_freebsd.go
+ f c7019bfadf08cbf162e4b274a5a9a19e04c3451d1e8955c6a953766012ef0d01 vendor/golang.org/x/sys/unix/types_freebsd.go
dmppatch 7
@@ -3601,4405 +3601,8 @@
 C%22%0A%0A
-// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Aconst ( // Directory mode bits%0A%09S_IFMT   = C.S_IFMT%0A%09S_IFIFO  = C.S_IFIFO%0A%09S_IFCHR  = C.S_IFCHR%0A%09S_IFDIR  = C.S_IFDIR%0A%09S_IFBLK  = C.S_IFBLK%0A%09S_IFREG  = C.S_IFREG%0A%09S_IFLNK  = C.S_IFLNK%0A%09S_IFSOCK = C.S_IFSOCK%0A%09S_ISUID  = C.S_ISUID%0A%09S_ISGID  = C.S_ISGID%0A%09S_ISVTX  = C.S_ISVTX%0A%09S_IRUSR  = C.S_IRUSR%0A%09S_IWUSR  = C.S_IWUSR%0A%09S_IXUSR  = C.S_IXUSR%0A)%0A%0Atype Stat_t C.struct_stat8%0A%0Atype Statfs_t C.struct_statfs%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0Atype Fsid C.struct_fsid%0A%0A// File system limits%0A%0Aconst (%0A%09PathMax = C.PATH_MAX%0A)%0A%0A// Advice to Fadvise%0A%0Aconst (%0A%09FADV_NORMAL     = C.POSIX_FADV_NORMAL%0A%09FADV_RANDOM     = C.POSIX_FADV_RANDOM%0A%09FADV_SEQUENTIAL = C.POSIX_FADV_SEQUENTIAL%0A%09FADV_WILLNEED   = C.POSIX_FADV_WILLNEED%0A%09FADV_DONTNEED   = C.POSIX_FADV_DONTNEED%0A%09FADV_NOREUSE    = C.POSIX_FADV_NOREUSE%0A)%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPMreqn C.struct_ip_mreqn%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPMreqn          = C.sizeof_struct_ip_mreqn%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09sizeofIfMsghdr         = C.sizeof_struct_if_msghdr%0A%09SizeofIfMsghdr         = C.sizeof_struct_if_msghdr8%0A%09sizeofIfData           = C.sizeof_struct_if_data%0A%09SizeofIfData           = C.sizeof_struct_if_data8%0A%09SizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfmaMsghdr       = C.sizeof_struct_ifma_msghdr%0A%09SizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr%0A%09SizeofRtMsghdr         = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics        = C.sizeof_struct_rt_metrics%0A)%0A%0Atype ifMsghdr C.struct_if_msghdr%0A%0Atype IfMsghdr C.struct_if_msghdr8%0A%0Atype ifData C.struct_if_data%0A%0Atype IfData C.struct_if_data8%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfmaMsghdr C.struct_ifma_msghdr%0A%0Atype IfAnnounceMsghdr C.struct_if_announcemsghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion    = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat       = C.sizeof_struct_bpf_stat%0A%09SizeofBpfZbuf       = C.sizeof_struct_bpf_zbuf%0A%09SizeofBpfProgram    = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn       = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr        = C.sizeof_struct_bpf_hdr%0A%09SizeofBpfZbufHeader = C.sizeof_struct_bpf_zbuf_header%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfZbuf C.struct_bpf_zbuf%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0Atype BpfZbufHeader C.struct_bpf_zbuf_header%0A%0A
 // T
@@ -3653,680 +3653,4 @@
 ios%0A
-%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_REMOVEDIR        = C.AT_REMOVEDIR%0A%09AT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR      = C.POLLERR%0A%09POLLHUP      = C.POLLHUP%0A%09POLLIN       = C.POLLIN%0A%09POLLINIGNEOF = C.POLLINIGNEOF%0A%09POLLNVAL     = C.POLLNVAL%0A%09POLLOUT      = C.POLLOUT%0A%09POLLPRI      = C.POLLPRI%0A%09POLLRDBAND   = C.POLLRDBAND%0A%09POLLRDNORM   = C.POLLRDNORM%0A%09POLLWRBAND   = C.POLLWRBAND%0A%09POLLWRNORM   = C.POLLWRNORM%0A)%0A%0A// Capabilities%0A%0Atype CapRights C.struct_cap_rights%0A%0A// Uname%0A%0Atype Utsname C.struct_utsname%0A
- f 93135ad2f2b96226dae6b0a3f705faa2a4af99773bbb0d86c74db3420c60248c vendor/golang.org/x/sys/unix/types_netbsd.go
+ f 31b8cc4de13d0d49f8f0b703d8c2918d3243129bdb856f0914b6a97ec9f4d43c vendor/golang.org/x/sys/unix/types_netbsd.go
dmppatch 7
@@ -1416,3586 +1416,8 @@
 C%22%0A%0A
-// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Atype Stat_t C.struct_stat%0A%0Atype Statfs_t C.struct_statfs%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0Atype Fsid C.fsid_t%0A%0A// File system limits%0A%0Aconst (%0A%09PathMax = C.PATH_MAX%0A)%0A%0A// Advice to Fadvise%0A%0Aconst (%0A%09FADV_NORMAL     = C.POSIX_FADV_NORMAL%0A%09FADV_RANDOM     = C.POSIX_FADV_RANDOM%0A%09FADV_SEQUENTIAL = C.POSIX_FADV_SEQUENTIAL%0A%09FADV_WILLNEED   = C.POSIX_FADV_WILLNEED%0A%09FADV_DONTNEED   = C.POSIX_FADV_DONTNEED%0A%09FADV_NOREUSE    = C.POSIX_FADV_NOREUSE%0A)%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr         = C.sizeof_struct_if_msghdr%0A%09SizeofIfData           = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr%0A%09SizeofRtMsghdr         = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics        = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfAnnounceMsghdr C.struct_if_announcemsghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0Atype Mclpool C.struct_mclpool%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0Atype BpfTimeval C.struct_bpf_timeval%0A%0A
 // T
@@ -1468,543 +1468,4 @@
 ios%0A
-%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A%0A// Sysctl%0A%0Atype Sysctlnode C.struct_sysctlnode%0A%0A// Uname%0A%0Atype Utsname C.struct_utsname%0A
- f 9783eef02be8bf2b6a3f59e5077c8475760dd98c09fbc271ec8140bdfdc132e0 vendor/golang.org/x/sys/unix/types_openbsd.go
+ f dfdae33cf42644b3d5d6a42aaceac6f0b8acf0516309a522168a4fd364fa6dd9 vendor/golang.org/x/sys/unix/types_openbsd.go
dmppatch 7
@@ -1392,3652 +1392,8 @@
 C%22%0A%0A
-// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Aconst ( // Directory mode bits%0A%09S_IFMT   = C.S_IFMT%0A%09S_IFIFO  = C.S_IFIFO%0A%09S_IFCHR  = C.S_IFCHR%0A%09S_IFDIR  = C.S_IFDIR%0A%09S_IFBLK  = C.S_IFBLK%0A%09S_IFREG  = C.S_IFREG%0A%09S_IFLNK  = C.S_IFLNK%0A%09S_IFSOCK = C.S_IFSOCK%0A%09S_ISUID  = C.S_ISUID%0A%09S_ISGID  = C.S_ISGID%0A%09S_ISVTX  = C.S_ISVTX%0A%09S_IRUSR  = C.S_IRUSR%0A%09S_IWUSR  = C.S_IWUSR%0A%09S_IXUSR  = C.S_IXUSR%0A)%0A%0Atype Stat_t C.struct_stat%0A%0Atype Statfs_t C.struct_statfs%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0Atype Fsid C.fsid_t%0A%0A// File system limits%0A%0Aconst (%0A%09PathMax = C.PATH_MAX%0A)%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr         = C.sizeof_struct_if_msghdr%0A%09SizeofIfData           = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr%0A%09SizeofRtMsghdr         = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics        = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfAnnounceMsghdr C.struct_if_announcemsghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0Atype Mclpool C.struct_mclpool%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0Atype BpfTimeval C.struct_bpf_timeval%0A%0A
 // T
@@ -1444,495 +1444,4 @@
 ios%0A
-%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A%0A// Uname%0A%0Atype Utsname C.struct_utsname%0A
- f dfe409bcdd367bd0309b576607ca6434da5c8c988363f968dc9887c8c6180290 vendor/golang.org/x/sys/unix/types_solaris.go
+ f e32264cfe98b422fd605165745be0c102744893db4c629fde4744ac20173d5af vendor/golang.org/x/sys/unix/types_solaris.go
dmppatch 7
@@ -1733,3696 +1733,8 @@
 C%22%0A%0A
-// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A%09PathMax        = C.PATH_MAX%0A%09MaxHostNameLen = C.MAXHOSTNAMELEN%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0Atype Timeval32 C.struct_timeval32%0A%0Atype Tms C.struct_tms%0A%0Atype Utimbuf C.struct_utimbuf%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Aconst ( // Directory mode bits%0A%09S_IFMT   = C.S_IFMT%0A%09S_IFIFO  = C.S_IFIFO%0A%09S_IFCHR  = C.S_IFCHR%0A%09S_IFDIR  = C.S_IFDIR%0A%09S_IFBLK  = C.S_IFBLK%0A%09S_IFREG  = C.S_IFREG%0A%09S_IFLNK  = C.S_IFLNK%0A%09S_IFSOCK = C.S_IFSOCK%0A%09S_ISUID  = C.S_ISUID%0A%09S_ISGID  = C.S_ISGID%0A%09S_ISVTX  = C.S_ISVTX%0A%09S_IRUSR  = C.S_IRUSR%0A%09S_IWUSR  = C.S_IWUSR%0A%09S_IXUSR  = C.S_IXUSR%0A)%0A%0Atype Stat_t C.struct_stat%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0A// Filesystems%0A%0Atype _Fsblkcnt_t C.fsblkcnt_t%0A%0Atype Statvfs_t C.struct_statvfs%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Misc%0A%0Atype Utsname C.struct_utsname%0A%0Atype Ustat_t C.struct_ustat%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A%09AT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW%0A%09AT_REMOVEDIR        = C.AT_REMOVEDIR%0A%09AT_EACCESS          = C.AT_EACCESS%0A)%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr  = C.sizeof_struct_if_msghdr%0A%09SizeofIfData    = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr = C.sizeof_struct_ifa_msghdr%0A%09SizeofRtMsghdr  = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfTimeval C.struct_bpf_timeval%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0A
 // T
@@ -1785,365 +1785,4 @@
 ios%0A
-%0Atype Termio C.struct_termio%0A%0Atype Winsize C.struct_winsize%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A
+ f 53ee50011ce593173f9a34308134c0aa49c8535323b46645c5d1266e9661d430 vendor/golang.org/x/sys/unix/xattr_bsd.go
dmppatch 2
@@ -0,0 +1,199 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build freebsd netbsd%0A%0Apackage unix%0A
- f f5b60d15812a20a7751911237eed4fc38e52b63870bde6e3e6fd59f514d94f56 vendor/golang.org/x/sys/unix/zerrors_darwin_386.go
+ f 61105021886fa245193d39381c8399b33769573a1536b678a4f2a33294084706 vendor/golang.org/x/sys/unix/zerrors_darwin_386.go
dmppatch 7
@@ -62872,16 +62872,264 @@
   = 0x2%0A
+%09XATTR_CREATE                      = 0x2%0A%09XATTR_NODEFAULT                   = 0x10%0A%09XATTR_NOFOLLOW                    = 0x1%0A%09XATTR_NOSECURITY                  = 0x8%0A%09XATTR_REPLACE                     = 0x4%0A%09XATTR_SHOWCOMPRESSION             = 0x20%0A
 )%0A%0A// Er
@@ -67344,7167 +67344,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EPWROFF%22, %22device power is off%22%7D,%0A%09%7B83, %22EDEVERR%22, %22device error%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EBADEXEC%22, %22bad executable (or shared library)%22%7D,%0A%09%7B86, %22EBADARCH%22, %22bad CPU type in executable%22%7D,%0A%09%7B87, %22ESHLIBVERS%22, %22shared library version mismatch%22%7D,%0A%09%7B88, %22EBADMACHO%22, %22malformed Mach-o file%22%7D,%0A%09%7B89, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B90, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B91, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B92, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B95, %22EMULTIHOP%22, %22EMULTIHOP (Reserved)%22%7D,%0A%09%7B96, %22ENODATA%22, %22no message available on STREAM%22%7D,%0A%09%7B97, %22ENOLINK%22, %22ENOLINK (Reserved)%22%7D,%0A%09%7B98, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B99, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B100, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B101, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B102, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B103, %22ENOPOLICY%22, %22policy not found%22%7D,%0A%09%7B104, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B105, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%09%7B106, %22EQFULL%22, %22interface output queue is full%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%7D%0A
- f 49915f9d710e6259c6d07e5b55ac537bfb35f95cdfc75959159f12d245dc2281 vendor/golang.org/x/sys/unix/zerrors_darwin_amd64.go
+ f d539341351cefca79153ce7eb7eed5774ef79adfca1ea78ffaa1b1202b8efe15 vendor/golang.org/x/sys/unix/zerrors_darwin_amd64.go
dmppatch 7
@@ -62874,16 +62874,264 @@
   = 0x2%0A
+%09XATTR_CREATE                      = 0x2%0A%09XATTR_NODEFAULT                   = 0x10%0A%09XATTR_NOFOLLOW                    = 0x1%0A%09XATTR_NOSECURITY                  = 0x8%0A%09XATTR_REPLACE                     = 0x4%0A%09XATTR_SHOWCOMPRESSION             = 0x20%0A
 )%0A%0A// Er
@@ -67346,7167 +67346,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EPWROFF%22, %22device power is off%22%7D,%0A%09%7B83, %22EDEVERR%22, %22device error%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EBADEXEC%22, %22bad executable (or shared library)%22%7D,%0A%09%7B86, %22EBADARCH%22, %22bad CPU type in executable%22%7D,%0A%09%7B87, %22ESHLIBVERS%22, %22shared library version mismatch%22%7D,%0A%09%7B88, %22EBADMACHO%22, %22malformed Mach-o file%22%7D,%0A%09%7B89, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B90, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B91, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B92, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B95, %22EMULTIHOP%22, %22EMULTIHOP (Reserved)%22%7D,%0A%09%7B96, %22ENODATA%22, %22no message available on STREAM%22%7D,%0A%09%7B97, %22ENOLINK%22, %22ENOLINK (Reserved)%22%7D,%0A%09%7B98, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B99, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B100, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B101, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B102, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B103, %22ENOPOLICY%22, %22policy not found%22%7D,%0A%09%7B104, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B105, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%09%7B106, %22EQFULL%22, %22interface output queue is full%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%7D%0A
- f f26c8e778d65c989e08e760fa768b42cdd633da2e3ce19e4a117e713e7881893 vendor/golang.org/x/sys/unix/zerrors_darwin_arm.go
+ f 55d7d6271d55dd78cc0b2a8fecf3e1336fdf8ec17d12013403e8e2527d2fbe2f vendor/golang.org/x/sys/unix/zerrors_darwin_arm.go
dmppatch 7
@@ -62862,16 +62862,264 @@
   = 0x2%0A
+%09XATTR_CREATE                      = 0x2%0A%09XATTR_NODEFAULT                   = 0x10%0A%09XATTR_NOFOLLOW                    = 0x1%0A%09XATTR_NOSECURITY                  = 0x8%0A%09XATTR_REPLACE                     = 0x4%0A%09XATTR_SHOWCOMPRESSION             = 0x20%0A
 )%0A%0A// Er
@@ -67334,7167 +67334,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EPWROFF%22, %22device power is off%22%7D,%0A%09%7B83, %22EDEVERR%22, %22device error%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EBADEXEC%22, %22bad executable (or shared library)%22%7D,%0A%09%7B86, %22EBADARCH%22, %22bad CPU type in executable%22%7D,%0A%09%7B87, %22ESHLIBVERS%22, %22shared library version mismatch%22%7D,%0A%09%7B88, %22EBADMACHO%22, %22malformed Mach-o file%22%7D,%0A%09%7B89, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B90, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B91, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B92, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B95, %22EMULTIHOP%22, %22EMULTIHOP (Reserved)%22%7D,%0A%09%7B96, %22ENODATA%22, %22no message available on STREAM%22%7D,%0A%09%7B97, %22ENOLINK%22, %22ENOLINK (Reserved)%22%7D,%0A%09%7B98, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B99, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B100, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B101, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B102, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B103, %22ENOPOLICY%22, %22policy not found%22%7D,%0A%09%7B104, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B105, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%09%7B106, %22EQFULL%22, %22interface output queue is full%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%7D%0A
- f cb9c5dfba956075afbfcdd090ccf970af92509f88c685214bc271caff016e4d2 vendor/golang.org/x/sys/unix/zerrors_darwin_arm64.go
+ f 95679bc312caf01f8eb06937be8e8b254d97f70675b21f41debe4bc8adae6c90 vendor/golang.org/x/sys/unix/zerrors_darwin_arm64.go
dmppatch 7
@@ -62874,16 +62874,264 @@
   = 0x2%0A
+%09XATTR_CREATE                      = 0x2%0A%09XATTR_NODEFAULT                   = 0x10%0A%09XATTR_NOFOLLOW                    = 0x1%0A%09XATTR_NOSECURITY                  = 0x8%0A%09XATTR_REPLACE                     = 0x4%0A%09XATTR_SHOWCOMPRESSION             = 0x20%0A
 )%0A%0A// Er
@@ -67346,7167 +67346,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EPWROFF%22, %22device power is off%22%7D,%0A%09%7B83, %22EDEVERR%22, %22device error%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EBADEXEC%22, %22bad executable (or shared library)%22%7D,%0A%09%7B86, %22EBADARCH%22, %22bad CPU type in executable%22%7D,%0A%09%7B87, %22ESHLIBVERS%22, %22shared library version mismatch%22%7D,%0A%09%7B88, %22EBADMACHO%22, %22malformed Mach-o file%22%7D,%0A%09%7B89, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B90, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B91, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B92, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B95, %22EMULTIHOP%22, %22EMULTIHOP (Reserved)%22%7D,%0A%09%7B96, %22ENODATA%22, %22no message available on STREAM%22%7D,%0A%09%7B97, %22ENOLINK%22, %22ENOLINK (Reserved)%22%7D,%0A%09%7B98, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B99, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B100, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B101, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B102, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B103, %22ENOPOLICY%22, %22policy not found%22%7D,%0A%09%7B104, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B105, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%09%7B106, %22EQFULL%22, %22interface output queue is full%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%7D%0A
- f 1c4eafe5af19b99c3a6bdec81a2553001f3444436fcdb64a152b41c65d8ded40 vendor/golang.org/x/sys/unix/zerrors_dragonfly_amd64.go
+ f d78143017ec135cc3be5b88a7ac73dd6c7462a57a8667dcb3b7c9ed6770d6419 vendor/golang.org/x/sys/unix/zerrors_dragonfly_amd64.go
dmppatch 3
@@ -58809,7077 +58809,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT     = syscall.Signal(0x6)%0A%09SIGALRM     = syscall.Signal(0xe)%0A%09SIGBUS      = syscall.Signal(0xa)%0A%09SIGCHLD     = syscall.Signal(0x14)%0A%09SIGCKPT     = syscall.Signal(0x21)%0A%09SIGCKPTEXIT = syscall.Signal(0x22)%0A%09SIGCONT     = syscall.Signal(0x13)%0A%09SIGEMT      = syscall.Signal(0x7)%0A%09SIGFPE      = syscall.Signal(0x8)%0A%09SIGHUP      = syscall.Signal(0x1)%0A%09SIGILL      = syscall.Signal(0x4)%0A%09SIGINFO     = syscall.Signal(0x1d)%0A%09SIGINT      = syscall.Signal(0x2)%0A%09SIGIO       = syscall.Signal(0x17)%0A%09SIGIOT      = syscall.Signal(0x6)%0A%09SIGKILL     = syscall.Signal(0x9)%0A%09SIGPIPE     = syscall.Signal(0xd)%0A%09SIGPROF     = syscall.Signal(0x1b)%0A%09SIGQUIT     = syscall.Signal(0x3)%0A%09SIGSEGV     = syscall.Signal(0xb)%0A%09SIGSTOP     = syscall.Signal(0x11)%0A%09SIGSYS      = syscall.Signal(0xc)%0A%09SIGTERM     = syscall.Signal(0xf)%0A%09SIGTHR      = syscall.Signal(0x20)%0A%09SIGTRAP     = syscall.Signal(0x5)%0A%09SIGTSTP     = syscall.Signal(0x12)%0A%09SIGTTIN     = syscall.Signal(0x15)%0A%09SIGTTOU     = syscall.Signal(0x16)%0A%09SIGURG      = syscall.Signal(0x10)%0A%09SIGUSR1     = syscall.Signal(0x1e)%0A%09SIGUSR2     = syscall.Signal(0x1f)%0A%09SIGVTALRM   = syscall.Signal(0x1a)%0A%09SIGWINCH    = syscall.Signal(0x1c)%0A%09SIGXCPU     = syscall.Signal(0x18)%0A%09SIGXFSZ     = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EWOULDBLOCK%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B86, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B87, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B88, %22EDOOFUS%22, %22programming error%22%7D,%0A%09%7B89, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B90, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B91, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B92, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B93, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B94, %22EUNUSED94%22, %22unknown error: 94%22%7D,%0A%09%7B95, %22EUNUSED95%22, %22unknown error: 95%22%7D,%0A%09%7B96, %22EUNUSED96%22, %22unknown error: 96%22%7D,%0A%09%7B97, %22EUNUSED97%22, %22unknown error: 97%22%7D,%0A%09%7B98, %22EUNUSED98%22, %22unknown error: 98%22%7D,%0A%09%7B99, %22ELAST%22, %22unknown error: 99%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22thread Scheduler%22%7D,%0A%09%7B33, %22SIGCKPT%22, %22checkPoint%22%7D,%0A%09%7B34, %22SIGCKPTEXIT%22, %22checkPointExit%22%7D,%0A%7D%0A
- f 20fe403b88e824d0d0d3187b4236004737e6fba992c00975fecda97cd7242eb2 vendor/golang.org/x/sys/unix/zerrors_freebsd_386.go
+ f 1dc86d1337bdddc33c069776c0b862433157ef33feb0961a0fc0ac358dcdbf46 vendor/golang.org/x/sys/unix/zerrors_freebsd_386.go
dmppatch 3
@@ -63465,6885 +63465,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGLIBRT  = syscall.Signal(0x21)%0A%09SIGLWP    = syscall.Signal(0x20)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B86, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B87, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B88, %22EDOOFUS%22, %22programming error%22%7D,%0A%09%7B89, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B90, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B91, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B92, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B93, %22ENOTCAPABLE%22, %22capabilities insufficient%22%7D,%0A%09%7B94, %22ECAPMODE%22, %22not permitted in capability mode%22%7D,%0A%09%7B95, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B96, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22unknown signal%22%7D,%0A%09%7B33, %22SIGLIBRT%22, %22unknown signal%22%7D,%0A%7D%0A
- f 635c9ede83d760e28d4a49d37216b300630f7cf74634995c93f3c1cf1aec31ec vendor/golang.org/x/sys/unix/zerrors_freebsd_amd64.go
+ f 3bf1d6e817d41a60d52aedfa07e908901b8ccfb32730a2d93fa90ee9dc1e7108 vendor/golang.org/x/sys/unix/zerrors_freebsd_amd64.go
dmppatch 3
@@ -63517,6885 +63517,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGLIBRT  = syscall.Signal(0x21)%0A%09SIGLWP    = syscall.Signal(0x20)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B86, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B87, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B88, %22EDOOFUS%22, %22programming error%22%7D,%0A%09%7B89, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B90, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B91, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B92, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B93, %22ENOTCAPABLE%22, %22capabilities insufficient%22%7D,%0A%09%7B94, %22ECAPMODE%22, %22not permitted in capability mode%22%7D,%0A%09%7B95, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B96, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22unknown signal%22%7D,%0A%09%7B33, %22SIGLIBRT%22, %22unknown signal%22%7D,%0A%7D%0A
- f 572f15aa1b6a8cfc97f857714608a327e0ff8b5dcb64d0e3be38da9b7fda6f2f vendor/golang.org/x/sys/unix/zerrors_freebsd_arm.go
+ f f9b6f3536ca15d4b6c8e6db37b86d82b077d82d93034c5adca9df0aeb5ad0dc3 vendor/golang.org/x/sys/unix/zerrors_freebsd_arm.go
dmppatch 3
@@ -63823,6885 +63823,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGLIBRT  = syscall.Signal(0x21)%0A%09SIGLWP    = syscall.Signal(0x20)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B86, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B87, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B88, %22EDOOFUS%22, %22programming error%22%7D,%0A%09%7B89, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B90, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B91, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B92, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B93, %22ENOTCAPABLE%22, %22capabilities insufficient%22%7D,%0A%09%7B94, %22ECAPMODE%22, %22not permitted in capability mode%22%7D,%0A%09%7B95, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B96, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22unknown signal%22%7D,%0A%09%7B33, %22SIGLIBRT%22, %22unknown signal%22%7D,%0A%7D%0A
- f 0c7b30529be71cbb7084076cd2ab9c7a413effc28d9c78163159f9c7ffcb44ed vendor/golang.org/x/sys/unix/zerrors_linux_386.go
+ f 09c6eb8f2be57878b575bb4c8790e0bc9b7425c5d5e9676ea67b60fe26221305 vendor/golang.org/x/sys/unix/zerrors_linux_386.go
dmppatch 94
@@ -144,48 +144,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20412,16 +20412,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22698,24 +22698,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -29007,52 +29007,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34799,24 +34799,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43532,16 +43532,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -44042,16 +44042,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -44130,24 +44130,72 @@
   = 0x20000%0A
+%09MAP_SYNC                             = 0x80000%0A
 %09MAP_TYPE   
@@ -49197,16 +49197,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56459,16 +56459,67 @@
 0042407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x4004240b%0A
 %09PERF_EV
@@ -59028,16 +59028,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61082,16 +61082,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61346,24 +61346,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -65169,16 +65169,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -67171,53 +67171,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -67505,24 +67505,1337 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x7002%0A%09RTC_AIE_ON                           = 0x7001%0A%09RTC_ALM_READ                         = 0x80247008%0A%09RTC_ALM_SET                          = 0x40247007%0A%09RTC_EPOCH_READ                       = 0x8004700d%0A%09RTC_EPOCH_SET                        = 0x4004700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x8004700b%0A%09RTC_IRQP_SET                         = 0x4004700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x7006%0A%09RTC_PIE_ON                           = 0x7005%0A%09RTC_PLL_GET                          = 0x801c7011%0A%09RTC_PLL_SET                          = 0x401c7012%0A%09RTC_RD_TIME                          = 0x80247009%0A%09RTC_SET_TIME                         = 0x4024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x7004%0A%09RTC_UIE_ON                           = 0x7003%0A%09RTC_VL_CLR                           = 0x7014%0A%09RTC_VL_READ                          = 0x80047013%0A%09RTC_WIE_OFF                          = 0x7010%0A%09RTC_WIE_ON                           = 0x700f%0A%09RTC_WKALM_RD                         = 0x80287010%0A%09RTC_WKALM_SET                        = 0x4028700f%0A
 %09RTF_ADDRCLA
@@ -73487,16 +73487,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -73709,16 +73709,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -73798,16 +73798,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -74020,16 +74020,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -74153,16 +74153,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -88904,16 +88904,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -108489,8424 +108489,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f cb6beccb7c1acb34a09c8f236d4a8442e0dee1aae3d45910dbd49f933c651343 vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
+ f 73608c6636825666deb10e59c495458ddba75cec357943eef8015feab39e47a4 vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
dmppatch 94
@@ -146,48 +146,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20414,16 +20414,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22700,24 +22700,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -29009,52 +29009,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34801,24 +34801,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43534,16 +43534,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -44044,16 +44044,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -44132,24 +44132,72 @@
   = 0x20000%0A
+%09MAP_SYNC                             = 0x80000%0A
 %09MAP_TYPE   
@@ -49199,16 +49199,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56458,16 +56458,67 @@
 0082407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x4008240b%0A
 %09PERF_EV
@@ -59027,16 +59027,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61089,16 +61089,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61353,24 +61353,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -65221,16 +65221,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -67223,53 +67223,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -67557,24 +67557,1337 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x7002%0A%09RTC_AIE_ON                           = 0x7001%0A%09RTC_ALM_READ                         = 0x80247008%0A%09RTC_ALM_SET                          = 0x40247007%0A%09RTC_EPOCH_READ                       = 0x8008700d%0A%09RTC_EPOCH_SET                        = 0x4008700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x8008700b%0A%09RTC_IRQP_SET                         = 0x4008700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x7006%0A%09RTC_PIE_ON                           = 0x7005%0A%09RTC_PLL_GET                          = 0x80207011%0A%09RTC_PLL_SET                          = 0x40207012%0A%09RTC_RD_TIME                          = 0x80247009%0A%09RTC_SET_TIME                         = 0x4024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x7004%0A%09RTC_UIE_ON                           = 0x7003%0A%09RTC_VL_CLR                           = 0x7014%0A%09RTC_VL_READ                          = 0x80047013%0A%09RTC_WIE_OFF                          = 0x7010%0A%09RTC_WIE_ON                           = 0x700f%0A%09RTC_WKALM_RD                         = 0x80287010%0A%09RTC_WKALM_SET                        = 0x4028700f%0A
 %09RTF_ADDRCLA
@@ -73539,16 +73539,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -73761,16 +73761,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -73850,16 +73850,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -74072,16 +74072,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -74205,16 +74205,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -88956,16 +88956,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -108497,8424 +108497,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f 1c277e9b6520219c7fafd81cc1693f19ca5b7d6dceea971ac444f4093530a102 vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
+ f d9ed8ff20c0a4ab7024125aaae53e4b4e8a57d6b9f830b1f68e375bc4b69dc55 vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
dmppatch 94
@@ -139,48 +139,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20402,16 +20402,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22637,24 +22637,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -28946,52 +28946,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34738,24 +34738,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43426,16 +43426,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -43936,16 +43936,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -44024,24 +44024,72 @@
   = 0x20000%0A
+%09MAP_SYNC                             = 0x80000%0A
 %09MAP_TYPE   
@@ -49091,16 +49091,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56353,16 +56353,67 @@
 0042407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x4004240b%0A
 %09PERF_EV
@@ -58922,16 +58922,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -60976,16 +60976,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61240,24 +61240,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -65475,16 +65475,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -67477,53 +67477,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -67811,24 +67811,1337 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x7002%0A%09RTC_AIE_ON                           = 0x7001%0A%09RTC_ALM_READ                         = 0x80247008%0A%09RTC_ALM_SET                          = 0x40247007%0A%09RTC_EPOCH_READ                       = 0x8004700d%0A%09RTC_EPOCH_SET                        = 0x4004700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x8004700b%0A%09RTC_IRQP_SET                         = 0x4004700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x7006%0A%09RTC_PIE_ON                           = 0x7005%0A%09RTC_PLL_GET                          = 0x801c7011%0A%09RTC_PLL_SET                          = 0x401c7012%0A%09RTC_RD_TIME                          = 0x80247009%0A%09RTC_SET_TIME                         = 0x4024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x7004%0A%09RTC_UIE_ON                           = 0x7003%0A%09RTC_VL_CLR                           = 0x7014%0A%09RTC_VL_READ                          = 0x80047013%0A%09RTC_WIE_OFF                          = 0x7010%0A%09RTC_WIE_ON                           = 0x700f%0A%09RTC_WKALM_RD                         = 0x80287010%0A%09RTC_WKALM_SET                        = 0x4028700f%0A
 %09RTF_ADDRCLA
@@ -73793,16 +73793,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -74015,16 +74015,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -74104,16 +74104,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -74326,16 +74326,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -74459,16 +74459,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -89210,16 +89210,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -108751,8424 +108751,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f 084da3f3d4b4a6eaadc1fc1fccddee039d52d1cb3dcd5c66ca128fcf35daea89 vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
+ f e77fa87e255e0687e0c2dfaab76f7e50d76b11d6ac5d09a1e0466af3caed22d6 vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
dmppatch 94
@@ -155,48 +155,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20483,16 +20483,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22820,24 +22820,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -29129,52 +29129,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34921,24 +34921,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43609,16 +43609,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -44119,16 +44119,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -44207,24 +44207,72 @@
   = 0x20000%0A
+%09MAP_SYNC                             = 0x80000%0A
 %09MAP_TYPE   
@@ -49274,16 +49274,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56532,16 +56532,67 @@
 0082407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x4008240b%0A
 %09PERF_EV
@@ -59101,16 +59101,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61163,16 +61163,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61427,24 +61427,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -64802,16 +64802,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -66804,53 +66804,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -67138,24 +67138,1337 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x7002%0A%09RTC_AIE_ON                           = 0x7001%0A%09RTC_ALM_READ                         = 0x80247008%0A%09RTC_ALM_SET                          = 0x40247007%0A%09RTC_EPOCH_READ                       = 0x8008700d%0A%09RTC_EPOCH_SET                        = 0x4008700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x8008700b%0A%09RTC_IRQP_SET                         = 0x4008700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x7006%0A%09RTC_PIE_ON                           = 0x7005%0A%09RTC_PLL_GET                          = 0x80207011%0A%09RTC_PLL_SET                          = 0x40207012%0A%09RTC_RD_TIME                          = 0x80247009%0A%09RTC_SET_TIME                         = 0x4024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x7004%0A%09RTC_UIE_ON                           = 0x7003%0A%09RTC_VL_CLR                           = 0x7014%0A%09RTC_VL_READ                          = 0x80047013%0A%09RTC_WIE_OFF                          = 0x7010%0A%09RTC_WIE_ON                           = 0x700f%0A%09RTC_WKALM_RD                         = 0x80287010%0A%09RTC_WKALM_SET                        = 0x4028700f%0A
 %09RTF_ADDRCLA
@@ -73120,16 +73120,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -73342,16 +73342,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -73431,16 +73431,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -73653,16 +73653,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -73786,16 +73786,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -88588,16 +88588,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -108129,8424 +108129,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f 1fea6c88de48438c86be10ab80764a18e70db604ec22a962dbea80671f13fba1 vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
+ f ca158dd7ad5a8023c807c8280fee6e4227c2b71a5e085f39d6416ce0b1df893d vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
dmppatch 90
@@ -140,48 +140,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20454,16 +20454,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22689,24 +22689,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -29005,52 +29005,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34801,24 +34801,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43492,16 +43492,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -44049,16 +44049,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -49156,16 +49156,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56416,16 +56416,67 @@
 0042407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x8004240b%0A
 %09PERF_EV
@@ -58997,16 +58997,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61051,16 +61051,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61315,24 +61315,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -65228,16 +65228,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -67230,53 +67230,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -67564,24 +67564,1373 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x20007002%0A%09RTC_AIE_ON                           = 0x20007001%0A%09RTC_ALM_READ                         = 0x40247008%0A%09RTC_ALM_SET                          = 0x80247007%0A%09RTC_EPOCH_READ                       = 0x4004700d%0A%09RTC_EPOCH_SET                        = 0x8004700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x4004700b%0A%09RTC_IRQP_SET                         = 0x8004700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x20007006%0A%09RTC_PIE_ON                           = 0x20007005%0A%09RTC_PLL_GET                          = 0x401c7011%0A%09RTC_PLL_SET                          = 0x801c7012%0A%09RTC_RD_TIME                          = 0x40247009%0A%09RTC_SET_TIME                         = 0x8024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x20007004%0A%09RTC_UIE_ON                           = 0x20007003%0A%09RTC_VL_CLR                           = 0x20007014%0A%09RTC_VL_READ                          = 0x40047013%0A%09RTC_WIE_OFF                          = 0x20007010%0A%09RTC_WIE_ON                           = 0x2000700f%0A%09RTC_WKALM_RD                         = 0x40287010%0A%09RTC_WKALM_SET                        = 0x8028700f%0A
 %09RTF_ADDRCLA
@@ -73582,16 +73582,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -73804,16 +73804,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -73893,16 +73893,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -74115,16 +74115,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -74248,16 +74248,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -89046,16 +89046,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -108846,8555 +108846,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x12)%0A%09SIGCLD    = syscall.Signal(0x12)%0A%09SIGCONT   = syscall.Signal(0x19)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x16)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x16)%0A%09SIGPROF   = syscall.Signal(0x1d)%0A%09SIGPWR    = syscall.Signal(0x13)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x17)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x18)%0A%09SIGTTIN   = syscall.Signal(0x1a)%0A%09SIGTTOU   = syscall.Signal(0x1b)%0A%09SIGURG    = syscall.Signal(0x15)%0A%09SIGUSR1   = syscall.Signal(0x10)%0A%09SIGUSR2   = syscall.Signal(0x11)%0A%09SIGVTALRM = syscall.Signal(0x1c)%0A%09SIGWINCH  = syscall.Signal(0x14)%0A%09SIGXCPU   = syscall.Signal(0x1e)%0A%09SIGXFSZ   = syscall.Signal(0x1f)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B51, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B53, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B54, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B89, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B90, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B91, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B135, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B137, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B138, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B139, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B140, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B141, %22EINIT%22, %22unknown error 141%22%7D,%0A%09%7B142, %22EREMDEV%22, %22unknown error 142%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B158, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B159, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B160, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B161, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B162, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B163, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B164, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B165, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B166, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B167, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B168, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%09%7B1133, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%7D%0A
- f 9489887e2526d176af865b6219768cf217abb5afc261faf9eb619ab5354c7a2b vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
+ f 1efb854c742c39a64a30c70e0b379c00d907d3b0404bd9e8aca9efd95d31cb47 vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
dmppatch 90
@@ -142,48 +142,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20456,16 +20456,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22691,24 +22691,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -29001,52 +29001,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34797,24 +34797,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43488,16 +43488,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -44045,16 +44045,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -49152,16 +49152,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56409,16 +56409,67 @@
 0082407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x8008240b%0A
 %09PERF_EV
@@ -58990,16 +58990,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61052,16 +61052,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61316,24 +61316,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -65229,16 +65229,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -67231,53 +67231,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -67565,24 +67565,1373 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x20007002%0A%09RTC_AIE_ON                           = 0x20007001%0A%09RTC_ALM_READ                         = 0x40247008%0A%09RTC_ALM_SET                          = 0x80247007%0A%09RTC_EPOCH_READ                       = 0x4008700d%0A%09RTC_EPOCH_SET                        = 0x8008700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x4008700b%0A%09RTC_IRQP_SET                         = 0x8008700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x20007006%0A%09RTC_PIE_ON                           = 0x20007005%0A%09RTC_PLL_GET                          = 0x40207011%0A%09RTC_PLL_SET                          = 0x80207012%0A%09RTC_RD_TIME                          = 0x40247009%0A%09RTC_SET_TIME                         = 0x8024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x20007004%0A%09RTC_UIE_ON                           = 0x20007003%0A%09RTC_VL_CLR                           = 0x20007014%0A%09RTC_VL_READ                          = 0x40047013%0A%09RTC_WIE_OFF                          = 0x20007010%0A%09RTC_WIE_ON                           = 0x2000700f%0A%09RTC_WKALM_RD                         = 0x40287010%0A%09RTC_WKALM_SET                        = 0x8028700f%0A
 %09RTF_ADDRCLA
@@ -73583,16 +73583,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -73805,16 +73805,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -73894,16 +73894,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -74116,16 +74116,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -74249,16 +74249,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -89047,16 +89047,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -108847,8555 +108847,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x12)%0A%09SIGCLD    = syscall.Signal(0x12)%0A%09SIGCONT   = syscall.Signal(0x19)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x16)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x16)%0A%09SIGPROF   = syscall.Signal(0x1d)%0A%09SIGPWR    = syscall.Signal(0x13)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x17)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x18)%0A%09SIGTTIN   = syscall.Signal(0x1a)%0A%09SIGTTOU   = syscall.Signal(0x1b)%0A%09SIGURG    = syscall.Signal(0x15)%0A%09SIGUSR1   = syscall.Signal(0x10)%0A%09SIGUSR2   = syscall.Signal(0x11)%0A%09SIGVTALRM = syscall.Signal(0x1c)%0A%09SIGWINCH  = syscall.Signal(0x14)%0A%09SIGXCPU   = syscall.Signal(0x1e)%0A%09SIGXFSZ   = syscall.Signal(0x1f)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B51, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B53, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B54, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B89, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B90, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B91, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B135, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B137, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B138, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B139, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B140, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B141, %22EINIT%22, %22unknown error 141%22%7D,%0A%09%7B142, %22EREMDEV%22, %22unknown error 142%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B158, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B159, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B160, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B161, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B162, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B163, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B164, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B165, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B166, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B167, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B168, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%09%7B1133, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%7D%0A
- f db06d3872e2092ae9f3f33537f9a12a88b33ce8c99b7908589bfccc1ab942eb3 vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
+ f df307b9e034e93fe4381ce0d4b1295a4b2b04c31e568622da9f6cfd6d58b4193 vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
dmppatch 90
@@ -144,48 +144,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20458,16 +20458,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22693,24 +22693,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -29003,52 +29003,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34799,24 +34799,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43490,16 +43490,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -44047,16 +44047,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -49154,16 +49154,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56411,16 +56411,67 @@
 0082407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x8008240b%0A
 %09PERF_EV
@@ -58992,16 +58992,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61054,16 +61054,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61318,24 +61318,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -65231,16 +65231,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -67233,53 +67233,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -67567,24 +67567,1373 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x20007002%0A%09RTC_AIE_ON                           = 0x20007001%0A%09RTC_ALM_READ                         = 0x40247008%0A%09RTC_ALM_SET                          = 0x80247007%0A%09RTC_EPOCH_READ                       = 0x4008700d%0A%09RTC_EPOCH_SET                        = 0x8008700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x4008700b%0A%09RTC_IRQP_SET                         = 0x8008700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x20007006%0A%09RTC_PIE_ON                           = 0x20007005%0A%09RTC_PLL_GET                          = 0x40207011%0A%09RTC_PLL_SET                          = 0x80207012%0A%09RTC_RD_TIME                          = 0x40247009%0A%09RTC_SET_TIME                         = 0x8024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x20007004%0A%09RTC_UIE_ON                           = 0x20007003%0A%09RTC_VL_CLR                           = 0x20007014%0A%09RTC_VL_READ                          = 0x40047013%0A%09RTC_WIE_OFF                          = 0x20007010%0A%09RTC_WIE_ON                           = 0x2000700f%0A%09RTC_WKALM_RD                         = 0x40287010%0A%09RTC_WKALM_SET                        = 0x8028700f%0A
 %09RTF_ADDRCLA
@@ -73585,16 +73585,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -73807,16 +73807,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -73896,16 +73896,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -74118,16 +74118,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -74251,16 +74251,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -89049,16 +89049,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -108849,8555 +108849,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x12)%0A%09SIGCLD    = syscall.Signal(0x12)%0A%09SIGCONT   = syscall.Signal(0x19)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x16)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x16)%0A%09SIGPROF   = syscall.Signal(0x1d)%0A%09SIGPWR    = syscall.Signal(0x13)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x17)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x18)%0A%09SIGTTIN   = syscall.Signal(0x1a)%0A%09SIGTTOU   = syscall.Signal(0x1b)%0A%09SIGURG    = syscall.Signal(0x15)%0A%09SIGUSR1   = syscall.Signal(0x10)%0A%09SIGUSR2   = syscall.Signal(0x11)%0A%09SIGVTALRM = syscall.Signal(0x1c)%0A%09SIGWINCH  = syscall.Signal(0x14)%0A%09SIGXCPU   = syscall.Signal(0x1e)%0A%09SIGXFSZ   = syscall.Signal(0x1f)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B51, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B53, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B54, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B89, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B90, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B91, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B135, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B137, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B138, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B139, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B140, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B141, %22EINIT%22, %22unknown error 141%22%7D,%0A%09%7B142, %22EREMDEV%22, %22unknown error 142%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B158, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B159, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B160, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B161, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B162, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B163, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B164, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B165, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B166, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B167, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B168, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%09%7B1133, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%7D%0A
- f 479c6268788112665706d601a9552ce7f73d808a05789a4e127c944f68a223cb vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
+ f 9c37fe24f15408c4e7e94925b97dac3a157b7e4ae0f0e095bdc1446c5bd50af7 vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
dmppatch 90
@@ -142,48 +142,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20456,16 +20456,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22691,24 +22691,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -29007,52 +29007,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34803,24 +34803,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43494,16 +43494,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -44051,16 +44051,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -49158,16 +49158,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56418,16 +56418,67 @@
 0042407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x8004240b%0A
 %09PERF_EV
@@ -58999,16 +58999,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61053,16 +61053,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61317,24 +61317,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -65230,16 +65230,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -67232,53 +67232,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -67566,24 +67566,1373 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x20007002%0A%09RTC_AIE_ON                           = 0x20007001%0A%09RTC_ALM_READ                         = 0x40247008%0A%09RTC_ALM_SET                          = 0x80247007%0A%09RTC_EPOCH_READ                       = 0x4004700d%0A%09RTC_EPOCH_SET                        = 0x8004700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x4004700b%0A%09RTC_IRQP_SET                         = 0x8004700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x20007006%0A%09RTC_PIE_ON                           = 0x20007005%0A%09RTC_PLL_GET                          = 0x401c7011%0A%09RTC_PLL_SET                          = 0x801c7012%0A%09RTC_RD_TIME                          = 0x40247009%0A%09RTC_SET_TIME                         = 0x8024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x20007004%0A%09RTC_UIE_ON                           = 0x20007003%0A%09RTC_VL_CLR                           = 0x20007014%0A%09RTC_VL_READ                          = 0x40047013%0A%09RTC_WIE_OFF                          = 0x20007010%0A%09RTC_WIE_ON                           = 0x2000700f%0A%09RTC_WKALM_RD                         = 0x40287010%0A%09RTC_WKALM_SET                        = 0x8028700f%0A
 %09RTF_ADDRCLA
@@ -73584,16 +73584,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -73806,16 +73806,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -73895,16 +73895,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -74117,16 +74117,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -74250,16 +74250,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -89048,16 +89048,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -108848,8555 +108848,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x12)%0A%09SIGCLD    = syscall.Signal(0x12)%0A%09SIGCONT   = syscall.Signal(0x19)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x16)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x16)%0A%09SIGPROF   = syscall.Signal(0x1d)%0A%09SIGPWR    = syscall.Signal(0x13)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x17)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x18)%0A%09SIGTTIN   = syscall.Signal(0x1a)%0A%09SIGTTOU   = syscall.Signal(0x1b)%0A%09SIGURG    = syscall.Signal(0x15)%0A%09SIGUSR1   = syscall.Signal(0x10)%0A%09SIGUSR2   = syscall.Signal(0x11)%0A%09SIGVTALRM = syscall.Signal(0x1c)%0A%09SIGWINCH  = syscall.Signal(0x14)%0A%09SIGXCPU   = syscall.Signal(0x1e)%0A%09SIGXFSZ   = syscall.Signal(0x1f)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B51, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B53, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B54, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B89, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B90, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B91, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B135, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B137, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B138, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B139, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B140, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B141, %22EINIT%22, %22unknown error 141%22%7D,%0A%09%7B142, %22EREMDEV%22, %22unknown error 142%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B158, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B159, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B160, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B161, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B162, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B163, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B164, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B165, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B166, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B167, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B168, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%09%7B1133, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%7D%0A
- f 2fa7dad0563b13276dc8003416e7d12493ce7a73c36869784f9c4530c1fca15f vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
+ f 15eee7330416d56ec88cbe16d4a2e11e5a4e4e6def4373bf1c1a77edcc969c03 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
dmppatch 90
@@ -141,48 +141,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20422,16 +20422,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22662,24 +22662,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -28973,52 +28973,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34770,24 +34770,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43459,16 +43459,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -43965,16 +43965,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -49081,16 +49081,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56451,16 +56451,67 @@
 0082407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x8008240b%0A
 %09PERF_EV
@@ -59077,16 +59077,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61139,16 +61139,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61403,24 +61403,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -67731,16 +67731,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -69733,53 +69733,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -70067,24 +70067,1373 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x20007002%0A%09RTC_AIE_ON                           = 0x20007001%0A%09RTC_ALM_READ                         = 0x40247008%0A%09RTC_ALM_SET                          = 0x80247007%0A%09RTC_EPOCH_READ                       = 0x4008700d%0A%09RTC_EPOCH_SET                        = 0x8008700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x4008700b%0A%09RTC_IRQP_SET                         = 0x8008700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x20007006%0A%09RTC_PIE_ON                           = 0x20007005%0A%09RTC_PLL_GET                          = 0x40207011%0A%09RTC_PLL_SET                          = 0x80207012%0A%09RTC_RD_TIME                          = 0x40247009%0A%09RTC_SET_TIME                         = 0x8024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x20007004%0A%09RTC_UIE_ON                           = 0x20007003%0A%09RTC_VL_CLR                           = 0x20007014%0A%09RTC_VL_READ                          = 0x40047013%0A%09RTC_WIE_OFF                          = 0x20007010%0A%09RTC_WIE_ON                           = 0x2000700f%0A%09RTC_WKALM_RD                         = 0x40287010%0A%09RTC_WKALM_SET                        = 0x8028700f%0A
 %09RTF_ADDRCLA
@@ -76085,16 +76085,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -76307,16 +76307,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -76396,16 +76396,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -76618,16 +76618,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -76751,16 +76751,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -91421,16 +91421,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -111335,8475 +111335,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B58, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f e4bfe7e22fa77dd14882bdd1da5022709441247626a23bfed22c922ef4c0f7b9 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
+ f 707e038115e597e843bdb7bf00c002b185fe9fbcfb6104a6abbedde23b9be90b vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
dmppatch 90
@@ -143,48 +143,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20424,16 +20424,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22664,24 +22664,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -28975,52 +28975,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34772,24 +34772,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43461,16 +43461,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -43967,16 +43967,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -49083,16 +49083,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56453,16 +56453,67 @@
 0082407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x8008240b%0A
 %09PERF_EV
@@ -59079,16 +59079,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61141,16 +61141,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61405,24 +61405,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -67733,16 +67733,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -69735,53 +69735,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -70069,24 +70069,1373 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x20007002%0A%09RTC_AIE_ON                           = 0x20007001%0A%09RTC_ALM_READ                         = 0x40247008%0A%09RTC_ALM_SET                          = 0x80247007%0A%09RTC_EPOCH_READ                       = 0x4008700d%0A%09RTC_EPOCH_SET                        = 0x8008700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x4008700b%0A%09RTC_IRQP_SET                         = 0x8008700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x20007006%0A%09RTC_PIE_ON                           = 0x20007005%0A%09RTC_PLL_GET                          = 0x40207011%0A%09RTC_PLL_SET                          = 0x80207012%0A%09RTC_RD_TIME                          = 0x40247009%0A%09RTC_SET_TIME                         = 0x8024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x20007004%0A%09RTC_UIE_ON                           = 0x20007003%0A%09RTC_VL_CLR                           = 0x20007014%0A%09RTC_VL_READ                          = 0x40047013%0A%09RTC_WIE_OFF                          = 0x20007010%0A%09RTC_WIE_ON                           = 0x2000700f%0A%09RTC_WKALM_RD                         = 0x40287010%0A%09RTC_WKALM_SET                        = 0x8028700f%0A
 %09RTF_ADDRCLA
@@ -76087,16 +76087,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -76309,16 +76309,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -76398,16 +76398,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -76620,16 +76620,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -76753,16 +76753,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -91423,16 +91423,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -111337,8475 +111337,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B58, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f 3af512ec7908aea35f78caaf198f31eaea5e50db604c568e4213c7944291ccf8 vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
+ f 33e83c609b5162fd687d0c7005f5039dc216f896227c1d5a1237d880eb5c508b vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
dmppatch 94
@@ -155,48 +155,59 @@
 ux%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -20432,16 +20432,63 @@
  0x8864%0A
+%09ETH_P_PREAUTH                        = 0x88c7%0A
 %09ETH_P_P
@@ -22667,24 +22667,112 @@
       = 0x0%0A
+%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A
 %09FS_IOC_GET_
@@ -28976,52 +28976,52 @@
 x40%0A
-%09IFA_MAX                              = 0x8%0A
+%09IFA_MAX                              = 0x9%0A
 %09IFF
@@ -34768,24 +34768,69 @@
      = 0x3b%0A
+%09IPV6_FREEBIND                        = 0x4e%0A
 %09IPV6_HDRINC
@@ -43456,16 +43456,65 @@
  = 0x10%0A
+%09MAP_FIXED_NOREPLACE                  = 0x100000%0A
 %09MAP_GRO
@@ -43966,16 +43966,60 @@
   = 0x1%0A
+%09MAP_SHARED_VALIDATE                  = 0x3%0A
 %09MAP_STA
@@ -44054,24 +44054,72 @@
   = 0x20000%0A
+%09MAP_SYNC                             = 0x80000%0A
 %09MAP_TYPE   
@@ -49121,16 +49121,1386 @@
   = 0x6%0A
+%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A
 %09NFS_SUP
@@ -56380,16 +56380,67 @@
 0082407%0A
+%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x4008240b%0A
 %09PERF_EV
@@ -58949,16 +58949,61 @@
  = 0x1b%0A
+%09PR_GET_SPECULATION_CTRL              = 0x34%0A
 %09PR_GET_
@@ -61011,16 +61011,61 @@
  = 0x1c%0A
+%09PR_SET_SPECULATION_CTRL              = 0x35%0A
 %09PR_SET_
@@ -61275,24 +61275,288 @@
       = 0x6%0A
+%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A
 %09PR_SVE_GET_
@@ -67974,16 +67974,148 @@
 2654973%0A
+%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A
 %09RLIMIT_
@@ -69976,53 +69976,53 @@
 0x4%0A
-%09RTA_MAX                              = 0x1a%0A
+%09RTA_MAX                              = 0x1d%0A
 %09RTC
@@ -70310,24 +70310,1337 @@
  = 0x200000%0A
+%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x7002%0A%09RTC_AIE_ON                           = 0x7001%0A%09RTC_ALM_READ                         = 0x80247008%0A%09RTC_ALM_SET                          = 0x40247007%0A%09RTC_EPOCH_READ                       = 0x8008700d%0A%09RTC_EPOCH_SET                        = 0x4008700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x8008700b%0A%09RTC_IRQP_SET                         = 0x4008700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x7006%0A%09RTC_PIE_ON                           = 0x7005%0A%09RTC_PLL_GET                          = 0x80207011%0A%09RTC_PLL_SET                          = 0x40207012%0A%09RTC_RD_TIME                          = 0x80247009%0A%09RTC_SET_TIME                         = 0x4024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x7004%0A%09RTC_UIE_ON                           = 0x7003%0A%09RTC_VL_CLR                           = 0x7014%0A%09RTC_VL_READ                          = 0x80047013%0A%09RTC_WIE_OFF                          = 0x7010%0A%09RTC_WIE_ON                           = 0x700f%0A%09RTC_WKALM_RD                         = 0x80287010%0A%09RTC_WKALM_SET                        = 0x4028700f%0A
 %09RTF_ADDRCLA
@@ -76292,16 +76292,61 @@
  = 0x2a%0A
+%09RTPROT_BGP                           = 0xba%0A
 %09RTPROT_
@@ -76514,16 +76514,61 @@
   = 0xd%0A
+%09RTPROT_EIGRP                         = 0xc0%0A
 %09RTPROT_
@@ -76603,16 +76603,61 @@
   = 0x8%0A
+%09RTPROT_ISIS                          = 0xbb%0A
 %09RTPROT_
@@ -76825,16 +76825,61 @@
   = 0xf%0A
+%09RTPROT_OSPF                          = 0xbc%0A
 %09RTPROT_
@@ -76958,16 +76958,61 @@
   = 0x1%0A
+%09RTPROT_RIP                           = 0xbd%0A
 %09RTPROT_
@@ -91709,16 +91709,106 @@
  = 0x1e%0A
+%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A
 %09TCP_INF
@@ -111250,8424 +111250,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f bc054446a0d98ae4530c1d8dd3a8fa97b382de4bc0d38b8514d247dd96d0af17 vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go
+ f 1411123e2f961ce7e76bed8bbdeecfd67de77f75dc6c082420f9769fa138e66d vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go
dmppatch 8
@@ -17,63 +17,61 @@
 m64%0A
-// MACHINE GENERATED BY THE COMMAND ABOVE; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0A// 
@@ -79538,6397 +79538,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCLD    = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGLOST   = syscall.Signal(0x1d)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x17)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1d)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errors = %5B...%5Dstring%7B%0A%091:   %22operation not permitted%22,%0A%092:   %22no such file or directory%22,%0A%093:   %22no such process%22,%0A%094:   %22interrupted system call%22,%0A%095:   %22input/output error%22,%0A%096:   %22no such device or address%22,%0A%097:   %22argument list too long%22,%0A%098:   %22exec format error%22,%0A%099:   %22bad file descriptor%22,%0A%0910:  %22no child processes%22,%0A%0911:  %22resource temporarily unavailable%22,%0A%0912:  %22cannot allocate memory%22,%0A%0913:  %22permission denied%22,%0A%0914:  %22bad address%22,%0A%0915:  %22block device required%22,%0A%0916:  %22device or resource busy%22,%0A%0917:  %22file exists%22,%0A%0918:  %22invalid cross-device link%22,%0A%0919:  %22no such device%22,%0A%0920:  %22not a directory%22,%0A%0921:  %22is a directory%22,%0A%0922:  %22invalid argument%22,%0A%0923:  %22too many open files in system%22,%0A%0924:  %22too many open files%22,%0A%0925:  %22inappropriate ioctl for device%22,%0A%0926:  %22text file busy%22,%0A%0927:  %22file too large%22,%0A%0928:  %22no space left on device%22,%0A%0929:  %22illegal seek%22,%0A%0930:  %22read-only file system%22,%0A%0931:  %22too many links%22,%0A%0932:  %22broken pipe%22,%0A%0933:  %22numerical argument out of domain%22,%0A%0934:  %22numerical result out of range%22,%0A%0936:  %22operation now in progress%22,%0A%0937:  %22operation already in progress%22,%0A%0938:  %22socket operation on non-socket%22,%0A%0939:  %22destination address required%22,%0A%0940:  %22message too long%22,%0A%0941:  %22protocol wrong type for socket%22,%0A%0942:  %22protocol not available%22,%0A%0943:  %22protocol not supported%22,%0A%0944:  %22socket type not supported%22,%0A%0945:  %22operation not supported%22,%0A%0946:  %22protocol family not supported%22,%0A%0947:  %22address family not supported by protocol%22,%0A%0948:  %22address already in use%22,%0A%0949:  %22cannot assign requested address%22,%0A%0950:  %22network is down%22,%0A%0951:  %22network is unreachable%22,%0A%0952:  %22network dropped connection on reset%22,%0A%0953:  %22software caused connection abort%22,%0A%0954:  %22connection reset by peer%22,%0A%0955:  %22no buffer space available%22,%0A%0956:  %22transport endpoint is already connected%22,%0A%0957:  %22transport endpoint is not connected%22,%0A%0958:  %22cannot send after transport endpoint shutdown%22,%0A%0959:  %22too many references: cannot splice%22,%0A%0960:  %22connection timed out%22,%0A%0961:  %22connection refused%22,%0A%0962:  %22too many levels of symbolic links%22,%0A%0963:  %22file name too long%22,%0A%0964:  %22host is down%22,%0A%0965:  %22no route to host%22,%0A%0966:  %22directory not empty%22,%0A%0967:  %22too many processes%22,%0A%0968:  %22too many users%22,%0A%0969:  %22disk quota exceeded%22,%0A%0970:  %22stale file handle%22,%0A%0971:  %22object is remote%22,%0A%0972:  %22device not a stream%22,%0A%0973:  %22timer expired%22,%0A%0974:  %22out of streams resources%22,%0A%0975:  %22no message of desired type%22,%0A%0976:  %22bad message%22,%0A%0977:  %22identifier removed%22,%0A%0978:  %22resource deadlock avoided%22,%0A%0979:  %22no locks available%22,%0A%0980:  %22machine is not on the network%22,%0A%0981:  %22unknown error 81%22,%0A%0982:  %22link has been severed%22,%0A%0983:  %22advertise error%22,%0A%0984:  %22srmount error%22,%0A%0985:  %22communication error on send%22,%0A%0986:  %22protocol error%22,%0A%0987:  %22multihop attempted%22,%0A%0988:  %22RFS specific error%22,%0A%0989:  %22remote address changed%22,%0A%0990:  %22function not implemented%22,%0A%0991:  %22streams pipe error%22,%0A%0992:  %22value too large for defined data type%22,%0A%0993:  %22file descriptor in bad state%22,%0A%0994:  %22channel number out of range%22,%0A%0995:  %22level 2 not synchronized%22,%0A%0996:  %22level 3 halted%22,%0A%0997:  %22level 3 reset%22,%0A%0998:  %22link number out of range%22,%0A%0999:  %22protocol driver not attached%22,%0A%09100: %22no CSI structure available%22,%0A%09101: %22level 2 halted%22,%0A%09102: %22invalid exchange%22,%0A%09103: %22invalid request descriptor%22,%0A%09104: %22exchange full%22,%0A%09105: %22no anode%22,%0A%09106: %22invalid request code%22,%0A%09107: %22invalid slot%22,%0A%09108: %22file locking deadlock error%22,%0A%09109: %22bad font file format%22,%0A%09110: %22cannot exec a shared library directly%22,%0A%09111: %22no data available%22,%0A%09112: %22accessing a corrupted shared library%22,%0A%09113: %22package not installed%22,%0A%09114: %22can not access a needed shared library%22,%0A%09115: %22name not unique on network%22,%0A%09116: %22interrupted system call should be restarted%22,%0A%09117: %22structure needs cleaning%22,%0A%09118: %22not a XENIX named type file%22,%0A%09119: %22no XENIX semaphores available%22,%0A%09120: %22is a named type file%22,%0A%09121: %22remote I/O error%22,%0A%09122: %22invalid or incomplete multibyte or wide character%22,%0A%09123: %22attempting to link in too many shared libraries%22,%0A%09124: %22.lib section in a.out corrupted%22,%0A%09125: %22no medium found%22,%0A%09126: %22wrong medium type%22,%0A%09127: %22operation canceled%22,%0A%09128: %22required key not available%22,%0A%09129: %22key has expired%22,%0A%09130: %22key has been revoked%22,%0A%09131: %22key was rejected by service%22,%0A%09132: %22owner died%22,%0A%09133: %22state not recoverable%22,%0A%09134: %22operation not possible due to RF-kill%22,%0A%09135: %22memory page has hardware error%22,%0A%7D%0A%0A// Signal table%0Avar signals = %5B...%5Dstring%7B%0A%091:  %22hangup%22,%0A%092:  %22interrupt%22,%0A%093:  %22quit%22,%0A%094:  %22illegal instruction%22,%0A%095:  %22trace/breakpoint trap%22,%0A%096:  %22aborted%22,%0A%097:  %22EMT trap%22,%0A%098:  %22floating point exception%22,%0A%099:  %22killed%22,%0A%0910: %22bus error%22,%0A%0911: %22segmentation fault%22,%0A%0912: %22bad system call%22,%0A%0913: %22broken pipe%22,%0A%0914: %22alarm clock%22,%0A%0915: %22terminated%22,%0A%0916: %22urgent I/O condition%22,%0A%0917: %22stopped (signal)%22,%0A%0918: %22stopped%22,%0A%0919: %22continued%22,%0A%0920: %22child exited%22,%0A%0921: %22stopped (tty input)%22,%0A%0922: %22stopped (tty output)%22,%0A%0923: %22I/O possible%22,%0A%0924: %22CPU time limit exceeded%22,%0A%0925: %22file size limit exceeded%22,%0A%0926: %22virtual timer expired%22,%0A%0927: %22profiling timer expired%22,%0A%0928: %22window changed%22,%0A%0929: %22resource lost%22,%0A%0930: %22user defined signal 1%22,%0A%0931: %22user defined signal 2%22,%0A%7D%0A
- f 5b141401631ce52e59d7faeb269483514b9177e0818c3726d48a1f89cdd8576f vendor/golang.org/x/sys/unix/zerrors_netbsd_386.go
+ f 39d9fb38ff98fc4ad05cafcd9519a106c427198e13e63c96c9c61115f89ddb31 vendor/golang.org/x/sys/unix/zerrors_netbsd_386.go
dmppatch 7
@@ -23348,16 +23348,180 @@
  0x4b00%0A
+%09EXTATTR_CMD_START                 = 0x1%0A%09EXTATTR_CMD_STOP                  = 0x2%0A%09EXTATTR_NAMESPACE_SYSTEM          = 0x2%0A%09EXTATTR_NAMESPACE_USER            = 0x1%0A
 %09EXTB   
@@ -65674,6760 +65674,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x20)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large or too small%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol option not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B86, %22ENOTSUP%22, %22not supported%22%7D,%0A%09%7B87, %22ECANCELED%22, %22operation Canceled%22%7D,%0A%09%7B88, %22EBADMSG%22, %22bad or Corrupt message%22%7D,%0A%09%7B89, %22ENODATA%22, %22no message available%22%7D,%0A%09%7B90, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B91, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B92, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B95, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B96, %22ELAST%22, %22protocol error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGPWR%22, %22power fail/restart%22%7D,%0A%7D%0A
- f 086bfdd8f0e81fb13cfc1f4abb9564196de595e8cba560178d06da0da0f619e6 vendor/golang.org/x/sys/unix/zerrors_netbsd_amd64.go
+ f 52d341af732621a247076c0d70595769c90fe36e7b0060c0412e5cca132aca21 vendor/golang.org/x/sys/unix/zerrors_netbsd_amd64.go
dmppatch 7
@@ -22930,16 +22930,180 @@
  0x4b00%0A
+%09EXTATTR_CMD_START                 = 0x1%0A%09EXTATTR_CMD_STOP                  = 0x2%0A%09EXTATTR_NAMESPACE_SYSTEM          = 0x2%0A%09EXTATTR_NAMESPACE_USER            = 0x1%0A
 %09EXTB   
@@ -65256,6760 +65256,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x20)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large or too small%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol option not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B86, %22ENOTSUP%22, %22not supported%22%7D,%0A%09%7B87, %22ECANCELED%22, %22operation Canceled%22%7D,%0A%09%7B88, %22EBADMSG%22, %22bad or Corrupt message%22%7D,%0A%09%7B89, %22ENODATA%22, %22no message available%22%7D,%0A%09%7B90, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B91, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B92, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B95, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B96, %22ELAST%22, %22protocol error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGPWR%22, %22power fail/restart%22%7D,%0A%7D%0A
- f 3f083aee03e66d0c75cff993e71beabfb5eafaa012f6ea13e13fd1134e48ffcc vendor/golang.org/x/sys/unix/zerrors_netbsd_arm.go
+ f 290a5b70d4a7171668cccc5ca4c1efbb9b536cc0ff0c6ae9ab0e690e9dfd9cce vendor/golang.org/x/sys/unix/zerrors_netbsd_arm.go
dmppatch 7
@@ -22584,16 +22584,180 @@
  0x4b00%0A
+%09EXTATTR_CMD_START                 = 0x1%0A%09EXTATTR_CMD_STOP                  = 0x2%0A%09EXTATTR_NAMESPACE_SYSTEM          = 0x2%0A%09EXTATTR_NAMESPACE_USER            = 0x1%0A
 %09EXTB   
@@ -64787,6760 +64787,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x20)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large or too small%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol option not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B86, %22ENOTSUP%22, %22not supported%22%7D,%0A%09%7B87, %22ECANCELED%22, %22operation Canceled%22%7D,%0A%09%7B88, %22EBADMSG%22, %22bad or Corrupt message%22%7D,%0A%09%7B89, %22ENODATA%22, %22no message available%22%7D,%0A%09%7B90, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B91, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B92, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B95, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B96, %22ELAST%22, %22protocol error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGPWR%22, %22power fail/restart%22%7D,%0A%7D%0A
- f f70215b417cfcebb431ecfad89839338075977aa93dc5f676eb549f7b9eab092 vendor/golang.org/x/sys/unix/zerrors_openbsd_386.go
+ f c3dfa3ef2aa30a511313c9bcbe4daf94f1e4d0ac250d567ac44c31dd6aade4a6 vendor/golang.org/x/sys/unix/zerrors_openbsd_386.go
dmppatch 7
@@ -52160,16 +52160,1211 @@
  = 0x40%0A
+%09S_BLKSIZE                         = 0x200%0A%09S_IEXEC                           = 0x40%0A%09S_IFBLK                           = 0x6000%0A%09S_IFCHR                           = 0x2000%0A%09S_IFDIR                           = 0x4000%0A%09S_IFIFO                           = 0x1000%0A%09S_IFLNK                           = 0xa000%0A%09S_IFMT                            = 0xf000%0A%09S_IFREG                           = 0x8000%0A%09S_IFSOCK                          = 0xc000%0A%09S_IREAD                           = 0x100%0A%09S_IRGRP                           = 0x20%0A%09S_IROTH                           = 0x4%0A%09S_IRUSR                           = 0x100%0A%09S_IRWXG                           = 0x38%0A%09S_IRWXO                           = 0x7%0A%09S_IRWXU                           = 0x1c0%0A%09S_ISGID                           = 0x400%0A%09S_ISTXT                           = 0x200%0A%09S_ISUID                           = 0x800%0A%09S_ISVTX                           = 0x200%0A%09S_IWGRP                           = 0x10%0A%09S_IWOTH                           = 0x2%0A%09S_IWRITE                          = 0x80%0A%09S_IWUSR                           = 0x80%0A%09S_IXGRP                           = 0x8%0A%09S_IXOTH                           = 0x1%0A%09S_IXUSR                           = 0x40%0A
 %09TCIFLUS
@@ -61662,6555 +61662,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EWOULDBLOCK%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC program not available%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIPSEC%22, %22IPsec processing failure%22%7D,%0A%09%7B83, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B84, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B85, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B86, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B87, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B88, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B89, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B90, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B91, %22ELAST%22, %22not supported%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22thread AST%22%7D,%0A%7D%0A
- f eabe6f3a231a8b2d33cdfa0ce18404fd7297bd095f34d4912e1b2c3dd33f4aa8 vendor/golang.org/x/sys/unix/zerrors_openbsd_amd64.go
+ f 82183ae25e171ee1cb7447580e7382d0558db33cf414d9988da90f48dc0df2a0 vendor/golang.org/x/sys/unix/zerrors_openbsd_amd64.go
dmppatch 454
@@ -1631,16 +1631,59 @@
   = 0x0%0A
+%09ALTWERASE                         = 0x200%0A
 %09ARPHRD_
@@ -6079,16 +6079,262 @@
  0x8000%0A
+%09CLOCK_BOOTTIME                    = 0x6%0A%09CLOCK_MONOTONIC                   = 0x3%0A%09CLOCK_PROCESS_CPUTIME_ID          = 0x2%0A%09CLOCK_REALTIME                    = 0x0%0A%09CLOCK_THREAD_CPUTIME_ID           = 0x4%0A%09CLOCK_UPTIME                      = 0x5%0A
 %09CREAD  
@@ -7668,16 +7668,59 @@
   = 0x0%0A
+%09DLT_OPENFLOW                      = 0x10b%0A
 %09DLT_PFL
@@ -8126,16 +8126,730 @@
   = 0xf%0A
+%09DLT_USBPCAP                       = 0xf9%0A%09DLT_USER0                         = 0x93%0A%09DLT_USER1                         = 0x94%0A%09DLT_USER10                        = 0x9d%0A%09DLT_USER11                        = 0x9e%0A%09DLT_USER12                        = 0x9f%0A%09DLT_USER13                        = 0xa0%0A%09DLT_USER14                        = 0xa1%0A%09DLT_USER15                        = 0xa2%0A%09DLT_USER2                         = 0x95%0A%09DLT_USER3                         = 0x96%0A%09DLT_USER4                         = 0x97%0A%09DLT_USER5                         = 0x98%0A%09DLT_USER6                         = 0x99%0A%09DLT_USER7                         = 0x9a%0A%09DLT_USER8                         = 0x9b%0A%09DLT_USER9                         = 0x9c%0A
 %09DT_BLK 
@@ -18118,24 +18118,68 @@
     = 0x600%0A
+%09ETHER_MAX_HARDMTU_LEN             = 0xff9b%0A
 %09ETHER_MAX_L
@@ -18375,16 +18375,58 @@
  = -0x3%0A
+%09EVFILT_DEVICE                     = -0x8%0A
 %09EVFILT_
@@ -18547,49 +18547,49 @@
 0x6%0A
-%09EVFILT_SYSCOUNT                   = 0x7%0A
+%09EVFILT_SYSCOUNT                   = 0x8%0A
 %09EVF
@@ -18706,24 +18706,315 @@
      = -0x2%0A
+%09EVL_ENCAPLEN                      = 0x4%0A%09EVL_PRIO_BITS                     = 0xd%0A%09EVL_PRIO_MAX                      = 0x7%0A%09EVL_VLID_MASK                     = 0xfff%0A%09EVL_VLID_MAX                      = 0xffe%0A%09EVL_VLID_MIN                      = 0x1%0A%09EVL_VLID_NULL                     = 0x0%0A
 %09EV_ADD     
@@ -19166,16 +19166,58 @@
   = 0x8%0A
+%09EV_DISPATCH                       = 0x80%0A
 %09EV_ENAB
@@ -19423,16 +19423,58 @@
  = 0x10%0A
+%09EV_RECEIPT                        = 0x40%0A
 %09EV_SYSF
@@ -20016,16 +20016,57 @@
   = 0x5%0A
+%09F_ISATTY                          = 0xb%0A
 %09F_OK   
@@ -20768,49 +20768,8 @@
 0x1%0A
-%09IFA_ROUTE                         = 0x1%0A
 %09IFF
@@ -21196,50 +21196,8 @@
 x80%0A
-%09IFF_NOTRAILERS                    = 0x20%0A
 %09IFF
@@ -21405,16 +21405,58 @@
 = 0x800%0A
+%09IFF_STATICARP                     = 0x20%0A
 %09IFF_UP 
@@ -26813,16 +26813,58 @@
  = 0x18%0A
+%09IFT_MBIM                          = 0xfa%0A
 %09IFT_MED
@@ -32104,90 +32104,8 @@
 102%0A
-%09IPPROTO_DIVERT_INIT               = 0x2%0A%09IPPROTO_DIVERT_RESP               = 0x1%0A
 %09IPP
@@ -34454,16 +34454,58 @@
  0xffff%0A
+%09IPV6_MINHOPCOUNT                  = 0x41%0A
 %09IPV6_MM
@@ -36127,52 +36127,8 @@
 000%0A
-%09IP_DIVERTFL                       = 0x1022%0A
 %09IP_
@@ -36331,16 +36331,58 @@
  = 0x1d%0A
+%09IP_IPDEFTTL                       = 0x25%0A
 %09IP_IPSE
@@ -37759,16 +37759,57 @@
  0x1021%0A
+%09IP_SENDSRCADDR                    = 0x7%0A
 %09IP_TOS 
@@ -37966,16 +37966,60 @@
  = 0x20%0A
+%09IUCLC                             = 0x1000%0A
 %09IXANY  
@@ -38843,49 +38843,93 @@
 000%0A
-%09MAP_COPY                          = 0x4%0A
+%09MAP_ANONYMOUS                     = 0x1000%0A%09MAP_COPY                          = 0x2%0A
 %09MAP
@@ -39011,137 +39011,134 @@
 x10%0A
-%09MAP_FLAGMASK                      = 0x1ff7%0A%09MAP_HASSEMAPHORE                  = 0x200%0A%09MAP_INHERIT                       = 0x80%0A
+%09MAP_FLAGMASK                      = 0x7ff7%0A%09MAP_HASSEMAPHORE                  = 0x0%0A%09MAP_INHERIT                       = 0x0%0A
 %09MAP
@@ -39178,49 +39178,8 @@
 0x1%0A
-%09MAP_INHERIT_DONATE_COPY           = 0x3%0A
 %09MAP
@@ -39260,93 +39260,131 @@
 0x0%0A
-%09MAP_NOEXTEND                      = 0x100%0A%09MAP_NORESERVE                     = 0x40%0A
+%09MAP_INHERIT_ZERO                  = 0x3%0A%09MAP_NOEXTEND                      = 0x0%0A%09MAP_NORESERVE                     = 0x0%0A
 %09MAP
@@ -39424,50 +39424,49 @@
 0x2%0A
-%09MAP_RENAME                        = 0x20%0A
+%09MAP_RENAME                        = 0x0%0A
 %09MAP
@@ -39506,51 +39506,93 @@
 0x1%0A
-%09MAP_TRYFIXED                      = 0x400%0A
+%09MAP_STACK                         = 0x4000%0A%09MAP_TRYFIXED                      = 0x0%0A
 %09MCL
@@ -39712,16 +39712,59 @@
 = 0x100%0A
+%09MSG_CMSG_CLOEXEC                  = 0x800%0A
 %09MSG_CTR
@@ -40465,49 +40465,90 @@
 0x3%0A
-%09NET_RT_MAXID                      = 0x6%0A
+%09NET_RT_IFNAMES                    = 0x6%0A%09NET_RT_MAXID                      = 0x7%0A
 %09NET
@@ -40669,24 +40669,71 @@
  0x80000000%0A
+%09NOKERNINFO                        = 0x2000000%0A
 %09NOTE_ATTRIB
@@ -40761,16 +40761,57 @@
   = 0x8%0A
+%09NOTE_CHANGE                       = 0x1%0A
 %09NOTE_CH
@@ -41577,16 +41577,58 @@
  = 0x10%0A
+%09OLCUC                             = 0x20%0A
 %09ONLCR  
@@ -41826,16 +41826,57 @@
   = 0x1%0A
+%09OXTABS                            = 0x4%0A
 %09O_ACCMO
@@ -43423,16 +43423,57 @@
   = 0x1%0A
+%09RLIMIT_MEMLOCK                    = 0x6%0A
 %09RLIMIT_
@@ -43505,16 +43505,98 @@
   = 0x8%0A
+%09RLIMIT_NPROC                      = 0x7%0A%09RLIMIT_RSS                        = 0x5%0A
 %09RLIMIT_
@@ -43725,16 +43725,57 @@
   = 0x6%0A
+%09RTAX_BFD                          = 0xb%0A
 %09RTAX_BR
@@ -43807,16 +43807,57 @@
   = 0x7%0A
+%09RTAX_DNS                          = 0xc%0A
 %09RTAX_DS
@@ -44098,49 +44098,49 @@
 0xa%0A
-%09RTAX_MAX                          = 0xb%0A
+%09RTAX_MAX                          = 0xf%0A
 %09RTA
@@ -44172,24 +44172,65 @@
       = 0x2%0A
+%09RTAX_SEARCH                       = 0xe%0A
 %09RTAX_SRC   
@@ -44299,16 +44299,57 @@
   = 0x9%0A
+%09RTAX_STATIC                       = 0xd%0A
 %09RTA_AUT
@@ -44382,16 +44382,59 @@
  = 0x40%0A
+%09RTA_BFD                           = 0x800%0A
 %09RTA_BRD
@@ -44467,16 +44467,60 @@
  = 0x80%0A
+%09RTA_DNS                           = 0x1000%0A
 %09RTA_DST
@@ -44798,24 +44798,68 @@
       = 0x4%0A
+%09RTA_SEARCH                        = 0x4000%0A
 %09RTA_SRC    
@@ -44932,16 +44932,60 @@
 = 0x200%0A
+%09RTA_STATIC                        = 0x2000%0A
 %09RTF_ANN
@@ -45016,24 +45016,71 @@
    = 0x4000%0A
+%09RTF_BFD                           = 0x1000000%0A
 %09RTF_BLACKHO
@@ -45107,24 +45107,115 @@
    = 0x1000%0A
+%09RTF_BROADCAST                     = 0x400000%0A%09RTF_CACHED                        = 0x20000%0A
 %09RTF_CLONED 
@@ -45290,16 +45290,62 @@
 = 0x100%0A
+%09RTF_CONNECTED                     = 0x800000%0A
 %09RTF_DON
@@ -45424,54 +45424,55 @@
 x10%0A
-%09RTF_FMASK                         = 0x10f808%0A
+%09RTF_FMASK                         = 0x110fc08%0A
 %09RTF
@@ -45596,50 +45596,54 @@
 400%0A
-%09RTF_MASK                          = 0x80%0A
+%09RTF_LOCAL                         = 0x200000%0A
 %09RTF
@@ -45767,24 +45767,67 @@
  = 0x100000%0A
+%09RTF_MULTICAST                     = 0x200%0A
 %09RTF_PERMANE
@@ -46035,53 +46035,8 @@
 0x8%0A
-%09RTF_SOURCE                        = 0x20000%0A
 %09RTF
@@ -46078,54 +46078,8 @@
 800%0A
-%09RTF_TUNNEL                        = 0x100000%0A
 %09RTF
@@ -46163,51 +46163,8 @@
 000%0A
-%09RTF_XRESOLVE                      = 0x200%0A
 %09RTM
@@ -46200,16 +46200,58 @@
   = 0x1%0A
+%09RTM_BFD                           = 0x12%0A
 %09RTM_CHA
@@ -46530,16 +46530,58 @@
   = 0xe%0A
+%09RTM_INVALIDATE                    = 0x11%0A
 %09RTM_LOC
@@ -46779,16 +46779,58 @@
   = 0xc%0A
+%09RTM_PROPOSAL                      = 0x13%0A
 %09RTM_RED
@@ -47321,16 +47321,99 @@
  = 0x20%0A
+%09RT_TABLEID_BITS                   = 0x8%0A%09RT_TABLEID_MASK                   = 0xff%0A
 %09RT_TABL
@@ -47923,56 +47923,8 @@
 987%0A
-%09SIOCALIFADDR                      = 0x8218691c%0A
 %09SIO
@@ -47971,152 +47971,200 @@
 307%0A
-%09SIOCBRDGADD                       = 0x8058693c%0A%09SIOCBRDGADDS                      = 0x80586941%0A%09SIOCBRDGARL                       = 0x806e694d%0A
+%09SIOCBRDGADD                       = 0x8060693c%0A%09SIOCBRDGADDL                      = 0x80606949%0A%09SIOCBRDGADDS                      = 0x80606941%0A%09SIOCBRDGARL                       = 0x808c694d%0A
 %09SIO
@@ -48211,440 +48211,440 @@
 947%0A
-%09SIOCBRDGDEL                       = 0x8058693d%0A%09SIOCBRDGDELS                      = 0x80586942%0A%09SIOCBRDGFLUSH                     = 0x80586948%0A%09SIOCBRDGFRL                       = 0x806e694e%0A%09SIOCBRDGGCACHE                    = 0xc0146941%0A%09SIOCBRDGGFD                       = 0xc0146952%0A%09SIOCBRDGGHT                       = 0xc0146951%0A%09SIOCBRDGGIFFLGS                   = 0xc058693e%0A%09SIOCBRDGGMA                       = 0xc0146953%0A
+%09SIOCBRDGDEL                       = 0x8060693d%0A%09SIOCBRDGDELS                      = 0x80606942%0A%09SIOCBRDGFLUSH                     = 0x80606948%0A%09SIOCBRDGFRL                       = 0x808c694e%0A%09SIOCBRDGGCACHE                    = 0xc0186941%0A%09SIOCBRDGGFD                       = 0xc0186952%0A%09SIOCBRDGGHT                       = 0xc0186951%0A%09SIOCBRDGGIFFLGS                   = 0xc060693e%0A%09SIOCBRDGGMA                       = 0xc0186953%0A
 %09SIO
@@ -48691,56 +48691,56 @@
 958%0A
-%09SIOCBRDGGPRI                      = 0xc0146950%0A
+%09SIOCBRDGGPRI                      = 0xc0186950%0A
 %09SIO
@@ -48787,152 +48787,104 @@
 94f%0A
-%09SIOCBRDGGSIFS                     = 0xc058693c%0A%09SIOCBRDGGTO                       = 0xc0146946%0A%09SIOCBRDGIFS                       = 0xc0586942%0A
+%09SIOCBRDGGTO                       = 0xc0186946%0A%09SIOCBRDGIFS                       = 0xc0606942%0A
 %09SIO
@@ -48979,536 +48979,584 @@
 944%0A
-%09SIOCBRDGSCACHE                    = 0x80146940%0A%09SIOCBRDGSFD                       = 0x80146952%0A%09SIOCBRDGSHT                       = 0x80146951%0A%09SIOCBRDGSIFCOST                   = 0x80586955%0A%09SIOCBRDGSIFFLGS                   = 0x8058693f%0A%09SIOCBRDGSIFPRIO                   = 0x80586954%0A%09SIOCBRDGSMA                       = 0x80146953%0A%09SIOCBRDGSPRI                      = 0x80146950%0A%09SIOCBRDGSPROTO                    = 0x8014695a%0A%09SIOCBRDGSTO                       = 0x80146945%0A%09SIOCBRDGSTXHC                     = 0x80146959%0A
+%09SIOCBRDGSCACHE                    = 0x80186940%0A%09SIOCBRDGSFD                       = 0x80186952%0A%09SIOCBRDGSHT                       = 0x80186951%0A%09SIOCBRDGSIFCOST                   = 0x80606955%0A%09SIOCBRDGSIFFLGS                   = 0x8060693f%0A%09SIOCBRDGSIFPRIO                   = 0x80606954%0A%09SIOCBRDGSIFPROT                   = 0x8060694a%0A%09SIOCBRDGSMA                       = 0x80186953%0A%09SIOCBRDGSPRI                      = 0x80186950%0A%09SIOCBRDGSPROTO                    = 0x8018695a%0A%09SIOCBRDGSTO                       = 0x80186945%0A%09SIOCBRDGSTXHC                     = 0x80186959%0A
 %09SIO
@@ -49695,16 +49695,64 @@
 0286989%0A
+%09SIOCDIFPARENT                     = 0x802069b4%0A
 %09SIOCDIF
@@ -49795,56 +49795,56 @@
 949%0A
-%09SIOCDLIFADDR                      = 0x8218691e%0A
+%09SIOCDVNETID                       = 0x802069af%0A
 %09SIO
@@ -49935,16 +49935,64 @@
 020699a%0A
+%09SIOCGETMPWCFG                     = 0xc02069ae%0A
 %09SIOCGET
@@ -50227,56 +50227,8 @@
 990%0A
-%09SIOCGHIWAT                        = 0x40047301%0A
 %09SIO
@@ -50275,56 +50275,8 @@
 921%0A
-%09SIOCGIFASYNCMAP                   = 0xc020697c%0A
 %09SIO
@@ -50803,56 +50803,104 @@
 9a5%0A
-%09SIOCGIFMEDIA                      = 0xc0306936%0A
+%09SIOCGIFLLPRIO                     = 0xc02069b6%0A%09SIOCGIFMEDIA                      = 0xc0406938%0A
 %09SIO
@@ -51043,56 +51043,104 @@
 925%0A
-%09SIOCGIFPDSTADDR                   = 0xc0206948%0A
+%09SIOCGIFPAIR                       = 0xc02069b1%0A%09SIOCGIFPARENT                     = 0xc02069b3%0A
 %09SIO
@@ -51187,56 +51187,8 @@
 99c%0A
-%09SIOCGIFPSRCADDR                   = 0xc0206947%0A
 %09SIO
@@ -51283,56 +51283,56 @@
 983%0A
-%09SIOCGIFTIMESLOT                   = 0xc0206986%0A
+%09SIOCGIFRXR                        = 0x802069aa%0A
 %09SIO
@@ -51379,56 +51379,8 @@
 99e%0A
-%09SIOCGLIFADDR                      = 0xc218691d%0A
 %09SIO
@@ -51423,16 +51423,64 @@
 218694b%0A
+%09SIOCGLIFPHYDF                     = 0xc02069c2%0A
 %09SIOCGLI
@@ -51571,56 +51571,8 @@
 9a9%0A
-%09SIOCGLOWAT                        = 0x40047303%0A
 %09SIO
@@ -51663,16 +51663,112 @@
 0206994%0A
+%09SIOCGUMBINFO                      = 0xc02069be%0A%09SIOCGUMBPARAM                     = 0xc02069c0%0A
 %09SIOCGVH
@@ -51807,16 +51807,64 @@
 02069f6%0A
+%09SIOCGVNETFLOWID                   = 0xc02069c4%0A
 %09SIOCGVN
@@ -51903,16 +51903,112 @@
 02069a7%0A
+%09SIOCIFAFATTACH                    = 0x801169ab%0A%09SIOCIFAFDETACH                    = 0x801169ac%0A
 %09SIOCIFC
@@ -52239,16 +52239,64 @@
 0206999%0A
+%09SIOCSETMPWCFG                     = 0x802069ad%0A
 %09SIOCSET
@@ -52435,56 +52435,8 @@
 98f%0A
-%09SIOCSHIWAT                        = 0x80047300%0A
 %09SIO
@@ -52483,56 +52483,8 @@
 90c%0A
-%09SIOCSIFASYNCMAP                   = 0x8020697d%0A
 %09SIO
@@ -52819,56 +52819,104 @@
 91f%0A
-%09SIOCSIFMEDIA                      = 0xc0206935%0A
+%09SIOCSIFLLPRIO                     = 0x802069b5%0A%09SIOCSIFMEDIA                      = 0xc0206937%0A
 %09SIO
@@ -53059,56 +53059,104 @@
 916%0A
-%09SIOCSIFPHYADDR                    = 0x80406946%0A
+%09SIOCSIFPAIR                       = 0x802069b0%0A%09SIOCSIFPARENT                     = 0x802069b2%0A
 %09SIO
@@ -53299,56 +53299,8 @@
 982%0A
-%09SIOCSIFTIMESLOT                   = 0x80206985%0A
 %09SIO
@@ -53387,24 +53387,72 @@
  0x8218694a%0A
+%09SIOCSLIFPHYDF                     = 0x802069c1%0A
 %09SIOCSLIFPHY
@@ -53539,56 +53539,8 @@
 9a8%0A
-%09SIOCSLOWAT                        = 0x80047302%0A
 %09SIO
@@ -53631,16 +53631,64 @@
 0206993%0A
+%09SIOCSUMBPARAM                     = 0x802069bf%0A
 %09SIOCSVH
@@ -53727,16 +53727,64 @@
 02069f5%0A
+%09SIOCSVNETFLOWID                   = 0x802069c3%0A
 %09SIOCSVN
@@ -53823,16 +53823,300 @@
 02069a6%0A
+%09SIOCSWGDPID                       = 0xc018695b%0A%09SIOCSWGMAXFLOW                    = 0xc0186960%0A%09SIOCSWGMAXGROUP                   = 0xc018695d%0A%09SIOCSWSDPID                       = 0x8018695c%0A%09SIOCSWSPORTNO                     = 0xc060695f%0A%09SOCK_CLOEXEC                      = 0x8000%0A
 %09SOCK_DG
@@ -54148,16 +54148,104 @@
   = 0x2%0A
+%09SOCK_DNS                          = 0x1000%0A%09SOCK_NONBLOCK                     = 0x4000%0A
 %09SOCK_RA
@@ -55519,16 +55519,1255 @@
  = 0x40%0A
+%09SO_ZEROIZE                        = 0x2000%0A%09S_BLKSIZE                         = 0x200%0A%09S_IEXEC                           = 0x40%0A%09S_IFBLK                           = 0x6000%0A%09S_IFCHR                           = 0x2000%0A%09S_IFDIR                           = 0x4000%0A%09S_IFIFO                           = 0x1000%0A%09S_IFLNK                           = 0xa000%0A%09S_IFMT                            = 0xf000%0A%09S_IFREG                           = 0x8000%0A%09S_IFSOCK                          = 0xc000%0A%09S_IREAD                           = 0x100%0A%09S_IRGRP                           = 0x20%0A%09S_IROTH                           = 0x4%0A%09S_IRUSR                           = 0x100%0A%09S_IRWXG                           = 0x38%0A%09S_IRWXO                           = 0x7%0A%09S_IRWXU                           = 0x1c0%0A%09S_ISGID                           = 0x400%0A%09S_ISTXT                           = 0x200%0A%09S_ISUID                           = 0x800%0A%09S_ISVTX                           = 0x200%0A%09S_IWGRP                           = 0x10%0A%09S_IWOTH                           = 0x2%0A%09S_IWRITE                          = 0x80%0A%09S_IWUSR                           = 0x80%0A%09S_IXGRP                           = 0x8%0A%09S_IXOTH                           = 0x1%0A%09S_IXUSR                           = 0x40%0A
 %09TCIFLUS
@@ -56799,16 +56799,57 @@
   = 0x1%0A
+%09TCIOFF                            = 0x3%0A
 %09TCIOFLU
@@ -56881,16 +56881,57 @@
   = 0x3%0A
+%09TCION                             = 0x4%0A
 %09TCOFLUS
@@ -56955,32 +56955,114 @@
           = 0x2%0A
+%09TCOOFF                            = 0x1%0A%09TCOON                             = 0x2%0A
 %09TCP_MAXBURST   
@@ -57424,49 +57424,8 @@
 x10%0A
-%09TCP_NSTATES                       = 0xb%0A
 %09TCP
@@ -57598,16 +57598,112 @@
 0007478%0A
+%09TIOCCHKVERAUTH                    = 0x2000741e%0A%09TIOCCLRVERAUTH                    = 0x2000741d%0A
 %09TIOCCON
@@ -60130,16 +60130,64 @@
 004741b%0A
+%09TIOCSETVERAUTH                    = 0x8004741c%0A
 %09TIOCSFL
@@ -60374,56 +60374,56 @@
 46e%0A
-%09TIOCSTAT                          = 0x80047465%0A
+%09TIOCSTAT                          = 0x20007465%0A
 %09TIO
@@ -60658,16 +60658,100 @@
 0047466%0A
+%09TIOCUCNTL_CBRK                    = 0x7a%0A%09TIOCUCNTL_SBRK                    = 0x7b%0A
 %09TOSTOP 
@@ -61199,16 +61199,508 @@
  = 0x10%0A
+%09VM_ANONMIN                        = 0x7%0A%09VM_LOADAVG                        = 0x2%0A%09VM_MAXID                          = 0xc%0A%09VM_MAXSLP                         = 0xa%0A%09VM_METER                          = 0x1%0A%09VM_NKMEMPAGES                     = 0x6%0A%09VM_PSSTRINGS                      = 0x3%0A%09VM_SWAPENCRYPT                    = 0x5%0A%09VM_USPACE                         = 0xb%0A%09VM_UVMEXP                         = 0x4%0A%09VM_VNODEMIN                       = 0x9%0A%09VM_VTEXTMIN                       = 0x8%0A
 %09VQUIT  
@@ -62190,50 +62190,8 @@
 0x1%0A
-%09WSTOPPED                          = 0x7f%0A
 %09WUN
@@ -62227,16 +62227,63 @@
   = 0x2%0A
+%09XCASE                             = 0x1000000%0A
 )%0A%0A// Er
@@ -62643,16 +62643,55 @@
 no(0x9)%0A
+%09EBADMSG         = syscall.Errno(0x5c)%0A
 %09EBADRPC
@@ -63695,47 +63695,47 @@
 15)%0A
-%09ELAST           = syscall.Errno(0x5b)%0A
+%09ELAST           = syscall.Errno(0x5f)%0A
 %09ELO
@@ -64779,16 +64779,55 @@
 o(0x42)%0A
+%09ENOTRECOVERABLE = syscall.Errno(0x5d)%0A
 %09ENOTSOC
@@ -65051,16 +65051,55 @@
 o(0x57)%0A
+%09EOWNERDEAD      = syscall.Errno(0x5e)%0A
 %09EPERM  
@@ -65362,16 +65362,55 @@
 o(0x4a)%0A
+%09EPROTO          = syscall.Errno(0x5f)%0A
 %09EPROTON
@@ -66069,6555 +66069,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EWOULDBLOCK%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC program not available%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIPSEC%22, %22IPsec processing failure%22%7D,%0A%09%7B83, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B84, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B85, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B86, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B87, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B88, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B89, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B90, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B91, %22ELAST%22, %22not supported%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22thread AST%22%7D,%0A%7D%0A
- f 0e17c46fe98a20c3a0622c1014abd42cb1e4f90adff7e6401bec6ab4acb8ef63 vendor/golang.org/x/sys/unix/zerrors_openbsd_arm.go
+ f 776e6010c212d42d24100fd8ecc4bee86b7679100b57ed2cb26631d4df26c46b vendor/golang.org/x/sys/unix/zerrors_openbsd_arm.go
dmppatch 7
@@ -52278,16 +52278,1211 @@
  = 0x40%0A
+%09S_BLKSIZE                         = 0x200%0A%09S_IEXEC                           = 0x40%0A%09S_IFBLK                           = 0x6000%0A%09S_IFCHR                           = 0x2000%0A%09S_IFDIR                           = 0x4000%0A%09S_IFIFO                           = 0x1000%0A%09S_IFLNK                           = 0xa000%0A%09S_IFMT                            = 0xf000%0A%09S_IFREG                           = 0x8000%0A%09S_IFSOCK                          = 0xc000%0A%09S_IREAD                           = 0x100%0A%09S_IRGRP                           = 0x20%0A%09S_IROTH                           = 0x4%0A%09S_IRUSR                           = 0x100%0A%09S_IRWXG                           = 0x38%0A%09S_IRWXO                           = 0x7%0A%09S_IRWXU                           = 0x1c0%0A%09S_ISGID                           = 0x400%0A%09S_ISTXT                           = 0x200%0A%09S_ISUID                           = 0x800%0A%09S_ISVTX                           = 0x200%0A%09S_IWGRP                           = 0x10%0A%09S_IWOTH                           = 0x2%0A%09S_IWRITE                          = 0x80%0A%09S_IWUSR                           = 0x80%0A%09S_IXGRP                           = 0x8%0A%09S_IXOTH                           = 0x1%0A%09S_IXUSR                           = 0x40%0A
 %09TCIFLUS
@@ -61738,6555 +61738,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EWOULDBLOCK%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC program not available%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIPSEC%22, %22IPsec processing failure%22%7D,%0A%09%7B83, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B84, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B85, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B86, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B87, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B88, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B89, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B90, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B91, %22ELAST%22, %22not supported%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22thread AST%22%7D,%0A%7D%0A
- f 2be9945fc1b828d7079ec331460a97732336e47e35a428c16ae81c80b0fa6fa0 vendor/golang.org/x/sys/unix/zerrors_solaris_amd64.go
+ f 897767a397667a321776a5cba443e227b7a328fd989b6379a583c2fd06860e70 vendor/golang.org/x/sys/unix/zerrors_solaris_amd64.go
dmppatch 3
@@ -49370,8738 +49370,4 @@
 )%0A)%0A
-%0A// Signals%0Aconst (%0A%09SIGABRT    = syscall.Signal(0x6)%0A%09SIGALRM    = syscall.Signal(0xe)%0A%09SIGBUS     = syscall.Signal(0xa)%0A%09SIGCANCEL  = syscall.Signal(0x24)%0A%09SIGCHLD    = syscall.Signal(0x12)%0A%09SIGCLD     = syscall.Signal(0x12)%0A%09SIGCONT    = syscall.Signal(0x19)%0A%09SIGEMT     = syscall.Signal(0x7)%0A%09SIGFPE     = syscall.Signal(0x8)%0A%09SIGFREEZE  = syscall.Signal(0x22)%0A%09SIGHUP     = syscall.Signal(0x1)%0A%09SIGILL     = syscall.Signal(0x4)%0A%09SIGINFO    = syscall.Signal(0x29)%0A%09SIGINT     = syscall.Signal(0x2)%0A%09SIGIO      = syscall.Signal(0x16)%0A%09SIGIOT     = syscall.Signal(0x6)%0A%09SIGJVM1    = syscall.Signal(0x27)%0A%09SIGJVM2    = syscall.Signal(0x28)%0A%09SIGKILL    = syscall.Signal(0x9)%0A%09SIGLOST    = syscall.Signal(0x25)%0A%09SIGLWP     = syscall.Signal(0x21)%0A%09SIGPIPE    = syscall.Signal(0xd)%0A%09SIGPOLL    = syscall.Signal(0x16)%0A%09SIGPROF    = syscall.Signal(0x1d)%0A%09SIGPWR     = syscall.Signal(0x13)%0A%09SIGQUIT    = syscall.Signal(0x3)%0A%09SIGSEGV    = syscall.Signal(0xb)%0A%09SIGSTOP    = syscall.Signal(0x17)%0A%09SIGSYS     = syscall.Signal(0xc)%0A%09SIGTERM    = syscall.Signal(0xf)%0A%09SIGTHAW    = syscall.Signal(0x23)%0A%09SIGTRAP    = syscall.Signal(0x5)%0A%09SIGTSTP    = syscall.Signal(0x18)%0A%09SIGTTIN    = syscall.Signal(0x1a)%0A%09SIGTTOU    = syscall.Signal(0x1b)%0A%09SIGURG     = syscall.Signal(0x15)%0A%09SIGUSR1    = syscall.Signal(0x10)%0A%09SIGUSR2    = syscall.Signal(0x11)%0A%09SIGVTALRM  = syscall.Signal(0x1c)%0A%09SIGWAITING = syscall.Signal(0x20)%0A%09SIGWINCH   = syscall.Signal(0x14)%0A%09SIGXCPU    = syscall.Signal(0x1e)%0A%09SIGXFSZ    = syscall.Signal(0x1f)%0A%09SIGXRES    = syscall.Signal(0x26)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22not owner%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22I/O error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22arg list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file number%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22not enough space%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22file table overflow%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22deadlock situation detected/avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no record locks available%22%7D,%0A%09%7B47, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B48, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B49, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B50, %22EBADE%22, %22bad exchange descriptor%22%7D,%0A%09%7B51, %22EBADR%22, %22bad request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22message tables full%22%7D,%0A%09%7B53, %22ENOANO%22, %22anode table overflow%22%7D,%0A%09%7B54, %22EBADRQC%22, %22bad request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock%22%7D,%0A%09%7B57, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B58, %22EOWNERDEAD%22, %22owner of the lock died%22%7D,%0A%09%7B59, %22ENOTRECOVERABLE%22, %22lock is not recoverable%22%7D,%0A%09%7B60, %22ENOSTR%22, %22not a stream device%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of stream resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22ELOCKUNMAPPED%22, %22locked lock was unmapped %22%7D,%0A%09%7B73, %22ENOTACTIVE%22, %22facility is not active%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22not a data message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in more shared libraries than system limit%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22can not exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B89, %22ENOSYS%22, %22operation not applicable%22%7D,%0A%09%7B90, %22ELOOP%22, %22number of symbolic links encountered during path name traversal exceeds MAXSYMLINKS%22%7D,%0A%09%7B91, %22ERESTART%22, %22error 91%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22error 92%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22option not supported by protocol%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22EOPNOTSUPP%22, %22operation not supported on transport endpoint%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection because of reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after socket shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal Instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/Breakpoint Trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort%22%7D,%0A%09%7B7, %22SIGEMT%22, %22emulation Trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22arithmetic Exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus Error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation Fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad System Call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken Pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm Clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user Signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user Signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child Status Changed%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power-Fail/Restart%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window Size Change%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent Socket Condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22pollable Event%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped (user)%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual Timer Expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling Timer Expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22cpu Limit Exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file Size Limit Exceeded%22%7D,%0A%09%7B32, %22SIGWAITING%22, %22no runnable lwp%22%7D,%0A%09%7B33, %22SIGLWP%22, %22inter-lwp signal%22%7D,%0A%09%7B34, %22SIGFREEZE%22, %22checkpoint Freeze%22%7D,%0A%09%7B35, %22SIGTHAW%22, %22checkpoint Thaw%22%7D,%0A%09%7B36, %22SIGCANCEL%22, %22thread Cancellation%22%7D,%0A%09%7B37, %22SIGLOST%22, %22resource Lost%22%7D,%0A%09%7B38, %22SIGXRES%22, %22resource Control Exceeded%22%7D,%0A%09%7B39, %22SIGJVM1%22, %22reserved for JVM 1%22%7D,%0A%09%7B40, %22SIGJVM2%22, %22reserved for JVM 2%22%7D,%0A%09%7B41, %22SIGINFO%22, %22information Request%22%7D,%0A%7D%0A
- f 792c9ff4d00513df5080e2407c65fb821dc11cd14056e418f041b51b4d19a67d vendor/golang.org/x/sys/unix/zptrace386_linux.go
+ f 98fa9c84019d67138d776aad1eeec6dba05d40dc43120cd3bd503af07e7a2ba2 vendor/golang.org/x/sys/unix/zptrace386_linux.go
dmppatch 3
@@ -129,1742 +129,4 @@
 nix%0A
-%0Aimport %22unsafe%22%0A%0A// PtraceRegs386 is the registers used by 386 binaries.%0Atype PtraceRegs386 struct %7B%0A%09Ebx      int32%0A%09Ecx      int32%0A%09Edx      int32%0A%09Esi      int32%0A%09Edi      int32%0A%09Ebp      int32%0A%09Eax      int32%0A%09Xds      int32%0A%09Xes      int32%0A%09Xfs      int32%0A%09Xgs      int32%0A%09Orig_eax int32%0A%09Eip      int32%0A%09Xcs      int32%0A%09Eflags   int32%0A%09Esp      int32%0A%09Xss      int32%0A%7D%0A%0A// PtraceGetRegs386 fetches the registers used by 386 binaries.%0Afunc PtraceGetRegs386(pid int, regsout *PtraceRegs386) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegs386 sets the registers used by 386 binaries.%0Afunc PtraceSetRegs386(pid int, regs *PtraceRegs386) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0A// PtraceRegsAmd64 is the registers used by amd64 binaries.%0Atype PtraceRegsAmd64 struct %7B%0A%09R15      uint64%0A%09R14      uint64%0A%09R13      uint64%0A%09R12      uint64%0A%09Rbp      uint64%0A%09Rbx      uint64%0A%09R11      uint64%0A%09R10      uint64%0A%09R9       uint64%0A%09R8       uint64%0A%09Rax      uint64%0A%09Rcx      uint64%0A%09Rdx      uint64%0A%09Rsi      uint64%0A%09Rdi      uint64%0A%09Orig_rax uint64%0A%09Rip      uint64%0A%09Cs       uint64%0A%09Eflags   uint64%0A%09Rsp      uint64%0A%09Ss       uint64%0A%09Fs_base  uint64%0A%09Gs_base  uint64%0A%09Ds       uint64%0A%09Es       uint64%0A%09Fs       uint64%0A%09Gs       uint64%0A%7D%0A%0A// PtraceGetRegsAmd64 fetches the registers used by amd64 binaries.%0Afunc PtraceGetRegsAmd64(pid int, regsout *PtraceRegsAmd64) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsAmd64 sets the registers used by amd64 binaries.%0Afunc PtraceSetRegsAmd64(pid int, regs *PtraceRegsAmd64) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A
- f 6253ec7ba005d6f156f5f5cd8ee7d8d598fcbf038f948bb46abd98fa21e7c714 vendor/golang.org/x/sys/unix/zptracearm_linux.go
+ f ed7a6d10d98325f0461220b52696a7233f7319e75658197bf01b0ae26e81d8db vendor/golang.org/x/sys/unix/zptracearm_linux.go
dmppatch 3
@@ -129,1093 +129,4 @@
 nix%0A
-%0Aimport %22unsafe%22%0A%0A// PtraceRegsArm is the registers used by arm binaries.%0Atype PtraceRegsArm struct %7B%0A%09Uregs %5B18%5Duint32%0A%7D%0A%0A// PtraceGetRegsArm fetches the registers used by arm binaries.%0Afunc PtraceGetRegsArm(pid int, regsout *PtraceRegsArm) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsArm sets the registers used by arm binaries.%0Afunc PtraceSetRegsArm(pid int, regs *PtraceRegsArm) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0A// PtraceRegsArm64 is the registers used by arm64 binaries.%0Atype PtraceRegsArm64 struct %7B%0A%09Regs   %5B31%5Duint64%0A%09Sp     uint64%0A%09Pc     uint64%0A%09Pstate uint64%0A%7D%0A%0A// PtraceGetRegsArm64 fetches the registers used by arm64 binaries.%0Afunc PtraceGetRegsArm64(pid int, regsout *PtraceRegsArm64) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsArm64 sets the registers used by arm64 binaries.%0Afunc PtraceSetRegsArm64(pid int, regs *PtraceRegsArm64) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A
- f bf857d0dcb43752a63dc82734f653143481c327b1f10e6a68df15c2dcc94169e vendor/golang.org/x/sys/unix/zptracemips_linux.go
+ f 2fd010fed63ee9fb79a10a19ea81d2fd8cae6f0196099780964e8a1c3cc0476e vendor/golang.org/x/sys/unix/zptracemips_linux.go
dmppatch 3
@@ -133,1279 +133,4 @@
 nix%0A
-%0Aimport %22unsafe%22%0A%0A// PtraceRegsMips is the registers used by mips binaries.%0Atype PtraceRegsMips struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0A// PtraceGetRegsMips fetches the registers used by mips binaries.%0Afunc PtraceGetRegsMips(pid int, regsout *PtraceRegsMips) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsMips sets the registers used by mips binaries.%0Afunc PtraceSetRegsMips(pid int, regs *PtraceRegsMips) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0A// PtraceRegsMips64 is the registers used by mips64 binaries.%0Atype PtraceRegsMips64 struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0A// PtraceGetRegsMips64 fetches the registers used by mips64 binaries.%0Afunc PtraceGetRegsMips64(pid int, regsout *PtraceRegsMips64) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsMips64 sets the registers used by mips64 binaries.%0Afunc PtraceSetRegsMips64(pid int, regs *PtraceRegsMips64) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A
- f 9242dc56c12da60f55bd6bed6ec08f04a3966903f14ee1e843c14be374717f21 vendor/golang.org/x/sys/unix/zptracemipsle_linux.go
+ f 73cf97b28a0652ea7960f5b894b48335ba64cbf682ffe42867a569bdbdba20d1 vendor/golang.org/x/sys/unix/zptracemipsle_linux.go
dmppatch 3
@@ -141,1323 +141,4 @@
 nix%0A
-%0Aimport %22unsafe%22%0A%0A// PtraceRegsMipsle is the registers used by mipsle binaries.%0Atype PtraceRegsMipsle struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0A// PtraceGetRegsMipsle fetches the registers used by mipsle binaries.%0Afunc PtraceGetRegsMipsle(pid int, regsout *PtraceRegsMipsle) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsMipsle sets the registers used by mipsle binaries.%0Afunc PtraceSetRegsMipsle(pid int, regs *PtraceRegsMipsle) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0A// PtraceRegsMips64le is the registers used by mips64le binaries.%0Atype PtraceRegsMips64le struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0A// PtraceGetRegsMips64le fetches the registers used by mips64le binaries.%0Afunc PtraceGetRegsMips64le(pid int, regsout *PtraceRegsMips64le) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsMips64le sets the registers used by mips64le binaries.%0Afunc PtraceSetRegsMips64le(pid int, regs *PtraceRegsMips64le) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A
- f ac9bbe9dd0ae41cc4fa95787f401ffdc2938e4ac4de57a39722c053625bdf66f vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go
+ f 3888c0f1694a1f1bb45d314836c5e192a41a91e335fb941b64682f27d945183f vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go
dmppatch 15
@@ -204,19 +204,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -217,10398 +217,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kill(pid int, signum int, posix int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // T
@@ -527,15962 +527,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exchangedata(path1 string, path2 string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path1)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(path2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := RawSyscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -828,11704 +828,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0, 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setprivexec(flag int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos), uintptr(pos%3E%3E32), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tp *Timeval) (sec int32, usec int32, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09sec = int32(r0)%0A%09usec = int32(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 7c2ccd9387634b6ecbc1407937cc41e85c6b1ade6826ad6dde107c84e8ee963c vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go
+ f ae32649e801f28e18514253d9c8f3f6056d71f1b6fb745b65e880a6a213a5de7 vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go
dmppatch 15
@@ -205,19 +205,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -218,10398 +218,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kill(pid int, signum int, posix int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // T
@@ -528,15908 +528,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exchangedata(path1 string, path2 string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path1)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(path2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := RawSyscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -829,11610 +829,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setprivexec(flag int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos))%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tp *Timeval) (sec int64, usec int32, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09sec = int64(r0)%0A%09usec = int32(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f f25d33183604b0f12dff916454714c73d2fde904110f26f7a676c2b081c001f3 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go
+ f 44458b23de2b2ba870bbda4c8c64852732491ea51fb7609e65db43ae49f66896 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go
dmppatch 19
@@ -1,92 +1,97 @@
-// mksyscall.pl -tags darwin,arm syscall_bsd.go syscall_darwin.go syscall_darwin_arm.go%0A
+// mksyscall.pl -l32 -tags darwin,arm syscall_bsd.go syscall_darwin.go syscall_darwin_arm.go%0A
 // C
@@ -204,19 +204,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -216,10398 +216,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kill(pid int, signum int, posix int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -527,15962 +527,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exchangedata(path1 string, path2 string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path1)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(path2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := RawSyscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -828,11704 +828,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0, 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setprivexec(flag int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos), uintptr(pos%3E%3E32), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tp *Timeval) (sec int32, usec int32, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09sec = int32(r0)%0A%09usec = int32(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 0c58ec8c0661369612255657940f5e844248b1718370d18fcb81467671a6ef15 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go
+ f 11109b3f6cfd1fb9682baaa416430d5569d36b5403d150c45882685eb4133667 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go
dmppatch 15
@@ -205,19 +205,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -218,10398 +218,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kill(pid int, signum int, posix int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // T
@@ -528,15908 +528,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exchangedata(path1 string, path2 string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path1)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(path2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := RawSyscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -829,11610 +829,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setprivexec(flag int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos))%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tp *Timeval) (sec int64, usec int32, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09sec = int64(r0)%0A%09usec = int32(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f c2ef759d3dda120ddf3c75387aeb31d9f456d311da11bf76d8750f70863e3340 vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go
+ f 2975d804f298a79b4286a73d018549173899282eaadca566c1c0fc6d7c82f85f vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go
dmppatch 15
@@ -228,19 +228,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -240,11098 +240,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc extpread(fd int, p %5B%5Dbyte, flags int, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTPREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc extpwrite(fd int, p %5B%5Dbyte, flags int, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTPWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -551,13301 +551,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -852,10577 +852,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(whence), 0, 0)%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 101e0da097839de3246b53be0d978cbbdb1a56e6d8f26b22332f23386bc9d30d vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go
+ f 1fe1910bcd94249af4168723c11b2b4a2169c086fa538664f3e5394d0d6242f1 vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go
dmppatch 15
@@ -208,19 +208,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -221,10220 +221,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // T
@@ -531,23582 +531,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CapEnter() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_ENTER, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsGet(version int, fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS___CAP_RIGHTS_GET, uintptr(version), uintptr(fd), uintptr(unsafe.Pointer(rightsp)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsLimit(fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_RIGHTS_LIMIT, uintptr(fd), uintptr(unsafe.Pointer(rightsp)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_POSIX_FADVISE, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(fdat int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(fdat), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -832,12483 +832,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0, 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos), uintptr(pos%3E%3E32), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 6a2000955e83b7f224c22c273c57342777d1299b0b8bcd18acb02dc3a3c9a500 vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go
+ f df5571e681354b09efc43c96cd9fc9c972a4ea2ac6ff49e3e8b05b6f10b1818a vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go
dmppatch 15
@@ -209,19 +209,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -222,10220 +222,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // T
@@ -532,23492 +532,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CapEnter() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_ENTER, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsGet(version int, fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS___CAP_RIGHTS_GET, uintptr(version), uintptr(fd), uintptr(unsafe.Pointer(rightsp)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsLimit(fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_RIGHTS_LIMIT, uintptr(fd), uintptr(unsafe.Pointer(rightsp)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_POSIX_FADVISE, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(fdat int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(fdat), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -833,12389 +833,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos))%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 724193e8ef55ed2b78268fd18e91918766631952aa70ed7ee8b28db9bf7be9bc vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go
+ f b47a12578b10e195f4afff48f59edea39d6abe4f4335ded6ed70176f60ae2370 vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go
dmppatch 15
@@ -213,19 +213,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -226,10220 +226,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // T
@@ -536,23601 +536,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CapEnter() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_ENTER, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsGet(version int, fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS___CAP_RIGHTS_GET, uintptr(version), uintptr(fd), uintptr(unsafe.Pointer(rightsp)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsLimit(fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_RIGHTS_LIMIT, uintptr(fd), uintptr(unsafe.Pointer(rightsp)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_POSIX_FADVISE, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(fdat int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(fdat), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -837,12493 +837,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 40baa2a6e9e9bcf40de8483b9d8e511c03079a6685ccf58f93dc528edc75cf59 vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
+ f 025b426d990ee31be6c2fa3acbea7eaba63936124ebd1acdb036bbdb656206ac vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
dmppatch 15
@@ -185,19 +185,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -198,385 +198,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // T
@@ -508,25187 +508,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off%3E%3E32), uintptr(len), uintptr(len%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -809,22414 +809,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64_64, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN32, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE64, uintptr(fd), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID32, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID32, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID32, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID32, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN32, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID32, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID32, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID32, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID32, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(off%3E%3E32), uintptr(n), uintptr(n%3E%3E32), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 9ca1a5bc3d10dea622e06db15a6a7648fb59f56fc80776d55e62ee191dc955f5 vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
+ f d245b40ce6ffe4284dbd6345df1a9d701e3497d75b179c6b00ed59c447352a52 vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
dmppatch 15
@@ -186,19 +186,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -198,385 +198,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -509,25157 +509,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -810,26916 +810,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 03f637821f9c94a11f9960c4a4f57907be738ab03e8e586b0924fbc0316b3215 vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
+ f 79cf37a2c6ce97df598a3fd127087ab25179ce5a063fe20426f05e3e0d119bad vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
dmppatch 15
@@ -190,19 +190,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -202,385 +202,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -513,25187 +513,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off%3E%3E32), uintptr(len), uintptr(len%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -814,25586 +814,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, flags int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(flags), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN32, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID32, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID32, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID32, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID32, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN32, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID32, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID32, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID32, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID32, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE64, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UGETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 9bfb5103ee003abc7f60bae1823c642eb7519965bf72aba572729a613356b867 vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
+ f 923337e072ff3c774fa9788b060528f05142a1a6177b4c6957ce161816a6c902 vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
dmppatch 15
@@ -186,19 +186,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -199,385 +199,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // T
@@ -509,25157 +509,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -810,24528 +810,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_PWAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f eb8e18c03f7cf1251e269a250055fc9fad8b7de635717bf182666c66251c3721 vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
+ f 972747d9303a60f3c1767159dd71f229b9900c5b633fc4165871e52c185522d6 vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
dmppatch 15
@@ -194,19 +194,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -206,385 +206,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -517,25187 +517,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off%3E%3E32), uintptr(off), uintptr(len%3E%3E32), uintptr(len))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -818,27262 +818,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(int64(r0)%3C%3C32 %7C int64(r1))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_FADVISE64, uintptr(fd), 0, uintptr(offset%3E%3E32), uintptr(offset), uintptr(length%3E%3E32), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE64, uintptr(fd), 0, uintptr(length%3E%3E32), uintptr(length), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset%3E%3E32), uintptr(offset))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset%3E%3E32), uintptr(offset))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_SYNC_FILE_RANGE, uintptr(fd), 0, uintptr(off%3E%3E32), uintptr(off), uintptr(n%3E%3E32), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length%3E%3E32), uintptr(length), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 9143102f9903b9ca2bfa53c813827b9b3c3a79b275bb24da7ffa5a48a83e09d3 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
+ f 65c6bfab744c75c24168442766929c0a3fa5dfaf8e806ce0aa084cb48c973f40 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
dmppatch 15
@@ -190,19 +190,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -202,385 +202,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -513,25157 +513,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -814,26593 +814,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fstat(fd int, st *stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc lstat(path string, st *stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc stat(path string, st *stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 566a51d6bb168445416c9f2ded932709b096e65a1371a9684798254c61189d18 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
+ f 3686e926286f6112ef97073beb04f7411b513182cad44476dc12596af0e58671 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
dmppatch 15
@@ -194,19 +194,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -206,385 +206,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -517,25157 +517,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -818,26593 +818,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fstat(fd int, st *stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc lstat(path string, st *stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc stat(path string, st *stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 23c57f311d53f87783750150086bc522f56e52b744837622421a278f2e8ecd04 vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
+ f a16c49ba7f8b304161b8f70f9890deb39e380c63262f16cb8758b343fb40af87 vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
dmppatch 15
@@ -198,19 +198,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -210,385 +210,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -521,25187 +521,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off%3E%3E32), uintptr(len), uintptr(len%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -822,27262 +822,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_FADVISE64, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE64, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_SYNC_FILE_RANGE, uintptr(fd), 0, uintptr(off), uintptr(off%3E%3E32), uintptr(n), uintptr(n%3E%3E32), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f cda02093f0d83d217e23e75309c79de525920dc83fc5f8dcd220ae25ff19313a vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
+ f cd8e1063cbaea7c6aabb370fbc5557de95455a892c3cc07d56d969c97de4c401 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
dmppatch 15
@@ -187,19 +187,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -199,385 +199,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -510,25157 +510,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -811,28135 +811,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UGETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE2, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 37f355138ec07a2bc663236fcb79ac811af0d6934647f86df97c69c2fb1d54ab vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
+ f 3a09924f89efa3845aab2896dcc8852c28497cf28d9e2df152aa2efa8f0e59d2 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
dmppatch 15
@@ -191,19 +191,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -203,385 +203,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -514,25157 +514,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -815,28135 +815,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UGETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE2, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f e6e79014875dc7124e4f3c3e529650a85d2569d431fc319c01be3783a12a2765 vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
+ f b8b17c916cd0fa45074fb15fa1782b7c311c62f4388289f4dc0089dfa5d012a4 vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
dmppatch 15
@@ -186,19 +186,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -199,385 +199,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // T
@@ -509,25157 +509,8 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -810,21779 +810,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f d38992052431dc63409d0e129dcd406e697534ad06f4a5f3d2ada17e86f51629 vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go
+ f 7ba02566265b32b163069bb8ed12a0a4fc01bad118f8c59f2742cb3a39b87e08 vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go
dmppatch 16
@@ -192,19 +192,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -205,29 +205,8 @@
 %0A)%0A%0A
-var _ syscall.Errno%0A%0A
 // T
@@ -271,18941 +271,137 @@
 IT%0A%0A
-func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A
+func ioctl(fd int, req uint, arg uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOCTL, uintptr(fd), uintptr(req), uintptr(arg))%0A
 %09if 
@@ -816,25374 +816,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09Syscall(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _, _ := RawSyscall(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 7d803701d54310cce1ecca46420771038eef91c0aca2193a0136356c8ccfa2d8 vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
+ f 727081903aaf39796582c3b9144ea6644f505e5faa3e3f7c685da031dda4485c vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
dmppatch 15
@@ -212,19 +212,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -224,10612 +224,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (fd1 int, fd2 int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09fd1 = int(r0)%0A%09fd2 = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -535,13657 +535,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_POSIX_FADVISE, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), 0, uintptr(length), uintptr(length%3E%3E32), uintptr(advice), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -836,8825 +836,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f d071b0656aee29ecb592a10456feb7ee9724cafc44658afaa30312339c163d51 vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
+ f 55ca1d02b4ee2f83be1092e1f73ec48a660d31e9d3de258b47e15651f1f02ee4 vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
dmppatch 15
@@ -213,19 +213,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -225,10612 +225,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (fd1 int, fd2 int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09fd1 = int(r0)%0A%09fd2 = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -536,13548 +536,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_POSIX_FADVISE, uintptr(fd), 0, uintptr(offset), 0, uintptr(length), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -837,8740 +837,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(whence), 0, 0)%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f d7ffdc04fd6dddcb2735e064ac3667cbf8c5a387567caa7c50544ed3af38d39d vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
+ f baf6e6749c989d94c32558f3a80ac1b57eb9961a1a9091e876d06607b7a842cb vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
dmppatch 15
@@ -217,19 +217,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -229,10612 +229,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (fd1 int, fd2 int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09fd1 = int(r0)%0A%09fd2 = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -540,13657 +540,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_POSIX_FADVISE, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), 0, uintptr(length), uintptr(length%3E%3E32), uintptr(advice), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -841,8825 +841,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 1b9e370317ed722a5ba4df97a7dc87e89f35de5a8a5f10ac63e1e8da321d933f vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
+ f a632d85c191eb9c3ceec9c2967109be923f90a34f8e9999d676be9f208dd730d vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
dmppatch 15
@@ -217,19 +217,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -229,10599 +229,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -540,13783 +540,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrtable() (rtable int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETRTABLE, 0, 0, 0)%0A%09rtable = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -841,10213 +841,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrtable(rtable int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRTABLE, uintptr(rtable), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 520f620a5bef9d47678e7da57216e3a9162ef0f5ff00ff740134715d43ac9d55 vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
+ f 702be529b80843626bb06109794f247ef42c20e6848140e16612aa8d3fbe8cbf vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
dmppatch 15
@@ -218,19 +218,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -230,10599 +230,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -541,13719 +541,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrtable() (rtable int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETRTABLE, 0, 0, 0)%0A%09rtable = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -842,10128 +842,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(whence), 0, 0)%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrtable(rtable int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRTABLE, uintptr(rtable), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 97315ed97e4ff75787ea4b5f1e955cef88c9dc9bd3c0035c0a305b9e26feaccb vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
+ f 0a4f30b46fcfd8568bce890589c45fe6c2a14d90712c161ab7b51c989f27fcd8 vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
dmppatch 15
@@ -222,19 +222,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -234,10599 +234,8 @@
 %22%0A)%0A
-%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// 
@@ -545,13783 +545,8 @@
 IT%0A%0A
-func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrtable() (rtable int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETRTABLE, 0, 0, 0)%0A%09rtable = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func
@@ -846,10213 +846,4 @@
 n%0A%7D%0A
-%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrtable(rtable int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRTABLE, uintptr(rtable), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f cc3b5bb6da43b38adbfefef7d5b3e5042548a47d946b675b6265bf2fcdcd20df vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go
+ f a0f5c487af0568f4a945d8d5f4ed2de35045e8ce5499a9d6854a918547a1aa68 vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go
dmppatch 15
@@ -202,19 +202,8 @@
 t (%0A
-%09%22syscall%22%0A
 %09%22un
@@ -215,18538 +215,8 @@
 %0A)%0A%0A
-//go:cgo_import_dynamic libc_pipe pipe %22libc.so%22%0A//go:cgo_import_dynamic libc_getsockname getsockname %22libsocket.so%22%0A//go:cgo_import_dynamic libc_getcwd getcwd %22libc.so%22%0A//go:cgo_import_dynamic libc_getgroups getgroups %22libc.so%22%0A//go:cgo_import_dynamic libc_setgroups setgroups %22libc.so%22%0A//go:cgo_import_dynamic libc_wait4 wait4 %22libc.so%22%0A//go:cgo_import_dynamic libc_gethostname gethostname %22libc.so%22%0A//go:cgo_import_dynamic libc_utimes utimes %22libc.so%22%0A//go:cgo_import_dynamic libc_utimensat utimensat %22libc.so%22%0A//go:cgo_import_dynamic libc_fcntl fcntl %22libc.so%22%0A//go:cgo_import_dynamic libc_futimesat futimesat %22libc.so%22%0A//go:cgo_import_dynamic libc_accept accept %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_recvmsg __xnet_recvmsg %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_sendmsg __xnet_sendmsg %22libsocket.so%22%0A//go:cgo_import_dynamic libc_acct acct %22libc.so%22%0A//go:cgo_import_dynamic libc___makedev __makedev %22libc.so%22%0A//go:cgo_import_dynamic libc___major __major %22libc.so%22%0A//go:cgo_import_dynamic libc___minor __minor %22libc.so%22%0A//go:cgo_import_dynamic libc_ioctl ioctl %22libc.so%22%0A//go:cgo_import_dynamic libc_poll poll %22libc.so%22%0A//go:cgo_import_dynamic libc_access access %22libc.so%22%0A//go:cgo_import_dynamic libc_adjtime adjtime %22libc.so%22%0A//go:cgo_import_dynamic libc_chdir chdir %22libc.so%22%0A//go:cgo_import_dynamic libc_chmod chmod %22libc.so%22%0A//go:cgo_import_dynamic libc_chown chown %22libc.so%22%0A//go:cgo_import_dynamic libc_chroot chroot %22libc.so%22%0A//go:cgo_import_dynamic libc_close close %22libc.so%22%0A//go:cgo_import_dynamic libc_creat creat %22libc.so%22%0A//go:cgo_import_dynamic libc_dup dup %22libc.so%22%0A//go:cgo_import_dynamic libc_dup2 dup2 %22libc.so%22%0A//go:cgo_import_dynamic libc_exit exit %22libc.so%22%0A//go:cgo_import_dynamic libc_fchdir fchdir %22libc.so%22%0A//go:cgo_import_dynamic libc_fchmod fchmod %22libc.so%22%0A//go:cgo_import_dynamic libc_fchmodat fchmodat %22libc.so%22%0A//go:cgo_import_dynamic libc_fchown fchown %22libc.so%22%0A//go:cgo_import_dynamic libc_fchownat fchownat %22libc.so%22%0A//go:cgo_import_dynamic libc_fdatasync fdatasync %22libc.so%22%0A//go:cgo_import_dynamic libc_flock flock %22libc.so%22%0A//go:cgo_import_dynamic libc_fpathconf fpathconf %22libc.so%22%0A//go:cgo_import_dynamic libc_fstat fstat %22libc.so%22%0A//go:cgo_import_dynamic libc_fstatat fstatat %22libc.so%22%0A//go:cgo_import_dynamic libc_fstatvfs fstatvfs %22libc.so%22%0A//go:cgo_import_dynamic libc_getdents getdents %22libc.so%22%0A//go:cgo_import_dynamic libc_getgid getgid %22libc.so%22%0A//go:cgo_import_dynamic libc_getpid getpid %22libc.so%22%0A//go:cgo_import_dynamic libc_getpgid getpgid %22libc.so%22%0A//go:cgo_import_dynamic libc_getpgrp getpgrp %22libc.so%22%0A//go:cgo_import_dynamic libc_geteuid geteuid %22libc.so%22%0A//go:cgo_import_dynamic libc_getegid getegid %22libc.so%22%0A//go:cgo_import_dynamic libc_getppid getppid %22libc.so%22%0A//go:cgo_import_dynamic libc_getpriority getpriority %22libc.so%22%0A//go:cgo_import_dynamic libc_getrlimit getrlimit %22libc.so%22%0A//go:cgo_import_dynamic libc_getrusage getrusage %22libc.so%22%0A//go:cgo_import_dynamic libc_gettimeofday gettimeofday %22libc.so%22%0A//go:cgo_import_dynamic libc_getuid getuid %22libc.so%22%0A//go:cgo_import_dynamic libc_kill kill %22libc.so%22%0A//go:cgo_import_dynamic libc_lchown lchown %22libc.so%22%0A//go:cgo_import_dynamic libc_link link %22libc.so%22%0A//go:cgo_import_dynamic libc___xnet_llisten __xnet_llisten %22libsocket.so%22%0A//go:cgo_import_dynamic libc_lstat lstat %22libc.so%22%0A//go:cgo_import_dynamic libc_madvise madvise %22libc.so%22%0A//go:cgo_import_dynamic libc_mkdir mkdir %22libc.so%22%0A//go:cgo_import_dynamic libc_mkdirat mkdirat %22libc.so%22%0A//go:cgo_import_dynamic libc_mkfifo mkfifo %22libc.so%22%0A//go:cgo_import_dynamic libc_mkfifoat mkfifoat %22libc.so%22%0A//go:cgo_import_dynamic libc_mknod mknod %22libc.so%22%0A//go:cgo_import_dynamic libc_mknodat mknodat %22libc.so%22%0A//go:cgo_import_dynamic libc_mlock mlock %22libc.so%22%0A//go:cgo_import_dynamic libc_mlockall mlockall %22libc.so%22%0A//go:cgo_import_dynamic libc_mprotect mprotect %22libc.so%22%0A//go:cgo_import_dynamic libc_msync msync %22libc.so%22%0A//go:cgo_import_dynamic libc_munlock munlock %22libc.so%22%0A//go:cgo_import_dynamic libc_munlockall munlockall %22libc.so%22%0A//go:cgo_import_dynamic libc_nanosleep nanosleep %22libc.so%22%0A//go:cgo_import_dynamic libc_open open %22libc.so%22%0A//go:cgo_import_dynamic libc_openat openat %22libc.so%22%0A//go:cgo_import_dynamic libc_pathconf pathconf %22libc.so%22%0A//go:cgo_import_dynamic libc_pause pause %22libc.so%22%0A//go:cgo_import_dynamic libc_pread pread %22libc.so%22%0A//go:cgo_import_dynamic libc_pwrite pwrite %22libc.so%22%0A//go:cgo_import_dynamic libc_read read %22libc.so%22%0A//go:cgo_import_dynamic libc_readlink readlink %22libc.so%22%0A//go:cgo_import_dynamic libc_rename rename %22libc.so%22%0A//go:cgo_import_dynamic libc_renameat renameat %22libc.so%22%0A//go:cgo_import_dynamic libc_rmdir rmdir %22libc.so%22%0A//go:cgo_import_dynamic libc_lseek lseek %22libc.so%22%0A//go:cgo_import_dynamic libc_select select %22libc.so%22%0A//go:cgo_import_dynamic libc_setegid setegid %22libc.so%22%0A//go:cgo_import_dynamic libc_seteuid seteuid %22libc.so%22%0A//go:cgo_import_dynamic libc_setgid setgid %22libc.so%22%0A//go:cgo_import_dynamic libc_sethostname sethostname %22libc.so%22%0A//go:cgo_import_dynamic libc_setpgid setpgid %22libc.so%22%0A//go:cgo_import_dynamic libc_setpriority setpriority %22libc.so%22%0A//go:cgo_import_dynamic libc_setregid setregid %22libc.so%22%0A//go:cgo_import_dynamic libc_setreuid setreuid %22libc.so%22%0A//go:cgo_import_dynamic libc_setrlimit setrlimit %22libc.so%22%0A//go:cgo_import_dynamic libc_setsid setsid %22libc.so%22%0A//go:cgo_import_dynamic libc_setuid setuid %22libc.so%22%0A//go:cgo_import_dynamic libc_shutdown shutdown %22libsocket.so%22%0A//go:cgo_import_dynamic libc_stat stat %22libc.so%22%0A//go:cgo_import_dynamic libc_statvfs statvfs %22libc.so%22%0A//go:cgo_import_dynamic libc_symlink symlink %22libc.so%22%0A//go:cgo_import_dynamic libc_sync sync %22libc.so%22%0A//go:cgo_import_dynamic libc_times times %22libc.so%22%0A//go:cgo_import_dynamic libc_truncate truncate %22libc.so%22%0A//go:cgo_import_dynamic libc_fsync fsync %22libc.so%22%0A//go:cgo_import_dynamic libc_ftruncate ftruncate %22libc.so%22%0A//go:cgo_import_dynamic libc_umask umask %22libc.so%22%0A//go:cgo_import_dynamic libc_uname uname %22libc.so%22%0A//go:cgo_import_dynamic libc_umount umount %22libc.so%22%0A//go:cgo_import_dynamic libc_unlink unlink %22libc.so%22%0A//go:cgo_import_dynamic libc_unlinkat unlinkat %22libc.so%22%0A//go:cgo_import_dynamic libc_ustat ustat %22libc.so%22%0A//go:cgo_import_dynamic libc_utime utime %22libc.so%22%0A//go:cgo_import_dynamic libc___xnet_bind __xnet_bind %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_connect __xnet_connect %22libsocket.so%22%0A//go:cgo_import_dynamic libc_mmap mmap %22libc.so%22%0A//go:cgo_import_dynamic libc_munmap munmap %22libc.so%22%0A//go:cgo_import_dynamic libc_sendfile sendfile %22libsendfile.so%22%0A//go:cgo_import_dynamic libc___xnet_sendto __xnet_sendto %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_socket __xnet_socket %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_socketpair __xnet_socketpair %22libsocket.so%22%0A//go:cgo_import_dynamic libc_write write %22libc.so%22%0A//go:cgo_import_dynamic libc___xnet_getsockopt __xnet_getsockopt %22libsocket.so%22%0A//go:cgo_import_dynamic libc_getpeername getpeername %22libsocket.so%22%0A//go:cgo_import_dynamic libc_setsockopt setsockopt %22libsocket.so%22%0A//go:cgo_import_dynamic libc_recvfrom recvfrom %22libsocket.so%22%0A%0A//go:linkname procpipe libc_pipe%0A//go:linkname procgetsockname libc_getsockname%0A//go:linkname procGetcwd libc_getcwd%0A//go:linkname procgetgroups libc_getgroups%0A//go:linkname procsetgroups libc_setgroups%0A//go:linkname procwait4 libc_wait4%0A//go:linkname procgethostname libc_gethostname%0A//go:linkname procutimes libc_utimes%0A//go:linkname procutimensat libc_utimensat%0A//go:linkname procfcntl libc_fcntl%0A//go:linkname procfutimesat libc_futimesat%0A//go:linkname procaccept libc_accept%0A//go:linkname proc__xnet_recvmsg libc___xnet_recvmsg%0A//go:linkname proc__xnet_sendmsg libc___xnet_sendmsg%0A//go:linkname procacct libc_acct%0A//go:linkname proc__makedev libc___makedev%0A//go:linkname proc__major libc___major%0A//go:linkname proc__minor libc___minor%0A//go:linkname procioctl libc_ioctl%0A//go:linkname procpoll libc_poll%0A//go:linkname procAccess libc_access%0A//go:linkname procAdjtime libc_adjtime%0A//go:linkname procChdir libc_chdir%0A//go:linkname procChmod libc_chmod%0A//go:linkname procChown libc_chown%0A//go:linkname procChroot libc_chroot%0A//go:linkname procClose libc_close%0A//go:linkname procCreat libc_creat%0A//go:linkname procDup libc_dup%0A//go:linkname procDup2 libc_dup2%0A//go:linkname procExit libc_exit%0A//go:linkname procFchdir libc_fchdir%0A//go:linkname procFchmod libc_fchmod%0A//go:linkname procFchmodat libc_fchmodat%0A//go:linkname procFchown libc_fchown%0A//go:linkname procFchownat libc_fchownat%0A//go:linkname procFdatasync libc_fdatasync%0A//go:linkname procFlock libc_flock%0A//go:linkname procFpathconf libc_fpathconf%0A//go:linkname procFstat libc_fstat%0A//go:linkname procFstatat libc_fstatat%0A//go:linkname procFstatvfs libc_fstatvfs%0A//go:linkname procGetdents libc_getdents%0A//go:linkname procGetgid libc_getgid%0A//go:linkname procGetpid libc_getpid%0A//go:linkname procGetpgid libc_getpgid%0A//go:linkname procGetpgrp libc_getpgrp%0A//go:linkname procGeteuid libc_geteuid%0A//go:linkname procGetegid libc_getegid%0A//go:linkname procGetppid libc_getppid%0A//go:linkname procGetpriority libc_getpriority%0A//go:linkname procGetrlimit libc_getrlimit%0A//go:linkname procGetrusage libc_getrusage%0A//go:linkname procGettimeofday libc_gettimeofday%0A//go:linkname procGetuid libc_getuid%0A//go:linkname procKill libc_kill%0A//go:linkname procLchown libc_lchown%0A//go:linkname procLink libc_link%0A//go:linkname proc__xnet_llisten libc___xnet_llisten%0A//go:linkname procLstat libc_lstat%0A//go:linkname procMadvise libc_madvise%0A//go:linkname procMkdir libc_mkdir%0A//go:linkname procMkdirat libc_mkdirat%0A//go:linkname procMkfifo libc_mkfifo%0A//go:linkname procMkfifoat libc_mkfifoat%0A//go:linkname procMknod libc_mknod%0A//go:linkname procMknodat libc_mknodat%0A//go:linkname procMlock libc_mlock%0A//go:linkname procMlockall libc_mlockall%0A//go:linkname procMprotect libc_mprotect%0A//go:linkname procMsync libc_msync%0A//go:linkname procMunlock libc_munlock%0A//go:linkname procMunlockall libc_munlockall%0A//go:linkname procNanosleep libc_nanosleep%0A//go:linkname procOpen libc_open%0A//go:linkname procOpenat libc_openat%0A//go:linkname procPathconf libc_pathconf%0A//go:linkname procPause libc_pause%0A//go:linkname procPread libc_pread%0A//go:linkname procPwrite libc_pwrite%0A//go:linkname procread libc_read%0A//go:linkname procReadlink libc_readlink%0A//go:linkname procRename libc_rename%0A//go:linkname procRenameat libc_renameat%0A//go:linkname procRmdir libc_rmdir%0A//go:linkname proclseek libc_lseek%0A//go:linkname procSelect libc_select%0A//go:linkname procSetegid libc_setegid%0A//go:linkname procSeteuid libc_seteuid%0A//go:linkname procSetgid libc_setgid%0A//go:linkname procSethostname libc_sethostname%0A//go:linkname procSetpgid libc_setpgid%0A//go:linkname procSetpriority libc_setpriority%0A//go:linkname procSetregid libc_setregid%0A//go:linkname procSetreuid libc_setreuid%0A//go:linkname procSetrlimit libc_setrlimit%0A//go:linkname procSetsid libc_setsid%0A//go:linkname procSetuid libc_setuid%0A//go:linkname procshutdown libc_shutdown%0A//go:linkname procStat libc_stat%0A//go:linkname procStatvfs libc_statvfs%0A//go:linkname procSymlink libc_symlink%0A//go:linkname procSync libc_sync%0A//go:linkname procTimes libc_times%0A//go:linkname procTruncate libc_truncate%0A//go:linkname procFsync libc_fsync%0A//go:linkname procFtruncate libc_ftruncate%0A//go:linkname procUmask libc_umask%0A//go:linkname procUname libc_uname%0A//go:linkname procumount libc_umount%0A//go:linkname procUnlink libc_unlink%0A//go:linkname procUnlinkat libc_unlinkat%0A//go:linkname procUstat libc_ustat%0A//go:linkname procUtime libc_utime%0A//go:linkname proc__xnet_bind libc___xnet_bind%0A//go:linkname proc__xnet_connect libc___xnet_connect%0A//go:linkname procmmap libc_mmap%0A//go:linkname procmunmap libc_munmap%0A//go:linkname procsendfile libc_sendfile%0A//go:linkname proc__xnet_sendto libc___xnet_sendto%0A//go:linkname proc__xnet_socket libc___xnet_socket%0A//go:linkname proc__xnet_socketpair libc___xnet_socketpair%0A//go:linkname procwrite libc_write%0A//go:linkname proc__xnet_getsockopt libc___xnet_getsockopt%0A//go:linkname procgetpeername libc_getpeername%0A//go:linkname procsetsockopt libc_setsockopt%0A//go:linkname procrecvfrom libc_recvfrom%0A%0Avar (%0A%09procpipe,%0A%09procgetsockname,%0A%09procGetcwd,%0A%09procgetgroups,%0A%09procsetgroups,%0A%09procwait4,%0A%09procgethostname,%0A%09procutimes,%0A%09procutimensat,%0A%09procfcntl,%0A%09procfutimesat,%0A%09procaccept,%0A%09proc__xnet_recvmsg,%0A%09proc__xnet_sendmsg,%0A%09procacct,%0A%09proc__makedev,%0A%09proc__major,%0A%09proc__minor,%0A%09procioctl,%0A%09procpoll,%0A%09procAccess,%0A%09procAdjtime,%0A%09procChdir,%0A%09procChmod,%0A%09procChown,%0A%09procChroot,%0A%09procClose,%0A%09procCreat,%0A%09procDup,%0A%09procDup2,%0A%09procExit,%0A%09procFchdir,%0A%09procFchmod,%0A%09procFchmodat,%0A%09procFchown,%0A%09procFchownat,%0A%09procFdatasync,%0A%09procFlock,%0A%09procFpathconf,%0A%09procFstat,%0A%09procFstatat,%0A%09procFstatvfs,%0A%09procGetdents,%0A%09procGetgid,%0A%09procGetpid,%0A%09procGetpgid,%0A%09procGetpgrp,%0A%09procGeteuid,%0A%09procGetegid,%0A%09procGetppid,%0A%09procGetpriority,%0A%09procGetrlimit,%0A%09procGetrusage,%0A%09procGettimeofday,%0A%09procGetuid,%0A%09procKill,%0A%09procLchown,%0A%09procLink,%0A%09proc__xnet_llisten,%0A%09procLstat,%0A%09procMadvise,%0A%09procMkdir,%0A%09procMkdirat,%0A%09procMkfifo,%0A%09procMkfifoat,%0A%09procMknod,%0A%09procMknodat,%0A%09procMlock,%0A%09procMlockall,%0A%09procMprotect,%0A%09procMsync,%0A%09procMunlock,%0A%09procMunlockall,%0A%09procNanosleep,%0A%09procOpen,%0A%09procOpenat,%0A%09procPathconf,%0A%09procPause,%0A%09procPread,%0A%09procPwrite,%0A%09procread,%0A%09procReadlink,%0A%09procRename,%0A%09procRenameat,%0A%09procRmdir,%0A%09proclseek,%0A%09procSelect,%0A%09procSetegid,%0A%09procSeteuid,%0A%09procSetgid,%0A%09procSethostname,%0A%09procSetpgid,%0A%09procSetpriority,%0A%09procSetregid,%0A%09procSetreuid,%0A%09procSetrlimit,%0A%09procSetsid,%0A%09procSetuid,%0A%09procshutdown,%0A%09procStat,%0A%09procStatvfs,%0A%09procSymlink,%0A%09procSync,%0A%09procTimes,%0A%09procTruncate,%0A%09procFsync,%0A%09procFtruncate,%0A%09procUmask,%0A%09procUname,%0A%09procumount,%0A%09procUnlink,%0A%09procUnlinkat,%0A%09procUstat,%0A%09procUtime,%0A%09proc__xnet_bind,%0A%09proc__xnet_connect,%0A%09procmmap,%0A%09procmunmap,%0A%09procsendfile,%0A%09proc__xnet_sendto,%0A%09proc__xnet_socket,%0A%09proc__xnet_socketpair,%0A%09procwrite,%0A%09proc__xnet_getsockopt,%0A%09procgetpeername,%0A%09procsetsockopt,%0A%09procrecvfrom syscallFunc%0A)%0A%0Afunc pipe(p *%5B2%5D_C_int) (n int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procpipe)), 1, uintptr(unsafe.Pointer(p)), 0, 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procgetsockname)), 3, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procGetcwd)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procgetgroups)), 2, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procsetgroups)), 2, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc wait4(pid int32, statusp *_C_int, options int, rusage *Rusage) (wpid int32, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procwait4)), 4, uintptr(pid), uintptr(unsafe.Pointer(statusp)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int32(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc gethostname(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procgethostname)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procutimes)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc utimensat(fd int, path string, times *%5B2%5DTimespec, flag int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procutimensat)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procfcntl)), 3, uintptr(fd), uintptr(cmd), uintptr(arg), 0, 0, 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc futimesat(fildes int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procfutimesat)), 3, uintptr(fildes), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procaccept)), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_recvmsg)), 3, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_sendmsg)), 3, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc acct(path *byte) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procacct)), 1, uintptr(unsafe.Pointer(path)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc __makedev(version int, major uint, minor uint) (val uint64) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&proc__makedev)), 3, uintptr(version), uintptr(major), uintptr(minor), 0, 0, 0)%0A%09val = uint64(r0)%0A%09return%0A%7D%0A%0Afunc __major(version int, dev uint64) (val uint) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&proc__major)), 2, uintptr(version), uintptr(dev), 0, 0, 0, 0)%0A%09val = uint(r0)%0A%09return%0A%7D%0A%0Afunc __minor(version int, dev uint64) (val uint) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&proc__minor)), 2, uintptr(version), uintptr(dev), 0, 0, 0, 0)%0A%09val = uint(r0)%0A%09return%0A%7D%0A%0A
 func
@@ -424,14920 +424,8 @@
 %0A%7D%0A%0A
-func poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procpoll)), 3, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procAccess)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procAdjtime)), 2, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procChdir)), 1, uintptr(unsafe.Pointer(_p0)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procChmod)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procChown)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procChroot)), 1, uintptr(unsafe.Pointer(_p0)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procClose)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Creat(path string, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procCreat)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procDup)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procDup2)), 2, uintptr(oldfd), uintptr(newfd), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Exit(code int) %7B%0A%09sysvicall6(uintptr(unsafe.Pointer(&procExit)), 1, uintptr(code), 0, 0, 0, 0, 0)%0A%09return%0A%7D%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchdir)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchmod)), 2, uintptr(fd), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchmodat)), 4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchown)), 3, uintptr(fd), uintptr(uid), uintptr(gid), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchownat)), 5, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFdatasync)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFlock)), 2, uintptr(fd), uintptr(how), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFpathconf)), 2, uintptr(fd), uintptr(name), 0, 0, 0, 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFstat)), 2, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFstatat)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fstatvfs(fd int, vfsstat *Statvfs_t) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFstatvfs)), 2, uintptr(fd), uintptr(unsafe.Pointer(vfsstat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procGetdents)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := rawSysvicall6(uintptr(unsafe.Pointer(&procGetgid)), 0, 0, 0, 0, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := rawSysvicall6(uintptr(unsafe.Pointer(&procGetpid)), 0, 0, 0, 0, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGetpgid)), 1, uintptr(pid), 0, 0, 0, 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getpgrp() (pgid int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGetpgrp)), 0, 0, 0, 0, 0, 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&procGeteuid)), 0, 0, 0, 0, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&procGetegid)), 0, 0, 0, 0, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&procGetppid)), 0, 0, 0, 0, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getpriority(which int, who int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procGetpriority)), 2, uintptr(which), uintptr(who), 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGetrlimit)), 2, uintptr(which), uintptr(unsafe.Pointer(lim)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGetrusage)), 2, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGettimeofday)), 1, uintptr(unsafe.Pointer(tv)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := rawSysvicall6(uintptr(unsafe.Pointer(&procGetuid)), 0, 0, 0, 0, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procKill)), 2, uintptr(pid), uintptr(signum), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procLchown)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procLink)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_llisten)), 2, uintptr(s), uintptr(backlog), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procLstat)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMadvise)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), uintptr(advice), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMkdir)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMkdirat)), 3, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMkfifo)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkfifoat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMkfifoat)), 3, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMknod)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMknodat)), 4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMlock)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMlockall)), 1, uintptr(flags), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMprotect)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), uintptr(prot), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMsync)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), uintptr(flags), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMunlock)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMunlockall)), 0, 0, 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procNanosleep)), 2, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procOpen)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procOpenat)), 4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procPathconf)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0, 0, 0, 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procPause)), 0, 0, 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procPread)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procPwrite)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0A
 func
@@ -706,11993 +706,4 @@
 n%0A%7D%0A
-%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procReadlink)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(len(buf)), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procRename)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procRenameat)), 4, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procRmdir)), 1, uintptr(unsafe.Pointer(_p0)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proclseek)), 3, uintptr(fd), uintptr(offset), uintptr(whence), 0, 0, 0)%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSelect)), 5, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetegid)), 1, uintptr(egid), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSeteuid)), 1, uintptr(euid), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetgid)), 1, uintptr(gid), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSethostname)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetpgid)), 2, uintptr(pid), uintptr(pgid), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSetpriority)), 3, uintptr(which), uintptr(who), uintptr(prio), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetregid)), 2, uintptr(rgid), uintptr(egid), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetreuid)), 2, uintptr(ruid), uintptr(euid), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetrlimit)), 2, uintptr(which), uintptr(unsafe.Pointer(lim)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetsid)), 0, 0, 0, 0, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetuid)), 1, uintptr(uid), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procshutdown)), 2, uintptr(s), uintptr(how), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procStat)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Statvfs(path string, vfsstat *Statvfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procStatvfs)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(vfsstat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSymlink)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSync)), 0, 0, 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procTimes)), 1, uintptr(unsafe.Pointer(tms)), 0, 0, 0, 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procTruncate)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFsync)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFtruncate)), 2, uintptr(fd), uintptr(length), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&procUmask)), 1, uintptr(mask), 0, 0, 0, 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procUname)), 1, uintptr(unsafe.Pointer(buf)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procumount)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procUnlink)), 1, uintptr(unsafe.Pointer(_p0)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procUnlinkat)), 3, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procUstat)), 2, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procUtime)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_bind)), 3, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_connect)), 3, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procmmap)), 6, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos))%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procmunmap)), 2, uintptr(addr), uintptr(length), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procsendfile)), 4, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_sendto)), 6, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_socket)), 3, uintptr(domain), uintptr(typ), uintptr(proto), 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&proc__xnet_socketpair)), 4, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procwrite)), 3, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_getsockopt)), 5, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procgetpeername)), 3, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procsetsockopt)), 5, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procrecvfrom)), 6, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A
- f 2c5a6190453d737aa568a086e836b90efbea0c758763e6a2c46cc15366bcde8c vendor/golang.org/x/sys/unix/zsysctl_openbsd_386.go
+ f 0a6e625c26f26c12e9034772b7c75c0706159c437c6b8294f18006f5a302bfcf vendor/golang.org/x/sys/unix/zsysctl_openbsd_386.go
dmppatch 8
@@ -20,63 +20,61 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0Apac
@@ -87,11898 +87,4 @@
 nix%0A
-%0Atype mibentry struct %7B%0A%09ctlname string%0A%09ctloid  %5B%5D_C_int%0A%7D%0A%0Avar sysctlMib = %5B%5Dmibentry%7B%0A%09%7B%22ddb.console%22, %5B%5D_C_int%7B9, 6%7D%7D,%0A%09%7B%22ddb.log%22, %5B%5D_C_int%7B9, 7%7D%7D,%0A%09%7B%22ddb.max_line%22, %5B%5D_C_int%7B9, 3%7D%7D,%0A%09%7B%22ddb.max_width%22, %5B%5D_C_int%7B9, 2%7D%7D,%0A%09%7B%22ddb.panic%22, %5B%5D_C_int%7B9, 5%7D%7D,%0A%09%7B%22ddb.radix%22, %5B%5D_C_int%7B9, 1%7D%7D,%0A%09%7B%22ddb.tab_stop_width%22, %5B%5D_C_int%7B9, 4%7D%7D,%0A%09%7B%22ddb.trigger%22, %5B%5D_C_int%7B9, 8%7D%7D,%0A%09%7B%22fs.posix.setuid%22, %5B%5D_C_int%7B3, 1, 1%7D%7D,%0A%09%7B%22hw.allowpowerdown%22, %5B%5D_C_int%7B6, 22%7D%7D,%0A%09%7B%22hw.byteorder%22, %5B%5D_C_int%7B6, 4%7D%7D,%0A%09%7B%22hw.cpuspeed%22, %5B%5D_C_int%7B6, 12%7D%7D,%0A%09%7B%22hw.diskcount%22, %5B%5D_C_int%7B6, 10%7D%7D,%0A%09%7B%22hw.disknames%22, %5B%5D_C_int%7B6, 8%7D%7D,%0A%09%7B%22hw.diskstats%22, %5B%5D_C_int%7B6, 9%7D%7D,%0A%09%7B%22hw.machine%22, %5B%5D_C_int%7B6, 1%7D%7D,%0A%09%7B%22hw.model%22, %5B%5D_C_int%7B6, 2%7D%7D,%0A%09%7B%22hw.ncpu%22, %5B%5D_C_int%7B6, 3%7D%7D,%0A%09%7B%22hw.ncpufound%22, %5B%5D_C_int%7B6, 21%7D%7D,%0A%09%7B%22hw.pagesize%22, %5B%5D_C_int%7B6, 7%7D%7D,%0A%09%7B%22hw.physmem%22, %5B%5D_C_int%7B6, 19%7D%7D,%0A%09%7B%22hw.product%22, %5B%5D_C_int%7B6, 15%7D%7D,%0A%09%7B%22hw.serialno%22, %5B%5D_C_int%7B6, 17%7D%7D,%0A%09%7B%22hw.setperf%22, %5B%5D_C_int%7B6, 13%7D%7D,%0A%09%7B%22hw.usermem%22, %5B%5D_C_int%7B6, 20%7D%7D,%0A%09%7B%22hw.uuid%22, %5B%5D_C_int%7B6, 18%7D%7D,%0A%09%7B%22hw.vendor%22, %5B%5D_C_int%7B6, 14%7D%7D,%0A%09%7B%22hw.version%22, %5B%5D_C_int%7B6, 16%7D%7D,%0A%09%7B%22kern.arandom%22, %5B%5D_C_int%7B1, 37%7D%7D,%0A%09%7B%22kern.argmax%22, %5B%5D_C_int%7B1, 8%7D%7D,%0A%09%7B%22kern.boottime%22, %5B%5D_C_int%7B1, 21%7D%7D,%0A%09%7B%22kern.bufcachepercent%22, %5B%5D_C_int%7B1, 72%7D%7D,%0A%09%7B%22kern.ccpu%22, %5B%5D_C_int%7B1, 45%7D%7D,%0A%09%7B%22kern.clockrate%22, %5B%5D_C_int%7B1, 12%7D%7D,%0A%09%7B%22kern.consdev%22, %5B%5D_C_int%7B1, 75%7D%7D,%0A%09%7B%22kern.cp_time%22, %5B%5D_C_int%7B1, 40%7D%7D,%0A%09%7B%22kern.cp_time2%22, %5B%5D_C_int%7B1, 71%7D%7D,%0A%09%7B%22kern.cryptodevallowsoft%22, %5B%5D_C_int%7B1, 53%7D%7D,%0A%09%7B%22kern.domainname%22, %5B%5D_C_int%7B1, 22%7D%7D,%0A%09%7B%22kern.file%22, %5B%5D_C_int%7B1, 73%7D%7D,%0A%09%7B%22kern.forkstat%22, %5B%5D_C_int%7B1, 42%7D%7D,%0A%09%7B%22kern.fscale%22, %5B%5D_C_int%7B1, 46%7D%7D,%0A%09%7B%22kern.fsync%22, %5B%5D_C_int%7B1, 33%7D%7D,%0A%09%7B%22kern.hostid%22, %5B%5D_C_int%7B1, 11%7D%7D,%0A%09%7B%22kern.hostname%22, %5B%5D_C_int%7B1, 10%7D%7D,%0A%09%7B%22kern.intrcnt.nintrcnt%22, %5B%5D_C_int%7B1, 63, 1%7D%7D,%0A%09%7B%22kern.job_control%22, %5B%5D_C_int%7B1, 19%7D%7D,%0A%09%7B%22kern.malloc.buckets%22, %5B%5D_C_int%7B1, 39, 1%7D%7D,%0A%09%7B%22kern.malloc.kmemnames%22, %5B%5D_C_int%7B1, 39, 3%7D%7D,%0A%09%7B%22kern.maxclusters%22, %5B%5D_C_int%7B1, 67%7D%7D,%0A%09%7B%22kern.maxfiles%22, %5B%5D_C_int%7B1, 7%7D%7D,%0A%09%7B%22kern.maxlocksperuid%22, %5B%5D_C_int%7B1, 70%7D%7D,%0A%09%7B%22kern.maxpartitions%22, %5B%5D_C_int%7B1, 23%7D%7D,%0A%09%7B%22kern.maxproc%22, %5B%5D_C_int%7B1, 6%7D%7D,%0A%09%7B%22kern.maxthread%22, %5B%5D_C_int%7B1, 25%7D%7D,%0A%09%7B%22kern.maxvnodes%22, %5B%5D_C_int%7B1, 5%7D%7D,%0A%09%7B%22kern.mbstat%22, %5B%5D_C_int%7B1, 59%7D%7D,%0A%09%7B%22kern.msgbuf%22, %5B%5D_C_int%7B1, 48%7D%7D,%0A%09%7B%22kern.msgbufsize%22, %5B%5D_C_int%7B1, 38%7D%7D,%0A%09%7B%22kern.nchstats%22, %5B%5D_C_int%7B1, 41%7D%7D,%0A%09%7B%22kern.netlivelocks%22, %5B%5D_C_int%7B1, 76%7D%7D,%0A%09%7B%22kern.nfiles%22, %5B%5D_C_int%7B1, 56%7D%7D,%0A%09%7B%22kern.ngroups%22, %5B%5D_C_int%7B1, 18%7D%7D,%0A%09%7B%22kern.nosuidcoredump%22, %5B%5D_C_int%7B1, 32%7D%7D,%0A%09%7B%22kern.nprocs%22, %5B%5D_C_int%7B1, 47%7D%7D,%0A%09%7B%22kern.nselcoll%22, %5B%5D_C_int%7B1, 43%7D%7D,%0A%09%7B%22kern.nthreads%22, %5B%5D_C_int%7B1, 26%7D%7D,%0A%09%7B%22kern.numvnodes%22, %5B%5D_C_int%7B1, 58%7D%7D,%0A%09%7B%22kern.osrelease%22, %5B%5D_C_int%7B1, 2%7D%7D,%0A%09%7B%22kern.osrevision%22, %5B%5D_C_int%7B1, 3%7D%7D,%0A%09%7B%22kern.ostype%22, %5B%5D_C_int%7B1, 1%7D%7D,%0A%09%7B%22kern.osversion%22, %5B%5D_C_int%7B1, 27%7D%7D,%0A%09%7B%22kern.pool_debug%22, %5B%5D_C_int%7B1, 77%7D%7D,%0A%09%7B%22kern.posix1version%22, %5B%5D_C_int%7B1, 17%7D%7D,%0A%09%7B%22kern.proc%22, %5B%5D_C_int%7B1, 66%7D%7D,%0A%09%7B%22kern.random%22, %5B%5D_C_int%7B1, 31%7D%7D,%0A%09%7B%22kern.rawpartition%22, %5B%5D_C_int%7B1, 24%7D%7D,%0A%09%7B%22kern.saved_ids%22, %5B%5D_C_int%7B1, 20%7D%7D,%0A%09%7B%22kern.securelevel%22, %5B%5D_C_int%7B1, 9%7D%7D,%0A%09%7B%22kern.seminfo%22, %5B%5D_C_int%7B1, 61%7D%7D,%0A%09%7B%22kern.shminfo%22, %5B%5D_C_int%7B1, 62%7D%7D,%0A%09%7B%22kern.somaxconn%22, %5B%5D_C_int%7B1, 28%7D%7D,%0A%09%7B%22kern.sominconn%22, %5B%5D_C_int%7B1, 29%7D%7D,%0A%09%7B%22kern.splassert%22, %5B%5D_C_int%7B1, 54%7D%7D,%0A%09%7B%22kern.stackgap_random%22, %5B%5D_C_int%7B1, 50%7D%7D,%0A%09%7B%22kern.sysvipc_info%22, %5B%5D_C_int%7B1, 51%7D%7D,%0A%09%7B%22kern.sysvmsg%22, %5B%5D_C_int%7B1, 34%7D%7D,%0A%09%7B%22kern.sysvsem%22, %5B%5D_C_int%7B1, 35%7D%7D,%0A%09%7B%22kern.sysvshm%22, %5B%5D_C_int%7B1, 36%7D%7D,%0A%09%7B%22kern.timecounter.choice%22, %5B%5D_C_int%7B1, 69, 4%7D%7D,%0A%09%7B%22kern.timecounter.hardware%22, %5B%5D_C_int%7B1, 69, 3%7D%7D,%0A%09%7B%22kern.timecounter.tick%22, %5B%5D_C_int%7B1, 69, 1%7D%7D,%0A%09%7B%22kern.timecounter.timestepwarnings%22, %5B%5D_C_int%7B1, 69, 2%7D%7D,%0A%09%7B%22kern.tty.maxptys%22, %5B%5D_C_int%7B1, 44, 6%7D%7D,%0A%09%7B%22kern.tty.nptys%22, %5B%5D_C_int%7B1, 44, 7%7D%7D,%0A%09%7B%22kern.tty.tk_cancc%22, %5B%5D_C_int%7B1, 44, 4%7D%7D,%0A%09%7B%22kern.tty.tk_nin%22, %5B%5D_C_int%7B1, 44, 1%7D%7D,%0A%09%7B%22kern.tty.tk_nout%22, %5B%5D_C_int%7B1, 44, 2%7D%7D,%0A%09%7B%22kern.tty.tk_rawcc%22, %5B%5D_C_int%7B1, 44, 3%7D%7D,%0A%09%7B%22kern.tty.ttyinfo%22, %5B%5D_C_int%7B1, 44, 5%7D%7D,%0A%09%7B%22kern.ttycount%22, %5B%5D_C_int%7B1, 57%7D%7D,%0A%09%7B%22kern.userasymcrypto%22, %5B%5D_C_int%7B1, 60%7D%7D,%0A%09%7B%22kern.usercrypto%22, %5B%5D_C_int%7B1, 52%7D%7D,%0A%09%7B%22kern.usermount%22, %5B%5D_C_int%7B1, 30%7D%7D,%0A%09%7B%22kern.version%22, %5B%5D_C_int%7B1, 4%7D%7D,%0A%09%7B%22kern.vnode%22, %5B%5D_C_int%7B1, 13%7D%7D,%0A%09%7B%22kern.watchdog.auto%22, %5B%5D_C_int%7B1, 64, 2%7D%7D,%0A%09%7B%22kern.watchdog.period%22, %5B%5D_C_int%7B1, 64, 1%7D%7D,%0A%09%7B%22net.bpf.bufsize%22, %5B%5D_C_int%7B4, 31, 1%7D%7D,%0A%09%7B%22net.bpf.maxbufsize%22, %5B%5D_C_int%7B4, 31, 2%7D%7D,%0A%09%7B%22net.inet.ah.enable%22, %5B%5D_C_int%7B4, 2, 51, 1%7D%7D,%0A%09%7B%22net.inet.ah.stats%22, %5B%5D_C_int%7B4, 2, 51, 2%7D%7D,%0A%09%7B%22net.inet.carp.allow%22, %5B%5D_C_int%7B4, 2, 112, 1%7D%7D,%0A%09%7B%22net.inet.carp.log%22, %5B%5D_C_int%7B4, 2, 112, 3%7D%7D,%0A%09%7B%22net.inet.carp.preempt%22, %5B%5D_C_int%7B4, 2, 112, 2%7D%7D,%0A%09%7B%22net.inet.carp.stats%22, %5B%5D_C_int%7B4, 2, 112, 4%7D%7D,%0A%09%7B%22net.inet.divert.recvspace%22, %5B%5D_C_int%7B4, 2, 258, 1%7D%7D,%0A%09%7B%22net.inet.divert.sendspace%22, %5B%5D_C_int%7B4, 2, 258, 2%7D%7D,%0A%09%7B%22net.inet.divert.stats%22, %5B%5D_C_int%7B4, 2, 258, 3%7D%7D,%0A%09%7B%22net.inet.esp.enable%22, %5B%5D_C_int%7B4, 2, 50, 1%7D%7D,%0A%09%7B%22net.inet.esp.stats%22, %5B%5D_C_int%7B4, 2, 50, 4%7D%7D,%0A%09%7B%22net.inet.esp.udpencap%22, %5B%5D_C_int%7B4, 2, 50, 2%7D%7D,%0A%09%7B%22net.inet.esp.udpencap_port%22, %5B%5D_C_int%7B4, 2, 50, 3%7D%7D,%0A%09%7B%22net.inet.etherip.allow%22, %5B%5D_C_int%7B4, 2, 97, 1%7D%7D,%0A%09%7B%22net.inet.etherip.stats%22, %5B%5D_C_int%7B4, 2, 97, 2%7D%7D,%0A%09%7B%22net.inet.gre.allow%22, %5B%5D_C_int%7B4, 2, 47, 1%7D%7D,%0A%09%7B%22net.inet.gre.wccp%22, %5B%5D_C_int%7B4, 2, 47, 2%7D%7D,%0A%09%7B%22net.inet.icmp.bmcastecho%22, %5B%5D_C_int%7B4, 2, 1, 2%7D%7D,%0A%09%7B%22net.inet.icmp.errppslimit%22, %5B%5D_C_int%7B4, 2, 1, 3%7D%7D,%0A%09%7B%22net.inet.icmp.maskrepl%22, %5B%5D_C_int%7B4, 2, 1, 1%7D%7D,%0A%09%7B%22net.inet.icmp.rediraccept%22, %5B%5D_C_int%7B4, 2, 1, 4%7D%7D,%0A%09%7B%22net.inet.icmp.redirtimeout%22, %5B%5D_C_int%7B4, 2, 1, 5%7D%7D,%0A%09%7B%22net.inet.icmp.stats%22, %5B%5D_C_int%7B4, 2, 1, 7%7D%7D,%0A%09%7B%22net.inet.icmp.tstamprepl%22, %5B%5D_C_int%7B4, 2, 1, 6%7D%7D,%0A%09%7B%22net.inet.igmp.stats%22, %5B%5D_C_int%7B4, 2, 2, 1%7D%7D,%0A%09%7B%22net.inet.ip.arpqueued%22, %5B%5D_C_int%7B4, 2, 0, 36%7D%7D,%0A%09%7B%22net.inet.ip.encdebug%22, %5B%5D_C_int%7B4, 2, 0, 12%7D%7D,%0A%09%7B%22net.inet.ip.forwarding%22, %5B%5D_C_int%7B4, 2, 0, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.congestion%22, %5B%5D_C_int%7B4, 2, 0, 30, 4%7D%7D,%0A%09%7B%22net.inet.ip.ifq.drops%22, %5B%5D_C_int%7B4, 2, 0, 30, 3%7D%7D,%0A%09%7B%22net.inet.ip.ifq.len%22, %5B%5D_C_int%7B4, 2, 0, 30, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.maxlen%22, %5B%5D_C_int%7B4, 2, 0, 30, 2%7D%7D,%0A%09%7B%22net.inet.ip.maxqueue%22, %5B%5D_C_int%7B4, 2, 0, 11%7D%7D,%0A%09%7B%22net.inet.ip.mforwarding%22, %5B%5D_C_int%7B4, 2, 0, 31%7D%7D,%0A%09%7B%22net.inet.ip.mrtproto%22, %5B%5D_C_int%7B4, 2, 0, 34%7D%7D,%0A%09%7B%22net.inet.ip.mrtstats%22, %5B%5D_C_int%7B4, 2, 0, 35%7D%7D,%0A%09%7B%22net.inet.ip.mtu%22, %5B%5D_C_int%7B4, 2, 0, 4%7D%7D,%0A%09%7B%22net.inet.ip.mtudisc%22, %5B%5D_C_int%7B4, 2, 0, 27%7D%7D,%0A%09%7B%22net.inet.ip.mtudisctimeout%22, %5B%5D_C_int%7B4, 2, 0, 28%7D%7D,%0A%09%7B%22net.inet.ip.multipath%22, %5B%5D_C_int%7B4, 2, 0, 32%7D%7D,%0A%09%7B%22net.inet.ip.portfirst%22, %5B%5D_C_int%7B4, 2, 0, 7%7D%7D,%0A%09%7B%22net.inet.ip.porthifirst%22, %5B%5D_C_int%7B4, 2, 0, 9%7D%7D,%0A%09%7B%22net.inet.ip.porthilast%22, %5B%5D_C_int%7B4, 2, 0, 10%7D%7D,%0A%09%7B%22net.inet.ip.portlast%22, %5B%5D_C_int%7B4, 2, 0, 8%7D%7D,%0A%09%7B%22net.inet.ip.redirect%22, %5B%5D_C_int%7B4, 2, 0, 2%7D%7D,%0A%09%7B%22net.inet.ip.sourceroute%22, %5B%5D_C_int%7B4, 2, 0, 5%7D%7D,%0A%09%7B%22net.inet.ip.stats%22, %5B%5D_C_int%7B4, 2, 0, 33%7D%7D,%0A%09%7B%22net.inet.ip.ttl%22, %5B%5D_C_int%7B4, 2, 0, 3%7D%7D,%0A%09%7B%22net.inet.ipcomp.enable%22, %5B%5D_C_int%7B4, 2, 108, 1%7D%7D,%0A%09%7B%22net.inet.ipcomp.stats%22, %5B%5D_C_int%7B4, 2, 108, 2%7D%7D,%0A%09%7B%22net.inet.ipip.allow%22, %5B%5D_C_int%7B4, 2, 4, 1%7D%7D,%0A%09%7B%22net.inet.ipip.stats%22, %5B%5D_C_int%7B4, 2, 4, 2%7D%7D,%0A%09%7B%22net.inet.mobileip.allow%22, %5B%5D_C_int%7B4, 2, 55, 1%7D%7D,%0A%09%7B%22net.inet.pfsync.stats%22, %5B%5D_C_int%7B4, 2, 240, 1%7D%7D,%0A%09%7B%22net.inet.pim.stats%22, %5B%5D_C_int%7B4, 2, 103, 1%7D%7D,%0A%09%7B%22net.inet.tcp.ackonpush%22, %5B%5D_C_int%7B4, 2, 6, 13%7D%7D,%0A%09%7B%22net.inet.tcp.always_keepalive%22, %5B%5D_C_int%7B4, 2, 6, 22%7D%7D,%0A%09%7B%22net.inet.tcp.baddynamic%22, %5B%5D_C_int%7B4, 2, 6, 6%7D%7D,%0A%09%7B%22net.inet.tcp.drop%22, %5B%5D_C_int%7B4, 2, 6, 19%7D%7D,%0A%09%7B%22net.inet.tcp.ecn%22, %5B%5D_C_int%7B4, 2, 6, 14%7D%7D,%0A%09%7B%22net.inet.tcp.ident%22, %5B%5D_C_int%7B4, 2, 6, 9%7D%7D,%0A%09%7B%22net.inet.tcp.keepidle%22, %5B%5D_C_int%7B4, 2, 6, 3%7D%7D,%0A%09%7B%22net.inet.tcp.keepinittime%22, %5B%5D_C_int%7B4, 2, 6, 2%7D%7D,%0A%09%7B%22net.inet.tcp.keepintvl%22, %5B%5D_C_int%7B4, 2, 6, 4%7D%7D,%0A%09%7B%22net.inet.tcp.mssdflt%22, %5B%5D_C_int%7B4, 2, 6, 11%7D%7D,%0A%09%7B%22net.inet.tcp.reasslimit%22, %5B%5D_C_int%7B4, 2, 6, 18%7D%7D,%0A%09%7B%22net.inet.tcp.rfc1323%22, %5B%5D_C_int%7B4, 2, 6, 1%7D%7D,%0A%09%7B%22net.inet.tcp.rfc3390%22, %5B%5D_C_int%7B4, 2, 6, 17%7D%7D,%0A%09%7B%22net.inet.tcp.rstppslimit%22, %5B%5D_C_int%7B4, 2, 6, 12%7D%7D,%0A%09%7B%22net.inet.tcp.sack%22, %5B%5D_C_int%7B4, 2, 6, 10%7D%7D,%0A%09%7B%22net.inet.tcp.sackholelimit%22, %5B%5D_C_int%7B4, 2, 6, 20%7D%7D,%0A%09%7B%22net.inet.tcp.slowhz%22, %5B%5D_C_int%7B4, 2, 6, 5%7D%7D,%0A%09%7B%22net.inet.tcp.stats%22, %5B%5D_C_int%7B4, 2, 6, 21%7D%7D,%0A%09%7B%22net.inet.tcp.synbucketlimit%22, %5B%5D_C_int%7B4, 2, 6, 16%7D%7D,%0A%09%7B%22net.inet.tcp.syncachelimit%22, %5B%5D_C_int%7B4, 2, 6, 15%7D%7D,%0A%09%7B%22net.inet.udp.baddynamic%22, %5B%5D_C_int%7B4, 2, 17, 2%7D%7D,%0A%09%7B%22net.inet.udp.checksum%22, %5B%5D_C_int%7B4, 2, 17, 1%7D%7D,%0A%09%7B%22net.inet.udp.recvspace%22, %5B%5D_C_int%7B4, 2, 17, 3%7D%7D,%0A%09%7B%22net.inet.udp.sendspace%22, %5B%5D_C_int%7B4, 2, 17, 4%7D%7D,%0A%09%7B%22net.inet.udp.stats%22, %5B%5D_C_int%7B4, 2, 17, 5%7D%7D,%0A%09%7B%22net.inet6.divert.recvspace%22, %5B%5D_C_int%7B4, 24, 86, 1%7D%7D,%0A%09%7B%22net.inet6.divert.sendspace%22, %5B%5D_C_int%7B4, 24, 86, 2%7D%7D,%0A%09%7B%22net.inet6.divert.stats%22, %5B%5D_C_int%7B4, 24, 86, 3%7D%7D,%0A%09%7B%22net.inet6.icmp6.errppslimit%22, %5B%5D_C_int%7B4, 24, 30, 14%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_hiwat%22, %5B%5D_C_int%7B4, 24, 30, 16%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_lowat%22, %5B%5D_C_int%7B4, 24, 30, 17%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_debug%22, %5B%5D_C_int%7B4, 24, 30, 18%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_delay%22, %5B%5D_C_int%7B4, 24, 30, 8%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_maxnudhint%22, %5B%5D_C_int%7B4, 24, 30, 15%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_mmaxtries%22, %5B%5D_C_int%7B4, 24, 30, 10%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_prune%22, %5B%5D_C_int%7B4, 24, 30, 6%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_umaxtries%22, %5B%5D_C_int%7B4, 24, 30, 9%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_useloopback%22, %5B%5D_C_int%7B4, 24, 30, 11%7D%7D,%0A%09%7B%22net.inet6.icmp6.nodeinfo%22, %5B%5D_C_int%7B4, 24, 30, 13%7D%7D,%0A%09%7B%22net.inet6.icmp6.rediraccept%22, %5B%5D_C_int%7B4, 24, 30, 2%7D%7D,%0A%09%7B%22net.inet6.icmp6.redirtimeout%22, %5B%5D_C_int%7B4, 24, 30, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.accept_rtadv%22, %5B%5D_C_int%7B4, 24, 17, 12%7D%7D,%0A%09%7B%22net.inet6.ip6.auto_flowlabel%22, %5B%5D_C_int%7B4, 24, 17, 17%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_count%22, %5B%5D_C_int%7B4, 24, 17, 16%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_pending%22, %5B%5D_C_int%7B4, 24, 17, 49%7D%7D,%0A%09%7B%22net.inet6.ip6.defmcasthlim%22, %5B%5D_C_int%7B4, 24, 17, 18%7D%7D,%0A%09%7B%22net.inet6.ip6.forwarding%22, %5B%5D_C_int%7B4, 24, 17, 1%7D%7D,%0A%09%7B%22net.inet6.ip6.forwsrcrt%22, %5B%5D_C_int%7B4, 24, 17, 5%7D%7D,%0A%09%7B%22net.inet6.ip6.hdrnestlimit%22, %5B%5D_C_int%7B4, 24, 17, 15%7D%7D,%0A%09%7B%22net.inet6.ip6.hlim%22, %5B%5D_C_int%7B4, 24, 17, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.log_interval%22, %5B%5D_C_int%7B4, 24, 17, 14%7D%7D,%0A%09%7B%22net.inet6.ip6.maxdynroutes%22, %5B%5D_C_int%7B4, 24, 17, 48%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfragpackets%22, %5B%5D_C_int%7B4, 24, 17, 9%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfrags%22, %5B%5D_C_int%7B4, 24, 17, 41%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifdefrouters%22, %5B%5D_C_int%7B4, 24, 17, 47%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifprefixes%22, %5B%5D_C_int%7B4, 24, 17, 46%7D%7D,%0A%09%7B%22net.inet6.ip6.mforwarding%22, %5B%5D_C_int%7B4, 24, 17, 42%7D%7D,%0A%09%7B%22net.inet6.ip6.mrtproto%22, %5B%5D_C_int%7B4, 24, 17, 8%7D%7D,%0A%09%7B%22net.inet6.ip6.mtudisctimeout%22, %5B%5D_C_int%7B4, 24, 17, 50%7D%7D,%0A%09%7B%22net.inet6.ip6.multicast_mtudisc%22, %5B%5D_C_int%7B4, 24, 17, 44%7D%7D,%0A%09%7B%22net.inet6.ip6.multipath%22, %5B%5D_C_int%7B4, 24, 17, 43%7D%7D,%0A%09%7B%22net.inet6.ip6.neighborgcthresh%22, %5B%5D_C_int%7B4, 24, 17, 45%7D%7D,%0A%09%7B%22net.inet6.ip6.redirect%22, %5B%5D_C_int%7B4, 24, 17, 2%7D%7D,%0A%09%7B%22net.inet6.ip6.rr_prune%22, %5B%5D_C_int%7B4, 24, 17, 22%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck%22, %5B%5D_C_int%7B4, 24, 17, 10%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck_logint%22, %5B%5D_C_int%7B4, 24, 17, 11%7D%7D,%0A%09%7B%22net.inet6.ip6.use_deprecated%22, %5B%5D_C_int%7B4, 24, 17, 21%7D%7D,%0A%09%7B%22net.inet6.ip6.v6only%22, %5B%5D_C_int%7B4, 24, 17, 24%7D%7D,%0A%09%7B%22net.key.sadb_dump%22, %5B%5D_C_int%7B4, 30, 1%7D%7D,%0A%09%7B%22net.key.spd_dump%22, %5B%5D_C_int%7B4, 30, 2%7D%7D,%0A%09%7B%22net.mpls.ifq.congestion%22, %5B%5D_C_int%7B4, 33, 3, 4%7D%7D,%0A%09%7B%22net.mpls.ifq.drops%22, %5B%5D_C_int%7B4, 33, 3, 3%7D%7D,%0A%09%7B%22net.mpls.ifq.len%22, %5B%5D_C_int%7B4, 33, 3, 1%7D%7D,%0A%09%7B%22net.mpls.ifq.maxlen%22, %5B%5D_C_int%7B4, 33, 3, 2%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip%22, %5B%5D_C_int%7B4, 33, 5%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip6%22, %5B%5D_C_int%7B4, 33, 6%7D%7D,%0A%09%7B%22net.mpls.maxloop_inkernel%22, %5B%5D_C_int%7B4, 33, 4%7D%7D,%0A%09%7B%22net.mpls.ttl%22, %5B%5D_C_int%7B4, 33, 2%7D%7D,%0A%09%7B%22net.pflow.stats%22, %5B%5D_C_int%7B4, 34, 1%7D%7D,%0A%09%7B%22net.pipex.enable%22, %5B%5D_C_int%7B4, 35, 1%7D%7D,%0A%09%7B%22vm.anonmin%22, %5B%5D_C_int%7B2, 7%7D%7D,%0A%09%7B%22vm.loadavg%22, %5B%5D_C_int%7B2, 2%7D%7D,%0A%09%7B%22vm.maxslp%22, %5B%5D_C_int%7B2, 10%7D%7D,%0A%09%7B%22vm.nkmempages%22, %5B%5D_C_int%7B2, 6%7D%7D,%0A%09%7B%22vm.psstrings%22, %5B%5D_C_int%7B2, 3%7D%7D,%0A%09%7B%22vm.swapencrypt.enable%22, %5B%5D_C_int%7B2, 5, 0%7D%7D,%0A%09%7B%22vm.swapencrypt.keyscreated%22, %5B%5D_C_int%7B2, 5, 1%7D%7D,%0A%09%7B%22vm.swapencrypt.keysdeleted%22, %5B%5D_C_int%7B2, 5, 2%7D%7D,%0A%09%7B%22vm.uspace%22, %5B%5D_C_int%7B2, 11%7D%7D,%0A%09%7B%22vm.uvmexp%22, %5B%5D_C_int%7B2, 4%7D%7D,%0A%09%7B%22vm.vmmeter%22, %5B%5D_C_int%7B2, 1%7D%7D,%0A%09%7B%22vm.vnodemin%22, %5B%5D_C_int%7B2, 9%7D%7D,%0A%09%7B%22vm.vtextmin%22, %5B%5D_C_int%7B2, 8%7D%7D,%0A%7D%0A
- f 2c5a6190453d737aa568a086e836b90efbea0c758763e6a2c46cc15366bcde8c vendor/golang.org/x/sys/unix/zsysctl_openbsd_amd64.go
+ f a850510e2a0d60cf8614cfa0cf4840f229b65809b59cfe070327e0c7684a5071 vendor/golang.org/x/sys/unix/zsysctl_openbsd_amd64.go
dmppatch 10
@@ -20,11967 +20,96 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0A
-package unix%0A%0Atype mibentry struct %7B%0A%09ctlname string%0A%09ctloid  %5B%5D_C_int%0A%7D%0A
+// +build amd64,openbsd%0A
 %0A
-var sysctlMib = %5B%5Dmibentry%7B%0A%09%7B%22ddb.console%22, %5B%5D_C_int%7B9, 6%7D%7D,%0A%09%7B%22ddb.log%22, %5B%5D_C_int%7B9, 7%7D%7D,%0A%09%7B%22ddb.max_line%22, %5B%5D_C_int%7B9, 3%7D%7D,%0A%09%7B%22ddb.max_width%22, %5B%5D_C_int%7B9, 2%7D%7D,%0A%09%7B%22ddb.panic%22, %5B%5D_C_int%7B9, 5%7D%7D,%0A%09%7B%22ddb.radix%22, %5B%5D_C_int%7B9, 1%7D%7D,%0A%09%7B%22ddb.tab_stop_width%22, %5B%5D_C_int%7B9, 4%7D%7D,%0A%09%7B%22ddb.trigger%22, %5B%5D_C_int%7B9, 8%7D%7D,%0A%09%7B%22fs.posix.setuid%22, %5B%5D_C_int%7B3, 1, 1%7D%7D,%0A%09%7B%22hw.allowpowerdown%22, %5B%5D_C_int%7B6, 22%7D%7D,%0A%09%7B%22hw.byteorder%22, %5B%5D_C_int%7B6, 4%7D%7D,%0A%09%7B%22hw.cpuspeed%22, %5B%5D_C_int%7B6, 12%7D%7D,%0A%09%7B%22hw.diskcount%22, %5B%5D_C_int%7B6, 10%7D%7D,%0A%09%7B%22hw.disknames%22, %5B%5D_C_int%7B6, 8%7D%7D,%0A%09%7B%22hw.diskstats%22, %5B%5D_C_int%7B6, 9%7D%7D,%0A%09%7B%22hw.machine%22, %5B%5D_C_int%7B6, 1%7D%7D,%0A%09%7B%22hw.model%22, %5B%5D_C_int%7B6, 2%7D%7D,%0A%09%7B%22hw.ncpu%22, %5B%5D_C_int%7B6, 3%7D%7D,%0A%09%7B%22hw.ncpufound%22, %5B%5D_C_int%7B6, 21%7D%7D,%0A%09%7B%22hw.pagesize%22, %5B%5D_C_int%7B6, 7%7D%7D,%0A%09%7B%22hw.physmem%22, %5B%5D_C_int%7B6, 19%7D%7D,%0A%09%7B%22hw.product%22, %5B%5D_C_int%7B6, 15%7D%7D,%0A%09%7B%22hw.serialno%22, %5B%5D_C_int%7B6, 17%7D%7D,%0A%09%7B%22hw.setperf%22, %5B%5D_C_int%7B6, 13%7D%7D,%0A%09%7B%22hw.usermem%22, %5B%5D_C_int%7B6, 20%7D%7D,%0A%09%7B%22hw.uuid%22, %5B%5D_C_int%7B6, 18%7D%7D,%0A%09%7B%22hw.vendor%22, %5B%5D_C_int%7B6, 14%7D%7D,%0A%09%7B%22hw.version%22, %5B%5D_C_int%7B6, 16%7D%7D,%0A%09%7B%22kern.arandom%22, %5B%5D_C_int%7B1, 37%7D%7D,%0A%09%7B%22kern.argmax%22, %5B%5D_C_int%7B1, 8%7D%7D,%0A%09%7B%22kern.boottime%22, %5B%5D_C_int%7B1, 21%7D%7D,%0A%09%7B%22kern.bufcachepercent%22, %5B%5D_C_int%7B1, 72%7D%7D,%0A%09%7B%22kern.ccpu%22, %5B%5D_C_int%7B1, 45%7D%7D,%0A%09%7B%22kern.clockrate%22, %5B%5D_C_int%7B1, 12%7D%7D,%0A%09%7B%22kern.consdev%22, %5B%5D_C_int%7B1, 75%7D%7D,%0A%09%7B%22kern.cp_time%22, %5B%5D_C_int%7B1, 40%7D%7D,%0A%09%7B%22kern.cp_time2%22, %5B%5D_C_int%7B1, 71%7D%7D,%0A%09%7B%22kern.cryptodevallowsoft%22, %5B%5D_C_int%7B1, 53%7D%7D,%0A%09%7B%22kern.domainname%22, %5B%5D_C_int%7B1, 22%7D%7D,%0A%09%7B%22kern.file%22, %5B%5D_C_int%7B1, 73%7D%7D,%0A%09%7B%22kern.forkstat%22, %5B%5D_C_int%7B1, 42%7D%7D,%0A%09%7B%22kern.fscale%22, %5B%5D_C_int%7B1, 46%7D%7D,%0A%09%7B%22kern.fsync%22, %5B%5D_C_int%7B1, 33%7D%7D,%0A%09%7B%22kern.hostid%22, %5B%5D_C_int%7B1, 11%7D%7D,%0A%09%7B%22kern.hostname%22, %5B%5D_C_int%7B1, 10%7D%7D,%0A%09%7B%22kern.intrcnt.nintrcnt%22, %5B%5D_C_int%7B1, 63, 1%7D%7D,%0A%09%7B%22kern.job_control%22, %5B%5D_C_int%7B1, 19%7D%7D,%0A%09%7B%22kern.malloc.buckets%22, %5B%5D_C_int%7B1, 39, 1%7D%7D,%0A%09%7B%22kern.malloc.kmemnames%22, %5B%5D_C_int%7B1, 39, 3%7D%7D,%0A%09%7B%22kern.maxclusters%22, %5B%5D_C_int%7B1, 67%7D%7D,%0A%09%7B%22kern.maxfiles%22, %5B%5D_C_int%7B1, 7%7D%7D,%0A%09%7B%22kern.maxlocksperuid%22, %5B%5D_C_int%7B1, 70%7D%7D,%0A%09%7B%22kern.maxpartitions%22, %5B%5D_C_int%7B1, 23%7D%7D,%0A%09%7B%22kern.maxproc%22, %5B%5D_C_int%7B1, 6%7D%7D,%0A%09%7B%22kern.maxthread%22, %5B%5D_C_int%7B1, 25%7D%7D,%0A%09%7B%22kern.maxvnodes%22, %5B%5D_C_int%7B1, 5%7D%7D,%0A%09%7B%22kern.mbstat%22, %5B%5D_C_int%7B1, 59%7D%7D,%0A%09%7B%22kern.msgbuf%22, %5B%5D_C_int%7B1, 48%7D%7D,%0A%09%7B%22kern.msgbufsize%22, %5B%5D_C_int%7B1, 38%7D%7D,%0A%09%7B%22kern.nchstats%22, %5B%5D_C_int%7B1, 41%7D%7D,%0A%09%7B%22kern.netlivelocks%22, %5B%5D_C_int%7B1, 76%7D%7D,%0A%09%7B%22kern.nfiles%22, %5B%5D_C_int%7B1, 56%7D%7D,%0A%09%7B%22kern.ngroups%22, %5B%5D_C_int%7B1, 18%7D%7D,%0A%09%7B%22kern.nosuidcoredump%22, %5B%5D_C_int%7B1, 32%7D%7D,%0A%09%7B%22kern.nprocs%22, %5B%5D_C_int%7B1, 47%7D%7D,%0A%09%7B%22kern.nselcoll%22, %5B%5D_C_int%7B1, 43%7D%7D,%0A%09%7B%22kern.nthreads%22, %5B%5D_C_int%7B1, 26%7D%7D,%0A%09%7B%22kern.numvnodes%22, %5B%5D_C_int%7B1, 58%7D%7D,%0A%09%7B%22kern.osrelease%22, %5B%5D_C_int%7B1, 2%7D%7D,%0A%09%7B%22kern.osrevision%22, %5B%5D_C_int%7B1, 3%7D%7D,%0A%09%7B%22kern.ostype%22, %5B%5D_C_int%7B1, 1%7D%7D,%0A%09%7B%22kern.osversion%22, %5B%5D_C_int%7B1, 27%7D%7D,%0A%09%7B%22kern.pool_debug%22, %5B%5D_C_int%7B1, 77%7D%7D,%0A%09%7B%22kern.posix1version%22, %5B%5D_C_int%7B1, 17%7D%7D,%0A%09%7B%22kern.proc%22, %5B%5D_C_int%7B1, 66%7D%7D,%0A%09%7B%22kern.random%22, %5B%5D_C_int%7B1, 31%7D%7D,%0A%09%7B%22kern.rawpartition%22, %5B%5D_C_int%7B1, 24%7D%7D,%0A%09%7B%22kern.saved_ids%22, %5B%5D_C_int%7B1, 20%7D%7D,%0A%09%7B%22kern.securelevel%22, %5B%5D_C_int%7B1, 9%7D%7D,%0A%09%7B%22kern.seminfo%22, %5B%5D_C_int%7B1, 61%7D%7D,%0A%09%7B%22kern.shminfo%22, %5B%5D_C_int%7B1, 62%7D%7D,%0A%09%7B%22kern.somaxconn%22, %5B%5D_C_int%7B1, 28%7D%7D,%0A%09%7B%22kern.sominconn%22, %5B%5D_C_int%7B1, 29%7D%7D,%0A%09%7B%22kern.splassert%22, %5B%5D_C_int%7B1, 54%7D%7D,%0A%09%7B%22kern.stackgap_random%22, %5B%5D_C_int%7B1, 50%7D%7D,%0A%09%7B%22kern.sysvipc_info%22, %5B%5D_C_int%7B1, 51%7D%7D,%0A%09%7B%22kern.sysvmsg%22, %5B%5D_C_int%7B1, 34%7D%7D,%0A%09%7B%22kern.sysvsem%22, %5B%5D_C_int%7B1, 35%7D%7D,%0A%09%7B%22kern.sysvshm%22, %5B%5D_C_int%7B1, 36%7D%7D,%0A%09%7B%22kern.timecounter.choice%22, %5B%5D_C_int%7B1, 69, 4%7D%7D,%0A%09%7B%22kern.timecounter.hardware%22, %5B%5D_C_int%7B1, 69, 3%7D%7D,%0A%09%7B%22kern.timecounter.tick%22, %5B%5D_C_int%7B1, 69, 1%7D%7D,%0A%09%7B%22kern.timecounter.timestepwarnings%22, %5B%5D_C_int%7B1, 69, 2%7D%7D,%0A%09%7B%22kern.tty.maxptys%22, %5B%5D_C_int%7B1, 44, 6%7D%7D,%0A%09%7B%22kern.tty.nptys%22, %5B%5D_C_int%7B1, 44, 7%7D%7D,%0A%09%7B%22kern.tty.tk_cancc%22, %5B%5D_C_int%7B1, 44, 4%7D%7D,%0A%09%7B%22kern.tty.tk_nin%22, %5B%5D_C_int%7B1, 44, 1%7D%7D,%0A%09%7B%22kern.tty.tk_nout%22, %5B%5D_C_int%7B1, 44, 2%7D%7D,%0A%09%7B%22kern.tty.tk_rawcc%22, %5B%5D_C_int%7B1, 44, 3%7D%7D,%0A%09%7B%22kern.tty.ttyinfo%22, %5B%5D_C_int%7B1, 44, 5%7D%7D,%0A%09%7B%22kern.ttycount%22, %5B%5D_C_int%7B1, 57%7D%7D,%0A%09%7B%22kern.userasymcrypto%22, %5B%5D_C_int%7B1, 60%7D%7D,%0A%09%7B%22kern.usercrypto%22, %5B%5D_C_int%7B1, 52%7D%7D,%0A%09%7B%22kern.usermount%22, %5B%5D_C_int%7B1, 30%7D%7D,%0A%09%7B%22kern.version%22, %5B%5D_C_int%7B1, 4%7D%7D,%0A%09%7B%22kern.vnode%22, %5B%5D_C_int%7B1, 13%7D%7D,%0A%09%7B%22kern.watchdog.auto%22, %5B%5D_C_int%7B1, 64, 2%7D%7D,%0A%09%7B%22kern.watchdog.period%22, %5B%5D_C_int%7B1, 64, 1%7D%7D,%0A%09%7B%22net.bpf.bufsize%22, %5B%5D_C_int%7B4, 31, 1%7D%7D,%0A%09%7B%22net.bpf.maxbufsize%22, %5B%5D_C_int%7B4, 31, 2%7D%7D,%0A%09%7B%22net.inet.ah.enable%22, %5B%5D_C_int%7B4, 2, 51, 1%7D%7D,%0A%09%7B%22net.inet.ah.stats%22, %5B%5D_C_int%7B4, 2, 51, 2%7D%7D,%0A%09%7B%22net.inet.carp.allow%22, %5B%5D_C_int%7B4, 2, 112, 1%7D%7D,%0A%09%7B%22net.inet.carp.log%22, %5B%5D_C_int%7B4, 2, 112, 3%7D%7D,%0A%09%7B%22net.inet.carp.preempt%22, %5B%5D_C_int%7B4, 2, 112, 2%7D%7D,%0A%09%7B%22net.inet.carp.stats%22, %5B%5D_C_int%7B4, 2, 112, 4%7D%7D,%0A%09%7B%22net.inet.divert.recvspace%22, %5B%5D_C_int%7B4, 2, 258, 1%7D%7D,%0A%09%7B%22net.inet.divert.sendspace%22, %5B%5D_C_int%7B4, 2, 258, 2%7D%7D,%0A%09%7B%22net.inet.divert.stats%22, %5B%5D_C_int%7B4, 2, 258, 3%7D%7D,%0A%09%7B%22net.inet.esp.enable%22, %5B%5D_C_int%7B4, 2, 50, 1%7D%7D,%0A%09%7B%22net.inet.esp.stats%22, %5B%5D_C_int%7B4, 2, 50, 4%7D%7D,%0A%09%7B%22net.inet.esp.udpencap%22, %5B%5D_C_int%7B4, 2, 50, 2%7D%7D,%0A%09%7B%22net.inet.esp.udpencap_port%22, %5B%5D_C_int%7B4, 2, 50, 3%7D%7D,%0A%09%7B%22net.inet.etherip.allow%22, %5B%5D_C_int%7B4, 2, 97, 1%7D%7D,%0A%09%7B%22net.inet.etherip.stats%22, %5B%5D_C_int%7B4, 2, 97, 2%7D%7D,%0A%09%7B%22net.inet.gre.allow%22, %5B%5D_C_int%7B4, 2, 47, 1%7D%7D,%0A%09%7B%22net.inet.gre.wccp%22, %5B%5D_C_int%7B4, 2, 47, 2%7D%7D,%0A%09%7B%22net.inet.icmp.bmcastecho%22, %5B%5D_C_int%7B4, 2, 1, 2%7D%7D,%0A%09%7B%22net.inet.icmp.errppslimit%22, %5B%5D_C_int%7B4, 2, 1, 3%7D%7D,%0A%09%7B%22net.inet.icmp.maskrepl%22, %5B%5D_C_int%7B4, 2, 1, 1%7D%7D,%0A%09%7B%22net.inet.icmp.rediraccept%22, %5B%5D_C_int%7B4, 2, 1, 4%7D%7D,%0A%09%7B%22net.inet.icmp.redirtimeout%22, %5B%5D_C_int%7B4, 2, 1, 5%7D%7D,%0A%09%7B%22net.inet.icmp.stats%22, %5B%5D_C_int%7B4, 2, 1, 7%7D%7D,%0A%09%7B%22net.inet.icmp.tstamprepl%22, %5B%5D_C_int%7B4, 2, 1, 6%7D%7D,%0A%09%7B%22net.inet.igmp.stats%22, %5B%5D_C_int%7B4, 2, 2, 1%7D%7D,%0A%09%7B%22net.inet.ip.arpqueued%22, %5B%5D_C_int%7B4, 2, 0, 36%7D%7D,%0A%09%7B%22net.inet.ip.encdebug%22, %5B%5D_C_int%7B4, 2, 0, 12%7D%7D,%0A%09%7B%22net.inet.ip.forwarding%22, %5B%5D_C_int%7B4, 2, 0, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.congestion%22, %5B%5D_C_int%7B4, 2, 0, 30, 4%7D%7D,%0A%09%7B%22net.inet.ip.ifq.drops%22, %5B%5D_C_int%7B4, 2, 0, 30, 3%7D%7D,%0A%09%7B%22net.inet.ip.ifq.len%22, %5B%5D_C_int%7B4, 2, 0, 30, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.maxlen%22, %5B%5D_C_int%7B4, 2, 0, 30, 2%7D%7D,%0A%09%7B%22net.inet.ip.maxqueue%22, %5B%5D_C_int%7B4, 2, 0, 11%7D%7D,%0A%09%7B%22net.inet.ip.mforwarding%22, %5B%5D_C_int%7B4, 2, 0, 31%7D%7D,%0A%09%7B%22net.inet.ip.mrtproto%22, %5B%5D_C_int%7B4, 2, 0, 34%7D%7D,%0A%09%7B%22net.inet.ip.mrtstats%22, %5B%5D_C_int%7B4, 2, 0, 35%7D%7D,%0A%09%7B%22net.inet.ip.mtu%22, %5B%5D_C_int%7B4, 2, 0, 4%7D%7D,%0A%09%7B%22net.inet.ip.mtudisc%22, %5B%5D_C_int%7B4, 2, 0, 27%7D%7D,%0A%09%7B%22net.inet.ip.mtudisctimeout%22, %5B%5D_C_int%7B4, 2, 0, 28%7D%7D,%0A%09%7B%22net.inet.ip.multipath%22, %5B%5D_C_int%7B4, 2, 0, 32%7D%7D,%0A%09%7B%22net.inet.ip.portfirst%22, %5B%5D_C_int%7B4, 2, 0, 7%7D%7D,%0A%09%7B%22net.inet.ip.porthifirst%22, %5B%5D_C_int%7B4, 2, 0, 9%7D%7D,%0A%09%7B%22net.inet.ip.porthilast%22, %5B%5D_C_int%7B4, 2, 0, 10%7D%7D,%0A%09%7B%22net.inet.ip.portlast%22, %5B%5D_C_int%7B4, 2, 0, 8%7D%7D,%0A%09%7B%22net.inet.ip.redirect%22, %5B%5D_C_int%7B4, 2, 0, 2%7D%7D,%0A%09%7B%22net.inet.ip.sourceroute%22, %5B%5D_C_int%7B4, 2, 0, 5%7D%7D,%0A%09%7B%22net.inet.ip.stats%22, %5B%5D_C_int%7B4, 2, 0, 33%7D%7D,%0A%09%7B%22net.inet.ip.ttl%22, %5B%5D_C_int%7B4, 2, 0, 3%7D%7D,%0A%09%7B%22net.inet.ipcomp.enable%22, %5B%5D_C_int%7B4, 2, 108, 1%7D%7D,%0A%09%7B%22net.inet.ipcomp.stats%22, %5B%5D_C_int%7B4, 2, 108, 2%7D%7D,%0A%09%7B%22net.inet.ipip.allow%22, %5B%5D_C_int%7B4, 2, 4, 1%7D%7D,%0A%09%7B%22net.inet.ipip.stats%22, %5B%5D_C_int%7B4, 2, 4, 2%7D%7D,%0A%09%7B%22net.inet.mobileip.allow%22, %5B%5D_C_int%7B4, 2, 55, 1%7D%7D,%0A%09%7B%22net.inet.pfsync.stats%22, %5B%5D_C_int%7B4, 2, 240, 1%7D%7D,%0A%09%7B%22net.inet.pim.stats%22, %5B%5D_C_int%7B4, 2, 103, 1%7D%7D,%0A%09%7B%22net.inet.tcp.ackonpush%22, %5B%5D_C_int%7B4, 2, 6, 13%7D%7D,%0A%09%7B%22net.inet.tcp.always_keepalive%22, %5B%5D_C_int%7B4, 2, 6, 22%7D%7D,%0A%09%7B%22net.inet.tcp.baddynamic%22, %5B%5D_C_int%7B4, 2, 6, 6%7D%7D,%0A%09%7B%22net.inet.tcp.drop%22, %5B%5D_C_int%7B4, 2, 6, 19%7D%7D,%0A%09%7B%22net.inet.tcp.ecn%22, %5B%5D_C_int%7B4, 2, 6, 14%7D%7D,%0A%09%7B%22net.inet.tcp.ident%22, %5B%5D_C_int%7B4, 2, 6, 9%7D%7D,%0A%09%7B%22net.inet.tcp.keepidle%22, %5B%5D_C_int%7B4, 2, 6, 3%7D%7D,%0A%09%7B%22net.inet.tcp.keepinittime%22, %5B%5D_C_int%7B4, 2, 6, 2%7D%7D,%0A%09%7B%22net.inet.tcp.keepintvl%22, %5B%5D_C_int%7B4, 2, 6, 4%7D%7D,%0A%09%7B%22net.inet.tcp.mssdflt%22, %5B%5D_C_int%7B4, 2, 6, 11%7D%7D,%0A%09%7B%22net.inet.tcp.reasslimit%22, %5B%5D_C_int%7B4, 2, 6, 18%7D%7D,%0A%09%7B%22net.inet.tcp.rfc1323%22, %5B%5D_C_int%7B4, 2, 6, 1%7D%7D,%0A%09%7B%22net.inet.tcp.rfc3390%22, %5B%5D_C_int%7B4, 2, 6, 17%7D%7D,%0A%09%7B%22net.inet.tcp.rstppslimit%22, %5B%5D_C_int%7B4, 2, 6, 12%7D%7D,%0A%09%7B%22net.inet.tcp.sack%22, %5B%5D_C_int%7B4, 2, 6, 10%7D%7D,%0A%09%7B%22net.inet.tcp.sackholelimit%22, %5B%5D_C_int%7B4, 2, 6, 20%7D%7D,%0A%09%7B%22net.inet.tcp.slowhz%22, %5B%5D_C_int%7B4, 2, 6, 5%7D%7D,%0A%09%7B%22net.inet.tcp.stats%22, %5B%5D_C_int%7B4, 2, 6, 21%7D%7D,%0A%09%7B%22net.inet.tcp.synbucketlimit%22, %5B%5D_C_int%7B4, 2, 6, 16%7D%7D,%0A%09%7B%22net.inet.tcp.syncachelimit%22, %5B%5D_C_int%7B4, 2, 6, 15%7D%7D,%0A%09%7B%22net.inet.udp.baddynamic%22, %5B%5D_C_int%7B4, 2, 17, 2%7D%7D,%0A%09%7B%22net.inet.udp.checksum%22, %5B%5D_C_int%7B4, 2, 17, 1%7D%7D,%0A%09%7B%22net.inet.udp.recvspace%22, %5B%5D_C_int%7B4, 2, 17, 3%7D%7D,%0A%09%7B%22net.inet.udp.sendspace%22, %5B%5D_C_int%7B4, 2, 17, 4%7D%7D,%0A%09%7B%22net.inet.udp.stats%22, %5B%5D_C_int%7B4, 2, 17, 5%7D%7D,%0A%09%7B%22net.inet6.divert.recvspace%22, %5B%5D_C_int%7B4, 24, 86, 1%7D%7D,%0A%09%7B%22net.inet6.divert.sendspace%22, %5B%5D_C_int%7B4, 24, 86, 2%7D%7D,%0A%09%7B%22net.inet6.divert.stats%22, %5B%5D_C_int%7B4, 24, 86, 3%7D%7D,%0A%09%7B%22net.inet6.icmp6.errppslimit%22, %5B%5D_C_int%7B4, 24, 30, 14%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_hiwat%22, %5B%5D_C_int%7B4, 24, 30, 16%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_lowat%22, %5B%5D_C_int%7B4, 24, 30, 17%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_debug%22, %5B%5D_C_int%7B4, 24, 30, 18%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_delay%22, %5B%5D_C_int%7B4, 24, 30, 8%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_maxnudhint%22, %5B%5D_C_int%7B4, 24, 30, 15%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_mmaxtries%22, %5B%5D_C_int%7B4, 24, 30, 10%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_prune%22, %5B%5D_C_int%7B4, 24, 30, 6%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_umaxtries%22, %5B%5D_C_int%7B4, 24, 30, 9%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_useloopback%22, %5B%5D_C_int%7B4, 24, 30, 11%7D%7D,%0A%09%7B%22net.inet6.icmp6.nodeinfo%22, %5B%5D_C_int%7B4, 24, 30, 13%7D%7D,%0A%09%7B%22net.inet6.icmp6.rediraccept%22, %5B%5D_C_int%7B4, 24, 30, 2%7D%7D,%0A%09%7B%22net.inet6.icmp6.redirtimeout%22, %5B%5D_C_int%7B4, 24, 30, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.accept_rtadv%22, %5B%5D_C_int%7B4, 24, 17, 12%7D%7D,%0A%09%7B%22net.inet6.ip6.auto_flowlabel%22, %5B%5D_C_int%7B4, 24, 17, 17%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_count%22, %5B%5D_C_int%7B4, 24, 17, 16%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_pending%22, %5B%5D_C_int%7B4, 24, 17, 49%7D%7D,%0A%09%7B%22net.inet6.ip6.defmcasthlim%22, %5B%5D_C_int%7B4, 24, 17, 18%7D%7D,%0A%09%7B%22net.inet6.ip6.forwarding%22, %5B%5D_C_int%7B4, 24, 17, 1%7D%7D,%0A%09%7B%22net.inet6.ip6.forwsrcrt%22, %5B%5D_C_int%7B4, 24, 17, 5%7D%7D,%0A%09%7B%22net.inet6.ip6.hdrnestlimit%22, %5B%5D_C_int%7B4, 24, 17, 15%7D%7D,%0A%09%7B%22net.inet6.ip6.hlim%22, %5B%5D_C_int%7B4, 24, 17, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.log_interval%22, %5B%5D_C_int%7B4, 24, 17, 14%7D%7D,%0A%09%7B%22net.inet6.ip6.maxdynroutes%22, %5B%5D_C_int%7B4, 24, 17, 48%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfragpackets%22, %5B%5D_C_int%7B4, 24, 17, 9%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfrags%22, %5B%5D_C_int%7B4, 24, 17, 41%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifdefrouters%22, %5B%5D_C_int%7B4, 24, 17, 47%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifprefixes%22, %5B%5D_C_int%7B4, 24, 17, 46%7D%7D,%0A%09%7B%22net.inet6.ip6.mforwarding%22, %5B%5D_C_int%7B4, 24, 17, 42%7D%7D,%0A%09%7B%22net.inet6.ip6.mrtproto%22, %5B%5D_C_int%7B4, 24, 17, 8%7D%7D,%0A%09%7B%22net.inet6.ip6.mtudisctimeout%22, %5B%5D_C_int%7B4, 24, 17, 50%7D%7D,%0A%09%7B%22net.inet6.ip6.multicast_mtudisc%22, %5B%5D_C_int%7B4, 24, 17, 44%7D%7D,%0A%09%7B%22net.inet6.ip6.multipath%22, %5B%5D_C_int%7B4, 24, 17, 43%7D%7D,%0A%09%7B%22net.inet6.ip6.neighborgcthresh%22, %5B%5D_C_int%7B4, 24, 17, 45%7D%7D,%0A%09%7B%22net.inet6.ip6.redirect%22, %5B%5D_C_int%7B4, 24, 17, 2%7D%7D,%0A%09%7B%22net.inet6.ip6.rr_prune%22, %5B%5D_C_int%7B4, 24, 17, 22%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck%22, %5B%5D_C_int%7B4, 24, 17, 10%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck_logint%22, %5B%5D_C_int%7B4, 24, 17, 11%7D%7D,%0A%09%7B%22net.inet6.ip6.use_deprecated%22, %5B%5D_C_int%7B4, 24, 17, 21%7D%7D,%0A%09%7B%22net.inet6.ip6.v6only%22, %5B%5D_C_int%7B4, 24, 17, 24%7D%7D,%0A%09%7B%22net.key.sadb_dump%22, %5B%5D_C_int%7B4, 30, 1%7D%7D,%0A%09%7B%22net.key.spd_dump%22, %5B%5D_C_int%7B4, 30, 2%7D%7D,%0A%09%7B%22net.mpls.ifq.congestion%22, %5B%5D_C_int%7B4, 33, 3, 4%7D%7D,%0A%09%7B%22net.mpls.ifq.drops%22, %5B%5D_C_int%7B4, 33, 3, 3%7D%7D,%0A%09%7B%22net.mpls.ifq.len%22, %5B%5D_C_int%7B4, 33, 3, 1%7D%7D,%0A%09%7B%22net.mpls.ifq.maxlen%22, %5B%5D_C_int%7B4, 33, 3, 2%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip%22, %5B%5D_C_int%7B4, 33, 5%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip6%22, %5B%5D_C_int%7B4, 33, 6%7D%7D,%0A%09%7B%22net.mpls.maxloop_inkernel%22, %5B%5D_C_int%7B4, 33, 4%7D%7D,%0A%09%7B%22net.mpls.ttl%22, %5B%5D_C_int%7B4, 33, 2%7D%7D,%0A%09%7B%22net.pflow.stats%22, %5B%5D_C_int%7B4, 34, 1%7D%7D,%0A%09%7B%22net.pipex.enable%22, %5B%5D_C_int%7B4, 35, 1%7D%7D,%0A%09%7B%22vm.anonmin%22, %5B%5D_C_int%7B2, 7%7D%7D,%0A%09%7B%22vm.loadavg%22, %5B%5D_C_int%7B2, 2%7D%7D,%0A%09%7B%22vm.maxslp%22, %5B%5D_C_int%7B2, 10%7D%7D,%0A%09%7B%22vm.nkmempages%22, %5B%5D_C_int%7B2, 6%7D%7D,%0A%09%7B%22vm.psstrings%22, %5B%5D_C_int%7B2, 3%7D%7D,%0A%09%7B%22vm.swapencrypt.enable%22, %5B%5D_C_int%7B2, 5, 0%7D%7D,%0A%09%7B%22vm.swapencrypt.keyscreated%22, %5B%5D_C_int%7B2, 5, 1%7D%7D,%0A%09%7B%22vm.swapencrypt.keysdeleted%22, %5B%5D_C_int%7B2, 5, 2%7D%7D,%0A%09%7B%22vm.uspace%22, %5B%5D_C_int%7B2, 11%7D%7D,%0A%09%7B%22vm.uvmexp%22, %5B%5D_C_int%7B2, 4%7D%7D,%0A%09%7B%22vm.vmmeter%22, %5B%5D_C_int%7B2, 1%7D%7D,%0A%09%7B%22vm.vnodemin%22, %5B%5D_C_int%7B2, 9%7D%7D,%0A%09%7B%22vm.vtextmin%22, %5B%5D_C_int%7B2, 8%7D%7D,%0A%7D%0A
+package unix%0A
- f 2c5a6190453d737aa568a086e836b90efbea0c758763e6a2c46cc15366bcde8c vendor/golang.org/x/sys/unix/zsysctl_openbsd_arm.go
+ f 0a6e625c26f26c12e9034772b7c75c0706159c437c6b8294f18006f5a302bfcf vendor/golang.org/x/sys/unix/zsysctl_openbsd_arm.go
dmppatch 8
@@ -20,63 +20,61 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0Apac
@@ -87,11898 +87,4 @@
 nix%0A
-%0Atype mibentry struct %7B%0A%09ctlname string%0A%09ctloid  %5B%5D_C_int%0A%7D%0A%0Avar sysctlMib = %5B%5Dmibentry%7B%0A%09%7B%22ddb.console%22, %5B%5D_C_int%7B9, 6%7D%7D,%0A%09%7B%22ddb.log%22, %5B%5D_C_int%7B9, 7%7D%7D,%0A%09%7B%22ddb.max_line%22, %5B%5D_C_int%7B9, 3%7D%7D,%0A%09%7B%22ddb.max_width%22, %5B%5D_C_int%7B9, 2%7D%7D,%0A%09%7B%22ddb.panic%22, %5B%5D_C_int%7B9, 5%7D%7D,%0A%09%7B%22ddb.radix%22, %5B%5D_C_int%7B9, 1%7D%7D,%0A%09%7B%22ddb.tab_stop_width%22, %5B%5D_C_int%7B9, 4%7D%7D,%0A%09%7B%22ddb.trigger%22, %5B%5D_C_int%7B9, 8%7D%7D,%0A%09%7B%22fs.posix.setuid%22, %5B%5D_C_int%7B3, 1, 1%7D%7D,%0A%09%7B%22hw.allowpowerdown%22, %5B%5D_C_int%7B6, 22%7D%7D,%0A%09%7B%22hw.byteorder%22, %5B%5D_C_int%7B6, 4%7D%7D,%0A%09%7B%22hw.cpuspeed%22, %5B%5D_C_int%7B6, 12%7D%7D,%0A%09%7B%22hw.diskcount%22, %5B%5D_C_int%7B6, 10%7D%7D,%0A%09%7B%22hw.disknames%22, %5B%5D_C_int%7B6, 8%7D%7D,%0A%09%7B%22hw.diskstats%22, %5B%5D_C_int%7B6, 9%7D%7D,%0A%09%7B%22hw.machine%22, %5B%5D_C_int%7B6, 1%7D%7D,%0A%09%7B%22hw.model%22, %5B%5D_C_int%7B6, 2%7D%7D,%0A%09%7B%22hw.ncpu%22, %5B%5D_C_int%7B6, 3%7D%7D,%0A%09%7B%22hw.ncpufound%22, %5B%5D_C_int%7B6, 21%7D%7D,%0A%09%7B%22hw.pagesize%22, %5B%5D_C_int%7B6, 7%7D%7D,%0A%09%7B%22hw.physmem%22, %5B%5D_C_int%7B6, 19%7D%7D,%0A%09%7B%22hw.product%22, %5B%5D_C_int%7B6, 15%7D%7D,%0A%09%7B%22hw.serialno%22, %5B%5D_C_int%7B6, 17%7D%7D,%0A%09%7B%22hw.setperf%22, %5B%5D_C_int%7B6, 13%7D%7D,%0A%09%7B%22hw.usermem%22, %5B%5D_C_int%7B6, 20%7D%7D,%0A%09%7B%22hw.uuid%22, %5B%5D_C_int%7B6, 18%7D%7D,%0A%09%7B%22hw.vendor%22, %5B%5D_C_int%7B6, 14%7D%7D,%0A%09%7B%22hw.version%22, %5B%5D_C_int%7B6, 16%7D%7D,%0A%09%7B%22kern.arandom%22, %5B%5D_C_int%7B1, 37%7D%7D,%0A%09%7B%22kern.argmax%22, %5B%5D_C_int%7B1, 8%7D%7D,%0A%09%7B%22kern.boottime%22, %5B%5D_C_int%7B1, 21%7D%7D,%0A%09%7B%22kern.bufcachepercent%22, %5B%5D_C_int%7B1, 72%7D%7D,%0A%09%7B%22kern.ccpu%22, %5B%5D_C_int%7B1, 45%7D%7D,%0A%09%7B%22kern.clockrate%22, %5B%5D_C_int%7B1, 12%7D%7D,%0A%09%7B%22kern.consdev%22, %5B%5D_C_int%7B1, 75%7D%7D,%0A%09%7B%22kern.cp_time%22, %5B%5D_C_int%7B1, 40%7D%7D,%0A%09%7B%22kern.cp_time2%22, %5B%5D_C_int%7B1, 71%7D%7D,%0A%09%7B%22kern.cryptodevallowsoft%22, %5B%5D_C_int%7B1, 53%7D%7D,%0A%09%7B%22kern.domainname%22, %5B%5D_C_int%7B1, 22%7D%7D,%0A%09%7B%22kern.file%22, %5B%5D_C_int%7B1, 73%7D%7D,%0A%09%7B%22kern.forkstat%22, %5B%5D_C_int%7B1, 42%7D%7D,%0A%09%7B%22kern.fscale%22, %5B%5D_C_int%7B1, 46%7D%7D,%0A%09%7B%22kern.fsync%22, %5B%5D_C_int%7B1, 33%7D%7D,%0A%09%7B%22kern.hostid%22, %5B%5D_C_int%7B1, 11%7D%7D,%0A%09%7B%22kern.hostname%22, %5B%5D_C_int%7B1, 10%7D%7D,%0A%09%7B%22kern.intrcnt.nintrcnt%22, %5B%5D_C_int%7B1, 63, 1%7D%7D,%0A%09%7B%22kern.job_control%22, %5B%5D_C_int%7B1, 19%7D%7D,%0A%09%7B%22kern.malloc.buckets%22, %5B%5D_C_int%7B1, 39, 1%7D%7D,%0A%09%7B%22kern.malloc.kmemnames%22, %5B%5D_C_int%7B1, 39, 3%7D%7D,%0A%09%7B%22kern.maxclusters%22, %5B%5D_C_int%7B1, 67%7D%7D,%0A%09%7B%22kern.maxfiles%22, %5B%5D_C_int%7B1, 7%7D%7D,%0A%09%7B%22kern.maxlocksperuid%22, %5B%5D_C_int%7B1, 70%7D%7D,%0A%09%7B%22kern.maxpartitions%22, %5B%5D_C_int%7B1, 23%7D%7D,%0A%09%7B%22kern.maxproc%22, %5B%5D_C_int%7B1, 6%7D%7D,%0A%09%7B%22kern.maxthread%22, %5B%5D_C_int%7B1, 25%7D%7D,%0A%09%7B%22kern.maxvnodes%22, %5B%5D_C_int%7B1, 5%7D%7D,%0A%09%7B%22kern.mbstat%22, %5B%5D_C_int%7B1, 59%7D%7D,%0A%09%7B%22kern.msgbuf%22, %5B%5D_C_int%7B1, 48%7D%7D,%0A%09%7B%22kern.msgbufsize%22, %5B%5D_C_int%7B1, 38%7D%7D,%0A%09%7B%22kern.nchstats%22, %5B%5D_C_int%7B1, 41%7D%7D,%0A%09%7B%22kern.netlivelocks%22, %5B%5D_C_int%7B1, 76%7D%7D,%0A%09%7B%22kern.nfiles%22, %5B%5D_C_int%7B1, 56%7D%7D,%0A%09%7B%22kern.ngroups%22, %5B%5D_C_int%7B1, 18%7D%7D,%0A%09%7B%22kern.nosuidcoredump%22, %5B%5D_C_int%7B1, 32%7D%7D,%0A%09%7B%22kern.nprocs%22, %5B%5D_C_int%7B1, 47%7D%7D,%0A%09%7B%22kern.nselcoll%22, %5B%5D_C_int%7B1, 43%7D%7D,%0A%09%7B%22kern.nthreads%22, %5B%5D_C_int%7B1, 26%7D%7D,%0A%09%7B%22kern.numvnodes%22, %5B%5D_C_int%7B1, 58%7D%7D,%0A%09%7B%22kern.osrelease%22, %5B%5D_C_int%7B1, 2%7D%7D,%0A%09%7B%22kern.osrevision%22, %5B%5D_C_int%7B1, 3%7D%7D,%0A%09%7B%22kern.ostype%22, %5B%5D_C_int%7B1, 1%7D%7D,%0A%09%7B%22kern.osversion%22, %5B%5D_C_int%7B1, 27%7D%7D,%0A%09%7B%22kern.pool_debug%22, %5B%5D_C_int%7B1, 77%7D%7D,%0A%09%7B%22kern.posix1version%22, %5B%5D_C_int%7B1, 17%7D%7D,%0A%09%7B%22kern.proc%22, %5B%5D_C_int%7B1, 66%7D%7D,%0A%09%7B%22kern.random%22, %5B%5D_C_int%7B1, 31%7D%7D,%0A%09%7B%22kern.rawpartition%22, %5B%5D_C_int%7B1, 24%7D%7D,%0A%09%7B%22kern.saved_ids%22, %5B%5D_C_int%7B1, 20%7D%7D,%0A%09%7B%22kern.securelevel%22, %5B%5D_C_int%7B1, 9%7D%7D,%0A%09%7B%22kern.seminfo%22, %5B%5D_C_int%7B1, 61%7D%7D,%0A%09%7B%22kern.shminfo%22, %5B%5D_C_int%7B1, 62%7D%7D,%0A%09%7B%22kern.somaxconn%22, %5B%5D_C_int%7B1, 28%7D%7D,%0A%09%7B%22kern.sominconn%22, %5B%5D_C_int%7B1, 29%7D%7D,%0A%09%7B%22kern.splassert%22, %5B%5D_C_int%7B1, 54%7D%7D,%0A%09%7B%22kern.stackgap_random%22, %5B%5D_C_int%7B1, 50%7D%7D,%0A%09%7B%22kern.sysvipc_info%22, %5B%5D_C_int%7B1, 51%7D%7D,%0A%09%7B%22kern.sysvmsg%22, %5B%5D_C_int%7B1, 34%7D%7D,%0A%09%7B%22kern.sysvsem%22, %5B%5D_C_int%7B1, 35%7D%7D,%0A%09%7B%22kern.sysvshm%22, %5B%5D_C_int%7B1, 36%7D%7D,%0A%09%7B%22kern.timecounter.choice%22, %5B%5D_C_int%7B1, 69, 4%7D%7D,%0A%09%7B%22kern.timecounter.hardware%22, %5B%5D_C_int%7B1, 69, 3%7D%7D,%0A%09%7B%22kern.timecounter.tick%22, %5B%5D_C_int%7B1, 69, 1%7D%7D,%0A%09%7B%22kern.timecounter.timestepwarnings%22, %5B%5D_C_int%7B1, 69, 2%7D%7D,%0A%09%7B%22kern.tty.maxptys%22, %5B%5D_C_int%7B1, 44, 6%7D%7D,%0A%09%7B%22kern.tty.nptys%22, %5B%5D_C_int%7B1, 44, 7%7D%7D,%0A%09%7B%22kern.tty.tk_cancc%22, %5B%5D_C_int%7B1, 44, 4%7D%7D,%0A%09%7B%22kern.tty.tk_nin%22, %5B%5D_C_int%7B1, 44, 1%7D%7D,%0A%09%7B%22kern.tty.tk_nout%22, %5B%5D_C_int%7B1, 44, 2%7D%7D,%0A%09%7B%22kern.tty.tk_rawcc%22, %5B%5D_C_int%7B1, 44, 3%7D%7D,%0A%09%7B%22kern.tty.ttyinfo%22, %5B%5D_C_int%7B1, 44, 5%7D%7D,%0A%09%7B%22kern.ttycount%22, %5B%5D_C_int%7B1, 57%7D%7D,%0A%09%7B%22kern.userasymcrypto%22, %5B%5D_C_int%7B1, 60%7D%7D,%0A%09%7B%22kern.usercrypto%22, %5B%5D_C_int%7B1, 52%7D%7D,%0A%09%7B%22kern.usermount%22, %5B%5D_C_int%7B1, 30%7D%7D,%0A%09%7B%22kern.version%22, %5B%5D_C_int%7B1, 4%7D%7D,%0A%09%7B%22kern.vnode%22, %5B%5D_C_int%7B1, 13%7D%7D,%0A%09%7B%22kern.watchdog.auto%22, %5B%5D_C_int%7B1, 64, 2%7D%7D,%0A%09%7B%22kern.watchdog.period%22, %5B%5D_C_int%7B1, 64, 1%7D%7D,%0A%09%7B%22net.bpf.bufsize%22, %5B%5D_C_int%7B4, 31, 1%7D%7D,%0A%09%7B%22net.bpf.maxbufsize%22, %5B%5D_C_int%7B4, 31, 2%7D%7D,%0A%09%7B%22net.inet.ah.enable%22, %5B%5D_C_int%7B4, 2, 51, 1%7D%7D,%0A%09%7B%22net.inet.ah.stats%22, %5B%5D_C_int%7B4, 2, 51, 2%7D%7D,%0A%09%7B%22net.inet.carp.allow%22, %5B%5D_C_int%7B4, 2, 112, 1%7D%7D,%0A%09%7B%22net.inet.carp.log%22, %5B%5D_C_int%7B4, 2, 112, 3%7D%7D,%0A%09%7B%22net.inet.carp.preempt%22, %5B%5D_C_int%7B4, 2, 112, 2%7D%7D,%0A%09%7B%22net.inet.carp.stats%22, %5B%5D_C_int%7B4, 2, 112, 4%7D%7D,%0A%09%7B%22net.inet.divert.recvspace%22, %5B%5D_C_int%7B4, 2, 258, 1%7D%7D,%0A%09%7B%22net.inet.divert.sendspace%22, %5B%5D_C_int%7B4, 2, 258, 2%7D%7D,%0A%09%7B%22net.inet.divert.stats%22, %5B%5D_C_int%7B4, 2, 258, 3%7D%7D,%0A%09%7B%22net.inet.esp.enable%22, %5B%5D_C_int%7B4, 2, 50, 1%7D%7D,%0A%09%7B%22net.inet.esp.stats%22, %5B%5D_C_int%7B4, 2, 50, 4%7D%7D,%0A%09%7B%22net.inet.esp.udpencap%22, %5B%5D_C_int%7B4, 2, 50, 2%7D%7D,%0A%09%7B%22net.inet.esp.udpencap_port%22, %5B%5D_C_int%7B4, 2, 50, 3%7D%7D,%0A%09%7B%22net.inet.etherip.allow%22, %5B%5D_C_int%7B4, 2, 97, 1%7D%7D,%0A%09%7B%22net.inet.etherip.stats%22, %5B%5D_C_int%7B4, 2, 97, 2%7D%7D,%0A%09%7B%22net.inet.gre.allow%22, %5B%5D_C_int%7B4, 2, 47, 1%7D%7D,%0A%09%7B%22net.inet.gre.wccp%22, %5B%5D_C_int%7B4, 2, 47, 2%7D%7D,%0A%09%7B%22net.inet.icmp.bmcastecho%22, %5B%5D_C_int%7B4, 2, 1, 2%7D%7D,%0A%09%7B%22net.inet.icmp.errppslimit%22, %5B%5D_C_int%7B4, 2, 1, 3%7D%7D,%0A%09%7B%22net.inet.icmp.maskrepl%22, %5B%5D_C_int%7B4, 2, 1, 1%7D%7D,%0A%09%7B%22net.inet.icmp.rediraccept%22, %5B%5D_C_int%7B4, 2, 1, 4%7D%7D,%0A%09%7B%22net.inet.icmp.redirtimeout%22, %5B%5D_C_int%7B4, 2, 1, 5%7D%7D,%0A%09%7B%22net.inet.icmp.stats%22, %5B%5D_C_int%7B4, 2, 1, 7%7D%7D,%0A%09%7B%22net.inet.icmp.tstamprepl%22, %5B%5D_C_int%7B4, 2, 1, 6%7D%7D,%0A%09%7B%22net.inet.igmp.stats%22, %5B%5D_C_int%7B4, 2, 2, 1%7D%7D,%0A%09%7B%22net.inet.ip.arpqueued%22, %5B%5D_C_int%7B4, 2, 0, 36%7D%7D,%0A%09%7B%22net.inet.ip.encdebug%22, %5B%5D_C_int%7B4, 2, 0, 12%7D%7D,%0A%09%7B%22net.inet.ip.forwarding%22, %5B%5D_C_int%7B4, 2, 0, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.congestion%22, %5B%5D_C_int%7B4, 2, 0, 30, 4%7D%7D,%0A%09%7B%22net.inet.ip.ifq.drops%22, %5B%5D_C_int%7B4, 2, 0, 30, 3%7D%7D,%0A%09%7B%22net.inet.ip.ifq.len%22, %5B%5D_C_int%7B4, 2, 0, 30, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.maxlen%22, %5B%5D_C_int%7B4, 2, 0, 30, 2%7D%7D,%0A%09%7B%22net.inet.ip.maxqueue%22, %5B%5D_C_int%7B4, 2, 0, 11%7D%7D,%0A%09%7B%22net.inet.ip.mforwarding%22, %5B%5D_C_int%7B4, 2, 0, 31%7D%7D,%0A%09%7B%22net.inet.ip.mrtproto%22, %5B%5D_C_int%7B4, 2, 0, 34%7D%7D,%0A%09%7B%22net.inet.ip.mrtstats%22, %5B%5D_C_int%7B4, 2, 0, 35%7D%7D,%0A%09%7B%22net.inet.ip.mtu%22, %5B%5D_C_int%7B4, 2, 0, 4%7D%7D,%0A%09%7B%22net.inet.ip.mtudisc%22, %5B%5D_C_int%7B4, 2, 0, 27%7D%7D,%0A%09%7B%22net.inet.ip.mtudisctimeout%22, %5B%5D_C_int%7B4, 2, 0, 28%7D%7D,%0A%09%7B%22net.inet.ip.multipath%22, %5B%5D_C_int%7B4, 2, 0, 32%7D%7D,%0A%09%7B%22net.inet.ip.portfirst%22, %5B%5D_C_int%7B4, 2, 0, 7%7D%7D,%0A%09%7B%22net.inet.ip.porthifirst%22, %5B%5D_C_int%7B4, 2, 0, 9%7D%7D,%0A%09%7B%22net.inet.ip.porthilast%22, %5B%5D_C_int%7B4, 2, 0, 10%7D%7D,%0A%09%7B%22net.inet.ip.portlast%22, %5B%5D_C_int%7B4, 2, 0, 8%7D%7D,%0A%09%7B%22net.inet.ip.redirect%22, %5B%5D_C_int%7B4, 2, 0, 2%7D%7D,%0A%09%7B%22net.inet.ip.sourceroute%22, %5B%5D_C_int%7B4, 2, 0, 5%7D%7D,%0A%09%7B%22net.inet.ip.stats%22, %5B%5D_C_int%7B4, 2, 0, 33%7D%7D,%0A%09%7B%22net.inet.ip.ttl%22, %5B%5D_C_int%7B4, 2, 0, 3%7D%7D,%0A%09%7B%22net.inet.ipcomp.enable%22, %5B%5D_C_int%7B4, 2, 108, 1%7D%7D,%0A%09%7B%22net.inet.ipcomp.stats%22, %5B%5D_C_int%7B4, 2, 108, 2%7D%7D,%0A%09%7B%22net.inet.ipip.allow%22, %5B%5D_C_int%7B4, 2, 4, 1%7D%7D,%0A%09%7B%22net.inet.ipip.stats%22, %5B%5D_C_int%7B4, 2, 4, 2%7D%7D,%0A%09%7B%22net.inet.mobileip.allow%22, %5B%5D_C_int%7B4, 2, 55, 1%7D%7D,%0A%09%7B%22net.inet.pfsync.stats%22, %5B%5D_C_int%7B4, 2, 240, 1%7D%7D,%0A%09%7B%22net.inet.pim.stats%22, %5B%5D_C_int%7B4, 2, 103, 1%7D%7D,%0A%09%7B%22net.inet.tcp.ackonpush%22, %5B%5D_C_int%7B4, 2, 6, 13%7D%7D,%0A%09%7B%22net.inet.tcp.always_keepalive%22, %5B%5D_C_int%7B4, 2, 6, 22%7D%7D,%0A%09%7B%22net.inet.tcp.baddynamic%22, %5B%5D_C_int%7B4, 2, 6, 6%7D%7D,%0A%09%7B%22net.inet.tcp.drop%22, %5B%5D_C_int%7B4, 2, 6, 19%7D%7D,%0A%09%7B%22net.inet.tcp.ecn%22, %5B%5D_C_int%7B4, 2, 6, 14%7D%7D,%0A%09%7B%22net.inet.tcp.ident%22, %5B%5D_C_int%7B4, 2, 6, 9%7D%7D,%0A%09%7B%22net.inet.tcp.keepidle%22, %5B%5D_C_int%7B4, 2, 6, 3%7D%7D,%0A%09%7B%22net.inet.tcp.keepinittime%22, %5B%5D_C_int%7B4, 2, 6, 2%7D%7D,%0A%09%7B%22net.inet.tcp.keepintvl%22, %5B%5D_C_int%7B4, 2, 6, 4%7D%7D,%0A%09%7B%22net.inet.tcp.mssdflt%22, %5B%5D_C_int%7B4, 2, 6, 11%7D%7D,%0A%09%7B%22net.inet.tcp.reasslimit%22, %5B%5D_C_int%7B4, 2, 6, 18%7D%7D,%0A%09%7B%22net.inet.tcp.rfc1323%22, %5B%5D_C_int%7B4, 2, 6, 1%7D%7D,%0A%09%7B%22net.inet.tcp.rfc3390%22, %5B%5D_C_int%7B4, 2, 6, 17%7D%7D,%0A%09%7B%22net.inet.tcp.rstppslimit%22, %5B%5D_C_int%7B4, 2, 6, 12%7D%7D,%0A%09%7B%22net.inet.tcp.sack%22, %5B%5D_C_int%7B4, 2, 6, 10%7D%7D,%0A%09%7B%22net.inet.tcp.sackholelimit%22, %5B%5D_C_int%7B4, 2, 6, 20%7D%7D,%0A%09%7B%22net.inet.tcp.slowhz%22, %5B%5D_C_int%7B4, 2, 6, 5%7D%7D,%0A%09%7B%22net.inet.tcp.stats%22, %5B%5D_C_int%7B4, 2, 6, 21%7D%7D,%0A%09%7B%22net.inet.tcp.synbucketlimit%22, %5B%5D_C_int%7B4, 2, 6, 16%7D%7D,%0A%09%7B%22net.inet.tcp.syncachelimit%22, %5B%5D_C_int%7B4, 2, 6, 15%7D%7D,%0A%09%7B%22net.inet.udp.baddynamic%22, %5B%5D_C_int%7B4, 2, 17, 2%7D%7D,%0A%09%7B%22net.inet.udp.checksum%22, %5B%5D_C_int%7B4, 2, 17, 1%7D%7D,%0A%09%7B%22net.inet.udp.recvspace%22, %5B%5D_C_int%7B4, 2, 17, 3%7D%7D,%0A%09%7B%22net.inet.udp.sendspace%22, %5B%5D_C_int%7B4, 2, 17, 4%7D%7D,%0A%09%7B%22net.inet.udp.stats%22, %5B%5D_C_int%7B4, 2, 17, 5%7D%7D,%0A%09%7B%22net.inet6.divert.recvspace%22, %5B%5D_C_int%7B4, 24, 86, 1%7D%7D,%0A%09%7B%22net.inet6.divert.sendspace%22, %5B%5D_C_int%7B4, 24, 86, 2%7D%7D,%0A%09%7B%22net.inet6.divert.stats%22, %5B%5D_C_int%7B4, 24, 86, 3%7D%7D,%0A%09%7B%22net.inet6.icmp6.errppslimit%22, %5B%5D_C_int%7B4, 24, 30, 14%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_hiwat%22, %5B%5D_C_int%7B4, 24, 30, 16%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_lowat%22, %5B%5D_C_int%7B4, 24, 30, 17%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_debug%22, %5B%5D_C_int%7B4, 24, 30, 18%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_delay%22, %5B%5D_C_int%7B4, 24, 30, 8%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_maxnudhint%22, %5B%5D_C_int%7B4, 24, 30, 15%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_mmaxtries%22, %5B%5D_C_int%7B4, 24, 30, 10%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_prune%22, %5B%5D_C_int%7B4, 24, 30, 6%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_umaxtries%22, %5B%5D_C_int%7B4, 24, 30, 9%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_useloopback%22, %5B%5D_C_int%7B4, 24, 30, 11%7D%7D,%0A%09%7B%22net.inet6.icmp6.nodeinfo%22, %5B%5D_C_int%7B4, 24, 30, 13%7D%7D,%0A%09%7B%22net.inet6.icmp6.rediraccept%22, %5B%5D_C_int%7B4, 24, 30, 2%7D%7D,%0A%09%7B%22net.inet6.icmp6.redirtimeout%22, %5B%5D_C_int%7B4, 24, 30, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.accept_rtadv%22, %5B%5D_C_int%7B4, 24, 17, 12%7D%7D,%0A%09%7B%22net.inet6.ip6.auto_flowlabel%22, %5B%5D_C_int%7B4, 24, 17, 17%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_count%22, %5B%5D_C_int%7B4, 24, 17, 16%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_pending%22, %5B%5D_C_int%7B4, 24, 17, 49%7D%7D,%0A%09%7B%22net.inet6.ip6.defmcasthlim%22, %5B%5D_C_int%7B4, 24, 17, 18%7D%7D,%0A%09%7B%22net.inet6.ip6.forwarding%22, %5B%5D_C_int%7B4, 24, 17, 1%7D%7D,%0A%09%7B%22net.inet6.ip6.forwsrcrt%22, %5B%5D_C_int%7B4, 24, 17, 5%7D%7D,%0A%09%7B%22net.inet6.ip6.hdrnestlimit%22, %5B%5D_C_int%7B4, 24, 17, 15%7D%7D,%0A%09%7B%22net.inet6.ip6.hlim%22, %5B%5D_C_int%7B4, 24, 17, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.log_interval%22, %5B%5D_C_int%7B4, 24, 17, 14%7D%7D,%0A%09%7B%22net.inet6.ip6.maxdynroutes%22, %5B%5D_C_int%7B4, 24, 17, 48%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfragpackets%22, %5B%5D_C_int%7B4, 24, 17, 9%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfrags%22, %5B%5D_C_int%7B4, 24, 17, 41%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifdefrouters%22, %5B%5D_C_int%7B4, 24, 17, 47%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifprefixes%22, %5B%5D_C_int%7B4, 24, 17, 46%7D%7D,%0A%09%7B%22net.inet6.ip6.mforwarding%22, %5B%5D_C_int%7B4, 24, 17, 42%7D%7D,%0A%09%7B%22net.inet6.ip6.mrtproto%22, %5B%5D_C_int%7B4, 24, 17, 8%7D%7D,%0A%09%7B%22net.inet6.ip6.mtudisctimeout%22, %5B%5D_C_int%7B4, 24, 17, 50%7D%7D,%0A%09%7B%22net.inet6.ip6.multicast_mtudisc%22, %5B%5D_C_int%7B4, 24, 17, 44%7D%7D,%0A%09%7B%22net.inet6.ip6.multipath%22, %5B%5D_C_int%7B4, 24, 17, 43%7D%7D,%0A%09%7B%22net.inet6.ip6.neighborgcthresh%22, %5B%5D_C_int%7B4, 24, 17, 45%7D%7D,%0A%09%7B%22net.inet6.ip6.redirect%22, %5B%5D_C_int%7B4, 24, 17, 2%7D%7D,%0A%09%7B%22net.inet6.ip6.rr_prune%22, %5B%5D_C_int%7B4, 24, 17, 22%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck%22, %5B%5D_C_int%7B4, 24, 17, 10%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck_logint%22, %5B%5D_C_int%7B4, 24, 17, 11%7D%7D,%0A%09%7B%22net.inet6.ip6.use_deprecated%22, %5B%5D_C_int%7B4, 24, 17, 21%7D%7D,%0A%09%7B%22net.inet6.ip6.v6only%22, %5B%5D_C_int%7B4, 24, 17, 24%7D%7D,%0A%09%7B%22net.key.sadb_dump%22, %5B%5D_C_int%7B4, 30, 1%7D%7D,%0A%09%7B%22net.key.spd_dump%22, %5B%5D_C_int%7B4, 30, 2%7D%7D,%0A%09%7B%22net.mpls.ifq.congestion%22, %5B%5D_C_int%7B4, 33, 3, 4%7D%7D,%0A%09%7B%22net.mpls.ifq.drops%22, %5B%5D_C_int%7B4, 33, 3, 3%7D%7D,%0A%09%7B%22net.mpls.ifq.len%22, %5B%5D_C_int%7B4, 33, 3, 1%7D%7D,%0A%09%7B%22net.mpls.ifq.maxlen%22, %5B%5D_C_int%7B4, 33, 3, 2%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip%22, %5B%5D_C_int%7B4, 33, 5%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip6%22, %5B%5D_C_int%7B4, 33, 6%7D%7D,%0A%09%7B%22net.mpls.maxloop_inkernel%22, %5B%5D_C_int%7B4, 33, 4%7D%7D,%0A%09%7B%22net.mpls.ttl%22, %5B%5D_C_int%7B4, 33, 2%7D%7D,%0A%09%7B%22net.pflow.stats%22, %5B%5D_C_int%7B4, 34, 1%7D%7D,%0A%09%7B%22net.pipex.enable%22, %5B%5D_C_int%7B4, 35, 1%7D%7D,%0A%09%7B%22vm.anonmin%22, %5B%5D_C_int%7B2, 7%7D%7D,%0A%09%7B%22vm.loadavg%22, %5B%5D_C_int%7B2, 2%7D%7D,%0A%09%7B%22vm.maxslp%22, %5B%5D_C_int%7B2, 10%7D%7D,%0A%09%7B%22vm.nkmempages%22, %5B%5D_C_int%7B2, 6%7D%7D,%0A%09%7B%22vm.psstrings%22, %5B%5D_C_int%7B2, 3%7D%7D,%0A%09%7B%22vm.swapencrypt.enable%22, %5B%5D_C_int%7B2, 5, 0%7D%7D,%0A%09%7B%22vm.swapencrypt.keyscreated%22, %5B%5D_C_int%7B2, 5, 1%7D%7D,%0A%09%7B%22vm.swapencrypt.keysdeleted%22, %5B%5D_C_int%7B2, 5, 2%7D%7D,%0A%09%7B%22vm.uspace%22, %5B%5D_C_int%7B2, 11%7D%7D,%0A%09%7B%22vm.uvmexp%22, %5B%5D_C_int%7B2, 4%7D%7D,%0A%09%7B%22vm.vmmeter%22, %5B%5D_C_int%7B2, 1%7D%7D,%0A%09%7B%22vm.vnodemin%22, %5B%5D_C_int%7B2, 9%7D%7D,%0A%09%7B%22vm.vtextmin%22, %5B%5D_C_int%7B2, 8%7D%7D,%0A%7D%0A
- f 26d51a00b1623341708198e90634d876563e4b207a597b2510bce58096231d28 vendor/golang.org/x/sys/unix/zsysnum_linux_386.go
+ f 32dbaa5d174f1d7971fbcbc1d682c00878db56a1e9cc39d263670bf7ee108b03 vendor/golang.org/x/sys/unix/zsysnum_linux_386.go
dmppatch 4
@@ -13038,10 +13038,78 @@
   = 384%0A
+%09SYS_IO_PGETEVENTS          = 385%0A%09SYS_RSEQ                   = 386%0A
 )%0A
- f 1fad978bb655f2f4deb6b6d055a62163e5e47a6ca2b157faf5267682df6c0b54 vendor/golang.org/x/sys/unix/zsysnum_linux_amd64.go
+ f 9f8f4be900c5dfe47a12f1ba7ff09b1fb177a4cd7b8fdeee31379f2d6b6c2d5d vendor/golang.org/x/sys/unix/zsysnum_linux_amd64.go
dmppatch 4
@@ -11408,10 +11408,78 @@
   = 332%0A
+%09SYS_IO_PGETEVENTS          = 333%0A%09SYS_RSEQ                   = 334%0A
 )%0A
- f 64eda9518b9a6785c2913f4c59699e2eeffe686e9141853855df88d9c3f55089 vendor/golang.org/x/sys/unix/zsysnum_linux_arm.go
+ f 3b13e3753393311eac55fccef79ef10fa7ac68680d46a002a2c8b609c784b674 vendor/golang.org/x/sys/unix/zsysnum_linux_arm.go
dmppatch 4
@@ -12108,10 +12108,44 @@
   = 397%0A
+%09SYS_RSEQ                   = 398%0A
 )%0A
- f 87fc01a2b63fed0fefdce5d6536d3c97e390ba196ae0c34f85b602a67a50e645 vendor/golang.org/x/sys/unix/zsysnum_linux_arm64.go
+ f 0b369993971fcff4c458f655d7c5ab681482cf5664e62393584930e6133420a0 vendor/golang.org/x/sys/unix/zsysnum_linux_arm64.go
dmppatch 4
@@ -9513,10 +9513,44 @@
   = 291%0A
+%09SYS_IO_PGETEVENTS          = 292%0A
 )%0A
- f 725b2dbcb6c73418769394d6f355d21bf5f47ab6b6fc234b3da2a5eff7c26d93 vendor/golang.org/x/sys/unix/zsysnum_linux_mips.go
+ f 49df9add5da4722510fcebd60051c5aaa8c54ce92078ba85777c1c77a9521ef1 vendor/golang.org/x/sys/unix/zsysnum_linux_mips.go
dmppatch 4
@@ -13000,10 +13000,80 @@
  = 4366%0A
+%09SYS_RSEQ                   = 4367%0A%09SYS_IO_PGETEVENTS          = 4368%0A
 )%0A
- f ddb655a74cfa7c78861d508543403568276882107ec517b48d79227ef33f18b7 vendor/golang.org/x/sys/unix/zsysnum_linux_mips64.go
+ f c4b614aff8a92690e705271b2174385e3dcf27167ab5b661b1887cf777e22610 vendor/golang.org/x/sys/unix/zsysnum_linux_mips64.go
dmppatch 4
@@ -11602,10 +11602,80 @@
  = 5326%0A
+%09SYS_RSEQ                   = 5327%0A%09SYS_IO_PGETEVENTS          = 5328%0A
 )%0A
- f 120dd2930929371767364e6157e6e899e35b2697ff277887f02c9bf3c1955aa8 vendor/golang.org/x/sys/unix/zsysnum_linux_mips64le.go
+ f 656c540e5d33ede4f474b0b5d40133bf8c1e101c172f4311966657b64ee6a389 vendor/golang.org/x/sys/unix/zsysnum_linux_mips64le.go
dmppatch 4
@@ -11604,10 +11604,80 @@
  = 5326%0A
+%09SYS_RSEQ                   = 5327%0A%09SYS_IO_PGETEVENTS          = 5328%0A
 )%0A
- f 3add86b7c775bf0dc5de0093387b35c72264df04c94d753ea49c2b737ab84cb5 vendor/golang.org/x/sys/unix/zsysnum_linux_mipsle.go
+ f 0ddcb5f4b226ab67224ba0a860727bf87b6cbaa49341a096c219689211ae237a vendor/golang.org/x/sys/unix/zsysnum_linux_mipsle.go
dmppatch 4
@@ -13002,10 +13002,80 @@
  = 4366%0A
+%09SYS_RSEQ                   = 4367%0A%09SYS_IO_PGETEVENTS          = 4368%0A
 )%0A
- f 1eec84233df9249fc9e708cac8e16215987864a1f0d464704d6e9f2857b75a8f vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64.go
+ f d36115290c581b93c491d3308b261f980453b33cd4182c93fdf894c247e53765 vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64.go
dmppatch 4
@@ -12457,10 +12457,78 @@
   = 386%0A
+%09SYS_RSEQ                   = 387%0A%09SYS_IO_PGETEVENTS          = 388%0A
 )%0A
- f abdb07a3e25b3be5864afdc0d4afc249fe70159fc9d4215be47e0c78d50a5665 vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64le.go
+ f 5448b4f7353273394d26f14614d848208498030f9cf74f30699c74b60790f5ab vendor/golang.org/x/sys/unix/zsysnum_linux_ppc64le.go
dmppatch 4
@@ -12459,10 +12459,78 @@
   = 386%0A
+%09SYS_RSEQ                   = 387%0A%09SYS_IO_PGETEVENTS          = 388%0A
 )%0A
- f a16e8667bbd9096fc4834acf277ad79e608690a24452ec6c02e0452b8f107e05 vendor/golang.org/x/sys/unix/zsysnum_linux_s390x.go
+ f bd69007388299204f677f02233a46915fe9ba79c96a6f543e5607c834f8217aa vendor/golang.org/x/sys/unix/zsysnum_linux_s390x.go
dmppatch 4
@@ -11178,10 +11178,112 @@
   = 380%0A
+%09SYS_KEXEC_FILE_LOAD        = 381%0A%09SYS_IO_PGETEVENTS          = 382%0A%09SYS_RSEQ                   = 383%0A
 )%0A
- f a08e230be0a2c6e1cbd8c9938d2c14dbfd7abe6d7316f0ad057f6a0cc0ada147 vendor/golang.org/x/sys/unix/zsysnum_linux_sparc64.go
+ f 4e8ca2a0e5dc8c7d66b111e10989b2db6e5364cb5ec96ac978ef8c8cd5a2a148 vendor/golang.org/x/sys/unix/zsysnum_linux_sparc64.go
dmppatch 5
@@ -87,63 +87,61 @@
 d.h%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0A// 
- f 044ecadde438ad4321b31e8f65fe002cd718826f313008d851204e4b343490ea vendor/golang.org/x/sys/unix/zsysnum_netbsd_386.go
+ f 68bd90764a78e50a89aae9cc4fd06cc98f41435e50cadb0e21763c0e1ef412d7 vendor/golang.org/x/sys/unix/zsysnum_netbsd_386.go
dmppatch 5
@@ -19,63 +19,61 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0A// 
- f 09db0c9e70fab665a02ac7752ca9d6a847b8a1b661154917eadd0ca4803ce6ee vendor/golang.org/x/sys/unix/zsysnum_netbsd_amd64.go
+ f 75612cba893657f26fc50b601b1995439950cee86b220886b084757ff5d3420d vendor/golang.org/x/sys/unix/zsysnum_netbsd_amd64.go
dmppatch 5
@@ -19,63 +19,61 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0A// 
- f b84b3c3f7d6dbcb348503eb3f65af51ce266d1d63f6ccd03c9f05617fa8bcfc9 vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm.go
+ f 114f5e8971aba8b09db7f7b0ae6c3ebdcdd32f8120c0454acd2a4d2f8349cab4 vendor/golang.org/x/sys/unix/zsysnum_netbsd_arm.go
dmppatch 5
@@ -19,63 +19,61 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0A// 
- f 01a2310a8d3d293ce048a1a42593336a1a4064d1095198a0a5a4f3e7b8f1216a vendor/golang.org/x/sys/unix/zsysnum_openbsd_386.go
+ f 9515ec69bbbeba8c6704eaee751e6f028b798162fbe1fc0d35a023413e281c57 vendor/golang.org/x/sys/unix/zsysnum_openbsd_386.go
dmppatch 5
@@ -20,63 +20,61 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0A// 
- f 2b1cd261f82c56cb538eb0a72653f2a97591a9c38d868ede192c3dc57a4ee000 vendor/golang.org/x/sys/unix/zsysnum_openbsd_amd64.go
+ f 676a1869c4eba88f2557c6ed64d4840ede6a1189e505bb6d32ae92cbd807df7e vendor/golang.org/x/sys/unix/zsysnum_openbsd_amd64.go
dmppatch 69
@@ -20,63 +20,76 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; see README.md. DO NOT EDIT.%0A
 %0A// 
@@ -519,24 +519,102 @@
 (int fd); %7D%0A
+%09SYS_GETENTROPY     = 7   // %7B int sys_getentropy(void *buf, size_t nbyte); %7D%0A
 %09SYS___TFORK
@@ -2401,86 +2401,86 @@
 , %5C%0A
-%09SYS_ACCESS         = 33  // %7B int sys_access(const char *path, int flags); %7D%0A
+%09SYS_ACCESS         = 33  // %7B int sys_access(const char *path, int amode); %7D%0A
 %09SYS
@@ -2686,76 +2686,8 @@
 ; %7D%0A
-%09SYS_KILL           = 37  // %7B int sys_kill(int pid, int signum); %7D%0A
 %09SYS
@@ -3448,89 +3448,8 @@
 ; %7D%0A
-%09SYS_GETLOGIN       = 49  // %7B int sys_getlogin(char *namebuf, u_int namelen); %7D%0A
 %09SYS
@@ -3964,87 +3964,80 @@
 , %5C%0A
-%09SYS_READLINK       = 58  // %7B int sys_readlink(const char *path, char *buf, %5C%0A
+%09SYS_READLINK       = 58  // %7B ssize_t sys_readlink(const char *path, %5C%0A
 %09SYS
@@ -5613,79 +5613,158 @@
 ; %7D%0A
-%09SYS_SETPGID        = 82  // %7B int sys_setpgid(pid_t pid, int pgid); %7D%0A
+%09SYS_SETPGID        = 82  // %7B int sys_setpgid(pid_t pid, pid_t pgid); %7D%0A%09SYS_FUTEX          = 83  // %7B int sys_futex(uint32_t *f, int op, int val, %5C%0A
 %09SYS
@@ -5890,24 +5890,100 @@
 s(int fd, %5C%0A
+%09SYS_KBIND          = 86  // %7B int sys_kbind(const struct __kbind *param, %5C%0A
 %09SYS_CLOCK_G
@@ -6415,24 +6415,103 @@
 id *arg); %7D%0A
+%09SYS_ACCEPT4        = 93  // %7B int sys_accept4(int s, struct sockaddr *name, %5C%0A
 %09SYS___THRSL
@@ -7045,24 +7045,169 @@
 d_t who); %7D%0A
+%09SYS_PIPE2          = 101 // %7B int sys_pipe2(int *fdp, int flags); %7D%0A%09SYS_DUP3           = 102 // %7B int sys_dup3(int from, int to, int flags); %7D%0A
 %09SYS_SIGRETU
@@ -7502,24 +7502,171 @@
 backlog); %7D%0A
+%09SYS_CHFLAGSAT      = 107 // %7B int sys_chflagsat(int fd, const char *path, %5C%0A%09SYS_PLEDGE         = 108 // %7B int sys_pledge(const char *promises, %5C%0A
 %09SYS_PPOLL  
@@ -7860,24 +7860,173 @@
 nt mask); %7D%0A
+%09SYS_SENDSYSLOG     = 112 // %7B int sys_sendsyslog(const char *buf, size_t nbyte, %5C%0A%09SYS_UNVEIL         = 114 // %7B int sys_unveil(const char *path, %5C%0A
 %09SYS_GETSOCK
@@ -8089,24 +8089,108 @@
 int name, %5C%0A
+%09SYS_THRKILL        = 119 // %7B int sys_thrkill(pid_t tid, int signum, void *tcb); %7D%0A
 %09SYS_READV  
@@ -8292,24 +8292,92 @@
 v(int fd, %5C%0A
+%09SYS_KILL           = 122 // %7B int sys_kill(int pid, int signum); %7D%0A
 %09SYS_FCHOWN 
@@ -9327,24 +9327,107 @@
 l *delta, %5C%0A
+%09SYS_GETLOGIN_R     = 141 // %7B int sys_getlogin_r(char *namebuf, u_int namelen); %7D%0A
 %09SYS_SETSID 
@@ -10789,90 +10789,88 @@
 ; %7D%0A
-%09SYS___SYSCTL       = 202 // %7B int sys___sysctl(const int *name, u_int namelen, %5C%0A
+%09SYS_SYSCTL         = 202 // %7B int sys_sysctl(const int *name, u_int namelen, %5C%0A
 %09SYS
- f 3e70bd21b3ab5e80b672ef35da266192525ace69ebb6412c8276161f03fb6313 vendor/golang.org/x/sys/unix/zsysnum_openbsd_arm.go
+ f cde4cc9be49324f10617704017476ebe65ea26b87578ae6fd17a810706c89bcc vendor/golang.org/x/sys/unix/zsysnum_openbsd_arm.go
dmppatch 5
@@ -20,63 +20,61 @@
 .pl%0A
-// MACHINE GENERATED BY THE ABOVE COMMAND; DO NOT EDIT%0A
+// Code generated by the command above; DO NOT EDIT.%0A
 %0A// 
- f 5e218c18904e344d116f5b9296021240f4835e7b5d9d9069f5281aff070cec8a vendor/golang.org/x/sys/unix/ztypes_darwin_386.go
+ f 66c5b6368e2491f2834b4f467bc5a42a23429014e01b1681e285a07c7bbb324f vendor/golang.org/x/sys/unix/ztypes_darwin_386.go
dmppatch 7
@@ -152,6497 +152,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timeval32 struct%7B%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           int32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Ino           uint64%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          int32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Qspare        %5B2%5Dint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Bsize       uint32%0A%09Iosize      int32%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      uint64%0A%09Files       uint64%0A%09Ffree       uint64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        uint32%0A%09Flags       uint32%0A%09Fssubtype   uint32%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B1024%5Dint8%0A%09Mntfromname %5B1024%5Dint8%0A%09Reserved    %5B8%5Duint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Fstore_t struct %7B%0A%09Flags      uint32%0A%09Posmode    int32%0A%09Offset     int64%0A%09Length     int64%0A%09Bytesalloc int64%0A%7D%0A%0Atype Radvisory_t struct %7B%0A%09Offset int64%0A%09Count  int32%0A%7D%0A%0Atype Fbootstraptransfer_t struct %7B%0A%09Offset int64%0A%09Length uint32%0A%09Buffer *byte%0A%7D%0A%0Atype Log2phys_t struct %7B%0A%09Flags       uint32%0A%09Contigbytes int64%0A%09Devoffset   int64%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino     uint64%0A%09Seekoff uint64%0A%09Reclen  uint16%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Name    %5B1024%5Dint8%0A%09_       %5B3%5Dbyte%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet4Pktinfo     = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int32%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr    = 0x70%0A%09SizeofIfData      = 0x60%0A%09SizeofIfaMsghdr   = 0x14%0A%09SizeofIfmaMsghdr  = 0x10%0A%09SizeofIfmaMsghdr2 = 0x14%0A%09SizeofRtMsghdr    = 0x5c%0A%09SizeofRtMetrics   = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Typelen    uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09Unused1    uint8%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Recvtiming uint32%0A%09Xmittiming uint32%0A%09Lastchange Timeval%0A%09Unused2    uint32%0A%09Hwassist   uint32%0A%09Reserved1  uint32%0A%09Reserved2  uint32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfmaMsghdr2 struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Index    uint16%0A%09_        %5B2%5Dbyte%0A%09Refcount int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   int32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Filler   %5B4%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type
@@ -284,603 +284,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x80%0A%09AT_SYMLINK_FOLLOW   = 0x40%0A%09AT_SYMLINK_NOFOLLOW = 0x20%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 6483678e2d3a6ba3f5abcde6765e144a9a7eb55269398fcdbd652c68c8e7ec06 vendor/golang.org/x/sys/unix/ztypes_darwin_amd64.go
+ f 0c049d1477747a54edeee042cd137a4caf47bb7496034e763abf3e24fdd2264a vendor/golang.org/x/sys/unix/ztypes_darwin_amd64.go
dmppatch 7
@@ -154,6622 +154,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%09_    %5B4%5Dbyte%0A%7D%0A%0Atype Timeval32 struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           int32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Ino           uint64%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          int32%0A%09_             %5B4%5Dbyte%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Qspare        %5B2%5Dint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Bsize       uint32%0A%09Iosize      int32%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      uint64%0A%09Files       uint64%0A%09Ffree       uint64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        uint32%0A%09Flags       uint32%0A%09Fssubtype   uint32%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B1024%5Dint8%0A%09Mntfromname %5B1024%5Dint8%0A%09Reserved    %5B8%5Duint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Fstore_t struct %7B%0A%09Flags      uint32%0A%09Posmode    int32%0A%09Offset     int64%0A%09Length     int64%0A%09Bytesalloc int64%0A%7D%0A%0Atype Radvisory_t struct %7B%0A%09Offset int64%0A%09Count  int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype Fbootstraptransfer_t struct %7B%0A%09Offset int64%0A%09Length uint64%0A%09Buffer *byte%0A%7D%0A%0Atype Log2phys_t struct %7B%0A%09Flags uint32%0A%09_     %5B8%5Dbyte%0A%09_     %5B8%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino     uint64%0A%09Seekoff uint64%0A%09Reclen  uint16%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Name    %5B1024%5Dint8%0A%09_       %5B3%5Dbyte%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09_          %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet4Pktinfo     = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr    = 0x70%0A%09SizeofIfData      = 0x60%0A%09SizeofIfaMsghdr   = 0x14%0A%09SizeofIfmaMsghdr  = 0x10%0A%09SizeofIfmaMsghdr2 = 0x14%0A%09SizeofRtMsghdr    = 0x5c%0A%09SizeofRtMetrics   = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Typelen    uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09Unused1    uint8%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Recvtiming uint32%0A%09Xmittiming uint32%0A%09Lastchange Timeval32%0A%09Unused2    uint32%0A%09Hwassist   uint32%0A%09Reserved1  uint32%0A%09Reserved2  uint32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfmaMsghdr2 struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Index    uint16%0A%09_        %5B2%5Dbyte%0A%09Refcount int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   int32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Filler   %5B4%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09_     %5B4%5Dbyte%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval32%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type
@@ -302,603 +302,4 @@
 4%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x80%0A%09AT_SYMLINK_FOLLOW   = 0x40%0A%09AT_SYMLINK_NOFOLLOW = 0x20%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 468b0b07c951e3f809c05031f5a14906990f587e398752bc28b4056fe487c895 vendor/golang.org/x/sys/unix/ztypes_darwin_arm.go
+ f 4d4e958875de6183262488a70912a2ce25455aec2279d46a87d70715fd2fc95d vendor/golang.org/x/sys/unix/ztypes_darwin_arm.go
dmppatch 7
@@ -171,6496 +171,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timeval32 %5B0%5Dbyte%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           int32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Ino           uint64%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          int32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Qspare        %5B2%5Dint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Bsize       uint32%0A%09Iosize      int32%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      uint64%0A%09Files       uint64%0A%09Ffree       uint64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        uint32%0A%09Flags       uint32%0A%09Fssubtype   uint32%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B1024%5Dint8%0A%09Mntfromname %5B1024%5Dint8%0A%09Reserved    %5B8%5Duint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Fstore_t struct %7B%0A%09Flags      uint32%0A%09Posmode    int32%0A%09Offset     int64%0A%09Length     int64%0A%09Bytesalloc int64%0A%7D%0A%0Atype Radvisory_t struct %7B%0A%09Offset int64%0A%09Count  int32%0A%7D%0A%0Atype Fbootstraptransfer_t struct %7B%0A%09Offset int64%0A%09Length uint32%0A%09Buffer *byte%0A%7D%0A%0Atype Log2phys_t struct %7B%0A%09Flags       uint32%0A%09Contigbytes int64%0A%09Devoffset   int64%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino     uint64%0A%09Seekoff uint64%0A%09Reclen  uint16%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Name    %5B1024%5Dint8%0A%09_       %5B3%5Dbyte%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet4Pktinfo     = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int32%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr    = 0x70%0A%09SizeofIfData      = 0x60%0A%09SizeofIfaMsghdr   = 0x14%0A%09SizeofIfmaMsghdr  = 0x10%0A%09SizeofIfmaMsghdr2 = 0x14%0A%09SizeofRtMsghdr    = 0x5c%0A%09SizeofRtMetrics   = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Typelen    uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09Unused1    uint8%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Recvtiming uint32%0A%09Xmittiming uint32%0A%09Lastchange Timeval%0A%09Unused2    uint32%0A%09Hwassist   uint32%0A%09Reserved1  uint32%0A%09Reserved2  uint32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfmaMsghdr2 struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Index    uint16%0A%09_        %5B2%5Dbyte%0A%09Refcount int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   int32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Filler   %5B4%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type
@@ -303,603 +303,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x80%0A%09AT_SYMLINK_FOLLOW   = 0x40%0A%09AT_SYMLINK_NOFOLLOW = 0x20%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 261a92bf614f55dba2ce100be26e0315141ba4ef9f077bd8cd5b53521ff76ac2 vendor/golang.org/x/sys/unix/ztypes_darwin_arm64.go
+ f fafabf2c64593962b255e0b9fe0bb9d1b14ec98d059b991b24de517fed4d4b19 vendor/golang.org/x/sys/unix/ztypes_darwin_arm64.go
dmppatch 7
@@ -154,6622 +154,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%09_    %5B4%5Dbyte%0A%7D%0A%0Atype Timeval32 struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           int32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Ino           uint64%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          int32%0A%09_             %5B4%5Dbyte%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Qspare        %5B2%5Dint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Bsize       uint32%0A%09Iosize      int32%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      uint64%0A%09Files       uint64%0A%09Ffree       uint64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        uint32%0A%09Flags       uint32%0A%09Fssubtype   uint32%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B1024%5Dint8%0A%09Mntfromname %5B1024%5Dint8%0A%09Reserved    %5B8%5Duint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Fstore_t struct %7B%0A%09Flags      uint32%0A%09Posmode    int32%0A%09Offset     int64%0A%09Length     int64%0A%09Bytesalloc int64%0A%7D%0A%0Atype Radvisory_t struct %7B%0A%09Offset int64%0A%09Count  int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype Fbootstraptransfer_t struct %7B%0A%09Offset int64%0A%09Length uint64%0A%09Buffer *byte%0A%7D%0A%0Atype Log2phys_t struct %7B%0A%09Flags uint32%0A%09_     %5B8%5Dbyte%0A%09_     %5B8%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino     uint64%0A%09Seekoff uint64%0A%09Reclen  uint16%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Name    %5B1024%5Dint8%0A%09_       %5B3%5Dbyte%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09_          %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet4Pktinfo     = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr    = 0x70%0A%09SizeofIfData      = 0x60%0A%09SizeofIfaMsghdr   = 0x14%0A%09SizeofIfmaMsghdr  = 0x10%0A%09SizeofIfmaMsghdr2 = 0x14%0A%09SizeofRtMsghdr    = 0x5c%0A%09SizeofRtMetrics   = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Typelen    uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09Unused1    uint8%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Recvtiming uint32%0A%09Xmittiming uint32%0A%09Lastchange Timeval32%0A%09Unused2    uint32%0A%09Hwassist   uint32%0A%09Reserved1  uint32%0A%09Reserved2  uint32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfmaMsghdr2 struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Index    uint16%0A%09_        %5B2%5Dbyte%0A%09Refcount int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   int32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Filler   %5B4%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09_     %5B4%5Dbyte%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval32%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type
@@ -302,603 +302,4 @@
 4%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x80%0A%09AT_SYMLINK_FOLLOW   = 0x40%0A%09AT_SYMLINK_NOFOLLOW = 0x20%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 0526a808e9beb4bf9e798bfd457487927f2938898063ff9ee07b23dfa9229901 vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go
+ f 5d91ef2d147e6a8eba36b9961f9b0b1863d020abf4d7b44eb8ec68010eefb9ea vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go
dmppatch 7
@@ -160,6454 +160,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur int64%0A%09Max int64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Aconst (%0A%09S_IFMT   = 0xf000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Atype Stat_t struct %7B%0A%09Ino      uint64%0A%09Nlink    uint32%0A%09Dev      uint32%0A%09Mode     uint16%0A%09Padding1 uint16%0A%09Uid      uint32%0A%09Gid      uint32%0A%09Rdev     uint32%0A%09Atim     Timespec%0A%09Mtim     Timespec%0A%09Ctim     Timespec%0A%09Size     int64%0A%09Blocks   int64%0A%09Blksize  uint32%0A%09Flags    uint32%0A%09Gen      uint32%0A%09Lspare   int32%0A%09Qspare1  int64%0A%09Qspare2  int64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Spare2      int64%0A%09Bsize       int64%0A%09Iosize      int64%0A%09Blocks      int64%0A%09Bfree       int64%0A%09Bavail      int64%0A%09Files       int64%0A%09Ffree       int64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        int32%0A%09Flags       int32%0A%09_           %5B4%5Dbyte%0A%09Syncwrites  int64%0A%09Asyncwrites int64%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B80%5Dint8%0A%09Syncreads   int64%0A%09Asyncreads  int64%0A%09Spares1     int16%0A%09Mntfromname %5B80%5Dint8%0A%09Spares2     int16%0A%09_           %5B4%5Dbyte%0A%09Spare       %5B2%5Dint64%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno  uint64%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Unused1 uint8%0A%09Unused2 uint32%0A%09Name    %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%09Rcf    uint16%0A%09Route  %5B16%5Duint16%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09_          %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x36%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Duint64%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0xb0%0A%09SizeofIfData           = 0xa0%0A%09SizeofIfaMsghdr        = 0x14%0A%09SizeofIfmaMsghdr       = 0x10%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x98%0A%09SizeofRtMetrics        = 0x70%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09_          %5B2%5Dbyte%0A%09Mtu        uint64%0A%09Metric     uint64%0A%09Link_state uint64%0A%09Baudrate   uint64%0A%09Ipackets   uint64%0A%09Ierrors    uint64%0A%09Opackets   uint64%0A%09Oerrors    uint64%0A%09Collisions uint64%0A%09Ibytes     uint64%0A%09Obytes     uint64%0A%09Imcasts    uint64%0A%09Omcasts    uint64%0A%09Iqdrops    uint64%0A%09Noproto    uint64%0A%09Hwassist   uint64%0A%09Oqdrops    uint64%0A%09Lastchange Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint64%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks     uint64%0A%09Mtu       uint64%0A%09Pksent    uint64%0A%09Expire    uint64%0A%09Sendpipe  uint64%0A%09Ssthresh  uint64%0A%09Rtt       uint64%0A%09Rttvar    uint64%0A%09Recvpipe  uint64%0A%09Hopcount  uint64%0A%09Mssopt    uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Msl       uint64%0A%09Iwmaxsegs uint64%0A%09Iwcapsegs uint64%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09_     %5B4%5Dbyte%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B6%5Dbyte%0A%7D%0A%0A
 type
@@ -292,547 +292,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = 0xfffafdcd%0A%09AT_SYMLINK_NOFOLLOW = 0x1%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B32%5Dbyte%0A%09Nodename %5B32%5Dbyte%0A%09Release  %5B32%5Dbyte%0A%09Version  %5B32%5Dbyte%0A%09Machine  %5B32%5Dbyte%0A%7D%0A
- f 9ef6c73646c28800dab479863d479393aef27f7352fb5000e355bf936ae2a61b vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
+ f f420dd85139327c42867044c11d9d1ffbf96fcdedb1a573b7e58e78bbd0ddf65 vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
dmppatch 7
@@ -154,7873 +154,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur int64%0A%09Max int64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Aconst (%0A%09S_IFMT   = 0xf000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Atype Stat_t struct %7B%0A%09Dev           uint32%0A%09Ino           uint32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          uint32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Birthtimespec Timespec%0A%09Pad_cgo_0     %5B8%5Dbyte%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Version     uint32%0A%09Type        uint32%0A%09Flags       uint64%0A%09Bsize       uint64%0A%09Iosize      uint64%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      int64%0A%09Files       uint64%0A%09Ffree       int64%0A%09Syncwrites  uint64%0A%09Asyncwrites uint64%0A%09Syncreads   uint64%0A%09Asyncreads  uint64%0A%09Spare       %5B10%5Duint64%0A%09Namemax     uint32%0A%09Owner       uint32%0A%09Fsid        Fsid%0A%09Charspare   %5B80%5Dint8%0A%09Fstypename  %5B16%5Dint8%0A%09Mntfromname %5B88%5Dint8%0A%09Mntonname   %5B88%5Dint8%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%09Sysid  int32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno uint32%0A%09Reclen uint16%0A%09Type   uint8%0A%09Namlen uint8%0A%09Name   %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B46%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x36%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPMreqn          = 0xc%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int32%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09X__fds_bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09sizeofIfMsghdr         = 0xa8%0A%09SizeofIfMsghdr         = 0x60%0A%09sizeofIfData           = 0x98%0A%09SizeofIfData           = 0x50%0A%09SizeofIfaMsghdr        = 0x14%0A%09SizeofIfmaMsghdr       = 0x10%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x5c%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype ifMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      ifData%0A%7D%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype ifData struct %7B%0A%09Type              uint8%0A%09Physical          uint8%0A%09Addrlen           uint8%0A%09Hdrlen            uint8%0A%09Link_state        uint8%0A%09Vhid              uint8%0A%09Datalen           uint16%0A%09Mtu               uint32%0A%09Metric            uint32%0A%09Baudrate          uint64%0A%09Ipackets          uint64%0A%09Ierrors           uint64%0A%09Opackets          uint64%0A%09Oerrors           uint64%0A%09Collisions        uint64%0A%09Ibytes            uint64%0A%09Obytes            uint64%0A%09Imcasts           uint64%0A%09Omcasts           uint64%0A%09Iqdrops           uint64%0A%09Oqdrops           uint64%0A%09Noproto           uint64%0A%09Hwassist          uint64%0A%09X__ifi_epoch      %5B8%5Dbyte%0A%09X__ifi_lastchange %5B16%5Dbyte%0A%7D%0A%0Atype IfData struct %7B%0A%09Type        uint8%0A%09Physical    uint8%0A%09Addrlen     uint8%0A%09Hdrlen      uint8%0A%09Link_state  uint8%0A%09Spare_char1 uint8%0A%09Spare_char2 uint8%0A%09Datalen     uint8%0A%09Mtu         uint32%0A%09Metric      uint32%0A%09Baudrate    uint32%0A%09Ipackets    uint32%0A%09Ierrors     uint32%0A%09Opackets    uint32%0A%09Oerrors     uint32%0A%09Collisions  uint32%0A%09Ibytes      uint32%0A%09Obytes      uint32%0A%09Imcasts     uint32%0A%09Omcasts     uint32%0A%09Iqdrops     uint32%0A%09Noproto     uint32%0A%09Hwassist    uint32%0A%09Epoch       int32%0A%09Lastchange  Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Metric    int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Fmask     int32%0A%09Inits     uint32%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Weight   uint32%0A%09Filler   %5B3%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion    = 0x4%0A%09SizeofBpfStat       = 0x8%0A%09SizeofBpfZbuf       = 0xc%0A%09SizeofBpfProgram    = 0x8%0A%09SizeofBpfInsn       = 0x8%0A%09SizeofBpfHdr        = 0x14%0A%09SizeofBpfZbufHeader = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfZbuf struct %7B%0A%09Bufa   *byte%0A%09Bufb   *byte%0A%09Buflen uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    Timeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfZbufHeader struct %7B%0A%09Kernel_gen uint32%0A%09Kernel_len uint32%0A%09User_gen   uint32%0A%09X_bzh_pad  %5B5%5Duint32%0A%7D%0A%0A
 type
@@ -286,695 +286,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_REMOVEDIR        = 0x800%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR      = 0x8%0A%09POLLHUP      = 0x10%0A%09POLLIN       = 0x1%0A%09POLLINIGNEOF = 0x2000%0A%09POLLNVAL     = 0x20%0A%09POLLOUT      = 0x4%0A%09POLLPRI      = 0x2%0A%09POLLRDBAND   = 0x80%0A%09POLLRDNORM   = 0x40%0A%09POLLWRBAND   = 0x100%0A%09POLLWRNORM   = 0x4%0A)%0A%0Atype CapRights struct %7B%0A%09Rights %5B2%5Duint64%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 9377b0c75b8a9ade8fd9b934bf16109573907102e6627ef36d2d0268ae31a150 vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
+ f 58a0acc4efe257638d4ca7cecdb28e895c2e654cf94926711af23e2139b2b57d vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
dmppatch 7
@@ -156,7956 +156,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur int64%0A%09Max int64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Aconst (%0A%09S_IFMT   = 0xf000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Atype Stat_t struct %7B%0A%09Dev           uint32%0A%09Ino           uint32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          uint32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Birthtimespec Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Version     uint32%0A%09Type        uint32%0A%09Flags       uint64%0A%09Bsize       uint64%0A%09Iosize      uint64%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      int64%0A%09Files       uint64%0A%09Ffree       int64%0A%09Syncwrites  uint64%0A%09Asyncwrites uint64%0A%09Syncreads   uint64%0A%09Asyncreads  uint64%0A%09Spare       %5B10%5Duint64%0A%09Namemax     uint32%0A%09Owner       uint32%0A%09Fsid        Fsid%0A%09Charspare   %5B80%5Dint8%0A%09Fstypename  %5B16%5Dint8%0A%09Mntfromname %5B88%5Dint8%0A%09Mntonname   %5B88%5Dint8%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start     int64%0A%09Len       int64%0A%09Pid       int32%0A%09Type      int16%0A%09Whence    int16%0A%09Sysid     int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno uint32%0A%09Reclen uint16%0A%09Type   uint8%0A%09Namlen uint8%0A%09Name   %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B46%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Pad_cgo_0  %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Pad_cgo_1  %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x36%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPMreqn          = 0xc%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09X__fds_bits %5B16%5Duint64%0A%7D%0A%0Aconst (%0A%09sizeofIfMsghdr         = 0xa8%0A%09SizeofIfMsghdr         = 0xa8%0A%09sizeofIfData           = 0x98%0A%09SizeofIfData           = 0x98%0A%09SizeofIfaMsghdr        = 0x14%0A%09SizeofIfmaMsghdr       = 0x10%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x98%0A%09SizeofRtMetrics        = 0x70%0A)%0A%0Atype ifMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      ifData%0A%7D%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype ifData struct %7B%0A%09Type              uint8%0A%09Physical          uint8%0A%09Addrlen           uint8%0A%09Hdrlen            uint8%0A%09Link_state        uint8%0A%09Vhid              uint8%0A%09Datalen           uint16%0A%09Mtu               uint32%0A%09Metric            uint32%0A%09Baudrate          uint64%0A%09Ipackets          uint64%0A%09Ierrors           uint64%0A%09Opackets          uint64%0A%09Oerrors           uint64%0A%09Collisions        uint64%0A%09Ibytes            uint64%0A%09Obytes            uint64%0A%09Imcasts           uint64%0A%09Omcasts           uint64%0A%09Iqdrops           uint64%0A%09Oqdrops           uint64%0A%09Noproto           uint64%0A%09Hwassist          uint64%0A%09X__ifi_epoch      %5B8%5Dbyte%0A%09X__ifi_lastchange %5B16%5Dbyte%0A%7D%0A%0Atype IfData struct %7B%0A%09Type        uint8%0A%09Physical    uint8%0A%09Addrlen     uint8%0A%09Hdrlen      uint8%0A%09Link_state  uint8%0A%09Spare_char1 uint8%0A%09Spare_char2 uint8%0A%09Datalen     uint8%0A%09Mtu         uint64%0A%09Metric      uint64%0A%09Baudrate    uint64%0A%09Ipackets    uint64%0A%09Ierrors     uint64%0A%09Opackets    uint64%0A%09Oerrors     uint64%0A%09Collisions  uint64%0A%09Ibytes      uint64%0A%09Obytes      uint64%0A%09Imcasts     uint64%0A%09Omcasts     uint64%0A%09Iqdrops     uint64%0A%09Noproto     uint64%0A%09Hwassist    uint64%0A%09Epoch       int64%0A%09Lastchange  Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Metric    int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Fmask     int32%0A%09Inits     uint64%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint64%0A%09Mtu      uint64%0A%09Hopcount uint64%0A%09Expire   uint64%0A%09Recvpipe uint64%0A%09Sendpipe uint64%0A%09Ssthresh uint64%0A%09Rtt      uint64%0A%09Rttvar   uint64%0A%09Pksent   uint64%0A%09Weight   uint64%0A%09Filler   %5B3%5Duint64%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion    = 0x4%0A%09SizeofBpfStat       = 0x8%0A%09SizeofBpfZbuf       = 0x18%0A%09SizeofBpfProgram    = 0x10%0A%09SizeofBpfInsn       = 0x8%0A%09SizeofBpfHdr        = 0x20%0A%09SizeofBpfZbufHeader = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfZbuf struct %7B%0A%09Bufa   *byte%0A%09Bufb   *byte%0A%09Buflen uint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len       uint32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Insns     *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    Timeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype BpfZbufHeader struct %7B%0A%09Kernel_gen uint32%0A%09Kernel_len uint32%0A%09User_gen   uint32%0A%09X_bzh_pad  %5B5%5Duint32%0A%7D%0A%0A
 type
@@ -288,695 +288,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_REMOVEDIR        = 0x800%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR      = 0x8%0A%09POLLHUP      = 0x10%0A%09POLLIN       = 0x1%0A%09POLLINIGNEOF = 0x2000%0A%09POLLNVAL     = 0x20%0A%09POLLOUT      = 0x4%0A%09POLLPRI      = 0x2%0A%09POLLRDBAND   = 0x80%0A%09POLLRDNORM   = 0x40%0A%09POLLWRBAND   = 0x100%0A%09POLLWRNORM   = 0x4%0A)%0A%0Atype CapRights struct %7B%0A%09Rights %5B2%5Duint64%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 9e9a2e43f302cb4ea5da16c06cb2f98448b46fdb8ca12c02f0f47eeddea94ce8 vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
+ f 095e31e7a1b6fd94d4bfd5c4e3a34aa8c06c6b7fa4f35ffc3f496afb5466f092 vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
dmppatch 7
@@ -171,7966 +171,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec       int64%0A%09Nsec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec       int64%0A%09Usec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur int64%0A%09Max int64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Aconst (%0A%09S_IFMT   = 0xf000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Atype Stat_t struct %7B%0A%09Dev           uint32%0A%09Ino           uint32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          uint32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Birthtimespec Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Version     uint32%0A%09Type        uint32%0A%09Flags       uint64%0A%09Bsize       uint64%0A%09Iosize      uint64%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      int64%0A%09Files       uint64%0A%09Ffree       int64%0A%09Syncwrites  uint64%0A%09Asyncwrites uint64%0A%09Syncreads   uint64%0A%09Asyncreads  uint64%0A%09Spare       %5B10%5Duint64%0A%09Namemax     uint32%0A%09Owner       uint32%0A%09Fsid        Fsid%0A%09Charspare   %5B80%5Dint8%0A%09Fstypename  %5B16%5Dint8%0A%09Mntfromname %5B88%5Dint8%0A%09Mntonname   %5B88%5Dint8%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start     int64%0A%09Len       int64%0A%09Pid       int32%0A%09Type      int16%0A%09Whence    int16%0A%09Sysid     int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno uint32%0A%09Reclen uint16%0A%09Type   uint8%0A%09Namlen uint8%0A%09Name   %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B46%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x36%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPMreqn          = 0xc%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int32%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09X__fds_bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09sizeofIfMsghdr         = 0xa8%0A%09SizeofIfMsghdr         = 0x70%0A%09sizeofIfData           = 0x98%0A%09SizeofIfData           = 0x60%0A%09SizeofIfaMsghdr        = 0x14%0A%09SizeofIfmaMsghdr       = 0x10%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x5c%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype ifMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      ifData%0A%7D%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype ifData struct %7B%0A%09Type              uint8%0A%09Physical          uint8%0A%09Addrlen           uint8%0A%09Hdrlen            uint8%0A%09Link_state        uint8%0A%09Vhid              uint8%0A%09Datalen           uint16%0A%09Mtu               uint32%0A%09Metric            uint32%0A%09Baudrate          uint64%0A%09Ipackets          uint64%0A%09Ierrors           uint64%0A%09Opackets          uint64%0A%09Oerrors           uint64%0A%09Collisions        uint64%0A%09Ibytes            uint64%0A%09Obytes            uint64%0A%09Imcasts           uint64%0A%09Omcasts           uint64%0A%09Iqdrops           uint64%0A%09Oqdrops           uint64%0A%09Noproto           uint64%0A%09Hwassist          uint64%0A%09X__ifi_epoch      %5B8%5Dbyte%0A%09X__ifi_lastchange %5B16%5Dbyte%0A%7D%0A%0Atype IfData struct %7B%0A%09Type        uint8%0A%09Physical    uint8%0A%09Addrlen     uint8%0A%09Hdrlen      uint8%0A%09Link_state  uint8%0A%09Spare_char1 uint8%0A%09Spare_char2 uint8%0A%09Datalen     uint8%0A%09Mtu         uint32%0A%09Metric      uint32%0A%09Baudrate    uint32%0A%09Ipackets    uint32%0A%09Ierrors     uint32%0A%09Opackets    uint32%0A%09Oerrors     uint32%0A%09Collisions  uint32%0A%09Ibytes      uint32%0A%09Obytes      uint32%0A%09Imcasts     uint32%0A%09Omcasts     uint32%0A%09Iqdrops     uint32%0A%09Noproto     uint32%0A%09Hwassist    uint32%0A%09Pad_cgo_0   %5B4%5Dbyte%0A%09Epoch       int64%0A%09Lastchange  Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Metric    int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Fmask     int32%0A%09Inits     uint32%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Weight   uint32%0A%09Filler   %5B3%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion    = 0x4%0A%09SizeofBpfStat       = 0x8%0A%09SizeofBpfZbuf       = 0xc%0A%09SizeofBpfProgram    = 0x8%0A%09SizeofBpfInsn       = 0x8%0A%09SizeofBpfHdr        = 0x20%0A%09SizeofBpfZbufHeader = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfZbuf struct %7B%0A%09Bufa   *byte%0A%09Bufb   *byte%0A%09Buflen uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    Timeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype BpfZbufHeader struct %7B%0A%09Kernel_gen uint32%0A%09Kernel_len uint32%0A%09User_gen   uint32%0A%09X_bzh_pad  %5B5%5Duint32%0A%7D%0A%0A
 type
@@ -303,695 +303,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_REMOVEDIR        = 0x800%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR      = 0x8%0A%09POLLHUP      = 0x10%0A%09POLLIN       = 0x1%0A%09POLLINIGNEOF = 0x2000%0A%09POLLNVAL     = 0x20%0A%09POLLOUT      = 0x4%0A%09POLLPRI      = 0x2%0A%09POLLRDBAND   = 0x80%0A%09POLLRDNORM   = 0x40%0A%09POLLWRBAND   = 0x100%0A%09POLLWRNORM   = 0x4%0A)%0A%0Atype CapRights struct %7B%0A%09Rights %5B2%5Duint64%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f ee183aa0b65e1e9a168ebdf5d9d4df79e76a7e2edec8d5450d0907dc1a4966ff vendor/golang.org/x/sys/unix/ztypes_linux_386.go
+ f 7feeb508303d931abeccf65862134a797cbd60b0824736980c56e3a44a5be1c1 vendor/golang.org/x/sys/unix/ztypes_linux_386.go
dmppatch 7
@@ -195,12745 +195,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Offset    int32%0A%09Freq      int32%0A%09Maxerror  int32%0A%09Esterror  int32%0A%09Status    int32%0A%09Constant  int32%0A%09Precision int32%0A%09Tolerance int32%0A%09Time      Timeval%0A%09Tick      int32%0A%09Ppsfreq   int32%0A%09Jitter    int32%0A%09Shift     int32%0A%09Stabil    int32%0A%09Jitcnt    int32%0A%09Calcnt    int32%0A%09Errcnt    int32%0A%09Stbcnt    int32%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int32%0A%0Atype Tms struct %7B%0A%09Utime  int32%0A%09Stime  int32%0A%09Cutime int32%0A%09Cstime int32%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int32%0A%09Modtime int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09_       uint16%0A%09_       %5B2%5Dbyte%0A%09_       uint32%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint64%0A%09_       uint16%0A%09_       %5B2%5Dbyte%0A%09Size    int64%0A%09Blksize int32%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Ino     uint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B1%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x1c%0A%09SizeofCmsghdr           = 0xc%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x8%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B2%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Ebx      int32%0A%09Ecx      int32%0A%09Edx      int32%0A%09Esi      int32%0A%09Edi      int32%0A%09Ebp      int32%0A%09Eax      int32%0A%09Xds      int32%0A%09Xes      int32%0A%09Xfs      int32%0A%09Xgs      int32%0A%09Orig_eax int32%0A%09Eip      int32%0A%09Xcs      int32%0A%09Eflags   int32%0A%09Esp      int32%0A%09Xss      int32%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int32%0A%09Loads     %5B3%5Duint32%0A%09Totalram  uint32%0A%09Freeram   uint32%0A%09Sharedram uint32%0A%09Bufferram uint32%0A%09Totalswap uint32%0A%09Freeswap  uint32%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Totalhigh uint32%0A%09Freehigh  uint32%0A%09Unit      uint32%0A%09_         %5B8%5Dint8%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09Tinode uint32%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B32%5Duint32%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -341,15808 +341,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint32%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x20%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B122%5Dint8%0A%09_      uint32%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09Start     uint32%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int32%0A%09Bsize   int32%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int32%0A%09Frsize  int32%0A%09Flags   int32%0A%09Spare   %5B4%5Dint32%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint32%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x18%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f 8e86a1de5eaa5b90f75e1f3292f640bde943b567b050a92f6a86421810367016 vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go
+ f 9a7260bb083b7fcdbff2f85f5f10f6d9918b83907c4f5c692685e0dcbff925b6 vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go
dmppatch 7
@@ -197,13085 +197,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Nlink   uint64%0A%09Mode    uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09_       int32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Blksize int64%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09_       %5B3%5Dint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09R15      uint64%0A%09R14      uint64%0A%09R13      uint64%0A%09R12      uint64%0A%09Rbp      uint64%0A%09Rbx      uint64%0A%09R11      uint64%0A%09R10      uint64%0A%09R9       uint64%0A%09R8       uint64%0A%09Rax      uint64%0A%09Rcx      uint64%0A%09Rdx      uint64%0A%09Rsi      uint64%0A%09Rdi      uint64%0A%09Orig_rax uint64%0A%09Rip      uint64%0A%09Cs       uint64%0A%09Eflags   uint64%0A%09Rsp      uint64%0A%09Ss       uint64%0A%09Fs_base  uint64%0A%09Gs_base  uint64%0A%09Ds       uint64%0A%09Es       uint64%0A%09Fs       uint64%0A%09Gs       uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -343,15844 +343,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f 19ce115e727c92fdfb3ef5b423439c3acd2fd446422b05d984fe4beb972d1ec9 vendor/golang.org/x/sys/unix/ztypes_linux_arm.go
+ f abf6492c186d7836190890691d7c35098dd10ff2870d81f76eb08949fb29cc30 vendor/golang.org/x/sys/unix/ztypes_linux_arm.go
dmppatch 7
@@ -190,12560 +190,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Offset    int32%0A%09Freq      int32%0A%09Maxerror  int32%0A%09Esterror  int32%0A%09Status    int32%0A%09Constant  int32%0A%09Precision int32%0A%09Tolerance int32%0A%09Time      Timeval%0A%09Tick      int32%0A%09Ppsfreq   int32%0A%09Jitter    int32%0A%09Shift     int32%0A%09Stabil    int32%0A%09Jitcnt    int32%0A%09Calcnt    int32%0A%09Errcnt    int32%0A%09Stbcnt    int32%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int32%0A%0Atype Tms struct %7B%0A%09Utime  int32%0A%09Stime  int32%0A%09Cutime int32%0A%09Cstime int32%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int32%0A%09Modtime int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09_       uint16%0A%09_       %5B2%5Dbyte%0A%09_       uint32%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint64%0A%09_       uint16%0A%09_       %5B6%5Dbyte%0A%09Size    int64%0A%09Blksize int32%0A%09_       %5B4%5Dbyte%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Ino     uint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Duint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Duint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Duint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x1c%0A%09SizeofCmsghdr           = 0xc%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x8%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B2%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Uregs %5B18%5Duint32%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int32%0A%09Loads     %5B3%5Duint32%0A%09Totalram  uint32%0A%09Freeram   uint32%0A%09Sharedram uint32%0A%09Bufferram uint32%0A%09Totalswap uint32%0A%09Freeswap  uint32%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Totalhigh uint32%0A%09Freehigh  uint32%0A%09Unit      uint32%0A%09_         %5B8%5Duint8%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09Tinode uint32%0A%09Fname  %5B6%5Duint8%0A%09Fpack  %5B6%5Duint8%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09PadFd  int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B32%5Duint32%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -336,15827 +336,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Duint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint32%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x20%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B122%5Duint8%0A%09_      uint32%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09Start     uint32%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int32%0A%09Bsize   int32%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int32%0A%09Frsize  int32%0A%09Flags   int32%0A%09Spare   %5B4%5Dint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint32%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x18%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f cd75ce8fe60f69edcee7cf7b7a8bbf285a0e0cbd6e8661cc2f203d60b8deec16 vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go
+ f 3401b401c0e33be442471ddbac990bd9fff21f6cd40eb60bd128e446c5791712 vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go
dmppatch 7
@@ -206,12720 +206,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint64%0A%09_       uint64%0A%09Size    int64%0A%09Blksize int32%0A%09_       int32%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09_       %5B2%5Dint32%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs   %5B31%5Duint64%0A%09Sp     uint64%0A%09Pc     uint64%0A%09Pstate uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09PadFd  int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -352,15844 +352,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f 6052d2cb5fab058e09840a8cb57c3d51c13c4a8c0c60ba7170a6ea89d5b0b3da vendor/golang.org/x/sys/unix/ztypes_linux_mips.go
+ f 687e4b021202955d0386780c15ca347011f760515090a8cee00030a2aa5beea7 vendor/golang.org/x/sys/unix/ztypes_linux_mips.go
dmppatch 7
@@ -191,12630 +191,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Offset    int32%0A%09Freq      int32%0A%09Maxerror  int32%0A%09Esterror  int32%0A%09Status    int32%0A%09Constant  int32%0A%09Precision int32%0A%09Tolerance int32%0A%09Time      Timeval%0A%09Tick      int32%0A%09Ppsfreq   int32%0A%09Jitter    int32%0A%09Shift     int32%0A%09Stabil    int32%0A%09Jitcnt    int32%0A%09Calcnt    int32%0A%09Errcnt    int32%0A%09Stbcnt    int32%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int32%0A%0Atype Tms struct %7B%0A%09Utime  int32%0A%09Stime  int32%0A%09Cutime int32%0A%09Cstime int32%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int32%0A%09Modtime int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint32%0A%09Pad1    %5B3%5Dint32%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint32%0A%09Pad2    %5B3%5Dint32%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize int32%0A%09Pad4    int32%0A%09Blocks  int64%0A%09Pad5    %5B14%5Dint32%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x1c%0A%09SizeofCmsghdr           = 0xc%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x8%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B2%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int32%0A%09Loads     %5B3%5Duint32%0A%09Totalram  uint32%0A%09Freeram   uint32%0A%09Sharedram uint32%0A%09Bufferram uint32%0A%09Totalswap uint32%0A%09Freeswap  uint32%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Totalhigh uint32%0A%09Freehigh  uint32%0A%09Unit      uint32%0A%09_         %5B8%5Dint8%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09Tinode uint32%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09PadFd  int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B32%5Duint32%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -337,15842 +337,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint32%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x20%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x8000000000000000%0A%09CBitFieldMaskBit1  = 0x4000000000000000%0A%09CBitFieldMaskBit2  = 0x2000000000000000%0A%09CBitFieldMaskBit3  = 0x1000000000000000%0A%09CBitFieldMaskBit4  = 0x800000000000000%0A%09CBitFieldMaskBit5  = 0x400000000000000%0A%09CBitFieldMaskBit6  = 0x200000000000000%0A%09CBitFieldMaskBit7  = 0x100000000000000%0A%09CBitFieldMaskBit8  = 0x80000000000000%0A%09CBitFieldMaskBit9  = 0x40000000000000%0A%09CBitFieldMaskBit10 = 0x20000000000000%0A%09CBitFieldMaskBit11 = 0x10000000000000%0A%09CBitFieldMaskBit12 = 0x8000000000000%0A%09CBitFieldMaskBit13 = 0x4000000000000%0A%09CBitFieldMaskBit14 = 0x2000000000000%0A%09CBitFieldMaskBit15 = 0x1000000000000%0A%09CBitFieldMaskBit16 = 0x800000000000%0A%09CBitFieldMaskBit17 = 0x400000000000%0A%09CBitFieldMaskBit18 = 0x200000000000%0A%09CBitFieldMaskBit19 = 0x100000000000%0A%09CBitFieldMaskBit20 = 0x80000000000%0A%09CBitFieldMaskBit21 = 0x40000000000%0A%09CBitFieldMaskBit22 = 0x20000000000%0A%09CBitFieldMaskBit23 = 0x10000000000%0A%09CBitFieldMaskBit24 = 0x8000000000%0A%09CBitFieldMaskBit25 = 0x4000000000%0A%09CBitFieldMaskBit26 = 0x2000000000%0A%09CBitFieldMaskBit27 = 0x1000000000%0A%09CBitFieldMaskBit28 = 0x800000000%0A%09CBitFieldMaskBit29 = 0x400000000%0A%09CBitFieldMaskBit30 = 0x200000000%0A%09CBitFieldMaskBit31 = 0x100000000%0A%09CBitFieldMaskBit32 = 0x80000000%0A%09CBitFieldMaskBit33 = 0x40000000%0A%09CBitFieldMaskBit34 = 0x20000000%0A%09CBitFieldMaskBit35 = 0x10000000%0A%09CBitFieldMaskBit36 = 0x8000000%0A%09CBitFieldMaskBit37 = 0x4000000%0A%09CBitFieldMaskBit38 = 0x2000000%0A%09CBitFieldMaskBit39 = 0x1000000%0A%09CBitFieldMaskBit40 = 0x800000%0A%09CBitFieldMaskBit41 = 0x400000%0A%09CBitFieldMaskBit42 = 0x200000%0A%09CBitFieldMaskBit43 = 0x100000%0A%09CBitFieldMaskBit44 = 0x80000%0A%09CBitFieldMaskBit45 = 0x40000%0A%09CBitFieldMaskBit46 = 0x20000%0A%09CBitFieldMaskBit47 = 0x10000%0A%09CBitFieldMaskBit48 = 0x8000%0A%09CBitFieldMaskBit49 = 0x4000%0A%09CBitFieldMaskBit50 = 0x2000%0A%09CBitFieldMaskBit51 = 0x1000%0A%09CBitFieldMaskBit52 = 0x800%0A%09CBitFieldMaskBit53 = 0x400%0A%09CBitFieldMaskBit54 = 0x200%0A%09CBitFieldMaskBit55 = 0x100%0A%09CBitFieldMaskBit56 = 0x80%0A%09CBitFieldMaskBit57 = 0x40%0A%09CBitFieldMaskBit58 = 0x20%0A%09CBitFieldMaskBit59 = 0x10%0A%09CBitFieldMaskBit60 = 0x8%0A%09CBitFieldMaskBit61 = 0x4%0A%09CBitFieldMaskBit62 = 0x2%0A%09CBitFieldMaskBit63 = 0x1%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B122%5Dint8%0A%09_      uint32%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09Start     uint32%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int32%0A%09Bsize   int32%0A%09Frsize  int32%0A%09_       %5B4%5Dbyte%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Bavail  uint64%0A%09Fsid    Fsid%0A%09Namelen int32%0A%09Flags   int32%0A%09Spare   %5B5%5Dint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint32%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x18%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f 5077d856e8c84a5f07dd93c9eca0487ac5a328dc73dc387272ed67e50ec3f022 vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go
+ f eb86b5ba720c93e10ade7198ef366a42281f1bd04b17e65cd567e0802629a469 vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go
dmppatch 7
@@ -193,12771 +193,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint32%0A%09Pad1    %5B3%5Duint32%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint32%0A%09Pad2    %5B3%5Duint32%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize uint32%0A%09Pad4    uint32%0A%09Blocks  int64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -339,15844 +339,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x8000000000000000%0A%09CBitFieldMaskBit1  = 0x4000000000000000%0A%09CBitFieldMaskBit2  = 0x2000000000000000%0A%09CBitFieldMaskBit3  = 0x1000000000000000%0A%09CBitFieldMaskBit4  = 0x800000000000000%0A%09CBitFieldMaskBit5  = 0x400000000000000%0A%09CBitFieldMaskBit6  = 0x200000000000000%0A%09CBitFieldMaskBit7  = 0x100000000000000%0A%09CBitFieldMaskBit8  = 0x80000000000000%0A%09CBitFieldMaskBit9  = 0x40000000000000%0A%09CBitFieldMaskBit10 = 0x20000000000000%0A%09CBitFieldMaskBit11 = 0x10000000000000%0A%09CBitFieldMaskBit12 = 0x8000000000000%0A%09CBitFieldMaskBit13 = 0x4000000000000%0A%09CBitFieldMaskBit14 = 0x2000000000000%0A%09CBitFieldMaskBit15 = 0x1000000000000%0A%09CBitFieldMaskBit16 = 0x800000000000%0A%09CBitFieldMaskBit17 = 0x400000000000%0A%09CBitFieldMaskBit18 = 0x200000000000%0A%09CBitFieldMaskBit19 = 0x100000000000%0A%09CBitFieldMaskBit20 = 0x80000000000%0A%09CBitFieldMaskBit21 = 0x40000000000%0A%09CBitFieldMaskBit22 = 0x20000000000%0A%09CBitFieldMaskBit23 = 0x10000000000%0A%09CBitFieldMaskBit24 = 0x8000000000%0A%09CBitFieldMaskBit25 = 0x4000000000%0A%09CBitFieldMaskBit26 = 0x2000000000%0A%09CBitFieldMaskBit27 = 0x1000000000%0A%09CBitFieldMaskBit28 = 0x800000000%0A%09CBitFieldMaskBit29 = 0x400000000%0A%09CBitFieldMaskBit30 = 0x200000000%0A%09CBitFieldMaskBit31 = 0x100000000%0A%09CBitFieldMaskBit32 = 0x80000000%0A%09CBitFieldMaskBit33 = 0x40000000%0A%09CBitFieldMaskBit34 = 0x20000000%0A%09CBitFieldMaskBit35 = 0x10000000%0A%09CBitFieldMaskBit36 = 0x8000000%0A%09CBitFieldMaskBit37 = 0x4000000%0A%09CBitFieldMaskBit38 = 0x2000000%0A%09CBitFieldMaskBit39 = 0x1000000%0A%09CBitFieldMaskBit40 = 0x800000%0A%09CBitFieldMaskBit41 = 0x400000%0A%09CBitFieldMaskBit42 = 0x200000%0A%09CBitFieldMaskBit43 = 0x100000%0A%09CBitFieldMaskBit44 = 0x80000%0A%09CBitFieldMaskBit45 = 0x40000%0A%09CBitFieldMaskBit46 = 0x20000%0A%09CBitFieldMaskBit47 = 0x10000%0A%09CBitFieldMaskBit48 = 0x8000%0A%09CBitFieldMaskBit49 = 0x4000%0A%09CBitFieldMaskBit50 = 0x2000%0A%09CBitFieldMaskBit51 = 0x1000%0A%09CBitFieldMaskBit52 = 0x800%0A%09CBitFieldMaskBit53 = 0x400%0A%09CBitFieldMaskBit54 = 0x200%0A%09CBitFieldMaskBit55 = 0x100%0A%09CBitFieldMaskBit56 = 0x80%0A%09CBitFieldMaskBit57 = 0x40%0A%09CBitFieldMaskBit58 = 0x20%0A%09CBitFieldMaskBit59 = 0x10%0A%09CBitFieldMaskBit60 = 0x8%0A%09CBitFieldMaskBit61 = 0x4%0A%09CBitFieldMaskBit62 = 0x2%0A%09CBitFieldMaskBit63 = 0x1%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Frsize  int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Bavail  uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Flags   int64%0A%09Spare   %5B5%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f 91d48b8e21985eccd20f72ea7cc7edb13b7be4eb087aed3149b878360c8c0baf vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go
+ f 94f5c5e71dd8e01be25efa679ad977bd7ef7782d5dc59cd793c2041829f7dbf9 vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go
dmppatch 7
@@ -195,12771 +195,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint32%0A%09Pad1    %5B3%5Duint32%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint32%0A%09Pad2    %5B3%5Duint32%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize uint32%0A%09Pad4    uint32%0A%09Blocks  int64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -341,15844 +341,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Frsize  int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Bavail  uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Flags   int64%0A%09Spare   %5B5%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f 1d2d41e661a1f276953655a524b5ac3401ab12bf8f11e0637e5518664dcab922 vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go
+ f e73653b005f7b60421641bffeb813aa4c346c3bfc77e588a61293a0b541cd4e8 vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go
dmppatch 7
@@ -193,12630 +193,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Offset    int32%0A%09Freq      int32%0A%09Maxerror  int32%0A%09Esterror  int32%0A%09Status    int32%0A%09Constant  int32%0A%09Precision int32%0A%09Tolerance int32%0A%09Time      Timeval%0A%09Tick      int32%0A%09Ppsfreq   int32%0A%09Jitter    int32%0A%09Shift     int32%0A%09Stabil    int32%0A%09Jitcnt    int32%0A%09Calcnt    int32%0A%09Errcnt    int32%0A%09Stbcnt    int32%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int32%0A%0Atype Tms struct %7B%0A%09Utime  int32%0A%09Stime  int32%0A%09Cutime int32%0A%09Cstime int32%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int32%0A%09Modtime int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint32%0A%09Pad1    %5B3%5Dint32%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint32%0A%09Pad2    %5B3%5Dint32%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize int32%0A%09Pad4    int32%0A%09Blocks  int64%0A%09Pad5    %5B14%5Dint32%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x1c%0A%09SizeofCmsghdr           = 0xc%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x8%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B2%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int32%0A%09Loads     %5B3%5Duint32%0A%09Totalram  uint32%0A%09Freeram   uint32%0A%09Sharedram uint32%0A%09Bufferram uint32%0A%09Totalswap uint32%0A%09Freeswap  uint32%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Totalhigh uint32%0A%09Freehigh  uint32%0A%09Unit      uint32%0A%09_         %5B8%5Dint8%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09Tinode uint32%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09PadFd  int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B32%5Duint32%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -339,15842 +339,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint32%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x20%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B122%5Dint8%0A%09_      uint32%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09Start     uint32%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int32%0A%09Bsize   int32%0A%09Frsize  int32%0A%09_       %5B4%5Dbyte%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Bavail  uint64%0A%09Fsid    Fsid%0A%09Namelen int32%0A%09Flags   int32%0A%09Spare   %5B5%5Dint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint32%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x18%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f 073e193a8dad5a6db96e799ba575e7328f14e4483ea8729e95684a8cd389be6e vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go
+ f 5cc062acb2c6db686ab87978884e45ce778ef3bfe4bc35a17864d82b5b07fe21 vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go
dmppatch 7
@@ -192,12914 +192,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Nlink   uint64%0A%09Mode    uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09_       int32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Blksize int64%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09_       uint64%0A%09_       uint64%0A%09_       uint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Duint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Duint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Duint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Gpr       %5B32%5Duint64%0A%09Nip       uint64%0A%09Msr       uint64%0A%09Orig_gpr3 uint64%0A%09Ctr       uint64%0A%09Link      uint64%0A%09Xer       uint64%0A%09Ccr       uint64%0A%09Softe     uint64%0A%09Trap      uint64%0A%09Dar       uint64%0A%09Dsisr     uint64%0A%09Result    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Duint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Duint8%0A%09Fpack  %5B6%5Duint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09_      int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -338,15846 +338,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Duint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x8000000000000000%0A%09CBitFieldMaskBit1  = 0x4000000000000000%0A%09CBitFieldMaskBit2  = 0x2000000000000000%0A%09CBitFieldMaskBit3  = 0x1000000000000000%0A%09CBitFieldMaskBit4  = 0x800000000000000%0A%09CBitFieldMaskBit5  = 0x400000000000000%0A%09CBitFieldMaskBit6  = 0x200000000000000%0A%09CBitFieldMaskBit7  = 0x100000000000000%0A%09CBitFieldMaskBit8  = 0x80000000000000%0A%09CBitFieldMaskBit9  = 0x40000000000000%0A%09CBitFieldMaskBit10 = 0x20000000000000%0A%09CBitFieldMaskBit11 = 0x10000000000000%0A%09CBitFieldMaskBit12 = 0x8000000000000%0A%09CBitFieldMaskBit13 = 0x4000000000000%0A%09CBitFieldMaskBit14 = 0x2000000000000%0A%09CBitFieldMaskBit15 = 0x1000000000000%0A%09CBitFieldMaskBit16 = 0x800000000000%0A%09CBitFieldMaskBit17 = 0x400000000000%0A%09CBitFieldMaskBit18 = 0x200000000000%0A%09CBitFieldMaskBit19 = 0x100000000000%0A%09CBitFieldMaskBit20 = 0x80000000000%0A%09CBitFieldMaskBit21 = 0x40000000000%0A%09CBitFieldMaskBit22 = 0x20000000000%0A%09CBitFieldMaskBit23 = 0x10000000000%0A%09CBitFieldMaskBit24 = 0x8000000000%0A%09CBitFieldMaskBit25 = 0x4000000000%0A%09CBitFieldMaskBit26 = 0x2000000000%0A%09CBitFieldMaskBit27 = 0x1000000000%0A%09CBitFieldMaskBit28 = 0x800000000%0A%09CBitFieldMaskBit29 = 0x400000000%0A%09CBitFieldMaskBit30 = 0x200000000%0A%09CBitFieldMaskBit31 = 0x100000000%0A%09CBitFieldMaskBit32 = 0x80000000%0A%09CBitFieldMaskBit33 = 0x40000000%0A%09CBitFieldMaskBit34 = 0x20000000%0A%09CBitFieldMaskBit35 = 0x10000000%0A%09CBitFieldMaskBit36 = 0x8000000%0A%09CBitFieldMaskBit37 = 0x4000000%0A%09CBitFieldMaskBit38 = 0x2000000%0A%09CBitFieldMaskBit39 = 0x1000000%0A%09CBitFieldMaskBit40 = 0x800000%0A%09CBitFieldMaskBit41 = 0x400000%0A%09CBitFieldMaskBit42 = 0x200000%0A%09CBitFieldMaskBit43 = 0x100000%0A%09CBitFieldMaskBit44 = 0x80000%0A%09CBitFieldMaskBit45 = 0x40000%0A%09CBitFieldMaskBit46 = 0x20000%0A%09CBitFieldMaskBit47 = 0x10000%0A%09CBitFieldMaskBit48 = 0x8000%0A%09CBitFieldMaskBit49 = 0x4000%0A%09CBitFieldMaskBit50 = 0x2000%0A%09CBitFieldMaskBit51 = 0x1000%0A%09CBitFieldMaskBit52 = 0x800%0A%09CBitFieldMaskBit53 = 0x400%0A%09CBitFieldMaskBit54 = 0x200%0A%09CBitFieldMaskBit55 = 0x100%0A%09CBitFieldMaskBit56 = 0x80%0A%09CBitFieldMaskBit57 = 0x40%0A%09CBitFieldMaskBit58 = 0x20%0A%09CBitFieldMaskBit59 = 0x10%0A%09CBitFieldMaskBit60 = 0x8%0A%09CBitFieldMaskBit61 = 0x4%0A%09CBitFieldMaskBit62 = 0x2%0A%09CBitFieldMaskBit63 = 0x1%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Duint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f 3ea6de30d70f1f509cd36d8c2529b71883517af7150f834adc7fc8cad348e2e3 vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go
+ f c0fe2bb880163c4d8c3d84a348df37293a96276aaca2a596cbe0985d7c3d7ae9 vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go
dmppatch 7
@@ -194,12914 +194,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Nlink   uint64%0A%09Mode    uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09_       int32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Blksize int64%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09_       uint64%0A%09_       uint64%0A%09_       uint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Duint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Duint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Duint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Gpr       %5B32%5Duint64%0A%09Nip       uint64%0A%09Msr       uint64%0A%09Orig_gpr3 uint64%0A%09Ctr       uint64%0A%09Link      uint64%0A%09Xer       uint64%0A%09Ccr       uint64%0A%09Softe     uint64%0A%09Trap      uint64%0A%09Dar       uint64%0A%09Dsisr     uint64%0A%09Result    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Duint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Duint8%0A%09Fpack  %5B6%5Duint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09_      int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -340,15846 +340,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Duint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Duint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f f224e6e9090d8dbb9305626ac9f4a29383e714dc77c76a20dfec720e7e29f259 vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go
+ f 809925b423571275028925775c795f31d0f0cc32d41f29ac2ef8637dd5e680d0 vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go
dmppatch 7
@@ -206,13273 +206,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Nlink   uint64%0A%09Mode    uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09_       int32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize int64%0A%09Blocks  int64%0A%09_       %5B3%5Dint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x6%0A%09FADV_NOREUSE    = 0x7%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Psw                      PtracePsw%0A%09Gprs                     %5B16%5Duint64%0A%09Acrs                     %5B16%5Duint32%0A%09Orig_gpr2                uint64%0A%09Fp_regs                  PtraceFpregs%0A%09Per_info                 PtracePer%0A%09Ieee_instruction_pointer uint64%0A%7D%0A%0Atype PtracePsw struct %7B%0A%09Mask uint64%0A%09Addr uint64%0A%7D%0A%0Atype PtraceFpregs struct %7B%0A%09Fpc  uint32%0A%09_    %5B4%5Dbyte%0A%09Fprs %5B16%5Dfloat64%0A%7D%0A%0Atype PtracePer struct %7B%0A%09_             %5B0%5Duint64%0A%09_             %5B24%5Dbyte%0A%09_             %5B8%5Dbyte%0A%09Starting_addr uint64%0A%09Ending_addr   uint64%0A%09Perc_atmid    uint16%0A%09_             %5B6%5Dbyte%0A%09Address       uint64%0A%09Access_id     uint8%0A%09_             %5B7%5Dbyte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09_      int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type
@@ -352,15867 +352,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x8000000000000000%0A%09CBitFieldMaskBit1  = 0x4000000000000000%0A%09CBitFieldMaskBit2  = 0x2000000000000000%0A%09CBitFieldMaskBit3  = 0x1000000000000000%0A%09CBitFieldMaskBit4  = 0x800000000000000%0A%09CBitFieldMaskBit5  = 0x400000000000000%0A%09CBitFieldMaskBit6  = 0x200000000000000%0A%09CBitFieldMaskBit7  = 0x100000000000000%0A%09CBitFieldMaskBit8  = 0x80000000000000%0A%09CBitFieldMaskBit9  = 0x40000000000000%0A%09CBitFieldMaskBit10 = 0x20000000000000%0A%09CBitFieldMaskBit11 = 0x10000000000000%0A%09CBitFieldMaskBit12 = 0x8000000000000%0A%09CBitFieldMaskBit13 = 0x4000000000000%0A%09CBitFieldMaskBit14 = 0x2000000000000%0A%09CBitFieldMaskBit15 = 0x1000000000000%0A%09CBitFieldMaskBit16 = 0x800000000000%0A%09CBitFieldMaskBit17 = 0x400000000000%0A%09CBitFieldMaskBit18 = 0x200000000000%0A%09CBitFieldMaskBit19 = 0x100000000000%0A%09CBitFieldMaskBit20 = 0x80000000000%0A%09CBitFieldMaskBit21 = 0x40000000000%0A%09CBitFieldMaskBit22 = 0x20000000000%0A%09CBitFieldMaskBit23 = 0x10000000000%0A%09CBitFieldMaskBit24 = 0x8000000000%0A%09CBitFieldMaskBit25 = 0x4000000000%0A%09CBitFieldMaskBit26 = 0x2000000000%0A%09CBitFieldMaskBit27 = 0x1000000000%0A%09CBitFieldMaskBit28 = 0x800000000%0A%09CBitFieldMaskBit29 = 0x400000000%0A%09CBitFieldMaskBit30 = 0x200000000%0A%09CBitFieldMaskBit31 = 0x100000000%0A%09CBitFieldMaskBit32 = 0x80000000%0A%09CBitFieldMaskBit33 = 0x40000000%0A%09CBitFieldMaskBit34 = 0x20000000%0A%09CBitFieldMaskBit35 = 0x10000000%0A%09CBitFieldMaskBit36 = 0x8000000%0A%09CBitFieldMaskBit37 = 0x4000000%0A%09CBitFieldMaskBit38 = 0x2000000%0A%09CBitFieldMaskBit39 = 0x1000000%0A%09CBitFieldMaskBit40 = 0x800000%0A%09CBitFieldMaskBit41 = 0x400000%0A%09CBitFieldMaskBit42 = 0x200000%0A%09CBitFieldMaskBit43 = 0x100000%0A%09CBitFieldMaskBit44 = 0x80000%0A%09CBitFieldMaskBit45 = 0x40000%0A%09CBitFieldMaskBit46 = 0x20000%0A%09CBitFieldMaskBit47 = 0x10000%0A%09CBitFieldMaskBit48 = 0x8000%0A%09CBitFieldMaskBit49 = 0x4000%0A%09CBitFieldMaskBit50 = 0x2000%0A%09CBitFieldMaskBit51 = 0x1000%0A%09CBitFieldMaskBit52 = 0x800%0A%09CBitFieldMaskBit53 = 0x400%0A%09CBitFieldMaskBit54 = 0x200%0A%09CBitFieldMaskBit55 = 0x100%0A%09CBitFieldMaskBit56 = 0x80%0A%09CBitFieldMaskBit57 = 0x40%0A%09CBitFieldMaskBit58 = 0x20%0A%09CBitFieldMaskBit59 = 0x10%0A%09CBitFieldMaskBit60 = 0x8%0A%09CBitFieldMaskBit61 = 0x4%0A%09CBitFieldMaskBit62 = 0x2%0A%09CBitFieldMaskBit63 = 0x1%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    uint32%0A%09Bsize   uint32%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen uint32%0A%09Frsize  uint32%0A%09Flags   uint32%0A%09Spare   %5B4%5Duint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A
- f bbaead6d239c564329da2096120786ed22cc31335129edb83900a746101ca925 vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go
+ f 07fbd054547d7b6016303e8f4848bf96ef3970834d0c86df01e03e1388cf6cb6 vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go
dmppatch 4
@@ -125,11994 +125,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec       int64%0A%09Usec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09Pad_cgo_2 %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09Pad_cgo_3 %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev                uint64%0A%09X__pad1            uint16%0A%09Pad_cgo_0          %5B6%5Dbyte%0A%09Ino                uint64%0A%09Mode               uint32%0A%09Nlink              uint32%0A%09Uid                uint32%0A%09Gid                uint32%0A%09Rdev               uint64%0A%09X__pad2            uint16%0A%09Pad_cgo_1          %5B6%5Dbyte%0A%09Size               int64%0A%09Blksize            int64%0A%09Blocks             int64%0A%09Atim               Timespec%0A%09Mtim               Timespec%0A%09Ctim               Timespec%0A%09X__glibc_reserved4 uint64%0A%09X__glibc_reserved5 uint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino       uint64%0A%09Off       int64%0A%09Reclen    uint16%0A%09Type      uint8%0A%09Name      %5B256%5Dint8%0A%09Pad_cgo_0 %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09X__val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type              int16%0A%09Whence            int16%0A%09Pad_cgo_0         %5B4%5Dbyte%0A%09Start             int64%0A%09Len               int64%0A%09Pid               int32%0A%09X__glibc_reserved int16%0A%09Pad_cgo_1         %5B2%5Dbyte%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Ifindex   int32%0A%09Addr      %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Pad_cgo_0  %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09Pad_cgo_1  %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09Pad_cgo_0      %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x2e%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family     uint8%0A%09X__ifi_pad uint8%0A%09Type       uint16%0A%09Index      int32%0A%09Flags      uint32%0A%09Change     uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len       uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%09Filter    *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs   %5B16%5Duint64%0A%09Tstate uint64%0A%09Tpc    uint64%0A%09Tnpc   uint64%0A%09Y      uint32%0A%09Magic  uint32%0A%7D%0A%0Atype ptracePsw struct %7B%0A%7D%0A%0Atype ptraceFpregs struct %7B%0A%7D%0A%0Atype ptracePer struct %7B%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09X_f       %5B0%5Dint8%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree     int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Tinode    uint64%0A%09Fname     %5B6%5Dint8%0A%09Fpack     %5B6%5Dint8%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events  uint32%0A%09X_padFd int32%0A%09Fd      int32%0A%09Pad     int32%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_REMOVEDIR        = 0x200%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x800%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09X__val %5B16%5Duint64%0A%7D%0A%0A
 type
- f cb06569cd584081fc14789b8af48007b0a1ebfc90e2c0c21d1acbcaa38d75790 vendor/golang.org/x/sys/unix/ztypes_netbsd_386.go
+ f 03d5699fac307625ec38de51a44700780137d57b889e0d0473349518a4fdaaa7 vendor/golang.org/x/sys/unix/ztypes_netbsd_386.go
dmppatch 7
@@ -152,5696 +152,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           uint64%0A%09Mode          uint32%0A%09Ino           uint64%0A%09Nlink         uint32%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          uint64%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       uint32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Spare         %5B2%5Duint32%0A%7D%0A%0Atype Statfs_t %5B0%5Dbyte%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno    uint64%0A%09Reclen    uint16%0A%09Namlen    uint16%0A%09Type      uint8%0A%09Name      %5B512%5Dint8%0A%09Pad_cgo_0 %5B3%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09X__fsid_val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter uint32%0A%09Flags  uint32%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  int32%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0x98%0A%09SizeofIfData           = 0x84%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x78%0A%09SizeofRtMetrics        = 0x50%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Pad_cgo_0  %5B1%5Dbyte%0A%09Link_state int32%0A%09Mtu        uint64%0A%09Metric     uint64%0A%09Baudrate   uint64%0A%09Ipackets   uint64%0A%09Ierrors    uint64%0A%09Opackets   uint64%0A%09Oerrors    uint64%0A%09Collisions uint64%0A%09Ibytes     uint64%0A%09Obytes     uint64%0A%09Imcasts    uint64%0A%09Omcasts    uint64%0A%09Iqdrops    uint64%0A%09Noproto    uint64%0A%09Lastchange Timespec%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Metric    int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Use       int32%0A%09Inits     int32%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint64%0A%09Mtu      uint64%0A%09Hopcount uint64%0A%09Recvpipe uint64%0A%09Sendpipe uint64%0A%09Ssthresh uint64%0A%09Rtt      uint64%0A%09Rttvar   uint64%0A%09Expire   int64%0A%09Pksent   int64%0A%7D%0A%0Atype Mclpool %5B0%5Dbyte%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x80%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv    uint64%0A%09Drop    uint64%0A%09Capt    uint64%0A%09Padding %5B13%5Duint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0A
 type
@@ -282,824 +282,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Sysctlnode struct %7B%0A%09Flags           uint32%0A%09Num             int32%0A%09Name            %5B32%5Dint8%0A%09Ver             uint32%0A%09X__rsvd         uint32%0A%09Un              %5B16%5Dbyte%0A%09X_sysctl_size   %5B8%5Dbyte%0A%09X_sysctl_func   %5B8%5Dbyte%0A%09X_sysctl_parent %5B8%5Dbyte%0A%09X_sysctl_desc   %5B8%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f a8b9ffc17899005aa6323922be09f0cecb333da5a4a2bcbd7ec849222d2b43e2 vendor/golang.org/x/sys/unix/ztypes_netbsd_amd64.go
+ f fb8fc07868ebf24f1f6a3dac854c95c7aa2ae6d904bfe50fbcee031b0f9e0049 vendor/golang.org/x/sys/unix/ztypes_netbsd_amd64.go
dmppatch 7
@@ -154,5880 +154,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec       int64%0A%09Usec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           uint64%0A%09Mode          uint32%0A%09Pad_cgo_0     %5B4%5Dbyte%0A%09Ino           uint64%0A%09Nlink         uint32%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Pad_cgo_1     %5B4%5Dbyte%0A%09Rdev          uint64%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       uint32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Spare         %5B2%5Duint32%0A%09Pad_cgo_2     %5B4%5Dbyte%0A%7D%0A%0Atype Statfs_t %5B0%5Dbyte%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno    uint64%0A%09Reclen    uint16%0A%09Namlen    uint16%0A%09Type      uint8%0A%09Name      %5B512%5Dint8%0A%09Pad_cgo_0 %5B3%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09X__fsid_val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Pad_cgo_0  %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Pad_cgo_1  %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident     uint64%0A%09Filter    uint32%0A%09Flags     uint32%0A%09Fflags    uint32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Data      int64%0A%09Udata     int64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0x98%0A%09SizeofIfData           = 0x88%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x78%0A%09SizeofRtMetrics        = 0x50%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Pad_cgo_0  %5B1%5Dbyte%0A%09Link_state int32%0A%09Mtu        uint64%0A%09Metric     uint64%0A%09Baudrate   uint64%0A%09Ipackets   uint64%0A%09Ierrors    uint64%0A%09Opackets   uint64%0A%09Oerrors    uint64%0A%09Collisions uint64%0A%09Ibytes     uint64%0A%09Obytes     uint64%0A%09Imcasts    uint64%0A%09Omcasts    uint64%0A%09Iqdrops    uint64%0A%09Noproto    uint64%0A%09Lastchange Timespec%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Metric    int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Use       int32%0A%09Inits     int32%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint64%0A%09Mtu      uint64%0A%09Hopcount uint64%0A%09Recvpipe uint64%0A%09Sendpipe uint64%0A%09Ssthresh uint64%0A%09Rtt      uint64%0A%09Rttvar   uint64%0A%09Expire   int64%0A%09Pksent   int64%0A%7D%0A%0Atype Mclpool %5B0%5Dbyte%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x80%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv    uint64%0A%09Drop    uint64%0A%09Capt    uint64%0A%09Padding %5B13%5Duint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len       uint32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Insns     *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0A
 type
@@ -284,824 +284,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Sysctlnode struct %7B%0A%09Flags           uint32%0A%09Num             int32%0A%09Name            %5B32%5Dint8%0A%09Ver             uint32%0A%09X__rsvd         uint32%0A%09Un              %5B16%5Dbyte%0A%09X_sysctl_size   %5B8%5Dbyte%0A%09X_sysctl_func   %5B8%5Dbyte%0A%09X_sysctl_parent %5B8%5Dbyte%0A%09X_sysctl_desc   %5B8%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 0498554619bbcd1f52d5b4abae8757d8f65d44ae9a297c43518477da7553a10d vendor/golang.org/x/sys/unix/ztypes_netbsd_arm.go
+ f 3743b9fb0481e28a7d71720ece0a1007e5b63e751aa0b52ba80c071b08bed792 vendor/golang.org/x/sys/unix/ztypes_netbsd_arm.go
dmppatch 7
@@ -152,5841 +152,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec       int64%0A%09Nsec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec       int64%0A%09Usec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           uint64%0A%09Mode          uint32%0A%09Pad_cgo_0     %5B4%5Dbyte%0A%09Ino           uint64%0A%09Nlink         uint32%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Pad_cgo_1     %5B4%5Dbyte%0A%09Rdev          uint64%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       uint32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Spare         %5B2%5Duint32%0A%09Pad_cgo_2     %5B4%5Dbyte%0A%7D%0A%0Atype Statfs_t %5B0%5Dbyte%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno    uint64%0A%09Reclen    uint16%0A%09Namlen    uint16%0A%09Type      uint8%0A%09Name      %5B512%5Dint8%0A%09Pad_cgo_0 %5B3%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09X__fsid_val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident     uint32%0A%09Filter    uint32%0A%09Flags     uint32%0A%09Fflags    uint32%0A%09Data      int64%0A%09Udata     int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0x98%0A%09SizeofIfData           = 0x88%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x78%0A%09SizeofRtMetrics        = 0x50%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Pad_cgo_0  %5B1%5Dbyte%0A%09Link_state int32%0A%09Mtu        uint64%0A%09Metric     uint64%0A%09Baudrate   uint64%0A%09Ipackets   uint64%0A%09Ierrors    uint64%0A%09Opackets   uint64%0A%09Oerrors    uint64%0A%09Collisions uint64%0A%09Ibytes     uint64%0A%09Obytes     uint64%0A%09Imcasts    uint64%0A%09Omcasts    uint64%0A%09Iqdrops    uint64%0A%09Noproto    uint64%0A%09Lastchange Timespec%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Metric    int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Use       int32%0A%09Inits     int32%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint64%0A%09Mtu      uint64%0A%09Hopcount uint64%0A%09Recvpipe uint64%0A%09Sendpipe uint64%0A%09Ssthresh uint64%0A%09Rtt      uint64%0A%09Rttvar   uint64%0A%09Expire   int64%0A%09Pksent   int64%0A%7D%0A%0Atype Mclpool %5B0%5Dbyte%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x80%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv    uint64%0A%09Drop    uint64%0A%09Capt    uint64%0A%09Padding %5B13%5Duint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0A
 type
@@ -282,824 +282,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Sysctlnode struct %7B%0A%09Flags           uint32%0A%09Num             int32%0A%09Name            %5B32%5Dint8%0A%09Ver             uint32%0A%09X__rsvd         uint32%0A%09Un              %5B16%5Dbyte%0A%09X_sysctl_size   %5B8%5Dbyte%0A%09X_sysctl_func   %5B8%5Dbyte%0A%09X_sysctl_parent %5B8%5Dbyte%0A%09X_sysctl_desc   %5B8%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 319d3845ab2b28583968fb53a5bda304cda5e31113b1965ac12dbc64e046483f vendor/golang.org/x/sys/unix/ztypes_openbsd_386.go
+ f a4dc6a2da243de99035589895eefab777f1d45d8a6db6ccbd29d7b3bd60bfab9 vendor/golang.org/x/sys/unix/ztypes_openbsd_386.go
dmppatch 7
@@ -154,6590 +154,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Aconst (%0A%09S_IFMT   = 0xf000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Atype Stat_t struct %7B%0A%09Mode           uint32%0A%09Dev            int32%0A%09Ino            uint64%0A%09Nlink          uint32%0A%09Uid            uint32%0A%09Gid            uint32%0A%09Rdev           int32%0A%09Atim           Timespec%0A%09Mtim           Timespec%0A%09Ctim           Timespec%0A%09Size           int64%0A%09Blocks         int64%0A%09Blksize        uint32%0A%09Flags          uint32%0A%09Gen            uint32%0A%09X__st_birthtim Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09F_flags       uint32%0A%09F_bsize       uint32%0A%09F_iosize      uint32%0A%09F_blocks      uint64%0A%09F_bfree       uint64%0A%09F_bavail      int64%0A%09F_files       uint64%0A%09F_ffree       uint64%0A%09F_favail      int64%0A%09F_syncwrites  uint64%0A%09F_syncreads   uint64%0A%09F_asyncwrites uint64%0A%09F_asyncreads  uint64%0A%09F_fsid        Fsid%0A%09F_namemax     uint32%0A%09F_owner       uint32%0A%09F_ctime       uint64%0A%09F_fstypename  %5B16%5Dint8%0A%09F_mntonname   %5B90%5Dint8%0A%09F_mntfromname %5B90%5Dint8%0A%09F_mntfromspec %5B90%5Dint8%0A%09Pad_cgo_0     %5B2%5Dbyte%0A%09Mount_info    %5B160%5Dbyte%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno       uint64%0A%09Off          int64%0A%09Reclen       uint16%0A%09Type         uint8%0A%09Namlen       uint8%0A%09X__d_padding %5B4%5Duint8%0A%09Name         %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B24%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x20%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0xec%0A%09SizeofIfData           = 0xd4%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x1a%0A%09SizeofRtMsghdr         = 0x60%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Xflags  int32%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type         uint8%0A%09Addrlen      uint8%0A%09Hdrlen       uint8%0A%09Link_state   uint8%0A%09Mtu          uint32%0A%09Metric       uint32%0A%09Pad          uint32%0A%09Baudrate     uint64%0A%09Ipackets     uint64%0A%09Ierrors      uint64%0A%09Opackets     uint64%0A%09Oerrors      uint64%0A%09Collisions   uint64%0A%09Ibytes       uint64%0A%09Obytes       uint64%0A%09Imcasts      uint64%0A%09Omcasts      uint64%0A%09Iqdrops      uint64%0A%09Noproto      uint64%0A%09Capabilities uint32%0A%09Lastchange   Timeval%0A%09Mclpool      %5B7%5DMclpool%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Metric  int32%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09What    uint16%0A%09Name    %5B16%5Dint8%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Hdrlen   uint16%0A%09Index    uint16%0A%09Tableid  uint16%0A%09Priority uint8%0A%09Mpls     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Fmask    int32%0A%09Pid      int32%0A%09Seq      int32%0A%09Errno    int32%0A%09Inits    uint32%0A%09Rmx      RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Pksent   uint64%0A%09Expire   int64%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Refcnt   uint32%0A%09Hopcount uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pad      uint32%0A%7D%0A%0Atype Mclpool struct %7B%0A%09Grown int32%0A%09Alive uint16%0A%09Hwm   uint16%0A%09Cwm   uint16%0A%09Lwm   uint16%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  uint32%0A%09Usec uint32%0A%7D%0A%0A
 type
@@ -284,547 +284,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x2%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 4668073f6a6cfb3627899e54837e95a4f5b5c1cd9c6524ab311d42a8a66f3fb3 vendor/golang.org/x/sys/unix/ztypes_openbsd_amd64.go
+ f 51e881e76d79af5c54b1f9eb54fa8d410fb1977c6e3effa59f15350482a006ab vendor/golang.org/x/sys/unix/ztypes_openbsd_amd64.go
dmppatch 7
@@ -156,6749 +156,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Aconst (%0A%09S_IFMT   = 0xf000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Atype Stat_t struct %7B%0A%09Mode           uint32%0A%09Dev            int32%0A%09Ino            uint64%0A%09Nlink          uint32%0A%09Uid            uint32%0A%09Gid            uint32%0A%09Rdev           int32%0A%09Atim           Timespec%0A%09Mtim           Timespec%0A%09Ctim           Timespec%0A%09Size           int64%0A%09Blocks         int64%0A%09Blksize        uint32%0A%09Flags          uint32%0A%09Gen            uint32%0A%09Pad_cgo_0      %5B4%5Dbyte%0A%09X__st_birthtim Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09F_flags       uint32%0A%09F_bsize       uint32%0A%09F_iosize      uint32%0A%09Pad_cgo_0     %5B4%5Dbyte%0A%09F_blocks      uint64%0A%09F_bfree       uint64%0A%09F_bavail      int64%0A%09F_files       uint64%0A%09F_ffree       uint64%0A%09F_favail      int64%0A%09F_syncwrites  uint64%0A%09F_syncreads   uint64%0A%09F_asyncwrites uint64%0A%09F_asyncreads  uint64%0A%09F_fsid        Fsid%0A%09F_namemax     uint32%0A%09F_owner       uint32%0A%09F_ctime       uint64%0A%09F_fstypename  %5B16%5Dint8%0A%09F_mntonname   %5B90%5Dint8%0A%09F_mntfromname %5B90%5Dint8%0A%09F_mntfromspec %5B90%5Dint8%0A%09Pad_cgo_1     %5B2%5Dbyte%0A%09Mount_info    %5B160%5Dbyte%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno       uint64%0A%09Off          int64%0A%09Reclen       uint16%0A%09Type         uint8%0A%09Namlen       uint8%0A%09X__d_padding %5B4%5Duint8%0A%09Name         %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B24%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Pad_cgo_0  %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Pad_cgo_1  %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x20%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0xf8%0A%09SizeofIfData           = 0xe0%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x1a%0A%09SizeofRtMsghdr         = 0x60%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Xflags  int32%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type         uint8%0A%09Addrlen      uint8%0A%09Hdrlen       uint8%0A%09Link_state   uint8%0A%09Mtu          uint32%0A%09Metric       uint32%0A%09Pad          uint32%0A%09Baudrate     uint64%0A%09Ipackets     uint64%0A%09Ierrors      uint64%0A%09Opackets     uint64%0A%09Oerrors      uint64%0A%09Collisions   uint64%0A%09Ibytes       uint64%0A%09Obytes       uint64%0A%09Imcasts      uint64%0A%09Omcasts      uint64%0A%09Iqdrops      uint64%0A%09Noproto      uint64%0A%09Capabilities uint32%0A%09Pad_cgo_0    %5B4%5Dbyte%0A%09Lastchange   Timeval%0A%09Mclpool      %5B7%5DMclpool%0A%09Pad_cgo_1    %5B4%5Dbyte%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Metric  int32%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09What    uint16%0A%09Name    %5B16%5Dint8%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Hdrlen   uint16%0A%09Index    uint16%0A%09Tableid  uint16%0A%09Priority uint8%0A%09Mpls     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Fmask    int32%0A%09Pid      int32%0A%09Seq      int32%0A%09Errno    int32%0A%09Inits    uint32%0A%09Rmx      RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Pksent   uint64%0A%09Expire   int64%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Refcnt   uint32%0A%09Hopcount uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pad      uint32%0A%7D%0A%0Atype Mclpool struct %7B%0A%09Grown int32%0A%09Alive uint16%0A%09Hwm   uint16%0A%09Cwm   uint16%0A%09Lwm   uint16%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len       uint32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Insns     *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  uint32%0A%09Usec uint32%0A%7D%0A%0A
 type
@@ -286,547 +286,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x2%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 168fef6d7755f564727019dea52d1f70532221f03b18b1a201a72c06b76fafcb vendor/golang.org/x/sys/unix/ztypes_openbsd_arm.go
+ f ffcfa5c5255a61ffefb0df2aeb13410fcd58250d4edbe7b387a5e0fe173efc26 vendor/golang.org/x/sys/unix/ztypes_openbsd_arm.go
dmppatch 7
@@ -154,6499 +154,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Aconst (%0A%09S_IFMT   = 0xf000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Atype Stat_t struct %7B%0A%09Mode           uint32%0A%09Dev            int32%0A%09Ino            uint64%0A%09Nlink          uint32%0A%09Uid            uint32%0A%09Gid            uint32%0A%09Rdev           int32%0A%09Atim           Timespec%0A%09Mtim           Timespec%0A%09Ctim           Timespec%0A%09Size           int64%0A%09Blocks         int64%0A%09Blksize        int32%0A%09Flags          uint32%0A%09Gen            uint32%0A%09X__st_birthtim Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09F_flags       uint32%0A%09F_bsize       uint32%0A%09F_iosize      uint32%0A%09F_blocks      uint64%0A%09F_bfree       uint64%0A%09F_bavail      int64%0A%09F_files       uint64%0A%09F_ffree       uint64%0A%09F_favail      int64%0A%09F_syncwrites  uint64%0A%09F_syncreads   uint64%0A%09F_asyncwrites uint64%0A%09F_asyncreads  uint64%0A%09F_fsid        Fsid%0A%09F_namemax     uint32%0A%09F_owner       uint32%0A%09F_ctime       uint64%0A%09F_fstypename  %5B16%5Duint8%0A%09F_mntonname   %5B90%5Duint8%0A%09F_mntfromname %5B90%5Duint8%0A%09F_mntfromspec %5B90%5Duint8%0A%09Pad_cgo_0     %5B2%5Dbyte%0A%09Mount_info    %5B160%5Dbyte%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno       uint64%0A%09Off          int64%0A%09Reclen       uint16%0A%09Type         uint8%0A%09Namlen       uint8%0A%09X__d_padding %5B4%5Duint8%0A%09Name         %5B256%5Duint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B24%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x20%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0x98%0A%09SizeofIfData           = 0x80%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x1a%0A%09SizeofRtMsghdr         = 0x60%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Xflags  int32%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type         uint8%0A%09Addrlen      uint8%0A%09Hdrlen       uint8%0A%09Link_state   uint8%0A%09Mtu          uint32%0A%09Metric       uint32%0A%09Pad          uint32%0A%09Baudrate     uint64%0A%09Ipackets     uint64%0A%09Ierrors      uint64%0A%09Opackets     uint64%0A%09Oerrors      uint64%0A%09Collisions   uint64%0A%09Ibytes       uint64%0A%09Obytes       uint64%0A%09Imcasts      uint64%0A%09Omcasts      uint64%0A%09Iqdrops      uint64%0A%09Noproto      uint64%0A%09Capabilities uint32%0A%09Lastchange   Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Metric  int32%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09What    uint16%0A%09Name    %5B16%5Duint8%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Hdrlen   uint16%0A%09Index    uint16%0A%09Tableid  uint16%0A%09Priority uint8%0A%09Mpls     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Fmask    int32%0A%09Pid      int32%0A%09Seq      int32%0A%09Errno    int32%0A%09Inits    uint32%0A%09Rmx      RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Pksent   uint64%0A%09Expire   int64%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Refcnt   uint32%0A%09Hopcount uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pad      uint32%0A%7D%0A%0Atype Mclpool struct%7B%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  uint32%0A%09Usec uint32%0A%7D%0A%0A
 type
@@ -284,547 +284,4 @@
 2%0A%7D%0A
-%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x2%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 4d15a0b17dc159cccac9b74715a992278e668e86f26530502e5942cbd5fc35d3 vendor/golang.org/x/sys/unix/ztypes_solaris_amd64.go
+ f ce8dff2a4e9c66fbbb976dca61961ea17285777cbffe971bb937034a59b58f70 vendor/golang.org/x/sys/unix/ztypes_solaris_amd64.go
dmppatch 7
@@ -156,6035 +156,8 @@
 ix%0A%0A
-const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x400%0A%09MaxHostNameLen = 0x100%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timeval32 struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Aconst (%0A%09S_IFMT   = 0xf000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize int32%0A%09_       %5B4%5Dbyte%0A%09Blocks  int64%0A%09Fstype  %5B16%5Dint8%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Sysid  int32%0A%09Pid    int32%0A%09Pad    %5B4%5Dint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Name   %5B1%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype _Fsblkcnt_t uint64%0A%0Atype Statvfs_t struct %7B%0A%09Bsize    uint64%0A%09Frsize   uint64%0A%09Blocks   uint64%0A%09Bfree    uint64%0A%09Bavail   uint64%0A%09Files    uint64%0A%09Ffree    uint64%0A%09Favail   uint64%0A%09Fsid     uint64%0A%09Basetype %5B16%5Dint8%0A%09Flag     uint64%0A%09Namemax  uint64%0A%09Fstr     %5B32%5Dint8%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family         uint16%0A%09Port           uint16%0A%09Flowinfo       uint32%0A%09Addr           %5B16%5Dbyte /* in6_addr */%0A%09Scope_id       uint32%0A%09X__sin6_src_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Family uint16%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B244%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B236%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *int8%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name         *byte%0A%09Namelen      uint32%0A%09_            %5B4%5Dbyte%0A%09Iov          *Iovec%0A%09Iovlen       int32%0A%09_            %5B4%5Dbyte%0A%09Accrights    *int8%0A%09Accrightslen int32%0A%09_            %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09X__icmp6_filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x20%0A%09SizeofSockaddrAny      = 0xfc%0A%09SizeofSockaddrUnix     = 0x6e%0A%09SizeofSockaddrDatalink = 0xfc%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x24%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Atype FdSet struct %7B%0A%09Bits %5B1024%5Dint64%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B257%5Dbyte%0A%09Nodename %5B257%5Dbyte%0A%09Release  %5B257%5Dbyte%0A%09Version  %5B257%5Dbyte%0A%09Machine  %5B257%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int64%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = 0xffd19553%0A%09AT_SYMLINK_NOFOLLOW = 0x1000%0A%09AT_SYMLINK_FOLLOW   = 0x2000%0A%09AT_REMOVEDIR        = 0x1%0A%09AT_EACCESS          = 0x4%0A)%0A%0Aconst (%0A%09SizeofIfMsghdr  = 0x54%0A%09SizeofIfData    = 0x44%0A%09SizeofIfaMsghdr = 0x14%0A%09SizeofRtMsghdr  = 0x4c%0A%09SizeofRtMetrics = 0x28%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09_          %5B1%5Dbyte%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Lastchange Timeval32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x80%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv    uint64%0A%09Drop    uint64%0A%09Capt    uint64%0A%09Padding %5B13%5Duint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09_     %5B4%5Dbyte%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  BpfTimeval%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type
@@ -268,478 +268,4 @@
 e%0A%7D%0A
-%0Atype Termio struct %7B%0A%09Iflag uint16%0A%09Oflag uint16%0A%09Cflag uint16%0A%09Lflag uint16%0A%09Line  int8%0A%09Cc    %5B8%5Duint8%0A%09_     %5B1%5Dbyte%0A%7D%0A%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A
+ f 1386d2e2eb8ec0a480b544ff0a967fcdd4abcfe1bd1f142f25b09c634d228cb9 vendor/golang.org/x/sys/windows/aliases.go
dmppatch 2
@@ -0,0 +1,211 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build windows%0A// +build go1.9%0A%0Apackage windows%0A
- f 91f9376d698dc9dce3e24f251266513b317e649f473bb41f4b86e235772c01dd vendor/golang.org/x/sys/windows/asm_windows_amd64.s
+ f 7c273bb9ccce074f7fdae1580fabbebc7b59c4fe2d8a3ccb7182bb295e4d8675 vendor/golang.org/x/sys/windows/asm_windows_amd64.s
dmppatch 5
@@ -316,40 +316,41 @@
 B)%0A%0A
-TEXT %C2%B7loadlibrary(SB), 7, $0-8%0A
+TEXT %C2%B7loadlibrary(SB), 7, $0-24%0A
 %09JMP
- f 95d1bd87578406553f1509462dc37a277e5c6a1605ae91a9c6f42ea586c7b719 vendor/golang.org/x/sys/windows/dll_windows.go
+ f 35bfa1de8a87825e0db0adc8aa48b116be18d66a03bcc033445c8b2ed164ddaf vendor/golang.org/x/sys/windows/dll_windows.go
dmppatch 3
@@ -173,11059 +173,4 @@
 ows%0A
-%0Aimport (%0A%09%22sync%22%0A%09%22sync/atomic%22%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0A// DLLError describes reasons for DLL load failures.%0Atype DLLError struct %7B%0A%09Err     error%0A%09ObjName string%0A%09Msg     string%0A%7D%0A%0Afunc (e *DLLError) Error() string %7B return e.Msg %7D%0A%0A// Implemented in runtime/syscall_windows.goc; we provide jumps to them in our assembly file.%0Afunc loadlibrary(filename *uint16) (handle uintptr, err syscall.Errno)%0Afunc getprocaddress(handle uintptr, procname *uint8) (proc uintptr, err syscall.Errno)%0A%0A// A DLL implements access to a single DLL.%0Atype DLL struct %7B%0A%09Name   string%0A%09Handle Handle%0A%7D%0A%0A// LoadDLL loads DLL file into memory.%0A//%0A// Warning: using LoadDLL without an absolute path name is subject to%0A// DLL preloading attacks. To safely load a system DLL, use LazyDLL%0A// with System set to true, or use LoadLibraryEx directly.%0Afunc LoadDLL(name string) (dll *DLL, err error) %7B%0A%09namep, err := UTF16PtrFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09h, e := loadlibrary(namep)%0A%09if e != 0 %7B%0A%09%09return nil, &DLLError%7B%0A%09%09%09Err:     e,%0A%09%09%09ObjName: name,%0A%09%09%09Msg:     %22Failed to load %22 + name + %22: %22 + e.Error(),%0A%09%09%7D%0A%09%7D%0A%09d := &DLL%7B%0A%09%09Name:   name,%0A%09%09Handle: Handle(h),%0A%09%7D%0A%09return d, nil%0A%7D%0A%0A// MustLoadDLL is like LoadDLL but panics if load operation failes.%0Afunc MustLoadDLL(name string) *DLL %7B%0A%09d, e := LoadDLL(name)%0A%09if e != nil %7B%0A%09%09panic(e)%0A%09%7D%0A%09return d%0A%7D%0A%0A// FindProc searches DLL d for procedure named name and returns *Proc%0A// if found. It returns an error if search fails.%0Afunc (d *DLL) FindProc(name string) (proc *Proc, err error) %7B%0A%09namep, err := BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09a, e := getprocaddress(uintptr(d.Handle), namep)%0A%09if e != 0 %7B%0A%09%09return nil, &DLLError%7B%0A%09%09%09Err:     e,%0A%09%09%09ObjName: name,%0A%09%09%09Msg:     %22Failed to find %22 + name + %22 procedure in %22 + d.Name + %22: %22 + e.Error(),%0A%09%09%7D%0A%09%7D%0A%09p := &Proc%7B%0A%09%09Dll:  d,%0A%09%09Name: name,%0A%09%09addr: a,%0A%09%7D%0A%09return p, nil%0A%7D%0A%0A// MustFindProc is like FindProc but panics if search fails.%0Afunc (d *DLL) MustFindProc(name string) *Proc %7B%0A%09p, e := d.FindProc(name)%0A%09if e != nil %7B%0A%09%09panic(e)%0A%09%7D%0A%09return p%0A%7D%0A%0A// Release unloads DLL d from memory.%0Afunc (d *DLL) Release() (err error) %7B%0A%09return FreeLibrary(d.Handle)%0A%7D%0A%0A// A Proc implements access to a procedure inside a DLL.%0Atype Proc struct %7B%0A%09Dll  *DLL%0A%09Name string%0A%09addr uintptr%0A%7D%0A%0A// Addr returns the address of the procedure represented by p.%0A// The return value can be passed to Syscall to run the procedure.%0Afunc (p *Proc) Addr() uintptr %7B%0A%09return p.addr%0A%7D%0A%0A//go:uintptrescapes%0A%0A// Call executes procedure p with arguments a. It will panic, if more than 15 arguments%0A// are supplied.%0A//%0A// The returned error is always non-nil, constructed from the result of GetLastError.%0A// Callers must inspect the primary return value to decide whether an error occurred%0A// (according to the semantics of the specific function being called) before consulting%0A// the error. The error will be guaranteed to contain windows.Errno.%0Afunc (p *Proc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) %7B%0A%09switch len(a) %7B%0A%09case 0:%0A%09%09return syscall.Syscall(p.Addr(), uintptr(len(a)), 0, 0, 0)%0A%09case 1:%0A%09%09return syscall.Syscall(p.Addr(), uintptr(len(a)), a%5B0%5D, 0, 0)%0A%09case 2:%0A%09%09return syscall.Syscall(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, 0)%0A%09case 3:%0A%09%09return syscall.Syscall(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D)%0A%09case 4:%0A%09%09return syscall.Syscall6(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, 0, 0)%0A%09case 5:%0A%09%09return syscall.Syscall6(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, 0)%0A%09case 6:%0A%09%09return syscall.Syscall6(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D)%0A%09case 7:%0A%09%09return syscall.Syscall9(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, 0, 0)%0A%09case 8:%0A%09%09return syscall.Syscall9(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, 0)%0A%09case 9:%0A%09%09return syscall.Syscall9(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D)%0A%09case 10:%0A%09%09return syscall.Syscall12(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, 0, 0)%0A%09case 11:%0A%09%09return syscall.Syscall12(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, 0)%0A%09case 12:%0A%09%09return syscall.Syscall12(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, a%5B11%5D)%0A%09case 13:%0A%09%09return syscall.Syscall15(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, a%5B11%5D, a%5B12%5D, 0, 0)%0A%09case 14:%0A%09%09return syscall.Syscall15(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, a%5B11%5D, a%5B12%5D, a%5B13%5D, 0)%0A%09case 15:%0A%09%09return syscall.Syscall15(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, a%5B11%5D, a%5B12%5D, a%5B13%5D, a%5B14%5D)%0A%09default:%0A%09%09panic(%22Call %22 + p.Name + %22 with too many arguments %22 + itoa(len(a)) + %22.%22)%0A%09%7D%0A%7D%0A%0A// A LazyDLL implements access to a single DLL.%0A// It will delay the load of the DLL until the first%0A// call to its Handle method or to one of its%0A// LazyProc's Addr method.%0Atype LazyDLL struct %7B%0A%09Name string%0A%0A%09// System determines whether the DLL must be loaded from the%0A%09// Windows System directory, bypassing the normal DLL search%0A%09// path.%0A%09System bool%0A%0A%09mu  sync.Mutex%0A%09dll *DLL // non nil once DLL is loaded%0A%7D%0A%0A// Load loads DLL file d.Name into memory. It returns an error if fails.%0A// Load will not try to load DLL, if it is already loaded into memory.%0Afunc (d *LazyDLL) Load() error %7B%0A%09// Non-racy version of:%0A%09// if d.dll != nil %7B%0A%09if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll))) != nil %7B%0A%09%09return nil%0A%09%7D%0A%09d.mu.Lock()%0A%09defer d.mu.Unlock()%0A%09if d.dll != nil %7B%0A%09%09return nil%0A%09%7D%0A%0A%09// kernel32.dll is special, since it's where LoadLibraryEx comes from.%0A%09// The kernel already special-cases its name, so it's always%0A%09// loaded from system32.%0A%09var dll *DLL%0A%09var err error%0A%09if d.Name == %22kernel32.dll%22 %7B%0A%09%09dll, err = LoadDLL(d.Name)%0A%09%7D else %7B%0A%09%09dll, err = loadLibraryEx(d.Name, d.System)%0A%09%7D%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// Non-racy version of:%0A%09// d.dll = dll%0A%09atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll)), unsafe.Pointer(dll))%0A%09return nil%0A%7D%0A%0A// mustLoad is like Load but panics if search fails.%0Afunc (d *LazyDLL) mustLoad() %7B%0A%09e := d.Load()%0A%09if e != nil %7B%0A%09%09panic(e)%0A%09%7D%0A%7D%0A%0A// Handle returns d's module handle.%0Afunc (d *LazyDLL) Handle() uintptr %7B%0A%09d.mustLoad()%0A%09return uintptr(d.dll.Handle)%0A%7D%0A%0A// NewProc returns a LazyProc for accessing the named procedure in the DLL d.%0Afunc (d *LazyDLL) NewProc(name string) *LazyProc %7B%0A%09return &LazyProc%7Bl: d, Name: name%7D%0A%7D%0A%0A// NewLazyDLL creates new LazyDLL associated with DLL file.%0Afunc NewLazyDLL(name string) *LazyDLL %7B%0A%09return &LazyDLL%7BName: name%7D%0A%7D%0A%0A// NewLazySystemDLL is like NewLazyDLL, but will only%0A// search Windows System directory for the DLL if name is%0A// a base name (like %22advapi32.dll%22).%0Afunc NewLazySystemDLL(name string) *LazyDLL %7B%0A%09return &LazyDLL%7BName: name, System: true%7D%0A%7D%0A%0A// A LazyProc implements access to a procedure inside a LazyDLL.%0A// It delays the lookup until the Addr method is called.%0Atype LazyProc struct %7B%0A%09Name string%0A%0A%09mu   sync.Mutex%0A%09l    *LazyDLL%0A%09proc *Proc%0A%7D%0A%0A// Find searches DLL for procedure named p.Name. It returns%0A// an error if search fails. Find will not search procedure,%0A// if it is already found and loaded into memory.%0Afunc (p *LazyProc) Find() error %7B%0A%09// Non-racy version of:%0A%09// if p.proc == nil %7B%0A%09if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc))) == nil %7B%0A%09%09p.mu.Lock()%0A%09%09defer p.mu.Unlock()%0A%09%09if p.proc == nil %7B%0A%09%09%09e := p.l.Load()%0A%09%09%09if e != nil %7B%0A%09%09%09%09return e%0A%09%09%09%7D%0A%09%09%09proc, e := p.l.dll.FindProc(p.Name)%0A%09%09%09if e != nil %7B%0A%09%09%09%09return e%0A%09%09%09%7D%0A%09%09%09// Non-racy version of:%0A%09%09%09// p.proc = proc%0A%09%09%09atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc)), unsafe.Pointer(proc))%0A%09%09%7D%0A%09%7D%0A%09return nil%0A%7D%0A%0A// mustFind is like Find but panics if search fails.%0Afunc (p *LazyProc) mustFind() %7B%0A%09e := p.Find()%0A%09if e != nil %7B%0A%09%09panic(e)%0A%09%7D%0A%7D%0A%0A// Addr returns the address of the procedure represented by p.%0A// The return value can be passed to Syscall to run the procedure.%0A// It will panic if the procedure cannot be found.%0Afunc (p *LazyProc) Addr() uintptr %7B%0A%09p.mustFind()%0A%09return p.proc.Addr()%0A%7D%0A%0A//go:uintptrescapes%0A%0A// Call executes procedure p with arguments a. It will panic, if more than 15 arguments%0A// are supplied. It will also panic if the procedure cannot be found.%0A//%0A// The returned error is always non-nil, constructed from the result of GetLastError.%0A// Callers must inspect the primary return value to decide whether an error occurred%0A// (according to the semantics of the specific function being called) before consulting%0A// the error. The error will be guaranteed to contain windows.Errno.%0Afunc (p *LazyProc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) %7B%0A%09p.mustFind()%0A%09return p.proc.Call(a...)%0A%7D%0A%0Avar canDoSearchSystem32Once struct %7B%0A%09sync.Once%0A%09v bool%0A%7D%0A%0Afunc initCanDoSearchSystem32() %7B%0A%09// https://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx says:%0A%09// %22Windows 7, Windows Server 2008 R2, Windows Vista, and Windows%0A%09// Server 2008: The LOAD_LIBRARY_SEARCH_* flags are available on%0A%09// systems that have KB2533623 installed. To determine whether the%0A%09// flags are available, use GetProcAddress to get the address of the%0A%09// AddDllDirectory, RemoveDllDirectory, or SetDefaultDllDirectories%0A%09// function. If GetProcAddress succeeds, the LOAD_LIBRARY_SEARCH_*%0A%09// flags can be used with LoadLibraryEx.%22%0A%09canDoSearchSystem32Once.v = (modkernel32.NewProc(%22AddDllDirectory%22).Find() == nil)%0A%7D%0A%0Afunc canDoSearchSystem32() bool %7B%0A%09canDoSearchSystem32Once.Do(initCanDoSearchSystem32)%0A%09return canDoSearchSystem32Once.v%0A%7D%0A%0Afunc isBaseName(name string) bool %7B%0A%09for _, c := range name %7B%0A%09%09if c == ':' %7C%7C c == '/' %7C%7C c == '%5C%5C' %7B%0A%09%09%09return false%0A%09%09%7D%0A%09%7D%0A%09return true%0A%7D%0A%0A// loadLibraryEx wraps the Windows LoadLibraryEx function.%0A//%0A// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx%0A//%0A// If name is not an absolute path, LoadLibraryEx searches for the DLL%0A// in a variety of automatic locations unless constrained by flags.%0A// See: https://msdn.microsoft.com/en-us/library/ff919712%2528VS.85%2529.aspx%0Afunc loadLibraryEx(name string, system bool) (*DLL, error) %7B%0A%09loadDLL := name%0A%09var flags uintptr%0A%09if system %7B%0A%09%09if canDoSearchSystem32() %7B%0A%09%09%09const LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800%0A%09%09%09flags = LOAD_LIBRARY_SEARCH_SYSTEM32%0A%09%09%7D else if isBaseName(name) %7B%0A%09%09%09// WindowsXP or unpatched Windows machine%0A%09%09%09// trying to load %22foo.dll%22 out of the system%0A%09%09%09// folder, but LoadLibraryEx doesn't support%0A%09%09%09// that yet on their system, so emulate it.%0A%09%09%09windir, _ := Getenv(%22WINDIR%22) // old var; apparently works on XP%0A%09%09%09if windir == %22%22 %7B%0A%09%09%09%09return nil, errString(%22%25WINDIR%25 not defined%22)%0A%09%09%09%7D%0A%09%09%09loadDLL = windir + %22%5C%5CSystem32%5C%5C%22 + name%0A%09%09%7D%0A%09%7D%0A%09h, err := LoadLibraryEx(loadDLL, 0, flags)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &DLL%7BName: name, Handle: h%7D, nil%0A%7D%0A%0Atype errString string%0A%0Afunc (s errString) Error() string %7B return string(s) %7D%0A
- f 318984a14c6d62c099cfe607e66f3e23511da19ed2280d1267edc5ff9b62fe86 vendor/golang.org/x/sys/windows/env_windows.go
+ f 1d9756e565cea8b2df0cb16c1e403b252d3dda357577d5d1703bd6d15f3c34dd vendor/golang.org/x/sys/windows/env_windows.go
dmppatch 3
@@ -208,346 +208,4 @@
 ows%0A
-%0Aimport %22syscall%22%0A%0Afunc Getenv(key string) (value string, found bool) %7B%0A%09return syscall.Getenv(key)%0A%7D%0A%0Afunc Setenv(key, value string) error %7B%0A%09return syscall.Setenv(key, value)%0A%7D%0A%0Afunc Clearenv() %7B%0A%09syscall.Clearenv()%0A%7D%0A%0Afunc Environ() %5B%5Dstring %7B%0A%09return syscall.Environ()%0A%7D%0A%0Afunc Unsetenv(key string) error %7B%0A%09return syscall.Unsetenv(key)%0A%7D%0A
- f 36e6102d274d20dbb5f740376453bb6ab13e02c86e2be706857a07a236b5682e vendor/golang.org/x/sys/windows/eventlog.go
+ f d08387e435d6d1d0fa654ded83d7c886b5760498375549f7c6fbbc63661bce5c vendor/golang.org/x/sys/windows/eventlog.go
dmppatch 3
@@ -192,633 +192,4 @@
 ows%0A
-%0Aconst (%0A%09EVENTLOG_SUCCESS          = 0%0A%09EVENTLOG_ERROR_TYPE       = 1%0A%09EVENTLOG_WARNING_TYPE     = 2%0A%09EVENTLOG_INFORMATION_TYPE = 4%0A%09EVENTLOG_AUDIT_SUCCESS    = 8%0A%09EVENTLOG_AUDIT_FAILURE    = 16%0A)%0A%0A//sys%09RegisterEventSource(uncServerName *uint16, sourceName *uint16) (handle Handle, err error) %5Bfailretval==0%5D = advapi32.RegisterEventSourceW%0A//sys%09DeregisterEventSource(handle Handle) (err error) = advapi32.DeregisterEventSource%0A//sys%09ReportEvent(log Handle, etype uint16, category uint16, eventId uint32, usrSId uintptr, numStrings uint16, dataSize uint32, strings **uint16, rawData *byte) (err error) = advapi32.ReportEventW%0A
- f fd58dc33d892badcfd5238722dbaa3b71b0d5e3ffa7a23b36015037530d56146 vendor/golang.org/x/sys/windows/exec_windows.go
+ f c87224258f6e207f33a4361113bf782d716c33c7e40623b41a6295c1cc6cc7cd vendor/golang.org/x/sys/windows/exec_windows.go
dmppatch 3
@@ -200,1750 +200,4 @@
 ows%0A
-%0A// EscapeArg rewrites command line argument s as prescribed%0A// in http://msdn.microsoft.com/en-us/library/ms880421.%0A// This function returns %22%22 (2 double quotes) if s is empty.%0A// Alternatively, these transformations are done:%0A// - every back slash (%5C) is doubled, but only if immediately%0A//   followed by double quote (%22);%0A// - every double quote (%22) is escaped by back slash (%5C);%0A// - finally, s is wrapped with double quotes (arg -%3E %22arg%22),%0A//   but only if there is space or tab inside s.%0Afunc EscapeArg(s string) string %7B%0A%09if len(s) == 0 %7B%0A%09%09return %22%5C%22%5C%22%22%0A%09%7D%0A%09n := len(s)%0A%09hasSpace := false%0A%09for i := 0; i %3C len(s); i++ %7B%0A%09%09switch s%5Bi%5D %7B%0A%09%09case '%22', '%5C%5C':%0A%09%09%09n++%0A%09%09case ' ', '%5Ct':%0A%09%09%09hasSpace = true%0A%09%09%7D%0A%09%7D%0A%09if hasSpace %7B%0A%09%09n += 2%0A%09%7D%0A%09if n == len(s) %7B%0A%09%09return s%0A%09%7D%0A%0A%09qs := make(%5B%5Dbyte, n)%0A%09j := 0%0A%09if hasSpace %7B%0A%09%09qs%5Bj%5D = '%22'%0A%09%09j++%0A%09%7D%0A%09slashes := 0%0A%09for i := 0; i %3C len(s); i++ %7B%0A%09%09switch s%5Bi%5D %7B%0A%09%09default:%0A%09%09%09slashes = 0%0A%09%09%09qs%5Bj%5D = s%5Bi%5D%0A%09%09case '%5C%5C':%0A%09%09%09slashes++%0A%09%09%09qs%5Bj%5D = s%5Bi%5D%0A%09%09case '%22':%0A%09%09%09for ; slashes %3E 0; slashes-- %7B%0A%09%09%09%09qs%5Bj%5D = '%5C%5C'%0A%09%09%09%09j++%0A%09%09%09%7D%0A%09%09%09qs%5Bj%5D = '%5C%5C'%0A%09%09%09j++%0A%09%09%09qs%5Bj%5D = s%5Bi%5D%0A%09%09%7D%0A%09%09j++%0A%09%7D%0A%09if hasSpace %7B%0A%09%09for ; slashes %3E 0; slashes-- %7B%0A%09%09%09qs%5Bj%5D = '%5C%5C'%0A%09%09%09j++%0A%09%09%7D%0A%09%09qs%5Bj%5D = '%22'%0A%09%09j++%0A%09%7D%0A%09return string(qs%5B:j%5D)%0A%7D%0A%0Afunc CloseOnExec(fd Handle) %7B%0A%09SetHandleInformation(Handle(fd), HANDLE_FLAG_INHERIT, 0)%0A%7D%0A%0A// FullPath retrieves the full path of the specified file.%0Afunc FullPath(name string) (path string, err error) %7B%0A%09p, err := UTF16PtrFromString(name)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := uint32(100)%0A%09for %7B%0A%09%09buf := make(%5B%5Duint16, n)%0A%09%09n, err = GetFullPathName(p, uint32(len(buf)), &buf%5B0%5D, nil)%0A%09%09if err != nil %7B%0A%09%09%09return %22%22, err%0A%09%09%7D%0A%09%09if n %3C= uint32(len(buf)) %7B%0A%09%09%09return UTF16ToString(buf%5B:n%5D), nil%0A%09%09%7D%0A%09%7D%0A%7D%0A
- f 218c056f2c289808308ecd2d6e0afd987c1c001e0e75410a4ef23470459681d9 vendor/golang.org/x/sys/windows/memory_windows.go
+ f e8280d9af46bbc376706573648ec3571699cecffc71815af4c8217f343e4bafe vendor/golang.org/x/sys/windows/memory_windows.go
dmppatch 3
@@ -173,533 +173,4 @@
 ows%0A
-%0Aconst (%0A%09MEM_COMMIT      = 0x00001000%0A%09MEM_RESERVE     = 0x00002000%0A%09MEM_DECOMMIT    = 0x00004000%0A%09MEM_RELEASE     = 0x00008000%0A%09MEM_RESET       = 0x00080000%0A%09MEM_TOP_DOWN    = 0x00100000%0A%09MEM_WRITE_WATCH = 0x00200000%0A%09MEM_PHYSICAL    = 0x00400000%0A%09MEM_RESET_UNDO  = 0x01000000%0A%09MEM_LARGE_PAGES = 0x20000000%0A%0A%09PAGE_NOACCESS          = 0x01%0A%09PAGE_READONLY          = 0x02%0A%09PAGE_READWRITE         = 0x04%0A%09PAGE_WRITECOPY         = 0x08%0A%09PAGE_EXECUTE_READ      = 0x20%0A%09PAGE_EXECUTE_READWRITE = 0x40%0A%09PAGE_EXECUTE_WRITECOPY = 0x80%0A)%0A
- f 42c5afa9e5a630f46ed19d1f86ed902e0d6502413b42cf641d7ef703c0c2db6a vendor/golang.org/x/sys/windows/race.go
+ f be89dce4cc3f35642f6141232fe8bb83939153db40216509d170e9f8a75aca70 vendor/golang.org/x/sys/windows/race.go
dmppatch 3
@@ -197,391 +197,4 @@
 ows%0A
-%0Aimport (%0A%09%22runtime%22%0A%09%22unsafe%22%0A)%0A%0Aconst raceenabled = true%0A%0Afunc raceAcquire(addr unsafe.Pointer) %7B%0A%09runtime.RaceAcquire(addr)%0A%7D%0A%0Afunc raceReleaseMerge(addr unsafe.Pointer) %7B%0A%09runtime.RaceReleaseMerge(addr)%0A%7D%0A%0Afunc raceReadRange(addr unsafe.Pointer, len int) %7B%0A%09runtime.RaceReadRange(addr, len)%0A%7D%0A%0Afunc raceWriteRange(addr unsafe.Pointer, len int) %7B%0A%09runtime.RaceWriteRange(addr, len)%0A%7D%0A
- f f483ad20eef4aedcabc598060fa414eab96f19e3391d1d65d9aec420d64ffd9d vendor/golang.org/x/sys/windows/race0.go
+ f 4802bf82b35e668cd0ed529c94f920e0ec007e276e09c03a78cccda6e05f4699 vendor/golang.org/x/sys/windows/race0.go
dmppatch 3
@@ -198,253 +198,4 @@
 ows%0A
-%0Aimport (%0A%09%22unsafe%22%0A)%0A%0Aconst raceenabled = false%0A%0Afunc raceAcquire(addr unsafe.Pointer) %7B%0A%7D%0A%0Afunc raceReleaseMerge(addr unsafe.Pointer) %7B%0A%7D%0A%0Afunc raceReadRange(addr unsafe.Pointer, len int) %7B%0A%7D%0A%0Afunc raceWriteRange(addr unsafe.Pointer, len int) %7B%0A%7D%0A
- f 05dad8d324d5a54be693bdd24b57a0b1216441f5dd8f115151b60bfc8dc379f8 vendor/golang.org/x/sys/windows/security_windows.go
+ f c161eab0877a67b7f544e08ff45b14f92463cd103a81950a1b5371e59fd31111 vendor/golang.org/x/sys/windows/security_windows.go
dmppatch 3
@@ -173,14512 +173,4 @@
 ows%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Aconst (%0A%09STANDARD_RIGHTS_REQUIRED = 0xf0000%0A%09STANDARD_RIGHTS_READ     = 0x20000%0A%09STANDARD_RIGHTS_WRITE    = 0x20000%0A%09STANDARD_RIGHTS_EXECUTE  = 0x20000%0A%09STANDARD_RIGHTS_ALL      = 0x1F0000%0A)%0A%0Aconst (%0A%09NameUnknown          = 0%0A%09NameFullyQualifiedDN = 1%0A%09NameSamCompatible    = 2%0A%09NameDisplay          = 3%0A%09NameUniqueId         = 6%0A%09NameCanonical        = 7%0A%09NameUserPrincipal    = 8%0A%09NameCanonicalEx      = 9%0A%09NameServicePrincipal = 10%0A%09NameDnsDomain        = 12%0A)%0A%0A// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.%0A// http://blogs.msdn.com/b/drnick/archive/2007/12/19/windows-and-upn-format-credentials.aspx%0A//sys%09TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) %5Bfailretval&0xff==0%5D = secur32.TranslateNameW%0A//sys%09GetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) %5Bfailretval&0xff==0%5D = secur32.GetUserNameExW%0A%0A// TranslateAccountName converts a directory service%0A// object name from one format to another.%0Afunc TranslateAccountName(username string, from, to uint32, initSize int) (string, error) %7B%0A%09u, e := UTF16PtrFromString(username)%0A%09if e != nil %7B%0A%09%09return %22%22, e%0A%09%7D%0A%09n := uint32(50)%0A%09for %7B%0A%09%09b := make(%5B%5Duint16, n)%0A%09%09e = TranslateName(u, from, to, &b%5B0%5D, &n)%0A%09%09if e == nil %7B%0A%09%09%09return UTF16ToString(b%5B:n%5D), nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return %22%22, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return %22%22, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Aconst (%0A%09// do not reorder%0A%09NetSetupUnknownStatus = iota%0A%09NetSetupUnjoined%0A%09NetSetupWorkgroupName%0A%09NetSetupDomainName%0A)%0A%0Atype UserInfo10 struct %7B%0A%09Name       *uint16%0A%09Comment    *uint16%0A%09UsrComment *uint16%0A%09FullName   *uint16%0A%7D%0A%0A//sys%09NetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) = netapi32.NetUserGetInfo%0A//sys%09NetGetJoinInformation(server *uint16, name **uint16, bufType *uint32) (neterr error) = netapi32.NetGetJoinInformation%0A//sys%09NetApiBufferFree(buf *byte) (neterr error) = netapi32.NetApiBufferFree%0A%0Aconst (%0A%09// do not reorder%0A%09SidTypeUser = 1 + iota%0A%09SidTypeGroup%0A%09SidTypeDomain%0A%09SidTypeAlias%0A%09SidTypeWellKnownGroup%0A%09SidTypeDeletedAccount%0A%09SidTypeInvalid%0A%09SidTypeUnknown%0A%09SidTypeComputer%0A%09SidTypeLabel%0A)%0A%0Atype SidIdentifierAuthority struct %7B%0A%09Value %5B6%5Dbyte%0A%7D%0A%0Avar (%0A%09SECURITY_NULL_SID_AUTHORITY        = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 0%7D%7D%0A%09SECURITY_WORLD_SID_AUTHORITY       = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 1%7D%7D%0A%09SECURITY_LOCAL_SID_AUTHORITY       = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 2%7D%7D%0A%09SECURITY_CREATOR_SID_AUTHORITY     = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 3%7D%7D%0A%09SECURITY_NON_UNIQUE_AUTHORITY      = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 4%7D%7D%0A%09SECURITY_NT_AUTHORITY              = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 5%7D%7D%0A%09SECURITY_MANDATORY_LABEL_AUTHORITY = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 16%7D%7D%0A)%0A%0Aconst (%0A%09SECURITY_NULL_RID                   = 0%0A%09SECURITY_WORLD_RID                  = 0%0A%09SECURITY_LOCAL_RID                  = 0%0A%09SECURITY_CREATOR_OWNER_RID          = 0%0A%09SECURITY_CREATOR_GROUP_RID          = 1%0A%09SECURITY_DIALUP_RID                 = 1%0A%09SECURITY_NETWORK_RID                = 2%0A%09SECURITY_BATCH_RID                  = 3%0A%09SECURITY_INTERACTIVE_RID            = 4%0A%09SECURITY_LOGON_IDS_RID              = 5%0A%09SECURITY_SERVICE_RID                = 6%0A%09SECURITY_LOCAL_SYSTEM_RID           = 18%0A%09SECURITY_BUILTIN_DOMAIN_RID         = 32%0A%09SECURITY_PRINCIPAL_SELF_RID         = 10%0A%09SECURITY_CREATOR_OWNER_SERVER_RID   = 0x2%0A%09SECURITY_CREATOR_GROUP_SERVER_RID   = 0x3%0A%09SECURITY_LOGON_IDS_RID_COUNT        = 0x3%0A%09SECURITY_ANONYMOUS_LOGON_RID        = 0x7%0A%09SECURITY_PROXY_RID                  = 0x8%0A%09SECURITY_ENTERPRISE_CONTROLLERS_RID = 0x9%0A%09SECURITY_SERVER_LOGON_RID           = SECURITY_ENTERPRISE_CONTROLLERS_RID%0A%09SECURITY_AUTHENTICATED_USER_RID     = 0xb%0A%09SECURITY_RESTRICTED_CODE_RID        = 0xc%0A%09SECURITY_NT_NON_UNIQUE_RID          = 0x15%0A)%0A%0A// Predefined domain-relative RIDs for local groups.%0A// See https://msdn.microsoft.com/en-us/library/windows/desktop/aa379649(v=vs.85).aspx%0Aconst (%0A%09DOMAIN_ALIAS_RID_ADMINS                         = 0x220%0A%09DOMAIN_ALIAS_RID_USERS                          = 0x221%0A%09DOMAIN_ALIAS_RID_GUESTS                         = 0x222%0A%09DOMAIN_ALIAS_RID_POWER_USERS                    = 0x223%0A%09DOMAIN_ALIAS_RID_ACCOUNT_OPS                    = 0x224%0A%09DOMAIN_ALIAS_RID_SYSTEM_OPS                     = 0x225%0A%09DOMAIN_ALIAS_RID_PRINT_OPS                      = 0x226%0A%09DOMAIN_ALIAS_RID_BACKUP_OPS                     = 0x227%0A%09DOMAIN_ALIAS_RID_REPLICATOR                     = 0x228%0A%09DOMAIN_ALIAS_RID_RAS_SERVERS                    = 0x229%0A%09DOMAIN_ALIAS_RID_PREW2KCOMPACCESS               = 0x22a%0A%09DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS           = 0x22b%0A%09DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS      = 0x22c%0A%09DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS = 0x22d%0A%09DOMAIN_ALIAS_RID_MONITORING_USERS               = 0X22e%0A%09DOMAIN_ALIAS_RID_LOGGING_USERS                  = 0x22f%0A%09DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS            = 0x230%0A%09DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS             = 0x231%0A%09DOMAIN_ALIAS_RID_DCOM_USERS                     = 0x232%0A%09DOMAIN_ALIAS_RID_IUSERS                         = 0x238%0A%09DOMAIN_ALIAS_RID_CRYPTO_OPERATORS               = 0x239%0A%09DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP     = 0x23b%0A%09DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP = 0x23c%0A%09DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP        = 0x23d%0A%09DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP      = 0x23e%0A)%0A%0A//sys%09LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountSidW%0A//sys%09LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountNameW%0A//sys%09ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) = advapi32.ConvertSidToStringSidW%0A//sys%09ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) = advapi32.ConvertStringSidToSidW%0A//sys%09GetLengthSid(sid *SID) (len uint32) = advapi32.GetLengthSid%0A//sys%09CopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) = advapi32.CopySid%0A//sys%09AllocateAndInitializeSid(identAuth *SidIdentifierAuthority, subAuth byte, subAuth0 uint32, subAuth1 uint32, subAuth2 uint32, subAuth3 uint32, subAuth4 uint32, subAuth5 uint32, subAuth6 uint32, subAuth7 uint32, sid **SID) (err error) = advapi32.AllocateAndInitializeSid%0A//sys%09FreeSid(sid *SID) (err error) %5Bfailretval!=0%5D = advapi32.FreeSid%0A//sys%09EqualSid(sid1 *SID, sid2 *SID) (isEqual bool) = advapi32.EqualSid%0A%0A// The security identifier (SID) structure is a variable-length%0A// structure used to uniquely identify users or groups.%0Atype SID struct%7B%7D%0A%0A// StringToSid converts a string-format security identifier%0A// sid into a valid, functional sid.%0Afunc StringToSid(s string) (*SID, error) %7B%0A%09var sid *SID%0A%09p, e := UTF16PtrFromString(s)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09e = ConvertStringSidToSid(p, &sid)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09defer LocalFree((Handle)(unsafe.Pointer(sid)))%0A%09return sid.Copy()%0A%7D%0A%0A// LookupSID retrieves a security identifier sid for the account%0A// and the name of the domain on which the account was found.%0A// System specify target computer to search.%0Afunc LookupSID(system, account string) (sid *SID, domain string, accType uint32, err error) %7B%0A%09if len(account) == 0 %7B%0A%09%09return nil, %22%22, 0, syscall.EINVAL%0A%09%7D%0A%09acc, e := UTF16PtrFromString(account)%0A%09if e != nil %7B%0A%09%09return nil, %22%22, 0, e%0A%09%7D%0A%09var sys *uint16%0A%09if len(system) %3E 0 %7B%0A%09%09sys, e = UTF16PtrFromString(system)%0A%09%09if e != nil %7B%0A%09%09%09return nil, %22%22, 0, e%0A%09%09%7D%0A%09%7D%0A%09n := uint32(50)%0A%09dn := uint32(50)%0A%09for %7B%0A%09%09b := make(%5B%5Dbyte, n)%0A%09%09db := make(%5B%5Duint16, dn)%0A%09%09sid = (*SID)(unsafe.Pointer(&b%5B0%5D))%0A%09%09e = LookupAccountName(sys, acc, sid, &n, &db%5B0%5D, &dn, &accType)%0A%09%09if e == nil %7B%0A%09%09%09return sid, UTF16ToString(db), accType, nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return nil, %22%22, 0, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return nil, %22%22, 0, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0A// String converts sid to a string format%0A// suitable for display, storage, or transmission.%0Afunc (sid *SID) String() (string, error) %7B%0A%09var s *uint16%0A%09e := ConvertSidToStringSid(sid, &s)%0A%09if e != nil %7B%0A%09%09return %22%22, e%0A%09%7D%0A%09defer LocalFree((Handle)(unsafe.Pointer(s)))%0A%09return UTF16ToString((*%5B256%5Duint16)(unsafe.Pointer(s))%5B:%5D), nil%0A%7D%0A%0A// Len returns the length, in bytes, of a valid security identifier sid.%0Afunc (sid *SID) Len() int %7B%0A%09return int(GetLengthSid(sid))%0A%7D%0A%0A// Copy creates a duplicate of security identifier sid.%0Afunc (sid *SID) Copy() (*SID, error) %7B%0A%09b := make(%5B%5Dbyte, sid.Len())%0A%09sid2 := (*SID)(unsafe.Pointer(&b%5B0%5D))%0A%09e := CopySid(uint32(len(b)), sid2, sid)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09return sid2, nil%0A%7D%0A%0A// LookupAccount retrieves the name of the account for this sid%0A// and the name of the first domain on which this sid is found.%0A// System specify target computer to search for.%0Afunc (sid *SID) LookupAccount(system string) (account, domain string, accType uint32, err error) %7B%0A%09var sys *uint16%0A%09if len(system) %3E 0 %7B%0A%09%09sys, err = UTF16PtrFromString(system)%0A%09%09if err != nil %7B%0A%09%09%09return %22%22, %22%22, 0, err%0A%09%09%7D%0A%09%7D%0A%09n := uint32(50)%0A%09dn := uint32(50)%0A%09for %7B%0A%09%09b := make(%5B%5Duint16, n)%0A%09%09db := make(%5B%5Duint16, dn)%0A%09%09e := LookupAccountSid(sys, sid, &b%5B0%5D, &n, &db%5B0%5D, &dn, &accType)%0A%09%09if e == nil %7B%0A%09%09%09return UTF16ToString(b), UTF16ToString(db), accType, nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return %22%22, %22%22, 0, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return %22%22, %22%22, 0, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Aconst (%0A%09// do not reorder%0A%09TOKEN_ASSIGN_PRIMARY = 1 %3C%3C iota%0A%09TOKEN_DUPLICATE%0A%09TOKEN_IMPERSONATE%0A%09TOKEN_QUERY%0A%09TOKEN_QUERY_SOURCE%0A%09TOKEN_ADJUST_PRIVILEGES%0A%09TOKEN_ADJUST_GROUPS%0A%09TOKEN_ADJUST_DEFAULT%0A%0A%09TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED %7C%0A%09%09TOKEN_ASSIGN_PRIMARY %7C%0A%09%09TOKEN_DUPLICATE %7C%0A%09%09TOKEN_IMPERSONATE %7C%0A%09%09TOKEN_QUERY %7C%0A%09%09TOKEN_QUERY_SOURCE %7C%0A%09%09TOKEN_ADJUST_PRIVILEGES %7C%0A%09%09TOKEN_ADJUST_GROUPS %7C%0A%09%09TOKEN_ADJUST_DEFAULT%0A%09TOKEN_READ  = STANDARD_RIGHTS_READ %7C TOKEN_QUERY%0A%09TOKEN_WRITE = STANDARD_RIGHTS_WRITE %7C%0A%09%09TOKEN_ADJUST_PRIVILEGES %7C%0A%09%09TOKEN_ADJUST_GROUPS %7C%0A%09%09TOKEN_ADJUST_DEFAULT%0A%09TOKEN_EXECUTE = STANDARD_RIGHTS_EXECUTE%0A)%0A%0Aconst (%0A%09// do not reorder%0A%09TokenUser = 1 + iota%0A%09TokenGroups%0A%09TokenPrivileges%0A%09TokenOwner%0A%09TokenPrimaryGroup%0A%09TokenDefaultDacl%0A%09TokenSource%0A%09TokenType%0A%09TokenImpersonationLevel%0A%09TokenStatistics%0A%09TokenRestrictedSids%0A%09TokenSessionId%0A%09TokenGroupsAndPrivileges%0A%09TokenSessionReference%0A%09TokenSandBoxInert%0A%09TokenAuditPolicy%0A%09TokenOrigin%0A%09TokenElevationType%0A%09TokenLinkedToken%0A%09TokenElevation%0A%09TokenHasRestrictions%0A%09TokenAccessInformation%0A%09TokenVirtualizationAllowed%0A%09TokenVirtualizationEnabled%0A%09TokenIntegrityLevel%0A%09TokenUIAccess%0A%09TokenMandatoryPolicy%0A%09TokenLogonSid%0A%09MaxTokenInfoClass%0A)%0A%0Atype SIDAndAttributes struct %7B%0A%09Sid        *SID%0A%09Attributes uint32%0A%7D%0A%0Atype Tokenuser struct %7B%0A%09User SIDAndAttributes%0A%7D%0A%0Atype Tokenprimarygroup struct %7B%0A%09PrimaryGroup *SID%0A%7D%0A%0Atype Tokengroups struct %7B%0A%09GroupCount uint32%0A%09Groups     %5B1%5DSIDAndAttributes%0A%7D%0A%0A// Authorization Functions%0A//sys checkTokenMembership(tokenHandle Token, sidToCheck *SID, isMember *int32) (err error) = advapi32.CheckTokenMembership%0A//sys%09OpenProcessToken(h Handle, access uint32, token *Token) (err error) = advapi32.OpenProcessToken%0A//sys%09GetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) = advapi32.GetTokenInformation%0A//sys%09GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) = userenv.GetUserProfileDirectoryW%0A%0A// An access token contains the security information for a logon session.%0A// The system creates an access token when a user logs on, and every%0A// process executed on behalf of the user has a copy of the token.%0A// The token identifies the user, the user's groups, and the user's%0A// privileges. The system uses the token to control access to securable%0A// objects and to control the ability of the user to perform various%0A// system-related operations on the local computer.%0Atype Token Handle%0A%0A// OpenCurrentProcessToken opens the access token%0A// associated with current process.%0Afunc OpenCurrentProcessToken() (Token, error) %7B%0A%09p, e := GetCurrentProcess()%0A%09if e != nil %7B%0A%09%09return 0, e%0A%09%7D%0A%09var t Token%0A%09e = OpenProcessToken(p, TOKEN_QUERY, &t)%0A%09if e != nil %7B%0A%09%09return 0, e%0A%09%7D%0A%09return t, nil%0A%7D%0A%0A// Close releases access to access token.%0Afunc (t Token) Close() error %7B%0A%09return CloseHandle(Handle(t))%0A%7D%0A%0A// getInfo retrieves a specified type of information about an access token.%0Afunc (t Token) getInfo(class uint32, initSize int) (unsafe.Pointer, error) %7B%0A%09n := uint32(initSize)%0A%09for %7B%0A%09%09b := make(%5B%5Dbyte, n)%0A%09%09e := GetTokenInformation(t, class, &b%5B0%5D, uint32(len(b)), &n)%0A%09%09if e == nil %7B%0A%09%09%09return unsafe.Pointer(&b%5B0%5D), nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return nil, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return nil, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0A// GetTokenUser retrieves access token t user account information.%0Afunc (t Token) GetTokenUser() (*Tokenuser, error) %7B%0A%09i, e := t.getInfo(TokenUser, 50)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09return (*Tokenuser)(i), nil%0A%7D%0A%0A// GetTokenGroups retrieves group accounts associated with access token t.%0Afunc (t Token) GetTokenGroups() (*Tokengroups, error) %7B%0A%09i, e := t.getInfo(TokenGroups, 50)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09return (*Tokengroups)(i), nil%0A%7D%0A%0A// GetTokenPrimaryGroup retrieves access token t primary group information.%0A// A pointer to a SID structure representing a group that will become%0A// the primary group of any objects created by a process using this access token.%0Afunc (t Token) GetTokenPrimaryGroup() (*Tokenprimarygroup, error) %7B%0A%09i, e := t.getInfo(TokenPrimaryGroup, 50)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09return (*Tokenprimarygroup)(i), nil%0A%7D%0A%0A// GetUserProfileDirectory retrieves path to the%0A// root directory of the access token t user's profile.%0Afunc (t Token) GetUserProfileDirectory() (string, error) %7B%0A%09n := uint32(100)%0A%09for %7B%0A%09%09b := make(%5B%5Duint16, n)%0A%09%09e := GetUserProfileDirectory(t, &b%5B0%5D, &n)%0A%09%09if e == nil %7B%0A%09%09%09return UTF16ToString(b), nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return %22%22, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return %22%22, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0A// IsMember reports whether the access token t is a member of the provided SID.%0Afunc (t Token) IsMember(sid *SID) (bool, error) %7B%0A%09var b int32%0A%09if e := checkTokenMembership(t, sid, &b); e != nil %7B%0A%09%09return false, e%0A%09%7D%0A%09return b != 0, nil%0A%7D%0A
- f f180bda228ea4ca5430fa4e45c070f0c022569fe4fc981115a82a765b3824991 vendor/golang.org/x/sys/windows/service.go
+ f d08387e435d6d1d0fa654ded83d7c886b5760498375549f7c6fbbc63661bce5c vendor/golang.org/x/sys/windows/service.go
dmppatch 3
@@ -192,6569 +192,4 @@
 ows%0A
-%0Aconst (%0A%09SC_MANAGER_CONNECT            = 1%0A%09SC_MANAGER_CREATE_SERVICE     = 2%0A%09SC_MANAGER_ENUMERATE_SERVICE  = 4%0A%09SC_MANAGER_LOCK               = 8%0A%09SC_MANAGER_QUERY_LOCK_STATUS  = 16%0A%09SC_MANAGER_MODIFY_BOOT_CONFIG = 32%0A%09SC_MANAGER_ALL_ACCESS         = 0xf003f%0A)%0A%0A//sys%09OpenSCManager(machineName *uint16, databaseName *uint16, access uint32) (handle Handle, err error) %5Bfailretval==0%5D = advapi32.OpenSCManagerW%0A%0Aconst (%0A%09SERVICE_KERNEL_DRIVER       = 1%0A%09SERVICE_FILE_SYSTEM_DRIVER  = 2%0A%09SERVICE_ADAPTER             = 4%0A%09SERVICE_RECOGNIZER_DRIVER   = 8%0A%09SERVICE_WIN32_OWN_PROCESS   = 16%0A%09SERVICE_WIN32_SHARE_PROCESS = 32%0A%09SERVICE_WIN32               = SERVICE_WIN32_OWN_PROCESS %7C SERVICE_WIN32_SHARE_PROCESS%0A%09SERVICE_INTERACTIVE_PROCESS = 256%0A%09SERVICE_DRIVER              = SERVICE_KERNEL_DRIVER %7C SERVICE_FILE_SYSTEM_DRIVER %7C SERVICE_RECOGNIZER_DRIVER%0A%09SERVICE_TYPE_ALL            = SERVICE_WIN32 %7C SERVICE_ADAPTER %7C SERVICE_DRIVER %7C SERVICE_INTERACTIVE_PROCESS%0A%0A%09SERVICE_BOOT_START   = 0%0A%09SERVICE_SYSTEM_START = 1%0A%09SERVICE_AUTO_START   = 2%0A%09SERVICE_DEMAND_START = 3%0A%09SERVICE_DISABLED     = 4%0A%0A%09SERVICE_ERROR_IGNORE   = 0%0A%09SERVICE_ERROR_NORMAL   = 1%0A%09SERVICE_ERROR_SEVERE   = 2%0A%09SERVICE_ERROR_CRITICAL = 3%0A%0A%09SC_STATUS_PROCESS_INFO = 0%0A%0A%09SERVICE_STOPPED          = 1%0A%09SERVICE_START_PENDING    = 2%0A%09SERVICE_STOP_PENDING     = 3%0A%09SERVICE_RUNNING          = 4%0A%09SERVICE_CONTINUE_PENDING = 5%0A%09SERVICE_PAUSE_PENDING    = 6%0A%09SERVICE_PAUSED           = 7%0A%09SERVICE_NO_CHANGE        = 0xffffffff%0A%0A%09SERVICE_ACCEPT_STOP                  = 1%0A%09SERVICE_ACCEPT_PAUSE_CONTINUE        = 2%0A%09SERVICE_ACCEPT_SHUTDOWN              = 4%0A%09SERVICE_ACCEPT_PARAMCHANGE           = 8%0A%09SERVICE_ACCEPT_NETBINDCHANGE         = 16%0A%09SERVICE_ACCEPT_HARDWAREPROFILECHANGE = 32%0A%09SERVICE_ACCEPT_POWEREVENT            = 64%0A%09SERVICE_ACCEPT_SESSIONCHANGE         = 128%0A%0A%09SERVICE_CONTROL_STOP                  = 1%0A%09SERVICE_CONTROL_PAUSE                 = 2%0A%09SERVICE_CONTROL_CONTINUE              = 3%0A%09SERVICE_CONTROL_INTERROGATE           = 4%0A%09SERVICE_CONTROL_SHUTDOWN              = 5%0A%09SERVICE_CONTROL_PARAMCHANGE           = 6%0A%09SERVICE_CONTROL_NETBINDADD            = 7%0A%09SERVICE_CONTROL_NETBINDREMOVE         = 8%0A%09SERVICE_CONTROL_NETBINDENABLE         = 9%0A%09SERVICE_CONTROL_NETBINDDISABLE        = 10%0A%09SERVICE_CONTROL_DEVICEEVENT           = 11%0A%09SERVICE_CONTROL_HARDWAREPROFILECHANGE = 12%0A%09SERVICE_CONTROL_POWEREVENT            = 13%0A%09SERVICE_CONTROL_SESSIONCHANGE         = 14%0A%0A%09SERVICE_ACTIVE    = 1%0A%09SERVICE_INACTIVE  = 2%0A%09SERVICE_STATE_ALL = 3%0A%0A%09SERVICE_QUERY_CONFIG           = 1%0A%09SERVICE_CHANGE_CONFIG          = 2%0A%09SERVICE_QUERY_STATUS           = 4%0A%09SERVICE_ENUMERATE_DEPENDENTS   = 8%0A%09SERVICE_START                  = 16%0A%09SERVICE_STOP                   = 32%0A%09SERVICE_PAUSE_CONTINUE         = 64%0A%09SERVICE_INTERROGATE            = 128%0A%09SERVICE_USER_DEFINED_CONTROL   = 256%0A%09SERVICE_ALL_ACCESS             = STANDARD_RIGHTS_REQUIRED %7C SERVICE_QUERY_CONFIG %7C SERVICE_CHANGE_CONFIG %7C SERVICE_QUERY_STATUS %7C SERVICE_ENUMERATE_DEPENDENTS %7C SERVICE_START %7C SERVICE_STOP %7C SERVICE_PAUSE_CONTINUE %7C SERVICE_INTERROGATE %7C SERVICE_USER_DEFINED_CONTROL%0A%09SERVICE_RUNS_IN_SYSTEM_PROCESS = 1%0A%09SERVICE_CONFIG_DESCRIPTION     = 1%0A%09SERVICE_CONFIG_FAILURE_ACTIONS = 2%0A%0A%09NO_ERROR = 0%0A%0A%09SC_ENUM_PROCESS_INFO = 0%0A)%0A%0Atype SERVICE_STATUS struct %7B%0A%09ServiceType             uint32%0A%09CurrentState            uint32%0A%09ControlsAccepted        uint32%0A%09Win32ExitCode           uint32%0A%09ServiceSpecificExitCode uint32%0A%09CheckPoint              uint32%0A%09WaitHint                uint32%0A%7D%0A%0Atype SERVICE_TABLE_ENTRY struct %7B%0A%09ServiceName *uint16%0A%09ServiceProc uintptr%0A%7D%0A%0Atype QUERY_SERVICE_CONFIG struct %7B%0A%09ServiceType      uint32%0A%09StartType        uint32%0A%09ErrorControl     uint32%0A%09BinaryPathName   *uint16%0A%09LoadOrderGroup   *uint16%0A%09TagId            uint32%0A%09Dependencies     *uint16%0A%09ServiceStartName *uint16%0A%09DisplayName      *uint16%0A%7D%0A%0Atype SERVICE_DESCRIPTION struct %7B%0A%09Description *uint16%0A%7D%0A%0Atype SERVICE_STATUS_PROCESS struct %7B%0A%09ServiceType             uint32%0A%09CurrentState            uint32%0A%09ControlsAccepted        uint32%0A%09Win32ExitCode           uint32%0A%09ServiceSpecificExitCode uint32%0A%09CheckPoint              uint32%0A%09WaitHint                uint32%0A%09ProcessId               uint32%0A%09ServiceFlags            uint32%0A%7D%0A%0Atype ENUM_SERVICE_STATUS_PROCESS struct %7B%0A%09ServiceName          *uint16%0A%09DisplayName          *uint16%0A%09ServiceStatusProcess SERVICE_STATUS_PROCESS%0A%7D%0A%0A//sys%09CloseServiceHandle(handle Handle) (err error) = advapi32.CloseServiceHandle%0A//sys%09CreateService(mgr Handle, serviceName *uint16, displayName *uint16, access uint32, srvType uint32, startType uint32, errCtl uint32, pathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16) (handle Handle, err error) %5Bfailretval==0%5D = advapi32.CreateServiceW%0A//sys%09OpenService(mgr Handle, serviceName *uint16, access uint32) (handle Handle, err error) %5Bfailretval==0%5D = advapi32.OpenServiceW%0A//sys%09DeleteService(service Handle) (err error) = advapi32.DeleteService%0A//sys%09StartService(service Handle, numArgs uint32, argVectors **uint16) (err error) = advapi32.StartServiceW%0A//sys%09QueryServiceStatus(service Handle, status *SERVICE_STATUS) (err error) = advapi32.QueryServiceStatus%0A//sys%09ControlService(service Handle, control uint32, status *SERVICE_STATUS) (err error) = advapi32.ControlService%0A//sys%09StartServiceCtrlDispatcher(serviceTable *SERVICE_TABLE_ENTRY) (err error) = advapi32.StartServiceCtrlDispatcherW%0A//sys%09SetServiceStatus(service Handle, serviceStatus *SERVICE_STATUS) (err error) = advapi32.SetServiceStatus%0A//sys%09ChangeServiceConfig(service Handle, serviceType uint32, startType uint32, errorControl uint32, binaryPathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16, displayName *uint16) (err error) = advapi32.ChangeServiceConfigW%0A//sys%09QueryServiceConfig(service Handle, serviceConfig *QUERY_SERVICE_CONFIG, bufSize uint32, bytesNeeded *uint32) (err error) = advapi32.QueryServiceConfigW%0A//sys%09ChangeServiceConfig2(service Handle, infoLevel uint32, info *byte) (err error) = advapi32.ChangeServiceConfig2W%0A//sys%09QueryServiceConfig2(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) = advapi32.QueryServiceConfig2W%0A//sys%09EnumServicesStatusEx(mgr Handle, infoLevel uint32, serviceType uint32, serviceState uint32, services *byte, bufSize uint32, bytesNeeded *uint32, servicesReturned *uint32, resumeHandle *uint32, groupName *uint16) (err error) = advapi32.EnumServicesStatusExW%0A
- f a979ea38da92c56dc17baa7fce72bb82ac4353867d47c5240cee4404bf356875 vendor/golang.org/x/sys/windows/str.go
+ f 999c92aefbb289294a360ceabd438085e9f02522555a5e2e69236e446e5d0dae vendor/golang.org/x/sys/windows/str.go
dmppatch 3
@@ -192,312 +192,4 @@
 ows%0A
-%0Afunc itoa(val int) string %7B // do it here rather than with fmt to avoid dependency%0A%09if val %3C 0 %7B%0A%09%09return %22-%22 + itoa(-val)%0A%09%7D%0A%09var buf %5B32%5Dbyte // big enough for int64%0A%09i := len(buf) - 1%0A%09for val %3E= 10 %7B%0A%09%09buf%5Bi%5D = byte(val%2510 + '0')%0A%09%09i--%0A%09%09val /= 10%0A%09%7D%0A%09buf%5Bi%5D = byte(val + '0')%0A%09return string(buf%5Bi:%5D)%0A%7D%0A
- f 15bb620236c7bba4ff1edbda701444c99ea5111e9d0b133329f8199a30fd26ac vendor/golang.org/x/sys/windows/syscall.go
+ f 86894e8c61501206e2ea20d1a8cd1b2b1c6c3041a9969ecd5da85fb9d49e14c0 vendor/golang.org/x/sys/windows/syscall.go
dmppatch 3
@@ -1224,1190 +1224,4 @@
 ws%22%0A
-%0Aimport (%0A%09%22syscall%22%0A)%0A%0A// ByteSliceFromString returns a NUL-terminated slice of bytes%0A// containing the text of s. If s contains a NUL byte at any%0A// location, it returns (nil, syscall.EINVAL).%0Afunc ByteSliceFromString(s string) (%5B%5Dbyte, error) %7B%0A%09for i := 0; i %3C len(s); i++ %7B%0A%09%09if s%5Bi%5D == 0 %7B%0A%09%09%09return nil, syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09a := make(%5B%5Dbyte, len(s)+1)%0A%09copy(a, s)%0A%09return a, nil%0A%7D%0A%0A// BytePtrFromString returns a pointer to a NUL-terminated array of%0A// bytes containing the text of s. If s contains a NUL byte at any%0A// location, it returns (nil, syscall.EINVAL).%0Afunc BytePtrFromString(s string) (*byte, error) %7B%0A%09a, err := ByteSliceFromString(s)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &a%5B0%5D, nil%0A%7D%0A%0A// Single-word zero for use when we need a valid pointer to 0 bytes.%0A// See mksyscall.pl.%0Avar _zero uintptr%0A%0Afunc (ts *Timespec) Unix() (sec int64, nsec int64) %7B%0A%09return int64(ts.Sec), int64(ts.Nsec)%0A%7D%0A%0Afunc (tv *Timeval) Unix() (sec int64, nsec int64) %7B%0A%09return int64(tv.Sec), int64(tv.Usec) * 1000%0A%7D%0A%0Afunc (ts *Timespec) Nano() int64 %7B%0A%09return int64(ts.Sec)*1e9 + int64(ts.Nsec)%0A%7D%0A%0Afunc (tv *Timeval) Nano() int64 %7B%0A%09return int64(tv.Sec)*1e9 + int64(tv.Usec)*1000%0A%7D%0A
- f dc3dc5e5404eb647d54dc23072322b0cb10c0d591c08fb035142cdcc3e414b2e vendor/golang.org/x/sys/windows/syscall_windows.go
+ f 20dfd94ee30ef16185423639762eb5a57cbf8f6a087c772ed820687588adbe7f vendor/golang.org/x/sys/windows/syscall_windows.go
dmppatch 3
@@ -199,44811 +199,4 @@
 ows%0A
-%0Aimport (%0A%09errorspkg %22errors%22%0A%09%22sync%22%0A%09%22syscall%22%0A%09%22unicode/utf16%22%0A%09%22unsafe%22%0A)%0A%0Atype Handle uintptr%0A%0Aconst (%0A%09InvalidHandle = %5EHandle(0)%0A%0A%09// Flags for DefineDosDevice.%0A%09DDD_EXACT_MATCH_ON_REMOVE = 0x00000004%0A%09DDD_NO_BROADCAST_SYSTEM   = 0x00000008%0A%09DDD_RAW_TARGET_PATH       = 0x00000001%0A%09DDD_REMOVE_DEFINITION     = 0x00000002%0A%0A%09// Return values for GetDriveType.%0A%09DRIVE_UNKNOWN     = 0%0A%09DRIVE_NO_ROOT_DIR = 1%0A%09DRIVE_REMOVABLE   = 2%0A%09DRIVE_FIXED       = 3%0A%09DRIVE_REMOTE      = 4%0A%09DRIVE_CDROM       = 5%0A%09DRIVE_RAMDISK     = 6%0A%0A%09// File system flags from GetVolumeInformation and GetVolumeInformationByHandle.%0A%09FILE_CASE_SENSITIVE_SEARCH        = 0x00000001%0A%09FILE_CASE_PRESERVED_NAMES         = 0x00000002%0A%09FILE_FILE_COMPRESSION             = 0x00000010%0A%09FILE_DAX_VOLUME                   = 0x20000000%0A%09FILE_NAMED_STREAMS                = 0x00040000%0A%09FILE_PERSISTENT_ACLS              = 0x00000008%0A%09FILE_READ_ONLY_VOLUME             = 0x00080000%0A%09FILE_SEQUENTIAL_WRITE_ONCE        = 0x00100000%0A%09FILE_SUPPORTS_ENCRYPTION          = 0x00020000%0A%09FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 0x00800000%0A%09FILE_SUPPORTS_HARD_LINKS          = 0x00400000%0A%09FILE_SUPPORTS_OBJECT_IDS          = 0x00010000%0A%09FILE_SUPPORTS_OPEN_BY_FILE_ID     = 0x01000000%0A%09FILE_SUPPORTS_REPARSE_POINTS      = 0x00000080%0A%09FILE_SUPPORTS_SPARSE_FILES        = 0x00000040%0A%09FILE_SUPPORTS_TRANSACTIONS        = 0x00200000%0A%09FILE_SUPPORTS_USN_JOURNAL         = 0x02000000%0A%09FILE_UNICODE_ON_DISK              = 0x00000004%0A%09FILE_VOLUME_IS_COMPRESSED         = 0x00008000%0A%09FILE_VOLUME_QUOTAS                = 0x00000020%0A)%0A%0A// StringToUTF16 is deprecated. Use UTF16FromString instead.%0A// If s contains a NUL byte this function panics instead of%0A// returning an error.%0Afunc StringToUTF16(s string) %5B%5Duint16 %7B%0A%09a, err := UTF16FromString(s)%0A%09if err != nil %7B%0A%09%09panic(%22windows: string with NUL passed to StringToUTF16%22)%0A%09%7D%0A%09return a%0A%7D%0A%0A// UTF16FromString returns the UTF-16 encoding of the UTF-8 string%0A// s, with a terminating NUL added. If s contains a NUL byte at any%0A// location, it returns (nil, syscall.EINVAL).%0Afunc UTF16FromString(s string) (%5B%5Duint16, error) %7B%0A%09for i := 0; i %3C len(s); i++ %7B%0A%09%09if s%5Bi%5D == 0 %7B%0A%09%09%09return nil, syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return utf16.Encode(%5B%5Drune(s + %22%5Cx00%22)), nil%0A%7D%0A%0A// UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s,%0A// with a terminating NUL removed.%0Afunc UTF16ToString(s %5B%5Duint16) string %7B%0A%09for i, v := range s %7B%0A%09%09if v == 0 %7B%0A%09%09%09s = s%5B0:i%5D%0A%09%09%09break%0A%09%09%7D%0A%09%7D%0A%09return string(utf16.Decode(s))%0A%7D%0A%0A// StringToUTF16Ptr is deprecated. Use UTF16PtrFromString instead.%0A// If s contains a NUL byte this function panics instead of%0A// returning an error.%0Afunc StringToUTF16Ptr(s string) *uint16 %7B return &StringToUTF16(s)%5B0%5D %7D%0A%0A// UTF16PtrFromString returns pointer to the UTF-16 encoding of%0A// the UTF-8 string s, with a terminating NUL added. If s%0A// contains a NUL byte at any location, it returns (nil, syscall.EINVAL).%0Afunc UTF16PtrFromString(s string) (*uint16, error) %7B%0A%09a, err := UTF16FromString(s)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &a%5B0%5D, nil%0A%7D%0A%0Afunc Getpagesize() int %7B return 4096 %7D%0A%0A// NewCallback converts a Go function to a function pointer conforming to the stdcall calling convention.%0A// This is useful when interoperating with Windows code requiring callbacks.%0Afunc NewCallback(fn interface%7B%7D) uintptr %7B%0A%09return syscall.NewCallback(fn)%0A%7D%0A%0A// NewCallbackCDecl converts a Go function to a function pointer conforming to the cdecl calling convention.%0A// This is useful when interoperating with Windows code requiring callbacks.%0Afunc NewCallbackCDecl(fn interface%7B%7D) uintptr %7B%0A%09return syscall.NewCallbackCDecl(fn)%0A%7D%0A%0A// windows api calls%0A%0A//sys%09GetLastError() (lasterr error)%0A//sys%09LoadLibrary(libname string) (handle Handle, err error) = LoadLibraryW%0A//sys%09LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) = LoadLibraryExW%0A//sys%09FreeLibrary(handle Handle) (err error)%0A//sys%09GetProcAddress(module Handle, procname string) (proc uintptr, err error)%0A//sys%09GetVersion() (ver uint32, err error)%0A//sys%09FormatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf %5B%5Duint16, args *byte) (n uint32, err error) = FormatMessageW%0A//sys%09ExitProcess(exitcode uint32)%0A//sys%09CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = CreateFileW%0A//sys%09ReadFile(handle Handle, buf %5B%5Dbyte, done *uint32, overlapped *Overlapped) (err error)%0A//sys%09WriteFile(handle Handle, buf %5B%5Dbyte, done *uint32, overlapped *Overlapped) (err error)%0A//sys%09SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) %5Bfailretval==0xffffffff%5D%0A//sys%09CloseHandle(handle Handle) (err error)%0A//sys%09GetStdHandle(stdhandle uint32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D%0A//sys%09SetStdHandle(stdhandle uint32, handle Handle) (err error)%0A//sys%09findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = FindFirstFileW%0A//sys%09findNextFile1(handle Handle, data *win32finddata1) (err error) = FindNextFileW%0A//sys%09FindClose(handle Handle) (err error)%0A//sys%09GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (err error)%0A//sys%09GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) = GetCurrentDirectoryW%0A//sys%09SetCurrentDirectory(path *uint16) (err error) = SetCurrentDirectoryW%0A//sys%09CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) = CreateDirectoryW%0A//sys%09RemoveDirectory(path *uint16) (err error) = RemoveDirectoryW%0A//sys%09DeleteFile(path *uint16) (err error) = DeleteFileW%0A//sys%09MoveFile(from *uint16, to *uint16) (err error) = MoveFileW%0A//sys%09MoveFileEx(from *uint16, to *uint16, flags uint32) (err error) = MoveFileExW%0A//sys%09GetComputerName(buf *uint16, n *uint32) (err error) = GetComputerNameW%0A//sys%09GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) = GetComputerNameExW%0A//sys%09SetEndOfFile(handle Handle) (err error)%0A//sys%09GetSystemTimeAsFileTime(time *Filetime)%0A//sys%09GetSystemTimePreciseAsFileTime(time *Filetime)%0A//sys%09GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, err error) %5Bfailretval==0xffffffff%5D%0A//sys%09CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uint32, threadcnt uint32) (handle Handle, err error)%0A//sys%09GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (err error)%0A//sys%09PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uint32, overlapped *Overlapped) (err error)%0A//sys%09CancelIo(s Handle) (err error)%0A//sys%09CancelIoEx(s Handle, o *Overlapped) (err error)%0A//sys%09CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) = CreateProcessW%0A//sys%09OpenProcess(da uint32, inheritHandle bool, pid uint32) (handle Handle, err error)%0A//sys%09TerminateProcess(handle Handle, exitcode uint32) (err error)%0A//sys%09GetExitCodeProcess(handle Handle, exitcode *uint32) (err error)%0A//sys%09GetStartupInfo(startupInfo *StartupInfo) (err error) = GetStartupInfoW%0A//sys%09GetCurrentProcess() (pseudoHandle Handle, err error)%0A//sys%09GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error)%0A//sys%09DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error)%0A//sys%09WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) %5Bfailretval==0xffffffff%5D%0A//sys%09GetTempPath(buflen uint32, buf *uint16) (n uint32, err error) = GetTempPathW%0A//sys%09CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error)%0A//sys%09GetFileType(filehandle Handle) (n uint32, err error)%0A//sys%09CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) = advapi32.CryptAcquireContextW%0A//sys%09CryptReleaseContext(provhandle Handle, flags uint32) (err error) = advapi32.CryptReleaseContext%0A//sys%09CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) = advapi32.CryptGenRandom%0A//sys%09GetEnvironmentStrings() (envs *uint16, err error) %5Bfailretval==nil%5D = kernel32.GetEnvironmentStringsW%0A//sys%09FreeEnvironmentStrings(envs *uint16) (err error) = kernel32.FreeEnvironmentStringsW%0A//sys%09GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) = kernel32.GetEnvironmentVariableW%0A//sys%09SetEnvironmentVariable(name *uint16, value *uint16) (err error) = kernel32.SetEnvironmentVariableW%0A//sys%09SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error)%0A//sys%09GetFileAttributes(name *uint16) (attrs uint32, err error) %5Bfailretval==INVALID_FILE_ATTRIBUTES%5D = kernel32.GetFileAttributesW%0A//sys%09SetFileAttributes(name *uint16, attrs uint32) (err error) = kernel32.SetFileAttributesW%0A//sys%09GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) = kernel32.GetFileAttributesExW%0A//sys%09GetCommandLine() (cmd *uint16) = kernel32.GetCommandLineW%0A//sys%09CommandLineToArgv(cmd *uint16, argc *int32) (argv *%5B8192%5D*%5B8192%5Duint16, err error) %5Bfailretval==nil%5D = shell32.CommandLineToArgvW%0A//sys%09LocalFree(hmem Handle) (handle Handle, err error) %5Bfailretval!=0%5D%0A//sys%09SetHandleInformation(handle Handle, mask uint32, flags uint32) (err error)%0A//sys%09FlushFileBuffers(handle Handle) (err error)%0A//sys%09GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error) = kernel32.GetFullPathNameW%0A//sys%09GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) = kernel32.GetLongPathNameW%0A//sys%09GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) = kernel32.GetShortPathNameW%0A//sys%09CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) = kernel32.CreateFileMappingW%0A//sys%09MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error)%0A//sys%09UnmapViewOfFile(addr uintptr) (err error)%0A//sys%09FlushViewOfFile(addr uintptr, length uintptr) (err error)%0A//sys%09VirtualLock(addr uintptr, length uintptr) (err error)%0A//sys%09VirtualUnlock(addr uintptr, length uintptr) (err error)%0A//sys%09VirtualAlloc(address uintptr, size uintptr, alloctype uint32, protect uint32) (value uintptr, err error) = kernel32.VirtualAlloc%0A//sys%09VirtualFree(address uintptr, size uintptr, freetype uint32) (err error) = kernel32.VirtualFree%0A//sys%09VirtualProtect(address uintptr, size uintptr, newprotect uint32, oldprotect *uint32) (err error) = kernel32.VirtualProtect%0A//sys%09TransmitFile(s Handle, handle Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *Overlapped, transmitFileBuf *TransmitFileBuffers, flags uint32) (err error) = mswsock.TransmitFile%0A//sys%09ReadDirectoryChanges(handle Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) = kernel32.ReadDirectoryChangesW%0A//sys%09CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) = crypt32.CertOpenSystemStoreW%0A//sys   CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = crypt32.CertOpenStore%0A//sys%09CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) %5Bfailretval==nil%5D = crypt32.CertEnumCertificatesInStore%0A//sys   CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) = crypt32.CertAddCertificateContextToStore%0A//sys%09CertCloseStore(store Handle, flags uint32) (err error) = crypt32.CertCloseStore%0A//sys   CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) = crypt32.CertGetCertificateChain%0A//sys   CertFreeCertificateChain(ctx *CertChainContext) = crypt32.CertFreeCertificateChain%0A//sys   CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *CertContext, err error) %5Bfailretval==nil%5D = crypt32.CertCreateCertificateContext%0A//sys   CertFreeCertificateContext(ctx *CertContext) (err error) = crypt32.CertFreeCertificateContext%0A//sys   CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) = crypt32.CertVerifyCertificateChainPolicy%0A//sys%09RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) = advapi32.RegOpenKeyExW%0A//sys%09RegCloseKey(key Handle) (regerrno error) = advapi32.RegCloseKey%0A//sys%09RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) = advapi32.RegQueryInfoKeyW%0A//sys%09RegEnumKeyEx(key Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *Filetime) (regerrno error) = advapi32.RegEnumKeyExW%0A//sys%09RegQueryValueEx(key Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) = advapi32.RegQueryValueExW%0A//sys%09getCurrentProcessId() (pid uint32) = kernel32.GetCurrentProcessId%0A//sys%09GetConsoleMode(console Handle, mode *uint32) (err error) = kernel32.GetConsoleMode%0A//sys%09SetConsoleMode(console Handle, mode uint32) (err error) = kernel32.SetConsoleMode%0A//sys%09GetConsoleScreenBufferInfo(console Handle, info *ConsoleScreenBufferInfo) (err error) = kernel32.GetConsoleScreenBufferInfo%0A//sys%09WriteConsole(console Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error) = kernel32.WriteConsoleW%0A//sys%09ReadConsole(console Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) = kernel32.ReadConsoleW%0A//sys%09CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = kernel32.CreateToolhelp32Snapshot%0A//sys%09Process32First(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32FirstW%0A//sys%09Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32NextW%0A//sys%09DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error)%0A// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.%0A//sys%09CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) %5Bfailretval&0xff==0%5D = CreateSymbolicLinkW%0A//sys%09CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) %5Bfailretval&0xff==0%5D = CreateHardLinkW%0A//sys%09GetCurrentThreadId() (id uint32)%0A//sys%09CreateEvent(eventAttrs *SecurityAttributes, manualReset uint32, initialState uint32, name *uint16) (handle Handle, err error) = kernel32.CreateEventW%0A//sys%09CreateEventEx(eventAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) = kernel32.CreateEventExW%0A//sys%09OpenEvent(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) = kernel32.OpenEventW%0A//sys%09SetEvent(event Handle) (err error) = kernel32.SetEvent%0A//sys%09ResetEvent(event Handle) (err error) = kernel32.ResetEvent%0A//sys%09PulseEvent(event Handle) (err error) = kernel32.PulseEvent%0A%0A// Volume Management Functions%0A//sys%09DefineDosDevice(flags uint32, deviceName *uint16, targetPath *uint16) (err error) = DefineDosDeviceW%0A//sys%09DeleteVolumeMountPoint(volumeMountPoint *uint16) (err error) = DeleteVolumeMountPointW%0A//sys%09FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = FindFirstVolumeW%0A//sys%09FindFirstVolumeMountPoint(rootPathName *uint16, volumeMountPoint *uint16, bufferLength uint32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = FindFirstVolumeMountPointW%0A//sys%09FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) = FindNextVolumeW%0A//sys%09FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) = FindNextVolumeMountPointW%0A//sys%09FindVolumeClose(findVolume Handle) (err error)%0A//sys%09FindVolumeMountPointClose(findVolumeMountPoint Handle) (err error)%0A//sys%09GetDriveType(rootPathName *uint16) (driveType uint32) = GetDriveTypeW%0A//sys%09GetLogicalDrives() (drivesBitMask uint32, err error) %5Bfailretval==0%5D%0A//sys%09GetLogicalDriveStrings(bufferLength uint32, buffer *uint16) (n uint32, err error) %5Bfailretval==0%5D = GetLogicalDriveStringsW%0A//sys%09GetVolumeInformation(rootPathName *uint16, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) = GetVolumeInformationW%0A//sys%09GetVolumeInformationByHandle(file Handle, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) = GetVolumeInformationByHandleW%0A//sys%09GetVolumeNameForVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16, bufferlength uint32) (err error) = GetVolumeNameForVolumeMountPointW%0A//sys%09GetVolumePathName(fileName *uint16, volumePathName *uint16, bufferLength uint32) (err error) = GetVolumePathNameW%0A//sys%09GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) = GetVolumePathNamesForVolumeNameW%0A//sys%09QueryDosDevice(deviceName *uint16, targetPath *uint16, max uint32) (n uint32, err error) %5Bfailretval==0%5D = QueryDosDeviceW%0A//sys%09SetVolumeLabel(rootPathName *uint16, volumeName *uint16) (err error) = SetVolumeLabelW%0A//sys%09SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) = SetVolumeMountPointW%0A%0A// syscall interface implementation for other packages%0A%0A// GetProcAddressByOrdinal retrieves the address of the exported%0A// function from module by ordinal.%0Afunc GetProcAddressByOrdinal(module Handle, ordinal uintptr) (proc uintptr, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetProcAddress.Addr(), 2, uintptr(module), ordinal, 0)%0A%09proc = uintptr(r0)%0A%09if proc == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Exit(code int) %7B ExitProcess(uint32(code)) %7D%0A%0Afunc makeInheritSa() *SecurityAttributes %7B%0A%09var sa SecurityAttributes%0A%09sa.Length = uint32(unsafe.Sizeof(sa))%0A%09sa.InheritHandle = 1%0A%09return &sa%0A%7D%0A%0Afunc Open(path string, mode int, perm uint32) (fd Handle, err error) %7B%0A%09if len(path) == 0 %7B%0A%09%09return InvalidHandle, ERROR_FILE_NOT_FOUND%0A%09%7D%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return InvalidHandle, err%0A%09%7D%0A%09var access uint32%0A%09switch mode & (O_RDONLY %7C O_WRONLY %7C O_RDWR) %7B%0A%09case O_RDONLY:%0A%09%09access = GENERIC_READ%0A%09case O_WRONLY:%0A%09%09access = GENERIC_WRITE%0A%09case O_RDWR:%0A%09%09access = GENERIC_READ %7C GENERIC_WRITE%0A%09%7D%0A%09if mode&O_CREAT != 0 %7B%0A%09%09access %7C= GENERIC_WRITE%0A%09%7D%0A%09if mode&O_APPEND != 0 %7B%0A%09%09access &%5E= GENERIC_WRITE%0A%09%09access %7C= FILE_APPEND_DATA%0A%09%7D%0A%09sharemode := uint32(FILE_SHARE_READ %7C FILE_SHARE_WRITE)%0A%09var sa *SecurityAttributes%0A%09if mode&O_CLOEXEC == 0 %7B%0A%09%09sa = makeInheritSa()%0A%09%7D%0A%09var createmode uint32%0A%09switch %7B%0A%09case mode&(O_CREAT%7CO_EXCL) == (O_CREAT %7C O_EXCL):%0A%09%09createmode = CREATE_NEW%0A%09case mode&(O_CREAT%7CO_TRUNC) == (O_CREAT %7C O_TRUNC):%0A%09%09createmode = CREATE_ALWAYS%0A%09case mode&O_CREAT == O_CREAT:%0A%09%09createmode = OPEN_ALWAYS%0A%09case mode&O_TRUNC == O_TRUNC:%0A%09%09createmode = TRUNCATE_EXISTING%0A%09default:%0A%09%09createmode = OPEN_EXISTING%0A%09%7D%0A%09h, e := CreateFile(pathp, access, sharemode, sa, createmode, FILE_ATTRIBUTE_NORMAL, 0)%0A%09return h, e%0A%7D%0A%0Afunc Read(fd Handle, p %5B%5Dbyte) (n int, err error) %7B%0A%09var done uint32%0A%09e := ReadFile(fd, p, &done, nil)%0A%09if e != nil %7B%0A%09%09if e == ERROR_BROKEN_PIPE %7B%0A%09%09%09// NOTE(brainman): work around ERROR_BROKEN_PIPE is returned on reading EOF from stdin%0A%09%09%09return 0, nil%0A%09%09%7D%0A%09%09return 0, e%0A%09%7D%0A%09if raceenabled %7B%0A%09%09if done %3E 0 %7B%0A%09%09%09raceWriteRange(unsafe.Pointer(&p%5B0%5D), int(done))%0A%09%09%7D%0A%09%09raceAcquire(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09return int(done), nil%0A%7D%0A%0Afunc Write(fd Handle, p %5B%5Dbyte) (n int, err error) %7B%0A%09if raceenabled %7B%0A%09%09raceReleaseMerge(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09var done uint32%0A%09e := WriteFile(fd, p, &done, nil)%0A%09if e != nil %7B%0A%09%09return 0, e%0A%09%7D%0A%09if raceenabled && done %3E 0 %7B%0A%09%09raceReadRange(unsafe.Pointer(&p%5B0%5D), int(done))%0A%09%7D%0A%09return int(done), nil%0A%7D%0A%0Avar ioSync int64%0A%0Afunc Seek(fd Handle, offset int64, whence int) (newoffset int64, err error) %7B%0A%09var w uint32%0A%09switch whence %7B%0A%09case 0:%0A%09%09w = FILE_BEGIN%0A%09case 1:%0A%09%09w = FILE_CURRENT%0A%09case 2:%0A%09%09w = FILE_END%0A%09%7D%0A%09hi := int32(offset %3E%3E 32)%0A%09lo := int32(offset)%0A%09// use GetFileType to check pipe, pipe can't do seek%0A%09ft, _ := GetFileType(fd)%0A%09if ft == FILE_TYPE_PIPE %7B%0A%09%09return 0, syscall.EPIPE%0A%09%7D%0A%09rlo, e := SetFilePointer(fd, lo, &hi, w)%0A%09if e != nil %7B%0A%09%09return 0, e%0A%09%7D%0A%09return int64(hi)%3C%3C32 + int64(rlo), nil%0A%7D%0A%0Afunc Close(fd Handle) (err error) %7B%0A%09return CloseHandle(fd)%0A%7D%0A%0Avar (%0A%09Stdin  = getStdHandle(STD_INPUT_HANDLE)%0A%09Stdout = getStdHandle(STD_OUTPUT_HANDLE)%0A%09Stderr = getStdHandle(STD_ERROR_HANDLE)%0A)%0A%0Afunc getStdHandle(stdhandle uint32) (fd Handle) %7B%0A%09r, _ := GetStdHandle(stdhandle)%0A%09CloseOnExec(r)%0A%09return r%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0Afunc Getwd() (wd string, err error) %7B%0A%09b := make(%5B%5Duint16, 300)%0A%09n, e := GetCurrentDirectory(uint32(len(b)), &b%5B0%5D)%0A%09if e != nil %7B%0A%09%09return %22%22, e%0A%09%7D%0A%09return string(utf16.Decode(b%5B0:n%5D)), nil%0A%7D%0A%0Afunc Chdir(path string) (err error) %7B%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return SetCurrentDirectory(pathp)%0A%7D%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return CreateDirectory(pathp, nil)%0A%7D%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return RemoveDirectory(pathp)%0A%7D%0A%0Afunc Unlink(path string) (err error) %7B%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return DeleteFile(pathp)%0A%7D%0A%0Afunc Rename(oldpath, newpath string) (err error) %7B%0A%09from, err := UTF16PtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09to, err := UTF16PtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return MoveFileEx(from, to, MOVEFILE_REPLACE_EXISTING)%0A%7D%0A%0Afunc ComputerName() (name string, err error) %7B%0A%09var n uint32 = MAX_COMPUTERNAME_LENGTH + 1%0A%09b := make(%5B%5Duint16, n)%0A%09e := GetComputerName(&b%5B0%5D, &n)%0A%09if e != nil %7B%0A%09%09return %22%22, e%0A%09%7D%0A%09return string(utf16.Decode(b%5B0:n%5D)), nil%0A%7D%0A%0Afunc Ftruncate(fd Handle, length int64) (err error) %7B%0A%09curoffset, e := Seek(fd, 0, 1)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09defer Seek(fd, curoffset, 0)%0A%09_, e = Seek(fd, length, 0)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09e = SetEndOfFile(fd)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09var ft Filetime%0A%09GetSystemTimeAsFileTime(&ft)%0A%09*tv = NsecToTimeval(ft.Nanoseconds())%0A%09return nil%0A%7D%0A%0Afunc Pipe(p %5B%5DHandle) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return syscall.EINVAL%0A%09%7D%0A%09var r, w Handle%0A%09e := CreatePipe(&r, &w, makeInheritSa(), 0)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09p%5B0%5D = r%0A%09p%5B1%5D = w%0A%09return nil%0A%7D%0A%0Afunc Utimes(path string, tv %5B%5DTimeval) (err error) %7B%0A%09if len(tv) != 2 %7B%0A%09%09return syscall.EINVAL%0A%09%7D%0A%09pathp, e := UTF16PtrFromString(path)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09h, e := CreateFile(pathp,%0A%09%09FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nil,%0A%09%09OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09defer Close(h)%0A%09a := NsecToFiletime(tv%5B0%5D.Nanoseconds())%0A%09w := NsecToFiletime(tv%5B1%5D.Nanoseconds())%0A%09return SetFileTime(h, nil, &a, &w)%0A%7D%0A%0Afunc UtimesNano(path string, ts %5B%5DTimespec) (err error) %7B%0A%09if len(ts) != 2 %7B%0A%09%09return syscall.EINVAL%0A%09%7D%0A%09pathp, e := UTF16PtrFromString(path)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09h, e := CreateFile(pathp,%0A%09%09FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nil,%0A%09%09OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09defer Close(h)%0A%09a := NsecToFiletime(TimespecToNsec(ts%5B0%5D))%0A%09w := NsecToFiletime(TimespecToNsec(ts%5B1%5D))%0A%09return SetFileTime(h, nil, &a, &w)%0A%7D%0A%0Afunc Fsync(fd Handle) (err error) %7B%0A%09return FlushFileBuffers(fd)%0A%7D%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09if mode == 0 %7B%0A%09%09return syscall.EINVAL%0A%09%7D%0A%09p, e := UTF16PtrFromString(path)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09attrs, e := GetFileAttributes(p)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09if mode&S_IWRITE != 0 %7B%0A%09%09attrs &%5E= FILE_ATTRIBUTE_READONLY%0A%09%7D else %7B%0A%09%09attrs %7C= FILE_ATTRIBUTE_READONLY%0A%09%7D%0A%09return SetFileAttributes(p, attrs)%0A%7D%0A%0Afunc LoadGetSystemTimePreciseAsFileTime() error %7B%0A%09return procGetSystemTimePreciseAsFileTime.Find()%0A%7D%0A%0Afunc LoadCancelIoEx() error %7B%0A%09return procCancelIoEx.Find()%0A%7D%0A%0Afunc LoadSetFileCompletionNotificationModes() error %7B%0A%09return procSetFileCompletionNotificationModes.Find()%0A%7D%0A%0A// net api calls%0A%0Aconst socket_error = uintptr(%5Euint32(0))%0A%0A//sys%09WSAStartup(verreq uint32, data *WSAData) (sockerr error) = ws2_32.WSAStartup%0A//sys%09WSACleanup() (err error) %5Bfailretval==socket_error%5D = ws2_32.WSACleanup%0A//sys%09WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSAIoctl%0A//sys%09socket(af int32, typ int32, protocol int32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = ws2_32.socket%0A//sys%09Setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.setsockopt%0A//sys%09Getsockopt(s Handle, level int32, optname int32, optval *byte, optlen *int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.getsockopt%0A//sys%09bind(s Handle, name unsafe.Pointer, namelen int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.bind%0A//sys%09connect(s Handle, name unsafe.Pointer, namelen int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.connect%0A//sys%09getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.getsockname%0A//sys%09getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.getpeername%0A//sys%09listen(s Handle, backlog int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.listen%0A//sys%09shutdown(s Handle, how int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.shutdown%0A//sys%09Closesocket(s Handle) (err error) %5Bfailretval==socket_error%5D = ws2_32.closesocket%0A//sys%09AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (err error) = mswsock.AcceptEx%0A//sys%09GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) = mswsock.GetAcceptExSockaddrs%0A//sys%09WSARecv(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSARecv%0A//sys%09WSASend(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSASend%0A//sys%09WSARecvFrom(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32,  from *RawSockaddrAny, fromlen *int32, overlapped *Overlapped, croutine *byte) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSARecvFrom%0A//sys%09WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32,  overlapped *Overlapped, croutine *byte) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSASendTo%0A//sys%09GetHostByName(name string) (h *Hostent, err error) %5Bfailretval==nil%5D = ws2_32.gethostbyname%0A//sys%09GetServByName(name string, proto string) (s *Servent, err error) %5Bfailretval==nil%5D = ws2_32.getservbyname%0A//sys%09Ntohs(netshort uint16) (u uint16) = ws2_32.ntohs%0A//sys%09GetProtoByName(name string) (p *Protoent, err error) %5Bfailretval==nil%5D = ws2_32.getprotobyname%0A//sys%09DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) = dnsapi.DnsQuery_W%0A//sys%09DnsRecordListFree(rl *DNSRecord, freetype uint32) = dnsapi.DnsRecordListFree%0A//sys%09DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) = dnsapi.DnsNameCompare_W%0A//sys%09GetAddrInfoW(nodename *uint16, servicename *uint16, hints *AddrinfoW, result **AddrinfoW) (sockerr error) = ws2_32.GetAddrInfoW%0A//sys%09FreeAddrInfoW(addrinfo *AddrinfoW) = ws2_32.FreeAddrInfoW%0A//sys%09GetIfEntry(pIfRow *MibIfRow) (errcode error) = iphlpapi.GetIfEntry%0A//sys%09GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode error) = iphlpapi.GetAdaptersInfo%0A//sys%09SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) = kernel32.SetFileCompletionNotificationModes%0A//sys%09WSAEnumProtocols(protocols *int32, protocolBuffer *WSAProtocolInfo, bufferLength *uint32) (n int32, err error) %5Bfailretval==-1%5D = ws2_32.WSAEnumProtocolsW%0A//sys%09GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) = iphlpapi.GetAdaptersAddresses%0A//sys%09GetACP() (acp uint32) = kernel32.GetACP%0A//sys%09MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) = kernel32.MultiByteToWideChar%0A%0A// For testing: clients can set this flag to force%0A// creation of IPv6 sockets to return EAFNOSUPPORT.%0Avar SocketDisableIPv6 bool%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype Sockaddr interface %7B%0A%09sockaddr() (ptr unsafe.Pointer, len int32, err error) // lowercase; only we can define Sockaddrs%0A%7D%0A%0Atype SockaddrInet4 struct %7B%0A%09Port int%0A%09Addr %5B4%5Dbyte%0A%09raw  RawSockaddrInet4%0A%7D%0A%0Afunc (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, int32, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, syscall.EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), int32(unsafe.Sizeof(sa.raw)), nil%0A%7D%0A%0Atype SockaddrInet6 struct %7B%0A%09Port   int%0A%09ZoneId uint32%0A%09Addr   %5B16%5Dbyte%0A%09raw    RawSockaddrInet6%0A%7D%0A%0Afunc (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, int32, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, syscall.EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET6%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09sa.raw.Scope_id = sa.ZoneId%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), int32(unsafe.Sizeof(sa.raw)), nil%0A%7D%0A%0Atype SockaddrUnix struct %7B%0A%09Name string%0A%7D%0A%0Afunc (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, int32, error) %7B%0A%09// TODO(brainman): implement SockaddrUnix.sockaddr()%0A%09return nil, 0, syscall.EWINDOWS%0A%7D%0A%0Afunc (rsa *RawSockaddrAny) Sockaddr() (Sockaddr, error) %7B%0A%09switch rsa.Addr.Family %7B%0A%09case AF_UNIX:%0A%09%09return nil, syscall.EWINDOWS%0A%0A%09case AF_INET:%0A%09%09pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet4)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_INET6:%0A%09%09pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet6)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09sa.ZoneId = pp.Scope_id%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%09%7D%0A%09return nil, syscall.EAFNOSUPPORT%0A%7D%0A%0Afunc Socket(domain, typ, proto int) (fd Handle, err error) %7B%0A%09if domain == AF_INET6 && SocketDisableIPv6 %7B%0A%09%09return InvalidHandle, syscall.EAFNOSUPPORT%0A%09%7D%0A%09return socket(int32(domain), int32(typ), int32(proto))%0A%7D%0A%0Afunc SetsockoptInt(fd Handle, level, opt int, value int) (err error) %7B%0A%09v := int32(value)%0A%09return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&v)), int32(unsafe.Sizeof(v)))%0A%7D%0A%0Afunc Bind(fd Handle, sa Sockaddr) (err error) %7B%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return bind(fd, ptr, n)%0A%7D%0A%0Afunc Connect(fd Handle, sa Sockaddr) (err error) %7B%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return connect(fd, ptr, n)%0A%7D%0A%0Afunc Getsockname(fd Handle) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09l := int32(unsafe.Sizeof(rsa))%0A%09if err = getsockname(fd, &rsa, &l); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return rsa.Sockaddr()%0A%7D%0A%0Afunc Getpeername(fd Handle) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09l := int32(unsafe.Sizeof(rsa))%0A%09if err = getpeername(fd, &rsa, &l); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return rsa.Sockaddr()%0A%7D%0A%0Afunc Listen(s Handle, n int) (err error) %7B%0A%09return listen(s, int32(n))%0A%7D%0A%0Afunc Shutdown(fd Handle, how int) (err error) %7B%0A%09return shutdown(fd, int32(how))%0A%7D%0A%0Afunc WSASendto(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to Sockaddr, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09rsa, l, err := to.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return WSASendTo(s, bufs, bufcnt, sent, flags, (*RawSockaddrAny)(unsafe.Pointer(rsa)), l, overlapped, croutine)%0A%7D%0A%0Afunc LoadGetAddrInfo() error %7B%0A%09return procGetAddrInfoW.Find()%0A%7D%0A%0Avar connectExFunc struct %7B%0A%09once sync.Once%0A%09addr uintptr%0A%09err  error%0A%7D%0A%0Afunc LoadConnectEx() error %7B%0A%09connectExFunc.once.Do(func() %7B%0A%09%09var s Handle%0A%09%09s, connectExFunc.err = Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)%0A%09%09if connectExFunc.err != nil %7B%0A%09%09%09return%0A%09%09%7D%0A%09%09defer CloseHandle(s)%0A%09%09var n uint32%0A%09%09connectExFunc.err = WSAIoctl(s,%0A%09%09%09SIO_GET_EXTENSION_FUNCTION_POINTER,%0A%09%09%09(*byte)(unsafe.Pointer(&WSAID_CONNECTEX)),%0A%09%09%09uint32(unsafe.Sizeof(WSAID_CONNECTEX)),%0A%09%09%09(*byte)(unsafe.Pointer(&connectExFunc.addr)),%0A%09%09%09uint32(unsafe.Sizeof(connectExFunc.addr)),%0A%09%09%09&n, nil, 0)%0A%09%7D)%0A%09return connectExFunc.err%0A%7D%0A%0Afunc connectEx(s Handle, name unsafe.Pointer, namelen int32, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(connectExFunc.addr, 7, uintptr(s), uintptr(name), uintptr(namelen), uintptr(unsafe.Pointer(sendBuf)), uintptr(sendDataLen), uintptr(unsafe.Pointer(bytesSent)), uintptr(unsafe.Pointer(overlapped)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = error(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ConnectEx(fd Handle, sa Sockaddr, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *Overlapped) error %7B%0A%09err := LoadConnectEx()%0A%09if err != nil %7B%0A%09%09return errorspkg.New(%22failed to find ConnectEx: %22 + err.Error())%0A%09%7D%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return connectEx(fd, ptr, n, sendBuf, sendDataLen, bytesSent, overlapped)%0A%7D%0A%0Avar sendRecvMsgFunc struct %7B%0A%09once     sync.Once%0A%09sendAddr uintptr%0A%09recvAddr uintptr%0A%09err      error%0A%7D%0A%0Afunc loadWSASendRecvMsg() error %7B%0A%09sendRecvMsgFunc.once.Do(func() %7B%0A%09%09var s Handle%0A%09%09s, sendRecvMsgFunc.err = Socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)%0A%09%09if sendRecvMsgFunc.err != nil %7B%0A%09%09%09return%0A%09%09%7D%0A%09%09defer CloseHandle(s)%0A%09%09var n uint32%0A%09%09sendRecvMsgFunc.err = WSAIoctl(s,%0A%09%09%09SIO_GET_EXTENSION_FUNCTION_POINTER,%0A%09%09%09(*byte)(unsafe.Pointer(&WSAID_WSARECVMSG)),%0A%09%09%09uint32(unsafe.Sizeof(WSAID_WSARECVMSG)),%0A%09%09%09(*byte)(unsafe.Pointer(&sendRecvMsgFunc.recvAddr)),%0A%09%09%09uint32(unsafe.Sizeof(sendRecvMsgFunc.recvAddr)),%0A%09%09%09&n, nil, 0)%0A%09%09if sendRecvMsgFunc.err != nil %7B%0A%09%09%09return%0A%09%09%7D%0A%09%09sendRecvMsgFunc.err = WSAIoctl(s,%0A%09%09%09SIO_GET_EXTENSION_FUNCTION_POINTER,%0A%09%09%09(*byte)(unsafe.Pointer(&WSAID_WSASENDMSG)),%0A%09%09%09uint32(unsafe.Sizeof(WSAID_WSASENDMSG)),%0A%09%09%09(*byte)(unsafe.Pointer(&sendRecvMsgFunc.sendAddr)),%0A%09%09%09uint32(unsafe.Sizeof(sendRecvMsgFunc.sendAddr)),%0A%09%09%09&n, nil, 0)%0A%09%7D)%0A%09return sendRecvMsgFunc.err%0A%7D%0A%0Afunc WSASendMsg(fd Handle, msg *WSAMsg, flags uint32, bytesSent *uint32, overlapped *Overlapped, croutine *byte) error %7B%0A%09err := loadWSASendRecvMsg()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall6(sendRecvMsgFunc.sendAddr, 6, uintptr(fd), uintptr(unsafe.Pointer(msg)), uintptr(flags), uintptr(unsafe.Pointer(bytesSent)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return err%0A%7D%0A%0Afunc WSARecvMsg(fd Handle, msg *WSAMsg, bytesReceived *uint32, overlapped *Overlapped, croutine *byte) error %7B%0A%09err := loadWSASendRecvMsg()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall6(sendRecvMsgFunc.recvAddr, 5, uintptr(fd), uintptr(unsafe.Pointer(msg)), uintptr(unsafe.Pointer(bytesReceived)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return err%0A%7D%0A%0A// Invented structures to support what package os expects.%0Atype Rusage struct %7B%0A%09CreationTime Filetime%0A%09ExitTime     Filetime%0A%09KernelTime   Filetime%0A%09UserTime     Filetime%0A%7D%0A%0Atype WaitStatus struct %7B%0A%09ExitCode uint32%0A%7D%0A%0Afunc (w WaitStatus) Exited() bool %7B return true %7D%0A%0Afunc (w WaitStatus) ExitStatus() int %7B return int(w.ExitCode) %7D%0A%0Afunc (w WaitStatus) Signal() Signal %7B return -1 %7D%0A%0Afunc (w WaitStatus) CoreDump() bool %7B return false %7D%0A%0Afunc (w WaitStatus) Stopped() bool %7B return false %7D%0A%0Afunc (w WaitStatus) Continued() bool %7B return false %7D%0A%0Afunc (w WaitStatus) StopSignal() Signal %7B return -1 %7D%0A%0Afunc (w WaitStatus) Signaled() bool %7B return false %7D%0A%0Afunc (w WaitStatus) TrapCause() int %7B return -1 %7D%0A%0A// Timespec is an invented structure on Windows, but here for%0A// consistency with the corresponding package for other operating systems.%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Afunc TimespecToNsec(ts Timespec) int64 %7B return int64(ts.Sec)*1e9 + int64(ts.Nsec) %7D%0A%0Afunc NsecToTimespec(nsec int64) (ts Timespec) %7B%0A%09ts.Sec = nsec / 1e9%0A%09ts.Nsec = nsec %25 1e9%0A%09return%0A%7D%0A%0A// TODO(brainman): fix all needed for net%0A%0Afunc Accept(fd Handle) (nfd Handle, sa Sockaddr, err error) %7B return 0, nil, syscall.EWINDOWS %7D%0Afunc Recvfrom(fd Handle, p %5B%5Dbyte, flags int) (n int, from Sockaddr, err error) %7B%0A%09return 0, nil, syscall.EWINDOWS%0A%7D%0Afunc Sendto(fd Handle, p %5B%5Dbyte, flags int, to Sockaddr) (err error)       %7B return syscall.EWINDOWS %7D%0Afunc SetsockoptTimeval(fd Handle, level, opt int, tv *Timeval) (err error) %7B return syscall.EWINDOWS %7D%0A%0A// The Linger struct is wrong but we only noticed after Go 1.%0A// sysLinger is the real system call structure.%0A%0A// BUG(brainman): The definition of Linger is not appropriate for direct use%0A// with Setsockopt and Getsockopt.%0A// Use SetsockoptLinger instead.%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype sysLinger struct %7B%0A%09Onoff  uint16%0A%09Linger uint16%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Afunc GetsockoptInt(fd Handle, level, opt int) (int, error) %7B return -1, syscall.EWINDOWS %7D%0A%0Afunc SetsockoptLinger(fd Handle, level, opt int, l *Linger) (err error) %7B%0A%09sys := sysLinger%7BOnoff: uint16(l.Onoff), Linger: uint16(l.Linger)%7D%0A%09return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&sys)), int32(unsafe.Sizeof(sys)))%0A%7D%0A%0Afunc SetsockoptInet4Addr(fd Handle, level, opt int, value %5B4%5Dbyte) (err error) %7B%0A%09return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&value%5B0%5D)), 4)%0A%7D%0Afunc SetsockoptIPMreq(fd Handle, level, opt int, mreq *IPMreq) (err error) %7B%0A%09return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(mreq)), int32(unsafe.Sizeof(*mreq)))%0A%7D%0Afunc SetsockoptIPv6Mreq(fd Handle, level, opt int, mreq *IPv6Mreq) (err error) %7B%0A%09return syscall.EWINDOWS%0A%7D%0A%0Afunc Getpid() (pid int) %7B return int(getCurrentProcessId()) %7D%0A%0Afunc FindFirstFile(name *uint16, data *Win32finddata) (handle Handle, err error) %7B%0A%09// NOTE(rsc): The Win32finddata struct is wrong for the system call:%0A%09// the two paths are each one uint16 short. Use the correct struct,%0A%09// a win32finddata1, and then copy the results out.%0A%09// There is no loss of expressivity here, because the final%0A%09// uint16, if it is used, is supposed to be a NUL, and Go doesn't need that.%0A%09// For Go 1.1, we might avoid the allocation of win32finddata1 here%0A%09// by adding a final Bug %5B2%5Duint16 field to the struct and then%0A%09// adjusting the fields in the result directly.%0A%09var data1 win32finddata1%0A%09handle, err = findFirstFile1(name, &data1)%0A%09if err == nil %7B%0A%09%09copyFindData(data, &data1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindNextFile(handle Handle, data *Win32finddata) (err error) %7B%0A%09var data1 win32finddata1%0A%09err = findNextFile1(handle, &data1)%0A%09if err == nil %7B%0A%09%09copyFindData(data, &data1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getProcessEntry(pid int) (*ProcessEntry32, error) %7B%0A%09snapshot, err := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09defer CloseHandle(snapshot)%0A%09var procEntry ProcessEntry32%0A%09procEntry.Size = uint32(unsafe.Sizeof(procEntry))%0A%09if err = Process32First(snapshot, &procEntry); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09for %7B%0A%09%09if procEntry.ProcessID == uint32(pid) %7B%0A%09%09%09return &procEntry, nil%0A%09%09%7D%0A%09%09err = Process32Next(snapshot, &procEntry)%0A%09%09if err != nil %7B%0A%09%09%09return nil, err%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Afunc Getppid() (ppid int) %7B%0A%09pe, err := getProcessEntry(Getpid())%0A%09if err != nil %7B%0A%09%09return -1%0A%09%7D%0A%09return int(pe.ParentProcessID)%0A%7D%0A%0A// TODO(brainman): fix all needed for os%0Afunc Fchdir(fd Handle) (err error)             %7B return syscall.EWINDOWS %7D%0Afunc Link(oldpath, newpath string) (err error) %7B return syscall.EWINDOWS %7D%0Afunc Symlink(path, link string) (err error)    %7B return syscall.EWINDOWS %7D%0A%0Afunc Fchmod(fd Handle, mode uint32) (err error)        %7B return syscall.EWINDOWS %7D%0Afunc Chown(path string, uid int, gid int) (err error)  %7B return syscall.EWINDOWS %7D%0Afunc Lchown(path string, uid int, gid int) (err error) %7B return syscall.EWINDOWS %7D%0Afunc Fchown(fd Handle, uid int, gid int) (err error)   %7B return syscall.EWINDOWS %7D%0A%0Afunc Getuid() (uid int)                  %7B return -1 %7D%0Afunc Geteuid() (euid int)                %7B return -1 %7D%0Afunc Getgid() (gid int)                  %7B return -1 %7D%0Afunc Getegid() (egid int)                %7B return -1 %7D%0Afunc Getgroups() (gids %5B%5Dint, err error) %7B return nil, syscall.EWINDOWS %7D%0A%0Atype Signal int%0A%0Afunc (s Signal) Signal() %7B%7D%0A%0Afunc (s Signal) String() string %7B%0A%09if 0 %3C= s && int(s) %3C len(signals) %7B%0A%09%09str := signals%5Bs%5D%0A%09%09if str != %22%22 %7B%0A%09%09%09return str%0A%09%09%7D%0A%09%7D%0A%09return %22signal %22 + itoa(int(s))%0A%7D%0A%0Afunc LoadCreateSymbolicLink() error %7B%0A%09return procCreateSymbolicLinkW.Find()%0A%7D%0A%0A// Readlink returns the destination of the named symbolic link.%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09fd, err := CreateFile(StringToUTF16Ptr(path), GENERIC_READ, 0, nil, OPEN_EXISTING,%0A%09%09FILE_FLAG_OPEN_REPARSE_POINT%7CFILE_FLAG_BACKUP_SEMANTICS, 0)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%09defer CloseHandle(fd)%0A%0A%09rdbbuf := make(%5B%5Dbyte, MAXIMUM_REPARSE_DATA_BUFFER_SIZE)%0A%09var bytesReturned uint32%0A%09err = DeviceIoControl(fd, FSCTL_GET_REPARSE_POINT, nil, 0, &rdbbuf%5B0%5D, uint32(len(rdbbuf)), &bytesReturned, nil)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%0A%09rdb := (*reparseDataBuffer)(unsafe.Pointer(&rdbbuf%5B0%5D))%0A%09var s string%0A%09switch rdb.ReparseTag %7B%0A%09case IO_REPARSE_TAG_SYMLINK:%0A%09%09data := (*symbolicLinkReparseBuffer)(unsafe.Pointer(&rdb.reparseBuffer))%0A%09%09p := (*%5B0xffff%5Duint16)(unsafe.Pointer(&data.PathBuffer%5B0%5D))%0A%09%09s = UTF16ToString(p%5Bdata.PrintNameOffset/2 : (data.PrintNameLength-data.PrintNameOffset)/2%5D)%0A%09case IO_REPARSE_TAG_MOUNT_POINT:%0A%09%09data := (*mountPointReparseBuffer)(unsafe.Pointer(&rdb.reparseBuffer))%0A%09%09p := (*%5B0xffff%5Duint16)(unsafe.Pointer(&data.PathBuffer%5B0%5D))%0A%09%09s = UTF16ToString(p%5Bdata.PrintNameOffset/2 : (data.PrintNameLength-data.PrintNameOffset)/2%5D)%0A%09default:%0A%09%09// the path is not a symlink or junction but another type of reparse%0A%09%09// point%0A%09%09return -1, syscall.ENOENT%0A%09%7D%0A%09n = copy(buf, %5B%5Dbyte(s))%0A%0A%09return n, nil%0A%7D%0A
- f f7e8e82ab05f785d5b8f2c6843fddcc0324722f9d332c6f9fc8b1ca32c04edec vendor/golang.org/x/sys/windows/types_windows.go
+ f 35bfa1de8a87825e0db0adc8aa48b116be18d66a03bcc033445c8b2ed164ddaf vendor/golang.org/x/sys/windows/types_windows.go
dmppatch 3
@@ -173,32709 +173,4 @@
 ows%0A
-%0Aimport %22syscall%22%0A%0Aconst (%0A%09// Windows errors.%0A%09ERROR_FILE_NOT_FOUND         syscall.Errno = 2%0A%09ERROR_PATH_NOT_FOUND         syscall.Errno = 3%0A%09ERROR_ACCESS_DENIED          syscall.Errno = 5%0A%09ERROR_NO_MORE_FILES          syscall.Errno = 18%0A%09ERROR_HANDLE_EOF             syscall.Errno = 38%0A%09ERROR_NETNAME_DELETED        syscall.Errno = 64%0A%09ERROR_FILE_EXISTS            syscall.Errno = 80%0A%09ERROR_BROKEN_PIPE            syscall.Errno = 109%0A%09ERROR_BUFFER_OVERFLOW        syscall.Errno = 111%0A%09ERROR_INSUFFICIENT_BUFFER    syscall.Errno = 122%0A%09ERROR_MOD_NOT_FOUND          syscall.Errno = 126%0A%09ERROR_PROC_NOT_FOUND         syscall.Errno = 127%0A%09ERROR_ALREADY_EXISTS         syscall.Errno = 183%0A%09ERROR_ENVVAR_NOT_FOUND       syscall.Errno = 203%0A%09ERROR_MORE_DATA              syscall.Errno = 234%0A%09ERROR_OPERATION_ABORTED      syscall.Errno = 995%0A%09ERROR_IO_PENDING             syscall.Errno = 997%0A%09ERROR_SERVICE_SPECIFIC_ERROR syscall.Errno = 1066%0A%09ERROR_NOT_FOUND              syscall.Errno = 1168%0A%09ERROR_PRIVILEGE_NOT_HELD     syscall.Errno = 1314%0A%09WSAEACCES                    syscall.Errno = 10013%0A%09WSAEMSGSIZE                  syscall.Errno = 10040%0A%09WSAECONNRESET                syscall.Errno = 10054%0A)%0A%0Aconst (%0A%09// Invented values to support what package os expects.%0A%09O_RDONLY   = 0x00000%0A%09O_WRONLY   = 0x00001%0A%09O_RDWR     = 0x00002%0A%09O_CREAT    = 0x00040%0A%09O_EXCL     = 0x00080%0A%09O_NOCTTY   = 0x00100%0A%09O_TRUNC    = 0x00200%0A%09O_NONBLOCK = 0x00800%0A%09O_APPEND   = 0x00400%0A%09O_SYNC     = 0x01000%0A%09O_ASYNC    = 0x02000%0A%09O_CLOEXEC  = 0x80000%0A)%0A%0Aconst (%0A%09// More invented values for signals%0A%09SIGHUP  = Signal(0x1)%0A%09SIGINT  = Signal(0x2)%0A%09SIGQUIT = Signal(0x3)%0A%09SIGILL  = Signal(0x4)%0A%09SIGTRAP = Signal(0x5)%0A%09SIGABRT = Signal(0x6)%0A%09SIGBUS  = Signal(0x7)%0A%09SIGFPE  = Signal(0x8)%0A%09SIGKILL = Signal(0x9)%0A%09SIGSEGV = Signal(0xb)%0A%09SIGPIPE = Signal(0xd)%0A%09SIGALRM = Signal(0xe)%0A%09SIGTERM = Signal(0xf)%0A)%0A%0Avar signals = %5B...%5Dstring%7B%0A%091:  %22hangup%22,%0A%092:  %22interrupt%22,%0A%093:  %22quit%22,%0A%094:  %22illegal instruction%22,%0A%095:  %22trace/breakpoint trap%22,%0A%096:  %22aborted%22,%0A%097:  %22bus error%22,%0A%098:  %22floating point exception%22,%0A%099:  %22killed%22,%0A%0910: %22user defined signal 1%22,%0A%0911: %22segmentation fault%22,%0A%0912: %22user defined signal 2%22,%0A%0913: %22broken pipe%22,%0A%0914: %22alarm clock%22,%0A%0915: %22terminated%22,%0A%7D%0A%0Aconst (%0A%09GENERIC_READ    = 0x80000000%0A%09GENERIC_WRITE   = 0x40000000%0A%09GENERIC_EXECUTE = 0x20000000%0A%09GENERIC_ALL     = 0x10000000%0A%0A%09FILE_LIST_DIRECTORY   = 0x00000001%0A%09FILE_APPEND_DATA      = 0x00000004%0A%09FILE_WRITE_ATTRIBUTES = 0x00000100%0A%0A%09FILE_SHARE_READ              = 0x00000001%0A%09FILE_SHARE_WRITE             = 0x00000002%0A%09FILE_SHARE_DELETE            = 0x00000004%0A%09FILE_ATTRIBUTE_READONLY      = 0x00000001%0A%09FILE_ATTRIBUTE_HIDDEN        = 0x00000002%0A%09FILE_ATTRIBUTE_SYSTEM        = 0x00000004%0A%09FILE_ATTRIBUTE_DIRECTORY     = 0x00000010%0A%09FILE_ATTRIBUTE_ARCHIVE       = 0x00000020%0A%09FILE_ATTRIBUTE_NORMAL        = 0x00000080%0A%09FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400%0A%0A%09INVALID_FILE_ATTRIBUTES = 0xffffffff%0A%0A%09CREATE_NEW        = 1%0A%09CREATE_ALWAYS     = 2%0A%09OPEN_EXISTING     = 3%0A%09OPEN_ALWAYS       = 4%0A%09TRUNCATE_EXISTING = 5%0A%0A%09FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000%0A%09FILE_FLAG_BACKUP_SEMANTICS   = 0x02000000%0A%09FILE_FLAG_OVERLAPPED         = 0x40000000%0A%0A%09HANDLE_FLAG_INHERIT    = 0x00000001%0A%09STARTF_USESTDHANDLES   = 0x00000100%0A%09STARTF_USESHOWWINDOW   = 0x00000001%0A%09DUPLICATE_CLOSE_SOURCE = 0x00000001%0A%09DUPLICATE_SAME_ACCESS  = 0x00000002%0A%0A%09STD_INPUT_HANDLE  = -10 & (1%3C%3C32 - 1)%0A%09STD_OUTPUT_HANDLE = -11 & (1%3C%3C32 - 1)%0A%09STD_ERROR_HANDLE  = -12 & (1%3C%3C32 - 1)%0A%0A%09FILE_BEGIN   = 0%0A%09FILE_CURRENT = 1%0A%09FILE_END     = 2%0A%0A%09LANG_ENGLISH       = 0x09%0A%09SUBLANG_ENGLISH_US = 0x01%0A%0A%09FORMAT_MESSAGE_ALLOCATE_BUFFER = 256%0A%09FORMAT_MESSAGE_IGNORE_INSERTS  = 512%0A%09FORMAT_MESSAGE_FROM_STRING     = 1024%0A%09FORMAT_MESSAGE_FROM_HMODULE    = 2048%0A%09FORMAT_MESSAGE_FROM_SYSTEM     = 4096%0A%09FORMAT_MESSAGE_ARGUMENT_ARRAY  = 8192%0A%09FORMAT_MESSAGE_MAX_WIDTH_MASK  = 255%0A%0A%09MAX_PATH      = 260%0A%09MAX_LONG_PATH = 32768%0A%0A%09MAX_COMPUTERNAME_LENGTH = 15%0A%0A%09TIME_ZONE_ID_UNKNOWN  = 0%0A%09TIME_ZONE_ID_STANDARD = 1%0A%0A%09TIME_ZONE_ID_DAYLIGHT = 2%0A%09IGNORE                = 0%0A%09INFINITE              = 0xffffffff%0A%0A%09WAIT_TIMEOUT   = 258%0A%09WAIT_ABANDONED = 0x00000080%0A%09WAIT_OBJECT_0  = 0x00000000%0A%09WAIT_FAILED    = 0xFFFFFFFF%0A%0A%09PROCESS_TERMINATE         = 1%0A%09PROCESS_QUERY_INFORMATION = 0x00000400%0A%09SYNCHRONIZE               = 0x00100000%0A%0A%09FILE_MAP_COPY    = 0x01%0A%09FILE_MAP_WRITE   = 0x02%0A%09FILE_MAP_READ    = 0x04%0A%09FILE_MAP_EXECUTE = 0x20%0A%0A%09CTRL_C_EVENT     = 0%0A%09CTRL_BREAK_EVENT = 1%0A%0A%09// Windows reserves errors %3E= 1%3C%3C29 for application use.%0A%09APPLICATION_ERROR = 1 %3C%3C 29%0A)%0A%0Aconst (%0A%09// Process creation flags.%0A%09CREATE_BREAKAWAY_FROM_JOB        = 0x01000000%0A%09CREATE_DEFAULT_ERROR_MODE        = 0x04000000%0A%09CREATE_NEW_CONSOLE               = 0x00000010%0A%09CREATE_NEW_PROCESS_GROUP         = 0x00000200%0A%09CREATE_NO_WINDOW                 = 0x08000000%0A%09CREATE_PROTECTED_PROCESS         = 0x00040000%0A%09CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000%0A%09CREATE_SEPARATE_WOW_VDM          = 0x00000800%0A%09CREATE_SHARED_WOW_VDM            = 0x00001000%0A%09CREATE_SUSPENDED                 = 0x00000004%0A%09CREATE_UNICODE_ENVIRONMENT       = 0x00000400%0A%09DEBUG_ONLY_THIS_PROCESS          = 0x00000002%0A%09DEBUG_PROCESS                    = 0x00000001%0A%09DETACHED_PROCESS                 = 0x00000008%0A%09EXTENDED_STARTUPINFO_PRESENT     = 0x00080000%0A%09INHERIT_PARENT_AFFINITY          = 0x00010000%0A)%0A%0Aconst (%0A%09// flags for CreateToolhelp32Snapshot%0A%09TH32CS_SNAPHEAPLIST = 0x01%0A%09TH32CS_SNAPPROCESS  = 0x02%0A%09TH32CS_SNAPTHREAD   = 0x04%0A%09TH32CS_SNAPMODULE   = 0x08%0A%09TH32CS_SNAPMODULE32 = 0x10%0A%09TH32CS_SNAPALL      = TH32CS_SNAPHEAPLIST %7C TH32CS_SNAPMODULE %7C TH32CS_SNAPPROCESS %7C TH32CS_SNAPTHREAD%0A%09TH32CS_INHERIT      = 0x80000000%0A)%0A%0Aconst (%0A%09// filters for ReadDirectoryChangesW%0A%09FILE_NOTIFY_CHANGE_FILE_NAME   = 0x001%0A%09FILE_NOTIFY_CHANGE_DIR_NAME    = 0x002%0A%09FILE_NOTIFY_CHANGE_ATTRIBUTES  = 0x004%0A%09FILE_NOTIFY_CHANGE_SIZE        = 0x008%0A%09FILE_NOTIFY_CHANGE_LAST_WRITE  = 0x010%0A%09FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x020%0A%09FILE_NOTIFY_CHANGE_CREATION    = 0x040%0A%09FILE_NOTIFY_CHANGE_SECURITY    = 0x100%0A)%0A%0Aconst (%0A%09// do not reorder%0A%09FILE_ACTION_ADDED = iota + 1%0A%09FILE_ACTION_REMOVED%0A%09FILE_ACTION_MODIFIED%0A%09FILE_ACTION_RENAMED_OLD_NAME%0A%09FILE_ACTION_RENAMED_NEW_NAME%0A)%0A%0Aconst (%0A%09// wincrypt.h%0A%09PROV_RSA_FULL                    = 1%0A%09PROV_RSA_SIG                     = 2%0A%09PROV_DSS                         = 3%0A%09PROV_FORTEZZA                    = 4%0A%09PROV_MS_EXCHANGE                 = 5%0A%09PROV_SSL                         = 6%0A%09PROV_RSA_SCHANNEL                = 12%0A%09PROV_DSS_DH                      = 13%0A%09PROV_EC_ECDSA_SIG                = 14%0A%09PROV_EC_ECNRA_SIG                = 15%0A%09PROV_EC_ECDSA_FULL               = 16%0A%09PROV_EC_ECNRA_FULL               = 17%0A%09PROV_DH_SCHANNEL                 = 18%0A%09PROV_SPYRUS_LYNKS                = 20%0A%09PROV_RNG                         = 21%0A%09PROV_INTEL_SEC                   = 22%0A%09PROV_REPLACE_OWF                 = 23%0A%09PROV_RSA_AES                     = 24%0A%09CRYPT_VERIFYCONTEXT              = 0xF0000000%0A%09CRYPT_NEWKEYSET                  = 0x00000008%0A%09CRYPT_DELETEKEYSET               = 0x00000010%0A%09CRYPT_MACHINE_KEYSET             = 0x00000020%0A%09CRYPT_SILENT                     = 0x00000040%0A%09CRYPT_DEFAULT_CONTAINER_OPTIONAL = 0x00000080%0A%0A%09USAGE_MATCH_TYPE_AND = 0%0A%09USAGE_MATCH_TYPE_OR  = 1%0A%0A%09X509_ASN_ENCODING   = 0x00000001%0A%09PKCS_7_ASN_ENCODING = 0x00010000%0A%0A%09CERT_STORE_PROV_MEMORY = 2%0A%0A%09CERT_STORE_ADD_ALWAYS = 4%0A%0A%09CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 0x00000004%0A%0A%09CERT_TRUST_NO_ERROR                          = 0x00000000%0A%09CERT_TRUST_IS_NOT_TIME_VALID                 = 0x00000001%0A%09CERT_TRUST_IS_REVOKED                        = 0x00000004%0A%09CERT_TRUST_IS_NOT_SIGNATURE_VALID            = 0x00000008%0A%09CERT_TRUST_IS_NOT_VALID_FOR_USAGE            = 0x00000010%0A%09CERT_TRUST_IS_UNTRUSTED_ROOT                 = 0x00000020%0A%09CERT_TRUST_REVOCATION_STATUS_UNKNOWN         = 0x00000040%0A%09CERT_TRUST_IS_CYCLIC                         = 0x00000080%0A%09CERT_TRUST_INVALID_EXTENSION                 = 0x00000100%0A%09CERT_TRUST_INVALID_POLICY_CONSTRAINTS        = 0x00000200%0A%09CERT_TRUST_INVALID_BASIC_CONSTRAINTS         = 0x00000400%0A%09CERT_TRUST_INVALID_NAME_CONSTRAINTS          = 0x00000800%0A%09CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = 0x00001000%0A%09CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT   = 0x00002000%0A%09CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = 0x00004000%0A%09CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT      = 0x00008000%0A%09CERT_TRUST_IS_OFFLINE_REVOCATION             = 0x01000000%0A%09CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY          = 0x02000000%0A%09CERT_TRUST_IS_EXPLICIT_DISTRUST              = 0x04000000%0A%09CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT    = 0x08000000%0A%0A%09CERT_CHAIN_POLICY_BASE              = 1%0A%09CERT_CHAIN_POLICY_AUTHENTICODE      = 2%0A%09CERT_CHAIN_POLICY_AUTHENTICODE_TS   = 3%0A%09CERT_CHAIN_POLICY_SSL               = 4%0A%09CERT_CHAIN_POLICY_BASIC_CONSTRAINTS = 5%0A%09CERT_CHAIN_POLICY_NT_AUTH           = 6%0A%09CERT_CHAIN_POLICY_MICROSOFT_ROOT    = 7%0A%09CERT_CHAIN_POLICY_EV                = 8%0A%0A%09CERT_E_EXPIRED       = 0x800B0101%0A%09CERT_E_ROLE          = 0x800B0103%0A%09CERT_E_PURPOSE       = 0x800B0106%0A%09CERT_E_UNTRUSTEDROOT = 0x800B0109%0A%09CERT_E_CN_NO_MATCH   = 0x800B010F%0A%0A%09AUTHTYPE_CLIENT = 1%0A%09AUTHTYPE_SERVER = 2%0A)%0A%0Avar (%0A%09OID_PKIX_KP_SERVER_AUTH = %5B%5Dbyte(%221.3.6.1.5.5.7.3.1%5Cx00%22)%0A%09OID_SERVER_GATED_CRYPTO = %5B%5Dbyte(%221.3.6.1.4.1.311.10.3.3%5Cx00%22)%0A%09OID_SGC_NETSCAPE        = %5B%5Dbyte(%222.16.840.1.113730.4.1%5Cx00%22)%0A)%0A%0A// Invented values to support what package os expects.%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Afunc (tv *Timeval) Nanoseconds() int64 %7B%0A%09return (int64(tv.Sec)*1e6 + int64(tv.Usec)) * 1e3%0A%7D%0A%0Afunc NsecToTimeval(nsec int64) (tv Timeval) %7B%0A%09tv.Sec = int32(nsec / 1e9)%0A%09tv.Usec = int32(nsec %25 1e9 / 1e3)%0A%09return%0A%7D%0A%0Atype SecurityAttributes struct %7B%0A%09Length             uint32%0A%09SecurityDescriptor uintptr%0A%09InheritHandle      uint32%0A%7D%0A%0Atype Overlapped struct %7B%0A%09Internal     uintptr%0A%09InternalHigh uintptr%0A%09Offset       uint32%0A%09OffsetHigh   uint32%0A%09HEvent       Handle%0A%7D%0A%0Atype FileNotifyInformation struct %7B%0A%09NextEntryOffset uint32%0A%09Action          uint32%0A%09FileNameLength  uint32%0A%09FileName        uint16%0A%7D%0A%0Atype Filetime struct %7B%0A%09LowDateTime  uint32%0A%09HighDateTime uint32%0A%7D%0A%0A// Nanoseconds returns Filetime ft in nanoseconds%0A// since Epoch (00:00:00 UTC, January 1, 1970).%0Afunc (ft *Filetime) Nanoseconds() int64 %7B%0A%09// 100-nanosecond intervals since January 1, 1601%0A%09nsec := int64(ft.HighDateTime)%3C%3C32 + int64(ft.LowDateTime)%0A%09// change starting time to the Epoch (00:00:00 UTC, January 1, 1970)%0A%09nsec -= 116444736000000000%0A%09// convert into nanoseconds%0A%09nsec *= 100%0A%09return nsec%0A%7D%0A%0Afunc NsecToFiletime(nsec int64) (ft Filetime) %7B%0A%09// convert into 100-nanosecond%0A%09nsec /= 100%0A%09// change starting time to January 1, 1601%0A%09nsec += 116444736000000000%0A%09// split into high / low%0A%09ft.LowDateTime = uint32(nsec & 0xffffffff)%0A%09ft.HighDateTime = uint32(nsec %3E%3E 32 & 0xffffffff)%0A%09return ft%0A%7D%0A%0Atype Win32finddata struct %7B%0A%09FileAttributes    uint32%0A%09CreationTime      Filetime%0A%09LastAccessTime    Filetime%0A%09LastWriteTime     Filetime%0A%09FileSizeHigh      uint32%0A%09FileSizeLow       uint32%0A%09Reserved0         uint32%0A%09Reserved1         uint32%0A%09FileName          %5BMAX_PATH - 1%5Duint16%0A%09AlternateFileName %5B13%5Duint16%0A%7D%0A%0A// This is the actual system call structure.%0A// Win32finddata is what we committed to in Go 1.%0Atype win32finddata1 struct %7B%0A%09FileAttributes    uint32%0A%09CreationTime      Filetime%0A%09LastAccessTime    Filetime%0A%09LastWriteTime     Filetime%0A%09FileSizeHigh      uint32%0A%09FileSizeLow       uint32%0A%09Reserved0         uint32%0A%09Reserved1         uint32%0A%09FileName          %5BMAX_PATH%5Duint16%0A%09AlternateFileName %5B14%5Duint16%0A%7D%0A%0Afunc copyFindData(dst *Win32finddata, src *win32finddata1) %7B%0A%09dst.FileAttributes = src.FileAttributes%0A%09dst.CreationTime = src.CreationTime%0A%09dst.LastAccessTime = src.LastAccessTime%0A%09dst.LastWriteTime = src.LastWriteTime%0A%09dst.FileSizeHigh = src.FileSizeHigh%0A%09dst.FileSizeLow = src.FileSizeLow%0A%09dst.Reserved0 = src.Reserved0%0A%09dst.Reserved1 = src.Reserved1%0A%0A%09// The src is 1 element bigger than dst, but it must be NUL.%0A%09copy(dst.FileName%5B:%5D, src.FileName%5B:%5D)%0A%09copy(dst.AlternateFileName%5B:%5D, src.AlternateFileName%5B:%5D)%0A%7D%0A%0Atype ByHandleFileInformation struct %7B%0A%09FileAttributes     uint32%0A%09CreationTime       Filetime%0A%09LastAccessTime     Filetime%0A%09LastWriteTime      Filetime%0A%09VolumeSerialNumber uint32%0A%09FileSizeHigh       uint32%0A%09FileSizeLow        uint32%0A%09NumberOfLinks      uint32%0A%09FileIndexHigh      uint32%0A%09FileIndexLow       uint32%0A%7D%0A%0Aconst (%0A%09GetFileExInfoStandard = 0%0A%09GetFileExMaxInfoLevel = 1%0A)%0A%0Atype Win32FileAttributeData struct %7B%0A%09FileAttributes uint32%0A%09CreationTime   Filetime%0A%09LastAccessTime Filetime%0A%09LastWriteTime  Filetime%0A%09FileSizeHigh   uint32%0A%09FileSizeLow    uint32%0A%7D%0A%0A// ShowWindow constants%0Aconst (%0A%09// winuser.h%0A%09SW_HIDE            = 0%0A%09SW_NORMAL          = 1%0A%09SW_SHOWNORMAL      = 1%0A%09SW_SHOWMINIMIZED   = 2%0A%09SW_SHOWMAXIMIZED   = 3%0A%09SW_MAXIMIZE        = 3%0A%09SW_SHOWNOACTIVATE  = 4%0A%09SW_SHOW            = 5%0A%09SW_MINIMIZE        = 6%0A%09SW_SHOWMINNOACTIVE = 7%0A%09SW_SHOWNA          = 8%0A%09SW_RESTORE         = 9%0A%09SW_SHOWDEFAULT     = 10%0A%09SW_FORCEMINIMIZE   = 11%0A)%0A%0Atype StartupInfo struct %7B%0A%09Cb            uint32%0A%09_             *uint16%0A%09Desktop       *uint16%0A%09Title         *uint16%0A%09X             uint32%0A%09Y             uint32%0A%09XSize         uint32%0A%09YSize         uint32%0A%09XCountChars   uint32%0A%09YCountChars   uint32%0A%09FillAttribute uint32%0A%09Flags         uint32%0A%09ShowWindow    uint16%0A%09_             uint16%0A%09_             *byte%0A%09StdInput      Handle%0A%09StdOutput     Handle%0A%09StdErr        Handle%0A%7D%0A%0Atype ProcessInformation struct %7B%0A%09Process   Handle%0A%09Thread    Handle%0A%09ProcessId uint32%0A%09ThreadId  uint32%0A%7D%0A%0Atype ProcessEntry32 struct %7B%0A%09Size            uint32%0A%09Usage           uint32%0A%09ProcessID       uint32%0A%09DefaultHeapID   uintptr%0A%09ModuleID        uint32%0A%09Threads         uint32%0A%09ParentProcessID uint32%0A%09PriClassBase    int32%0A%09Flags           uint32%0A%09ExeFile         %5BMAX_PATH%5Duint16%0A%7D%0A%0Atype Systemtime struct %7B%0A%09Year         uint16%0A%09Month        uint16%0A%09DayOfWeek    uint16%0A%09Day          uint16%0A%09Hour         uint16%0A%09Minute       uint16%0A%09Second       uint16%0A%09Milliseconds uint16%0A%7D%0A%0Atype Timezoneinformation struct %7B%0A%09Bias         int32%0A%09StandardName %5B32%5Duint16%0A%09StandardDate Systemtime%0A%09StandardBias int32%0A%09DaylightName %5B32%5Duint16%0A%09DaylightDate Systemtime%0A%09DaylightBias int32%0A%7D%0A%0A// Socket related.%0A%0Aconst (%0A%09AF_UNSPEC  = 0%0A%09AF_UNIX    = 1%0A%09AF_INET    = 2%0A%09AF_INET6   = 23%0A%09AF_NETBIOS = 17%0A%0A%09SOCK_STREAM    = 1%0A%09SOCK_DGRAM     = 2%0A%09SOCK_RAW       = 3%0A%09SOCK_SEQPACKET = 5%0A%0A%09IPPROTO_IP   = 0%0A%09IPPROTO_IPV6 = 0x29%0A%09IPPROTO_TCP  = 6%0A%09IPPROTO_UDP  = 17%0A%0A%09SOL_SOCKET                = 0xffff%0A%09SO_REUSEADDR              = 4%0A%09SO_KEEPALIVE              = 8%0A%09SO_DONTROUTE              = 16%0A%09SO_BROADCAST              = 32%0A%09SO_LINGER                 = 128%0A%09SO_RCVBUF                 = 0x1002%0A%09SO_SNDBUF                 = 0x1001%0A%09SO_UPDATE_ACCEPT_CONTEXT  = 0x700b%0A%09SO_UPDATE_CONNECT_CONTEXT = 0x7010%0A%0A%09IOC_OUT                            = 0x40000000%0A%09IOC_IN                             = 0x80000000%0A%09IOC_VENDOR                         = 0x18000000%0A%09IOC_INOUT                          = IOC_IN %7C IOC_OUT%0A%09IOC_WS2                            = 0x08000000%0A%09SIO_GET_EXTENSION_FUNCTION_POINTER = IOC_INOUT %7C IOC_WS2 %7C 6%0A%09SIO_KEEPALIVE_VALS                 = IOC_IN %7C IOC_VENDOR %7C 4%0A%09SIO_UDP_CONNRESET                  = IOC_IN %7C IOC_VENDOR %7C 12%0A%0A%09// cf. http://support.microsoft.com/default.aspx?scid=kb;en-us;257460%0A%0A%09IP_TOS             = 0x3%0A%09IP_TTL             = 0x4%0A%09IP_MULTICAST_IF    = 0x9%0A%09IP_MULTICAST_TTL   = 0xa%0A%09IP_MULTICAST_LOOP  = 0xb%0A%09IP_ADD_MEMBERSHIP  = 0xc%0A%09IP_DROP_MEMBERSHIP = 0xd%0A%0A%09IPV6_V6ONLY         = 0x1b%0A%09IPV6_UNICAST_HOPS   = 0x4%0A%09IPV6_MULTICAST_IF   = 0x9%0A%09IPV6_MULTICAST_HOPS = 0xa%0A%09IPV6_MULTICAST_LOOP = 0xb%0A%09IPV6_JOIN_GROUP     = 0xc%0A%09IPV6_LEAVE_GROUP    = 0xd%0A%0A%09MSG_OOB       = 0x1%0A%09MSG_PEEK      = 0x2%0A%09MSG_DONTROUTE = 0x4%0A%09MSG_WAITALL   = 0x8%0A%0A%09MSG_TRUNC  = 0x0100%0A%09MSG_CTRUNC = 0x0200%0A%09MSG_BCAST  = 0x0400%0A%09MSG_MCAST  = 0x0800%0A%0A%09SOMAXCONN = 0x7fffffff%0A%0A%09TCP_NODELAY = 1%0A%0A%09SHUT_RD   = 0%0A%09SHUT_WR   = 1%0A%09SHUT_RDWR = 2%0A%0A%09WSADESCRIPTION_LEN = 256%0A%09WSASYS_STATUS_LEN  = 128%0A)%0A%0Atype WSABuf struct %7B%0A%09Len uint32%0A%09Buf *byte%0A%7D%0A%0Atype WSAMsg struct %7B%0A%09Name        *syscall.RawSockaddrAny%0A%09Namelen     int32%0A%09Buffers     *WSABuf%0A%09BufferCount uint32%0A%09Control     WSABuf%0A%09Flags       uint32%0A%7D%0A%0A// Invented values to support what package os expects.%0Aconst (%0A%09S_IFMT   = 0x1f000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWRITE = 0x80%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Aconst (%0A%09FILE_TYPE_CHAR    = 0x0002%0A%09FILE_TYPE_DISK    = 0x0001%0A%09FILE_TYPE_PIPE    = 0x0003%0A%09FILE_TYPE_REMOTE  = 0x8000%0A%09FILE_TYPE_UNKNOWN = 0x0000%0A)%0A%0Atype Hostent struct %7B%0A%09Name     *byte%0A%09Aliases  **byte%0A%09AddrType uint16%0A%09Length   uint16%0A%09AddrList **byte%0A%7D%0A%0Atype Protoent struct %7B%0A%09Name    *byte%0A%09Aliases **byte%0A%09Proto   uint16%0A%7D%0A%0Aconst (%0A%09DNS_TYPE_A       = 0x0001%0A%09DNS_TYPE_NS      = 0x0002%0A%09DNS_TYPE_MD      = 0x0003%0A%09DNS_TYPE_MF      = 0x0004%0A%09DNS_TYPE_CNAME   = 0x0005%0A%09DNS_TYPE_SOA     = 0x0006%0A%09DNS_TYPE_MB      = 0x0007%0A%09DNS_TYPE_MG      = 0x0008%0A%09DNS_TYPE_MR      = 0x0009%0A%09DNS_TYPE_NULL    = 0x000a%0A%09DNS_TYPE_WKS     = 0x000b%0A%09DNS_TYPE_PTR     = 0x000c%0A%09DNS_TYPE_HINFO   = 0x000d%0A%09DNS_TYPE_MINFO   = 0x000e%0A%09DNS_TYPE_MX      = 0x000f%0A%09DNS_TYPE_TEXT    = 0x0010%0A%09DNS_TYPE_RP      = 0x0011%0A%09DNS_TYPE_AFSDB   = 0x0012%0A%09DNS_TYPE_X25     = 0x0013%0A%09DNS_TYPE_ISDN    = 0x0014%0A%09DNS_TYPE_RT      = 0x0015%0A%09DNS_TYPE_NSAP    = 0x0016%0A%09DNS_TYPE_NSAPPTR = 0x0017%0A%09DNS_TYPE_SIG     = 0x0018%0A%09DNS_TYPE_KEY     = 0x0019%0A%09DNS_TYPE_PX      = 0x001a%0A%09DNS_TYPE_GPOS    = 0x001b%0A%09DNS_TYPE_AAAA    = 0x001c%0A%09DNS_TYPE_LOC     = 0x001d%0A%09DNS_TYPE_NXT     = 0x001e%0A%09DNS_TYPE_EID     = 0x001f%0A%09DNS_TYPE_NIMLOC  = 0x0020%0A%09DNS_TYPE_SRV     = 0x0021%0A%09DNS_TYPE_ATMA    = 0x0022%0A%09DNS_TYPE_NAPTR   = 0x0023%0A%09DNS_TYPE_KX      = 0x0024%0A%09DNS_TYPE_CERT    = 0x0025%0A%09DNS_TYPE_A6      = 0x0026%0A%09DNS_TYPE_DNAME   = 0x0027%0A%09DNS_TYPE_SINK    = 0x0028%0A%09DNS_TYPE_OPT     = 0x0029%0A%09DNS_TYPE_DS      = 0x002B%0A%09DNS_TYPE_RRSIG   = 0x002E%0A%09DNS_TYPE_NSEC    = 0x002F%0A%09DNS_TYPE_DNSKEY  = 0x0030%0A%09DNS_TYPE_DHCID   = 0x0031%0A%09DNS_TYPE_UINFO   = 0x0064%0A%09DNS_TYPE_UID     = 0x0065%0A%09DNS_TYPE_GID     = 0x0066%0A%09DNS_TYPE_UNSPEC  = 0x0067%0A%09DNS_TYPE_ADDRS   = 0x00f8%0A%09DNS_TYPE_TKEY    = 0x00f9%0A%09DNS_TYPE_TSIG    = 0x00fa%0A%09DNS_TYPE_IXFR    = 0x00fb%0A%09DNS_TYPE_AXFR    = 0x00fc%0A%09DNS_TYPE_MAILB   = 0x00fd%0A%09DNS_TYPE_MAILA   = 0x00fe%0A%09DNS_TYPE_ALL     = 0x00ff%0A%09DNS_TYPE_ANY     = 0x00ff%0A%09DNS_TYPE_WINS    = 0xff01%0A%09DNS_TYPE_WINSR   = 0xff02%0A%09DNS_TYPE_NBSTAT  = 0xff01%0A)%0A%0Aconst (%0A%09DNS_INFO_NO_RECORDS = 0x251D%0A)%0A%0Aconst (%0A%09// flags inside DNSRecord.Dw%0A%09DnsSectionQuestion   = 0x0000%0A%09DnsSectionAnswer     = 0x0001%0A%09DnsSectionAuthority  = 0x0002%0A%09DnsSectionAdditional = 0x0003%0A)%0A%0Atype DNSSRVData struct %7B%0A%09Target   *uint16%0A%09Priority uint16%0A%09Weight   uint16%0A%09Port     uint16%0A%09Pad      uint16%0A%7D%0A%0Atype DNSPTRData struct %7B%0A%09Host *uint16%0A%7D%0A%0Atype DNSMXData struct %7B%0A%09NameExchange *uint16%0A%09Preference   uint16%0A%09Pad          uint16%0A%7D%0A%0Atype DNSTXTData struct %7B%0A%09StringCount uint16%0A%09StringArray %5B1%5D*uint16%0A%7D%0A%0Atype DNSRecord struct %7B%0A%09Next     *DNSRecord%0A%09Name     *uint16%0A%09Type     uint16%0A%09Length   uint16%0A%09Dw       uint32%0A%09Ttl      uint32%0A%09Reserved uint32%0A%09Data     %5B40%5Dbyte%0A%7D%0A%0Aconst (%0A%09TF_DISCONNECT         = 1%0A%09TF_REUSE_SOCKET       = 2%0A%09TF_WRITE_BEHIND       = 4%0A%09TF_USE_DEFAULT_WORKER = 0%0A%09TF_USE_SYSTEM_THREAD  = 16%0A%09TF_USE_KERNEL_APC     = 32%0A)%0A%0Atype TransmitFileBuffers struct %7B%0A%09Head       uintptr%0A%09HeadLength uint32%0A%09Tail       uintptr%0A%09TailLength uint32%0A%7D%0A%0Aconst (%0A%09IFF_UP           = 1%0A%09IFF_BROADCAST    = 2%0A%09IFF_LOOPBACK     = 4%0A%09IFF_POINTTOPOINT = 8%0A%09IFF_MULTICAST    = 16%0A)%0A%0Aconst SIO_GET_INTERFACE_LIST = 0x4004747F%0A%0A// TODO(mattn): SockaddrGen is union of sockaddr/sockaddr_in/sockaddr_in6_old.%0A// will be fixed to change variable type as suitable.%0A%0Atype SockaddrGen %5B24%5Dbyte%0A%0Atype InterfaceInfo struct %7B%0A%09Flags            uint32%0A%09Address          SockaddrGen%0A%09BroadcastAddress SockaddrGen%0A%09Netmask          SockaddrGen%0A%7D%0A%0Atype IpAddressString struct %7B%0A%09String %5B16%5Dbyte%0A%7D%0A%0Atype IpMaskString IpAddressString%0A%0Atype IpAddrString struct %7B%0A%09Next      *IpAddrString%0A%09IpAddress IpAddressString%0A%09IpMask    IpMaskString%0A%09Context   uint32%0A%7D%0A%0Aconst MAX_ADAPTER_NAME_LENGTH = 256%0Aconst MAX_ADAPTER_DESCRIPTION_LENGTH = 128%0Aconst MAX_ADAPTER_ADDRESS_LENGTH = 8%0A%0Atype IpAdapterInfo struct %7B%0A%09Next                *IpAdapterInfo%0A%09ComboIndex          uint32%0A%09AdapterName         %5BMAX_ADAPTER_NAME_LENGTH + 4%5Dbyte%0A%09Description         %5BMAX_ADAPTER_DESCRIPTION_LENGTH + 4%5Dbyte%0A%09AddressLength       uint32%0A%09Address             %5BMAX_ADAPTER_ADDRESS_LENGTH%5Dbyte%0A%09Index               uint32%0A%09Type                uint32%0A%09DhcpEnabled         uint32%0A%09CurrentIpAddress    *IpAddrString%0A%09IpAddressList       IpAddrString%0A%09GatewayList         IpAddrString%0A%09DhcpServer          IpAddrString%0A%09HaveWins            bool%0A%09PrimaryWinsServer   IpAddrString%0A%09SecondaryWinsServer IpAddrString%0A%09LeaseObtained       int64%0A%09LeaseExpires        int64%0A%7D%0A%0Aconst MAXLEN_PHYSADDR = 8%0Aconst MAX_INTERFACE_NAME_LEN = 256%0Aconst MAXLEN_IFDESCR = 256%0A%0Atype MibIfRow struct %7B%0A%09Name            %5BMAX_INTERFACE_NAME_LEN%5Duint16%0A%09Index           uint32%0A%09Type            uint32%0A%09Mtu             uint32%0A%09Speed           uint32%0A%09PhysAddrLen     uint32%0A%09PhysAddr        %5BMAXLEN_PHYSADDR%5Dbyte%0A%09AdminStatus     uint32%0A%09OperStatus      uint32%0A%09LastChange      uint32%0A%09InOctets        uint32%0A%09InUcastPkts     uint32%0A%09InNUcastPkts    uint32%0A%09InDiscards      uint32%0A%09InErrors        uint32%0A%09InUnknownProtos uint32%0A%09OutOctets       uint32%0A%09OutUcastPkts    uint32%0A%09OutNUcastPkts   uint32%0A%09OutDiscards     uint32%0A%09OutErrors       uint32%0A%09OutQLen         uint32%0A%09DescrLen        uint32%0A%09Descr           %5BMAXLEN_IFDESCR%5Dbyte%0A%7D%0A%0Atype CertContext struct %7B%0A%09EncodingType uint32%0A%09EncodedCert  *byte%0A%09Length       uint32%0A%09CertInfo     uintptr%0A%09Store        Handle%0A%7D%0A%0Atype CertChainContext struct %7B%0A%09Size                       uint32%0A%09TrustStatus                CertTrustStatus%0A%09ChainCount                 uint32%0A%09Chains                     **CertSimpleChain%0A%09LowerQualityChainCount     uint32%0A%09LowerQualityChains         **CertChainContext%0A%09HasRevocationFreshnessTime uint32%0A%09RevocationFreshnessTime    uint32%0A%7D%0A%0Atype CertSimpleChain struct %7B%0A%09Size                       uint32%0A%09TrustStatus                CertTrustStatus%0A%09NumElements                uint32%0A%09Elements                   **CertChainElement%0A%09TrustListInfo              uintptr%0A%09HasRevocationFreshnessTime uint32%0A%09RevocationFreshnessTime    uint32%0A%7D%0A%0Atype CertChainElement struct %7B%0A%09Size              uint32%0A%09CertContext       *CertContext%0A%09TrustStatus       CertTrustStatus%0A%09RevocationInfo    *CertRevocationInfo%0A%09IssuanceUsage     *CertEnhKeyUsage%0A%09ApplicationUsage  *CertEnhKeyUsage%0A%09ExtendedErrorInfo *uint16%0A%7D%0A%0Atype CertRevocationInfo struct %7B%0A%09Size             uint32%0A%09RevocationResult uint32%0A%09RevocationOid    *byte%0A%09OidSpecificInfo  uintptr%0A%09HasFreshnessTime uint32%0A%09FreshnessTime    uint32%0A%09CrlInfo          uintptr // *CertRevocationCrlInfo%0A%7D%0A%0Atype CertTrustStatus struct %7B%0A%09ErrorStatus uint32%0A%09InfoStatus  uint32%0A%7D%0A%0Atype CertUsageMatch struct %7B%0A%09Type  uint32%0A%09Usage CertEnhKeyUsage%0A%7D%0A%0Atype CertEnhKeyUsage struct %7B%0A%09Length           uint32%0A%09UsageIdentifiers **byte%0A%7D%0A%0Atype CertChainPara struct %7B%0A%09Size                         uint32%0A%09RequestedUsage               CertUsageMatch%0A%09RequstedIssuancePolicy       CertUsageMatch%0A%09URLRetrievalTimeout          uint32%0A%09CheckRevocationFreshnessTime uint32%0A%09RevocationFreshnessTime      uint32%0A%09CacheResync                  *Filetime%0A%7D%0A%0Atype CertChainPolicyPara struct %7B%0A%09Size            uint32%0A%09Flags           uint32%0A%09ExtraPolicyPara uintptr%0A%7D%0A%0Atype SSLExtraCertChainPolicyPara struct %7B%0A%09Size       uint32%0A%09AuthType   uint32%0A%09Checks     uint32%0A%09ServerName *uint16%0A%7D%0A%0Atype CertChainPolicyStatus struct %7B%0A%09Size              uint32%0A%09Error             uint32%0A%09ChainIndex        uint32%0A%09ElementIndex      uint32%0A%09ExtraPolicyStatus uintptr%0A%7D%0A%0Aconst (%0A%09// do not reorder%0A%09HKEY_CLASSES_ROOT = 0x80000000 + iota%0A%09HKEY_CURRENT_USER%0A%09HKEY_LOCAL_MACHINE%0A%09HKEY_USERS%0A%09HKEY_PERFORMANCE_DATA%0A%09HKEY_CURRENT_CONFIG%0A%09HKEY_DYN_DATA%0A%0A%09KEY_QUERY_VALUE        = 1%0A%09KEY_SET_VALUE          = 2%0A%09KEY_CREATE_SUB_KEY     = 4%0A%09KEY_ENUMERATE_SUB_KEYS = 8%0A%09KEY_NOTIFY             = 16%0A%09KEY_CREATE_LINK        = 32%0A%09KEY_WRITE              = 0x20006%0A%09KEY_EXECUTE            = 0x20019%0A%09KEY_READ               = 0x20019%0A%09KEY_WOW64_64KEY        = 0x0100%0A%09KEY_WOW64_32KEY        = 0x0200%0A%09KEY_ALL_ACCESS         = 0xf003f%0A)%0A%0Aconst (%0A%09// do not reorder%0A%09REG_NONE = iota%0A%09REG_SZ%0A%09REG_EXPAND_SZ%0A%09REG_BINARY%0A%09REG_DWORD_LITTLE_ENDIAN%0A%09REG_DWORD_BIG_ENDIAN%0A%09REG_LINK%0A%09REG_MULTI_SZ%0A%09REG_RESOURCE_LIST%0A%09REG_FULL_RESOURCE_DESCRIPTOR%0A%09REG_RESOURCE_REQUIREMENTS_LIST%0A%09REG_QWORD_LITTLE_ENDIAN%0A%09REG_DWORD = REG_DWORD_LITTLE_ENDIAN%0A%09REG_QWORD = REG_QWORD_LITTLE_ENDIAN%0A)%0A%0Atype AddrinfoW struct %7B%0A%09Flags     int32%0A%09Family    int32%0A%09Socktype  int32%0A%09Protocol  int32%0A%09Addrlen   uintptr%0A%09Canonname *uint16%0A%09Addr      uintptr%0A%09Next      *AddrinfoW%0A%7D%0A%0Aconst (%0A%09AI_PASSIVE     = 1%0A%09AI_CANONNAME   = 2%0A%09AI_NUMERICHOST = 4%0A)%0A%0Atype GUID struct %7B%0A%09Data1 uint32%0A%09Data2 uint16%0A%09Data3 uint16%0A%09Data4 %5B8%5Dbyte%0A%7D%0A%0Avar WSAID_CONNECTEX = GUID%7B%0A%090x25a207b9,%0A%090xddf3,%0A%090x4660,%0A%09%5B8%5Dbyte%7B0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e%7D,%0A%7D%0A%0Avar WSAID_WSASENDMSG = GUID%7B%0A%090xa441e712,%0A%090x754f,%0A%090x43ca,%0A%09%5B8%5Dbyte%7B0x84, 0xa7, 0x0d, 0xee, 0x44, 0xcf, 0x60, 0x6d%7D,%0A%7D%0A%0Avar WSAID_WSARECVMSG = GUID%7B%0A%090xf689d7c8,%0A%090x6f1f,%0A%090x436b,%0A%09%5B8%5Dbyte%7B0x8a, 0x53, 0xe5, 0x4f, 0xe3, 0x51, 0xc3, 0x22%7D,%0A%7D%0A%0Aconst (%0A%09FILE_SKIP_COMPLETION_PORT_ON_SUCCESS = 1%0A%09FILE_SKIP_SET_EVENT_ON_HANDLE        = 2%0A)%0A%0Aconst (%0A%09WSAPROTOCOL_LEN    = 255%0A%09MAX_PROTOCOL_CHAIN = 7%0A%09BASE_PROTOCOL      = 1%0A%09LAYERED_PROTOCOL   = 0%0A%0A%09XP1_CONNECTIONLESS           = 0x00000001%0A%09XP1_GUARANTEED_DELIVERY      = 0x00000002%0A%09XP1_GUARANTEED_ORDER         = 0x00000004%0A%09XP1_MESSAGE_ORIENTED         = 0x00000008%0A%09XP1_PSEUDO_STREAM            = 0x00000010%0A%09XP1_GRACEFUL_CLOSE           = 0x00000020%0A%09XP1_EXPEDITED_DATA           = 0x00000040%0A%09XP1_CONNECT_DATA             = 0x00000080%0A%09XP1_DISCONNECT_DATA          = 0x00000100%0A%09XP1_SUPPORT_BROADCAST        = 0x00000200%0A%09XP1_SUPPORT_MULTIPOINT       = 0x00000400%0A%09XP1_MULTIPOINT_CONTROL_PLANE = 0x00000800%0A%09XP1_MULTIPOINT_DATA_PLANE    = 0x00001000%0A%09XP1_QOS_SUPPORTED            = 0x00002000%0A%09XP1_UNI_SEND                 = 0x00008000%0A%09XP1_UNI_RECV                 = 0x00010000%0A%09XP1_IFS_HANDLES              = 0x00020000%0A%09XP1_PARTIAL_MESSAGE          = 0x00040000%0A%09XP1_SAN_SUPPORT_SDP          = 0x00080000%0A%0A%09PFL_MULTIPLE_PROTO_ENTRIES  = 0x00000001%0A%09PFL_RECOMMENDED_PROTO_ENTRY = 0x00000002%0A%09PFL_HIDDEN                  = 0x00000004%0A%09PFL_MATCHES_PROTOCOL_ZERO   = 0x00000008%0A%09PFL_NETWORKDIRECT_PROVIDER  = 0x00000010%0A)%0A%0Atype WSAProtocolInfo struct %7B%0A%09ServiceFlags1     uint32%0A%09ServiceFlags2     uint32%0A%09ServiceFlags3     uint32%0A%09ServiceFlags4     uint32%0A%09ProviderFlags     uint32%0A%09ProviderId        GUID%0A%09CatalogEntryId    uint32%0A%09ProtocolChain     WSAProtocolChain%0A%09Version           int32%0A%09AddressFamily     int32%0A%09MaxSockAddr       int32%0A%09MinSockAddr       int32%0A%09SocketType        int32%0A%09Protocol          int32%0A%09ProtocolMaxOffset int32%0A%09NetworkByteOrder  int32%0A%09SecurityScheme    int32%0A%09MessageSize       uint32%0A%09ProviderReserved  uint32%0A%09ProtocolName      %5BWSAPROTOCOL_LEN + 1%5Duint16%0A%7D%0A%0Atype WSAProtocolChain struct %7B%0A%09ChainLen     int32%0A%09ChainEntries %5BMAX_PROTOCOL_CHAIN%5Duint32%0A%7D%0A%0Atype TCPKeepalive struct %7B%0A%09OnOff    uint32%0A%09Time     uint32%0A%09Interval uint32%0A%7D%0A%0Atype symbolicLinkReparseBuffer struct %7B%0A%09SubstituteNameOffset uint16%0A%09SubstituteNameLength uint16%0A%09PrintNameOffset      uint16%0A%09PrintNameLength      uint16%0A%09Flags                uint32%0A%09PathBuffer           %5B1%5Duint16%0A%7D%0A%0Atype mountPointReparseBuffer struct %7B%0A%09SubstituteNameOffset uint16%0A%09SubstituteNameLength uint16%0A%09PrintNameOffset      uint16%0A%09PrintNameLength      uint16%0A%09PathBuffer           %5B1%5Duint16%0A%7D%0A%0Atype reparseDataBuffer struct %7B%0A%09ReparseTag        uint32%0A%09ReparseDataLength uint16%0A%09Reserved          uint16%0A%0A%09// GenericReparseBuffer%0A%09reparseBuffer byte%0A%7D%0A%0Aconst (%0A%09FSCTL_GET_REPARSE_POINT          = 0x900A8%0A%09MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 16 * 1024%0A%09IO_REPARSE_TAG_MOUNT_POINT       = 0xA0000003%0A%09IO_REPARSE_TAG_SYMLINK           = 0xA000000C%0A%09SYMBOLIC_LINK_FLAG_DIRECTORY     = 0x1%0A)%0A%0Aconst (%0A%09ComputerNameNetBIOS                   = 0%0A%09ComputerNameDnsHostname               = 1%0A%09ComputerNameDnsDomain                 = 2%0A%09ComputerNameDnsFullyQualified         = 3%0A%09ComputerNamePhysicalNetBIOS           = 4%0A%09ComputerNamePhysicalDnsHostname       = 5%0A%09ComputerNamePhysicalDnsDomain         = 6%0A%09ComputerNamePhysicalDnsFullyQualified = 7%0A%09ComputerNameMax                       = 8%0A)%0A%0Aconst (%0A%09MOVEFILE_REPLACE_EXISTING      = 0x1%0A%09MOVEFILE_COPY_ALLOWED          = 0x2%0A%09MOVEFILE_DELAY_UNTIL_REBOOT    = 0x4%0A%09MOVEFILE_WRITE_THROUGH         = 0x8%0A%09MOVEFILE_CREATE_HARDLINK       = 0x10%0A%09MOVEFILE_FAIL_IF_NOT_TRACKABLE = 0x20%0A)%0A%0Aconst GAA_FLAG_INCLUDE_PREFIX = 0x00000010%0A%0Aconst (%0A%09IF_TYPE_OTHER              = 1%0A%09IF_TYPE_ETHERNET_CSMACD    = 6%0A%09IF_TYPE_ISO88025_TOKENRING = 9%0A%09IF_TYPE_PPP                = 23%0A%09IF_TYPE_SOFTWARE_LOOPBACK  = 24%0A%09IF_TYPE_ATM                = 37%0A%09IF_TYPE_IEEE80211          = 71%0A%09IF_TYPE_TUNNEL             = 131%0A%09IF_TYPE_IEEE1394           = 144%0A)%0A%0Atype SocketAddress struct %7B%0A%09Sockaddr       *syscall.RawSockaddrAny%0A%09SockaddrLength int32%0A%7D%0A%0Atype IpAdapterUnicastAddress struct %7B%0A%09Length             uint32%0A%09Flags              uint32%0A%09Next               *IpAdapterUnicastAddress%0A%09Address            SocketAddress%0A%09PrefixOrigin       int32%0A%09SuffixOrigin       int32%0A%09DadState           int32%0A%09ValidLifetime      uint32%0A%09PreferredLifetime  uint32%0A%09LeaseLifetime      uint32%0A%09OnLinkPrefixLength uint8%0A%7D%0A%0Atype IpAdapterAnycastAddress struct %7B%0A%09Length  uint32%0A%09Flags   uint32%0A%09Next    *IpAdapterAnycastAddress%0A%09Address SocketAddress%0A%7D%0A%0Atype IpAdapterMulticastAddress struct %7B%0A%09Length  uint32%0A%09Flags   uint32%0A%09Next    *IpAdapterMulticastAddress%0A%09Address SocketAddress%0A%7D%0A%0Atype IpAdapterDnsServerAdapter struct %7B%0A%09Length   uint32%0A%09Reserved uint32%0A%09Next     *IpAdapterDnsServerAdapter%0A%09Address  SocketAddress%0A%7D%0A%0Atype IpAdapterPrefix struct %7B%0A%09Length       uint32%0A%09Flags        uint32%0A%09Next         *IpAdapterPrefix%0A%09Address      SocketAddress%0A%09PrefixLength uint32%0A%7D%0A%0Atype IpAdapterAddresses struct %7B%0A%09Length                uint32%0A%09IfIndex               uint32%0A%09Next                  *IpAdapterAddresses%0A%09AdapterName           *byte%0A%09FirstUnicastAddress   *IpAdapterUnicastAddress%0A%09FirstAnycastAddress   *IpAdapterAnycastAddress%0A%09FirstMulticastAddress *IpAdapterMulticastAddress%0A%09FirstDnsServerAddress *IpAdapterDnsServerAdapter%0A%09DnsSuffix             *uint16%0A%09Description           *uint16%0A%09FriendlyName          *uint16%0A%09PhysicalAddress       %5Bsyscall.MAX_ADAPTER_ADDRESS_LENGTH%5Dbyte%0A%09PhysicalAddressLength uint32%0A%09Flags                 uint32%0A%09Mtu                   uint32%0A%09IfType                uint32%0A%09OperStatus            uint32%0A%09Ipv6IfIndex           uint32%0A%09ZoneIndices           %5B16%5Duint32%0A%09FirstPrefix           *IpAdapterPrefix%0A%09/* more fields might be present here. */%0A%7D%0A%0Aconst (%0A%09IfOperStatusUp             = 1%0A%09IfOperStatusDown           = 2%0A%09IfOperStatusTesting        = 3%0A%09IfOperStatusUnknown        = 4%0A%09IfOperStatusDormant        = 5%0A%09IfOperStatusNotPresent     = 6%0A%09IfOperStatusLowerLayerDown = 7%0A)%0A%0A// Console related constants used for the mode parameter to SetConsoleMode. See%0A// https://docs.microsoft.com/en-us/windows/console/setconsolemode for details.%0A%0Aconst (%0A%09ENABLE_PROCESSED_INPUT        = 0x1%0A%09ENABLE_LINE_INPUT             = 0x2%0A%09ENABLE_ECHO_INPUT             = 0x4%0A%09ENABLE_WINDOW_INPUT           = 0x8%0A%09ENABLE_MOUSE_INPUT            = 0x10%0A%09ENABLE_INSERT_MODE            = 0x20%0A%09ENABLE_QUICK_EDIT_MODE        = 0x40%0A%09ENABLE_EXTENDED_FLAGS         = 0x80%0A%09ENABLE_AUTO_POSITION          = 0x100%0A%09ENABLE_VIRTUAL_TERMINAL_INPUT = 0x200%0A%0A%09ENABLE_PROCESSED_OUTPUT            = 0x1%0A%09ENABLE_WRAP_AT_EOL_OUTPUT          = 0x2%0A%09ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x4%0A%09DISABLE_NEWLINE_AUTO_RETURN        = 0x8%0A%09ENABLE_LVB_GRID_WORLDWIDE          = 0x10%0A)%0A%0Atype Coord struct %7B%0A%09X int16%0A%09Y int16%0A%7D%0A%0Atype SmallRect struct %7B%0A%09Left   int16%0A%09Top    int16%0A%09Right  int16%0A%09Bottom int16%0A%7D%0A%0A// Used with GetConsoleScreenBuffer to retreive information about a console%0A// screen buffer. See%0A// https://docs.microsoft.com/en-us/windows/console/console-screen-buffer-info-str%0A// for details.%0A%0Atype ConsoleScreenBufferInfo struct %7B%0A%09Size              Coord%0A%09CursorPosition    Coord%0A%09Attributes        uint16%0A%09Window            SmallRect%0A%09MaximumWindowSize Coord%0A%7D%0A
- f fba7c3ffd3cdaf0d535ac67df50b1225827c6f04a75334cbb2384ed1c3515b69 vendor/golang.org/x/sys/windows/types_windows_386.go
+ f 35bfa1de8a87825e0db0adc8aa48b116be18d66a03bcc033445c8b2ed164ddaf vendor/golang.org/x/sys/windows/types_windows_386.go
dmppatch 3
@@ -173,305 +173,4 @@
 ows%0A
-%0Atype WSAData struct %7B%0A%09Version      uint16%0A%09HighVersion  uint16%0A%09Description  %5BWSADESCRIPTION_LEN + 1%5Dbyte%0A%09SystemStatus %5BWSASYS_STATUS_LEN + 1%5Dbyte%0A%09MaxSockets   uint16%0A%09MaxUdpDg     uint16%0A%09VendorInfo   *byte%0A%7D%0A%0Atype Servent struct %7B%0A%09Name    *byte%0A%09Aliases **byte%0A%09Port    uint16%0A%09Proto   *byte%0A%7D%0A
- f 6ebf889bcbd4ef923625462e1514af19ffdad94e7659f7dbab7506cba112b69b vendor/golang.org/x/sys/windows/types_windows_amd64.go
+ f 35bfa1de8a87825e0db0adc8aa48b116be18d66a03bcc033445c8b2ed164ddaf vendor/golang.org/x/sys/windows/types_windows_amd64.go
dmppatch 3
@@ -173,305 +173,4 @@
 ows%0A
-%0Atype WSAData struct %7B%0A%09Version      uint16%0A%09HighVersion  uint16%0A%09MaxSockets   uint16%0A%09MaxUdpDg     uint16%0A%09VendorInfo   *byte%0A%09Description  %5BWSADESCRIPTION_LEN + 1%5Dbyte%0A%09SystemStatus %5BWSASYS_STATUS_LEN + 1%5Dbyte%0A%7D%0A%0Atype Servent struct %7B%0A%09Name    *byte%0A%09Aliases **byte%0A%09Proto   *byte%0A%09Port    uint16%0A%7D%0A
- f 9c0fca6007c5450c634b96a216cce0954cc757f4ffca5110a5062c5648608044 vendor/golang.org/x/sys/windows/zsyscall_windows.go
+ f 0876f5fc883cf56a1591e5aec36f4c45a1b303d5589392dd5e4896499987b0f8 vendor/golang.org/x/sys/windows/zsyscall_windows.go
dmppatch 7
@@ -1,63 +1,53 @@
-// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT%0A
+// Code generated by 'go generate'; DO NOT EDIT.%0A
 %0Apac
@@ -63,90355 +63,4 @@
 ows%0A
-%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Avar _ unsafe.Pointer%0A%0A// Do the interface allocations only once for common%0A// Errno values.%0Aconst (%0A%09errnoERROR_IO_PENDING = 997%0A)%0A%0Avar (%0A%09errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)%0A)%0A%0A// errnoErr returns common boxed Errno values, to prevent%0A// allocations at runtime.%0Afunc errnoErr(e syscall.Errno) error %7B%0A%09switch e %7B%0A%09case 0:%0A%09%09return nil%0A%09case errnoERROR_IO_PENDING:%0A%09%09return errERROR_IO_PENDING%0A%09%7D%0A%09// TODO: add more here, after collecting data on the common%0A%09// error values see on Windows. (perhaps when running%0A%09// all.bat?)%0A%09return e%0A%7D%0A%0Avar (%0A%09modadvapi32 = NewLazySystemDLL(%22advapi32.dll%22)%0A%09modkernel32 = NewLazySystemDLL(%22kernel32.dll%22)%0A%09modshell32  = NewLazySystemDLL(%22shell32.dll%22)%0A%09modmswsock  = NewLazySystemDLL(%22mswsock.dll%22)%0A%09modcrypt32  = NewLazySystemDLL(%22crypt32.dll%22)%0A%09modws2_32   = NewLazySystemDLL(%22ws2_32.dll%22)%0A%09moddnsapi   = NewLazySystemDLL(%22dnsapi.dll%22)%0A%09modiphlpapi = NewLazySystemDLL(%22iphlpapi.dll%22)%0A%09modsecur32  = NewLazySystemDLL(%22secur32.dll%22)%0A%09modnetapi32 = NewLazySystemDLL(%22netapi32.dll%22)%0A%09moduserenv  = NewLazySystemDLL(%22userenv.dll%22)%0A%0A%09procRegisterEventSourceW               = modadvapi32.NewProc(%22RegisterEventSourceW%22)%0A%09procDeregisterEventSource              = modadvapi32.NewProc(%22DeregisterEventSource%22)%0A%09procReportEventW                       = modadvapi32.NewProc(%22ReportEventW%22)%0A%09procOpenSCManagerW                     = modadvapi32.NewProc(%22OpenSCManagerW%22)%0A%09procCloseServiceHandle                 = modadvapi32.NewProc(%22CloseServiceHandle%22)%0A%09procCreateServiceW                     = modadvapi32.NewProc(%22CreateServiceW%22)%0A%09procOpenServiceW                       = modadvapi32.NewProc(%22OpenServiceW%22)%0A%09procDeleteService                      = modadvapi32.NewProc(%22DeleteService%22)%0A%09procStartServiceW                      = modadvapi32.NewProc(%22StartServiceW%22)%0A%09procQueryServiceStatus                 = modadvapi32.NewProc(%22QueryServiceStatus%22)%0A%09procControlService                     = modadvapi32.NewProc(%22ControlService%22)%0A%09procStartServiceCtrlDispatcherW        = modadvapi32.NewProc(%22StartServiceCtrlDispatcherW%22)%0A%09procSetServiceStatus                   = modadvapi32.NewProc(%22SetServiceStatus%22)%0A%09procChangeServiceConfigW               = modadvapi32.NewProc(%22ChangeServiceConfigW%22)%0A%09procQueryServiceConfigW                = modadvapi32.NewProc(%22QueryServiceConfigW%22)%0A%09procChangeServiceConfig2W              = modadvapi32.NewProc(%22ChangeServiceConfig2W%22)%0A%09procQueryServiceConfig2W               = modadvapi32.NewProc(%22QueryServiceConfig2W%22)%0A%09procEnumServicesStatusExW              = modadvapi32.NewProc(%22EnumServicesStatusExW%22)%0A%09procGetLastError                       = modkernel32.NewProc(%22GetLastError%22)%0A%09procLoadLibraryW                       = modkernel32.NewProc(%22LoadLibraryW%22)%0A%09procLoadLibraryExW                     = modkernel32.NewProc(%22LoadLibraryExW%22)%0A%09procFreeLibrary                        = modkernel32.NewProc(%22FreeLibrary%22)%0A%09procGetProcAddress                     = modkernel32.NewProc(%22GetProcAddress%22)%0A%09procGetVersion                         = modkernel32.NewProc(%22GetVersion%22)%0A%09procFormatMessageW                     = modkernel32.NewProc(%22FormatMessageW%22)%0A%09procExitProcess                        = modkernel32.NewProc(%22ExitProcess%22)%0A%09procCreateFileW                        = modkernel32.NewProc(%22CreateFileW%22)%0A%09procReadFile                           = modkernel32.NewProc(%22ReadFile%22)%0A%09procWriteFile                          = modkernel32.NewProc(%22WriteFile%22)%0A%09procSetFilePointer                     = modkernel32.NewProc(%22SetFilePointer%22)%0A%09procCloseHandle                        = modkernel32.NewProc(%22CloseHandle%22)%0A%09procGetStdHandle                       = modkernel32.NewProc(%22GetStdHandle%22)%0A%09procSetStdHandle                       = modkernel32.NewProc(%22SetStdHandle%22)%0A%09procFindFirstFileW                     = modkernel32.NewProc(%22FindFirstFileW%22)%0A%09procFindNextFileW                      = modkernel32.NewProc(%22FindNextFileW%22)%0A%09procFindClose                          = modkernel32.NewProc(%22FindClose%22)%0A%09procGetFileInformationByHandle         = modkernel32.NewProc(%22GetFileInformationByHandle%22)%0A%09procGetCurrentDirectoryW               = modkernel32.NewProc(%22GetCurrentDirectoryW%22)%0A%09procSetCurrentDirectoryW               = modkernel32.NewProc(%22SetCurrentDirectoryW%22)%0A%09procCreateDirectoryW                   = modkernel32.NewProc(%22CreateDirectoryW%22)%0A%09procRemoveDirectoryW                   = modkernel32.NewProc(%22RemoveDirectoryW%22)%0A%09procDeleteFileW                        = modkernel32.NewProc(%22DeleteFileW%22)%0A%09procMoveFileW                          = modkernel32.NewProc(%22MoveFileW%22)%0A%09procMoveFileExW                        = modkernel32.NewProc(%22MoveFileExW%22)%0A%09procGetComputerNameW                   = modkernel32.NewProc(%22GetComputerNameW%22)%0A%09procGetComputerNameExW                 = modkernel32.NewProc(%22GetComputerNameExW%22)%0A%09procSetEndOfFile                       = modkernel32.NewProc(%22SetEndOfFile%22)%0A%09procGetSystemTimeAsFileTime            = modkernel32.NewProc(%22GetSystemTimeAsFileTime%22)%0A%09procGetSystemTimePreciseAsFileTime     = modkernel32.NewProc(%22GetSystemTimePreciseAsFileTime%22)%0A%09procGetTimeZoneInformation             = modkernel32.NewProc(%22GetTimeZoneInformation%22)%0A%09procCreateIoCompletionPort             = modkernel32.NewProc(%22CreateIoCompletionPort%22)%0A%09procGetQueuedCompletionStatus          = modkernel32.NewProc(%22GetQueuedCompletionStatus%22)%0A%09procPostQueuedCompletionStatus         = modkernel32.NewProc(%22PostQueuedCompletionStatus%22)%0A%09procCancelIo                           = modkernel32.NewProc(%22CancelIo%22)%0A%09procCancelIoEx                         = modkernel32.NewProc(%22CancelIoEx%22)%0A%09procCreateProcessW                     = modkernel32.NewProc(%22CreateProcessW%22)%0A%09procOpenProcess                        = modkernel32.NewProc(%22OpenProcess%22)%0A%09procTerminateProcess                   = modkernel32.NewProc(%22TerminateProcess%22)%0A%09procGetExitCodeProcess                 = modkernel32.NewProc(%22GetExitCodeProcess%22)%0A%09procGetStartupInfoW                    = modkernel32.NewProc(%22GetStartupInfoW%22)%0A%09procGetCurrentProcess                  = modkernel32.NewProc(%22GetCurrentProcess%22)%0A%09procGetProcessTimes                    = modkernel32.NewProc(%22GetProcessTimes%22)%0A%09procDuplicateHandle                    = modkernel32.NewProc(%22DuplicateHandle%22)%0A%09procWaitForSingleObject                = modkernel32.NewProc(%22WaitForSingleObject%22)%0A%09procGetTempPathW                       = modkernel32.NewProc(%22GetTempPathW%22)%0A%09procCreatePipe                         = modkernel32.NewProc(%22CreatePipe%22)%0A%09procGetFileType                        = modkernel32.NewProc(%22GetFileType%22)%0A%09procCryptAcquireContextW               = modadvapi32.NewProc(%22CryptAcquireContextW%22)%0A%09procCryptReleaseContext                = modadvapi32.NewProc(%22CryptReleaseContext%22)%0A%09procCryptGenRandom                     = modadvapi32.NewProc(%22CryptGenRandom%22)%0A%09procGetEnvironmentStringsW             = modkernel32.NewProc(%22GetEnvironmentStringsW%22)%0A%09procFreeEnvironmentStringsW            = modkernel32.NewProc(%22FreeEnvironmentStringsW%22)%0A%09procGetEnvironmentVariableW            = modkernel32.NewProc(%22GetEnvironmentVariableW%22)%0A%09procSetEnvironmentVariableW            = modkernel32.NewProc(%22SetEnvironmentVariableW%22)%0A%09procSetFileTime                        = modkernel32.NewProc(%22SetFileTime%22)%0A%09procGetFileAttributesW                 = modkernel32.NewProc(%22GetFileAttributesW%22)%0A%09procSetFileAttributesW                 = modkernel32.NewProc(%22SetFileAttributesW%22)%0A%09procGetFileAttributesExW               = modkernel32.NewProc(%22GetFileAttributesExW%22)%0A%09procGetCommandLineW                    = modkernel32.NewProc(%22GetCommandLineW%22)%0A%09procCommandLineToArgvW                 = modshell32.NewProc(%22CommandLineToArgvW%22)%0A%09procLocalFree                          = modkernel32.NewProc(%22LocalFree%22)%0A%09procSetHandleInformation               = modkernel32.NewProc(%22SetHandleInformation%22)%0A%09procFlushFileBuffers                   = modkernel32.NewProc(%22FlushFileBuffers%22)%0A%09procGetFullPathNameW                   = modkernel32.NewProc(%22GetFullPathNameW%22)%0A%09procGetLongPathNameW                   = modkernel32.NewProc(%22GetLongPathNameW%22)%0A%09procGetShortPathNameW                  = modkernel32.NewProc(%22GetShortPathNameW%22)%0A%09procCreateFileMappingW                 = modkernel32.NewProc(%22CreateFileMappingW%22)%0A%09procMapViewOfFile                      = modkernel32.NewProc(%22MapViewOfFile%22)%0A%09procUnmapViewOfFile                    = modkernel32.NewProc(%22UnmapViewOfFile%22)%0A%09procFlushViewOfFile                    = modkernel32.NewProc(%22FlushViewOfFile%22)%0A%09procVirtualLock                        = modkernel32.NewProc(%22VirtualLock%22)%0A%09procVirtualUnlock                      = modkernel32.NewProc(%22VirtualUnlock%22)%0A%09procVirtualAlloc                       = modkernel32.NewProc(%22VirtualAlloc%22)%0A%09procVirtualFree                        = modkernel32.NewProc(%22VirtualFree%22)%0A%09procVirtualProtect                     = modkernel32.NewProc(%22VirtualProtect%22)%0A%09procTransmitFile                       = modmswsock.NewProc(%22TransmitFile%22)%0A%09procReadDirectoryChangesW              = modkernel32.NewProc(%22ReadDirectoryChangesW%22)%0A%09procCertOpenSystemStoreW               = modcrypt32.NewProc(%22CertOpenSystemStoreW%22)%0A%09procCertOpenStore                      = modcrypt32.NewProc(%22CertOpenStore%22)%0A%09procCertEnumCertificatesInStore        = modcrypt32.NewProc(%22CertEnumCertificatesInStore%22)%0A%09procCertAddCertificateContextToStore   = modcrypt32.NewProc(%22CertAddCertificateContextToStore%22)%0A%09procCertCloseStore                     = modcrypt32.NewProc(%22CertCloseStore%22)%0A%09procCertGetCertificateChain            = modcrypt32.NewProc(%22CertGetCertificateChain%22)%0A%09procCertFreeCertificateChain           = modcrypt32.NewProc(%22CertFreeCertificateChain%22)%0A%09procCertCreateCertificateContext       = modcrypt32.NewProc(%22CertCreateCertificateContext%22)%0A%09procCertFreeCertificateContext         = modcrypt32.NewProc(%22CertFreeCertificateContext%22)%0A%09procCertVerifyCertificateChainPolicy   = modcrypt32.NewProc(%22CertVerifyCertificateChainPolicy%22)%0A%09procRegOpenKeyExW                      = modadvapi32.NewProc(%22RegOpenKeyExW%22)%0A%09procRegCloseKey                        = modadvapi32.NewProc(%22RegCloseKey%22)%0A%09procRegQueryInfoKeyW                   = modadvapi32.NewProc(%22RegQueryInfoKeyW%22)%0A%09procRegEnumKeyExW                      = modadvapi32.NewProc(%22RegEnumKeyExW%22)%0A%09procRegQueryValueExW                   = modadvapi32.NewProc(%22RegQueryValueExW%22)%0A%09procGetCurrentProcessId                = modkernel32.NewProc(%22GetCurrentProcessId%22)%0A%09procGetConsoleMode                     = modkernel32.NewProc(%22GetConsoleMode%22)%0A%09procSetConsoleMode                     = modkernel32.NewProc(%22SetConsoleMode%22)%0A%09procGetConsoleScreenBufferInfo         = modkernel32.NewProc(%22GetConsoleScreenBufferInfo%22)%0A%09procWriteConsoleW                      = modkernel32.NewProc(%22WriteConsoleW%22)%0A%09procReadConsoleW                       = modkernel32.NewProc(%22ReadConsoleW%22)%0A%09procCreateToolhelp32Snapshot           = modkernel32.NewProc(%22CreateToolhelp32Snapshot%22)%0A%09procProcess32FirstW                    = modkernel32.NewProc(%22Process32FirstW%22)%0A%09procProcess32NextW                     = modkernel32.NewProc(%22Process32NextW%22)%0A%09procDeviceIoControl                    = modkernel32.NewProc(%22DeviceIoControl%22)%0A%09procCreateSymbolicLinkW                = modkernel32.NewProc(%22CreateSymbolicLinkW%22)%0A%09procCreateHardLinkW                    = modkernel32.NewProc(%22CreateHardLinkW%22)%0A%09procGetCurrentThreadId                 = modkernel32.NewProc(%22GetCurrentThreadId%22)%0A%09procCreateEventW                       = modkernel32.NewProc(%22CreateEventW%22)%0A%09procCreateEventExW                     = modkernel32.NewProc(%22CreateEventExW%22)%0A%09procOpenEventW                         = modkernel32.NewProc(%22OpenEventW%22)%0A%09procSetEvent                           = modkernel32.NewProc(%22SetEvent%22)%0A%09procResetEvent                         = modkernel32.NewProc(%22ResetEvent%22)%0A%09procPulseEvent                         = modkernel32.NewProc(%22PulseEvent%22)%0A%09procDefineDosDeviceW                   = modkernel32.NewProc(%22DefineDosDeviceW%22)%0A%09procDeleteVolumeMountPointW            = modkernel32.NewProc(%22DeleteVolumeMountPointW%22)%0A%09procFindFirstVolumeW                   = modkernel32.NewProc(%22FindFirstVolumeW%22)%0A%09procFindFirstVolumeMountPointW         = modkernel32.NewProc(%22FindFirstVolumeMountPointW%22)%0A%09procFindNextVolumeW                    = modkernel32.NewProc(%22FindNextVolumeW%22)%0A%09procFindNextVolumeMountPointW          = modkernel32.NewProc(%22FindNextVolumeMountPointW%22)%0A%09procFindVolumeClose                    = modkernel32.NewProc(%22FindVolumeClose%22)%0A%09procFindVolumeMountPointClose          = modkernel32.NewProc(%22FindVolumeMountPointClose%22)%0A%09procGetDriveTypeW                      = modkernel32.NewProc(%22GetDriveTypeW%22)%0A%09procGetLogicalDrives                   = modkernel32.NewProc(%22GetLogicalDrives%22)%0A%09procGetLogicalDriveStringsW            = modkernel32.NewProc(%22GetLogicalDriveStringsW%22)%0A%09procGetVolumeInformationW              = modkernel32.NewProc(%22GetVolumeInformationW%22)%0A%09procGetVolumeInformationByHandleW      = modkernel32.NewProc(%22GetVolumeInformationByHandleW%22)%0A%09procGetVolumeNameForVolumeMountPointW  = modkernel32.NewProc(%22GetVolumeNameForVolumeMountPointW%22)%0A%09procGetVolumePathNameW                 = modkernel32.NewProc(%22GetVolumePathNameW%22)%0A%09procGetVolumePathNamesForVolumeNameW   = modkernel32.NewProc(%22GetVolumePathNamesForVolumeNameW%22)%0A%09procQueryDosDeviceW                    = modkernel32.NewProc(%22QueryDosDeviceW%22)%0A%09procSetVolumeLabelW                    = modkernel32.NewProc(%22SetVolumeLabelW%22)%0A%09procSetVolumeMountPointW               = modkernel32.NewProc(%22SetVolumeMountPointW%22)%0A%09procWSAStartup                         = modws2_32.NewProc(%22WSAStartup%22)%0A%09procWSACleanup                         = modws2_32.NewProc(%22WSACleanup%22)%0A%09procWSAIoctl                           = modws2_32.NewProc(%22WSAIoctl%22)%0A%09procsocket                             = modws2_32.NewProc(%22socket%22)%0A%09procsetsockopt                         = modws2_32.NewProc(%22setsockopt%22)%0A%09procgetsockopt                         = modws2_32.NewProc(%22getsockopt%22)%0A%09procbind                               = modws2_32.NewProc(%22bind%22)%0A%09procconnect                            = modws2_32.NewProc(%22connect%22)%0A%09procgetsockname                        = modws2_32.NewProc(%22getsockname%22)%0A%09procgetpeername                        = modws2_32.NewProc(%22getpeername%22)%0A%09proclisten                             = modws2_32.NewProc(%22listen%22)%0A%09procshutdown                           = modws2_32.NewProc(%22shutdown%22)%0A%09procclosesocket                        = modws2_32.NewProc(%22closesocket%22)%0A%09procAcceptEx                           = modmswsock.NewProc(%22AcceptEx%22)%0A%09procGetAcceptExSockaddrs               = modmswsock.NewProc(%22GetAcceptExSockaddrs%22)%0A%09procWSARecv                            = modws2_32.NewProc(%22WSARecv%22)%0A%09procWSASend                            = modws2_32.NewProc(%22WSASend%22)%0A%09procWSARecvFrom                        = modws2_32.NewProc(%22WSARecvFrom%22)%0A%09procWSASendTo                          = modws2_32.NewProc(%22WSASendTo%22)%0A%09procgethostbyname                      = modws2_32.NewProc(%22gethostbyname%22)%0A%09procgetservbyname                      = modws2_32.NewProc(%22getservbyname%22)%0A%09procntohs                              = modws2_32.NewProc(%22ntohs%22)%0A%09procgetprotobyname                     = modws2_32.NewProc(%22getprotobyname%22)%0A%09procDnsQuery_W                         = moddnsapi.NewProc(%22DnsQuery_W%22)%0A%09procDnsRecordListFree                  = moddnsapi.NewProc(%22DnsRecordListFree%22)%0A%09procDnsNameCompare_W                   = moddnsapi.NewProc(%22DnsNameCompare_W%22)%0A%09procGetAddrInfoW                       = modws2_32.NewProc(%22GetAddrInfoW%22)%0A%09procFreeAddrInfoW                      = modws2_32.NewProc(%22FreeAddrInfoW%22)%0A%09procGetIfEntry                         = modiphlpapi.NewProc(%22GetIfEntry%22)%0A%09procGetAdaptersInfo                    = modiphlpapi.NewProc(%22GetAdaptersInfo%22)%0A%09procSetFileCompletionNotificationModes = modkernel32.NewProc(%22SetFileCompletionNotificationModes%22)%0A%09procWSAEnumProtocolsW                  = modws2_32.NewProc(%22WSAEnumProtocolsW%22)%0A%09procGetAdaptersAddresses               = modiphlpapi.NewProc(%22GetAdaptersAddresses%22)%0A%09procGetACP                             = modkernel32.NewProc(%22GetACP%22)%0A%09procMultiByteToWideChar                = modkernel32.NewProc(%22MultiByteToWideChar%22)%0A%09procTranslateNameW                     = modsecur32.NewProc(%22TranslateNameW%22)%0A%09procGetUserNameExW                     = modsecur32.NewProc(%22GetUserNameExW%22)%0A%09procNetUserGetInfo                     = modnetapi32.NewProc(%22NetUserGetInfo%22)%0A%09procNetGetJoinInformation              = modnetapi32.NewProc(%22NetGetJoinInformation%22)%0A%09procNetApiBufferFree                   = modnetapi32.NewProc(%22NetApiBufferFree%22)%0A%09procLookupAccountSidW                  = modadvapi32.NewProc(%22LookupAccountSidW%22)%0A%09procLookupAccountNameW                 = modadvapi32.NewProc(%22LookupAccountNameW%22)%0A%09procConvertSidToStringSidW             = modadvapi32.NewProc(%22ConvertSidToStringSidW%22)%0A%09procConvertStringSidToSidW             = modadvapi32.NewProc(%22ConvertStringSidToSidW%22)%0A%09procGetLengthSid                       = modadvapi32.NewProc(%22GetLengthSid%22)%0A%09procCopySid                            = modadvapi32.NewProc(%22CopySid%22)%0A%09procAllocateAndInitializeSid           = modadvapi32.NewProc(%22AllocateAndInitializeSid%22)%0A%09procFreeSid                            = modadvapi32.NewProc(%22FreeSid%22)%0A%09procEqualSid                           = modadvapi32.NewProc(%22EqualSid%22)%0A%09procCheckTokenMembership               = modadvapi32.NewProc(%22CheckTokenMembership%22)%0A%09procOpenProcessToken                   = modadvapi32.NewProc(%22OpenProcessToken%22)%0A%09procGetTokenInformation                = modadvapi32.NewProc(%22GetTokenInformation%22)%0A%09procGetUserProfileDirectoryW           = moduserenv.NewProc(%22GetUserProfileDirectoryW%22)%0A)%0A%0Afunc RegisterEventSource(uncServerName *uint16, sourceName *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procRegisterEventSourceW.Addr(), 2, uintptr(unsafe.Pointer(uncServerName)), uintptr(unsafe.Pointer(sourceName)), 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeregisterEventSource(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDeregisterEventSource.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ReportEvent(log Handle, etype uint16, category uint16, eventId uint32, usrSId uintptr, numStrings uint16, dataSize uint32, strings **uint16, rawData *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procReportEventW.Addr(), 9, uintptr(log), uintptr(etype), uintptr(category), uintptr(eventId), uintptr(usrSId), uintptr(numStrings), uintptr(dataSize), uintptr(unsafe.Pointer(strings)), uintptr(unsafe.Pointer(rawData)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenSCManager(machineName *uint16, databaseName *uint16, access uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procOpenSCManagerW.Addr(), 3, uintptr(unsafe.Pointer(machineName)), uintptr(unsafe.Pointer(databaseName)), uintptr(access))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CloseServiceHandle(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCloseServiceHandle.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateService(mgr Handle, serviceName *uint16, displayName *uint16, access uint32, srvType uint32, startType uint32, errCtl uint32, pathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall15(procCreateServiceW.Addr(), 13, uintptr(mgr), uintptr(unsafe.Pointer(serviceName)), uintptr(unsafe.Pointer(displayName)), uintptr(access), uintptr(srvType), uintptr(startType), uintptr(errCtl), uintptr(unsafe.Pointer(pathName)), uintptr(unsafe.Pointer(loadOrderGroup)), uintptr(unsafe.Pointer(tagId)), uintptr(unsafe.Pointer(dependencies)), uintptr(unsafe.Pointer(serviceStartName)), uintptr(unsafe.Pointer(password)), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenService(mgr Handle, serviceName *uint16, access uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procOpenServiceW.Addr(), 3, uintptr(mgr), uintptr(unsafe.Pointer(serviceName)), uintptr(access))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeleteService(service Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDeleteService.Addr(), 1, uintptr(service), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc StartService(service Handle, numArgs uint32, argVectors **uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procStartServiceW.Addr(), 3, uintptr(service), uintptr(numArgs), uintptr(unsafe.Pointer(argVectors)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc QueryServiceStatus(service Handle, status *SERVICE_STATUS) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procQueryServiceStatus.Addr(), 2, uintptr(service), uintptr(unsafe.Pointer(status)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ControlService(service Handle, control uint32, status *SERVICE_STATUS) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procControlService.Addr(), 3, uintptr(service), uintptr(control), uintptr(unsafe.Pointer(status)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc StartServiceCtrlDispatcher(serviceTable *SERVICE_TABLE_ENTRY) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procStartServiceCtrlDispatcherW.Addr(), 1, uintptr(unsafe.Pointer(serviceTable)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetServiceStatus(service Handle, serviceStatus *SERVICE_STATUS) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetServiceStatus.Addr(), 2, uintptr(service), uintptr(unsafe.Pointer(serviceStatus)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ChangeServiceConfig(service Handle, serviceType uint32, startType uint32, errorControl uint32, binaryPathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16, displayName *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall12(procChangeServiceConfigW.Addr(), 11, uintptr(service), uintptr(serviceType), uintptr(startType), uintptr(errorControl), uintptr(unsafe.Pointer(binaryPathName)), uintptr(unsafe.Pointer(loadOrderGroup)), uintptr(unsafe.Pointer(tagId)), uintptr(unsafe.Pointer(dependencies)), uintptr(unsafe.Pointer(serviceStartName)), uintptr(unsafe.Pointer(password)), uintptr(unsafe.Pointer(displayName)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc QueryServiceConfig(service Handle, serviceConfig *QUERY_SERVICE_CONFIG, bufSize uint32, bytesNeeded *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procQueryServiceConfigW.Addr(), 4, uintptr(service), uintptr(unsafe.Pointer(serviceConfig)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ChangeServiceConfig2(service Handle, infoLevel uint32, info *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procChangeServiceConfig2W.Addr(), 3, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(info)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc QueryServiceConfig2(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procQueryServiceConfig2W.Addr(), 5, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(buff)), uintptr(buffSize), uintptr(unsafe.Pointer(bytesNeeded)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc EnumServicesStatusEx(mgr Handle, infoLevel uint32, serviceType uint32, serviceState uint32, services *byte, bufSize uint32, bytesNeeded *uint32, servicesReturned *uint32, resumeHandle *uint32, groupName *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall12(procEnumServicesStatusExW.Addr(), 10, uintptr(mgr), uintptr(infoLevel), uintptr(serviceType), uintptr(serviceState), uintptr(unsafe.Pointer(services)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), uintptr(unsafe.Pointer(servicesReturned)), uintptr(unsafe.Pointer(resumeHandle)), uintptr(unsafe.Pointer(groupName)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetLastError() (lasterr error) %7B%0A%09r0, _, _ := syscall.Syscall(procGetLastError.Addr(), 0, 0, 0, 0)%0A%09if r0 != 0 %7B%0A%09%09lasterr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LoadLibrary(libname string) (handle Handle, err error) %7B%0A%09var _p0 *uint16%0A%09_p0, err = syscall.UTF16PtrFromString(libname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _LoadLibrary(_p0)%0A%7D%0A%0Afunc _LoadLibrary(libname *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procLoadLibraryW.Addr(), 1, uintptr(unsafe.Pointer(libname)), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) %7B%0A%09var _p0 *uint16%0A%09_p0, err = syscall.UTF16PtrFromString(libname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _LoadLibraryEx(_p0, zero, flags)%0A%7D%0A%0Afunc _LoadLibraryEx(libname *uint16, zero Handle, flags uintptr) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procLoadLibraryExW.Addr(), 3, uintptr(unsafe.Pointer(libname)), uintptr(zero), uintptr(flags))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FreeLibrary(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFreeLibrary.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetProcAddress(module Handle, procname string) (proc uintptr, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = syscall.BytePtrFromString(procname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _GetProcAddress(module, _p0)%0A%7D%0A%0Afunc _GetProcAddress(module Handle, procname *byte) (proc uintptr, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetProcAddress.Addr(), 2, uintptr(module), uintptr(unsafe.Pointer(procname)), 0)%0A%09proc = uintptr(r0)%0A%09if proc == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVersion() (ver uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetVersion.Addr(), 0, 0, 0, 0)%0A%09ver = uint32(r0)%0A%09if ver == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FormatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf %5B%5Duint16, args *byte) (n uint32, err error) %7B%0A%09var _p0 *uint16%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := syscall.Syscall9(procFormatMessageW.Addr(), 7, uintptr(flags), uintptr(msgsrc), uintptr(msgid), uintptr(langid), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(args)), 0, 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ExitProcess(exitcode uint32) %7B%0A%09syscall.Syscall(procExitProcess.Addr(), 1, uintptr(exitcode), 0, 0)%0A%09return%0A%7D%0A%0Afunc CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall9(procCreateFileW.Addr(), 7, uintptr(unsafe.Pointer(name)), uintptr(access), uintptr(mode), uintptr(unsafe.Pointer(sa)), uintptr(createmode), uintptr(attrs), uintptr(templatefile), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ReadFile(handle Handle, buf %5B%5Dbyte, done *uint32, overlapped *Overlapped) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall6(procReadFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WriteFile(handle Handle, buf %5B%5Dbyte, done *uint32, overlapped *Overlapped) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall6(procWriteFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procSetFilePointer.Addr(), 4, uintptr(handle), uintptr(lowoffset), uintptr(unsafe.Pointer(highoffsetptr)), uintptr(whence), 0, 0)%0A%09newlowoffset = uint32(r0)%0A%09if newlowoffset == 0xffffffff %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CloseHandle(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCloseHandle.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetStdHandle(stdhandle uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetStdHandle.Addr(), 1, uintptr(stdhandle), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetStdHandle(stdhandle uint32, handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetStdHandle.Addr(), 2, uintptr(stdhandle), uintptr(handle), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procFindFirstFileW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(data)), 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc findNextFile1(handle Handle, data *win32finddata1) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindNextFileW.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindClose(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindClose.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetFileInformationByHandle.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetCurrentDirectoryW.Addr(), 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetCurrentDirectory(path *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetCurrentDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCreateDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(sa)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RemoveDirectory(path *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procRemoveDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeleteFile(path *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDeleteFileW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc MoveFile(from *uint16, to *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procMoveFileW.Addr(), 2, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc MoveFileEx(from *uint16, to *uint16, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procMoveFileExW.Addr(), 3, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), uintptr(flags))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetComputerName(buf *uint16, n *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetComputerNameW.Addr(), 2, uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetComputerNameExW.Addr(), 3, uintptr(nametype), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetEndOfFile(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetEndOfFile.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetSystemTimeAsFileTime(time *Filetime) %7B%0A%09syscall.Syscall(procGetSystemTimeAsFileTime.Addr(), 1, uintptr(unsafe.Pointer(time)), 0, 0)%0A%09return%0A%7D%0A%0Afunc GetSystemTimePreciseAsFileTime(time *Filetime) %7B%0A%09syscall.Syscall(procGetSystemTimePreciseAsFileTime.Addr(), 1, uintptr(unsafe.Pointer(time)), 0, 0)%0A%09return%0A%7D%0A%0Afunc GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetTimeZoneInformation.Addr(), 1, uintptr(unsafe.Pointer(tzi)), 0, 0)%0A%09rc = uint32(r0)%0A%09if rc == 0xffffffff %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uint32, threadcnt uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCreateIoCompletionPort.Addr(), 4, uintptr(filehandle), uintptr(cphandle), uintptr(key), uintptr(threadcnt), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procGetQueuedCompletionStatus.Addr(), 5, uintptr(cphandle), uintptr(unsafe.Pointer(qty)), uintptr(unsafe.Pointer(key)), uintptr(unsafe.Pointer(overlapped)), uintptr(timeout), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uint32, overlapped *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procPostQueuedCompletionStatus.Addr(), 4, uintptr(cphandle), uintptr(qty), uintptr(key), uintptr(unsafe.Pointer(overlapped)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CancelIo(s Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCancelIo.Addr(), 1, uintptr(s), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CancelIoEx(s Handle, o *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCancelIoEx.Addr(), 2, uintptr(s), uintptr(unsafe.Pointer(o)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) %7B%0A%09var _p0 uint32%0A%09if inheritHandles %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall12(procCreateProcessW.Addr(), 10, uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenProcess(da uint32, inheritHandle bool, pid uint32) (handle Handle, err error) %7B%0A%09var _p0 uint32%0A%09if inheritHandle %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r0, _, e1 := syscall.Syscall(procOpenProcess.Addr(), 3, uintptr(da), uintptr(_p0), uintptr(pid))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc TerminateProcess(handle Handle, exitcode uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procTerminateProcess.Addr(), 2, uintptr(handle), uintptr(exitcode), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetExitCodeProcess(handle Handle, exitcode *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetExitCodeProcess.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(exitcode)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetStartupInfo(startupInfo *StartupInfo) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetStartupInfoW.Addr(), 1, uintptr(unsafe.Pointer(startupInfo)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetCurrentProcess() (pseudoHandle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetCurrentProcess.Addr(), 0, 0, 0, 0)%0A%09pseudoHandle = Handle(r0)%0A%09if pseudoHandle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procGetProcessTimes.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(creationTime)), uintptr(unsafe.Pointer(exitTime)), uintptr(unsafe.Pointer(kernelTime)), uintptr(unsafe.Pointer(userTime)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error) %7B%0A%09var _p0 uint32%0A%09if bInheritHandle %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall9(procDuplicateHandle.Addr(), 7, uintptr(hSourceProcessHandle), uintptr(hSourceHandle), uintptr(hTargetProcessHandle), uintptr(unsafe.Pointer(lpTargetHandle)), uintptr(dwDesiredAccess), uintptr(_p0), uintptr(dwOptions), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procWaitForSingleObject.Addr(), 2, uintptr(handle), uintptr(waitMilliseconds), 0)%0A%09event = uint32(r0)%0A%09if event == 0xffffffff %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetTempPath(buflen uint32, buf *uint16) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetTempPathW.Addr(), 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procCreatePipe.Addr(), 4, uintptr(unsafe.Pointer(readhandle)), uintptr(unsafe.Pointer(writehandle)), uintptr(unsafe.Pointer(sa)), uintptr(size), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFileType(filehandle Handle) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetFileType.Addr(), 1, uintptr(filehandle), 0, 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procCryptAcquireContextW.Addr(), 5, uintptr(unsafe.Pointer(provhandle)), uintptr(unsafe.Pointer(container)), uintptr(unsafe.Pointer(provider)), uintptr(provtype), uintptr(flags), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CryptReleaseContext(provhandle Handle, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCryptReleaseContext.Addr(), 2, uintptr(provhandle), uintptr(flags), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCryptGenRandom.Addr(), 3, uintptr(provhandle), uintptr(buflen), uintptr(unsafe.Pointer(buf)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetEnvironmentStrings() (envs *uint16, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetEnvironmentStringsW.Addr(), 0, 0, 0, 0)%0A%09envs = (*uint16)(unsafe.Pointer(r0))%0A%09if envs == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FreeEnvironmentStrings(envs *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFreeEnvironmentStringsW.Addr(), 1, uintptr(unsafe.Pointer(envs)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetEnvironmentVariableW.Addr(), 3, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(buffer)), uintptr(size))%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetEnvironmentVariable(name *uint16, value *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetEnvironmentVariableW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(value)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procSetFileTime.Addr(), 4, uintptr(handle), uintptr(unsafe.Pointer(ctime)), uintptr(unsafe.Pointer(atime)), uintptr(unsafe.Pointer(wtime)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFileAttributes(name *uint16) (attrs uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetFileAttributesW.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)%0A%09attrs = uint32(r0)%0A%09if attrs == INVALID_FILE_ATTRIBUTES %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetFileAttributes(name *uint16, attrs uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetFileAttributesW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(attrs), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetFileAttributesExW.Addr(), 3, uintptr(unsafe.Pointer(name)), uintptr(level), uintptr(unsafe.Pointer(info)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetCommandLine() (cmd *uint16) %7B%0A%09r0, _, _ := syscall.Syscall(procGetCommandLineW.Addr(), 0, 0, 0, 0)%0A%09cmd = (*uint16)(unsafe.Pointer(r0))%0A%09return%0A%7D%0A%0Afunc CommandLineToArgv(cmd *uint16, argc *int32) (argv *%5B8192%5D*%5B8192%5Duint16, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCommandLineToArgvW.Addr(), 2, uintptr(unsafe.Pointer(cmd)), uintptr(unsafe.Pointer(argc)), 0)%0A%09argv = (*%5B8192%5D*%5B8192%5Duint16)(unsafe.Pointer(r0))%0A%09if argv == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LocalFree(hmem Handle) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procLocalFree.Addr(), 1, uintptr(hmem), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle != 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetHandleInformation(handle Handle, mask uint32, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetHandleInformation.Addr(), 3, uintptr(handle), uintptr(mask), uintptr(flags))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FlushFileBuffers(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFlushFileBuffers.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procGetFullPathNameW.Addr(), 4, uintptr(unsafe.Pointer(path)), uintptr(buflen), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(fname)), 0, 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetLongPathNameW.Addr(), 3, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(buf)), uintptr(buflen))%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetShortPathNameW.Addr(), 3, uintptr(unsafe.Pointer(longpath)), uintptr(unsafe.Pointer(shortpath)), uintptr(buflen))%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCreateFileMappingW.Addr(), 6, uintptr(fhandle), uintptr(unsafe.Pointer(sa)), uintptr(prot), uintptr(maxSizeHigh), uintptr(maxSizeLow), uintptr(unsafe.Pointer(name)))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procMapViewOfFile.Addr(), 5, uintptr(handle), uintptr(access), uintptr(offsetHigh), uintptr(offsetLow), uintptr(length), 0)%0A%09addr = uintptr(r0)%0A%09if addr == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc UnmapViewOfFile(addr uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procUnmapViewOfFile.Addr(), 1, uintptr(addr), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FlushViewOfFile(addr uintptr, length uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFlushViewOfFile.Addr(), 2, uintptr(addr), uintptr(length), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualLock(addr uintptr, length uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procVirtualLock.Addr(), 2, uintptr(addr), uintptr(length), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualUnlock(addr uintptr, length uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procVirtualUnlock.Addr(), 2, uintptr(addr), uintptr(length), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualAlloc(address uintptr, size uintptr, alloctype uint32, protect uint32) (value uintptr, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procVirtualAlloc.Addr(), 4, uintptr(address), uintptr(size), uintptr(alloctype), uintptr(protect), 0, 0)%0A%09value = uintptr(r0)%0A%09if value == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualFree(address uintptr, size uintptr, freetype uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procVirtualFree.Addr(), 3, uintptr(address), uintptr(size), uintptr(freetype))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualProtect(address uintptr, size uintptr, newprotect uint32, oldprotect *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procVirtualProtect.Addr(), 4, uintptr(address), uintptr(size), uintptr(newprotect), uintptr(unsafe.Pointer(oldprotect)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc TransmitFile(s Handle, handle Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *Overlapped, transmitFileBuf *TransmitFileBuffers, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procTransmitFile.Addr(), 7, uintptr(s), uintptr(handle), uintptr(bytesToWrite), uintptr(bytsPerSend), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(transmitFileBuf)), uintptr(flags), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ReadDirectoryChanges(handle Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) %7B%0A%09var _p0 uint32%0A%09if watchSubTree %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall9(procReadDirectoryChangesW.Addr(), 8, uintptr(handle), uintptr(unsafe.Pointer(buf)), uintptr(buflen), uintptr(_p0), uintptr(mask), uintptr(unsafe.Pointer(retlen)), uintptr(unsafe.Pointer(overlapped)), uintptr(completionRoutine), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCertOpenSystemStoreW.Addr(), 2, uintptr(hprov), uintptr(unsafe.Pointer(name)), 0)%0A%09store = Handle(r0)%0A%09if store == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCertOpenStore.Addr(), 5, uintptr(storeProvider), uintptr(msgAndCertEncodingType), uintptr(cryptProv), uintptr(flags), uintptr(para), 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCertEnumCertificatesInStore.Addr(), 2, uintptr(store), uintptr(unsafe.Pointer(prevContext)), 0)%0A%09context = (*CertContext)(unsafe.Pointer(r0))%0A%09if context == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procCertAddCertificateContextToStore.Addr(), 4, uintptr(store), uintptr(unsafe.Pointer(certContext)), uintptr(addDisposition), uintptr(unsafe.Pointer(storeContext)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertCloseStore(store Handle, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCertCloseStore.Addr(), 2, uintptr(store), uintptr(flags), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procCertGetCertificateChain.Addr(), 8, uintptr(engine), uintptr(unsafe.Pointer(leaf)), uintptr(unsafe.Pointer(time)), uintptr(additionalStore), uintptr(unsafe.Pointer(para)), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(chainCtx)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertFreeCertificateChain(ctx *CertChainContext) %7B%0A%09syscall.Syscall(procCertFreeCertificateChain.Addr(), 1, uintptr(unsafe.Pointer(ctx)), 0, 0)%0A%09return%0A%7D%0A%0Afunc CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *CertContext, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCertCreateCertificateContext.Addr(), 3, uintptr(certEncodingType), uintptr(unsafe.Pointer(certEncoded)), uintptr(encodedLen))%0A%09context = (*CertContext)(unsafe.Pointer(r0))%0A%09if context == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertFreeCertificateContext(ctx *CertContext) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCertFreeCertificateContext.Addr(), 1, uintptr(unsafe.Pointer(ctx)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procCertVerifyCertificateChainPolicy.Addr(), 4, uintptr(policyOID), uintptr(unsafe.Pointer(chain)), uintptr(unsafe.Pointer(para)), uintptr(unsafe.Pointer(status)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall6(procRegOpenKeyExW.Addr(), 5, uintptr(key), uintptr(unsafe.Pointer(subkey)), uintptr(options), uintptr(desiredAccess), uintptr(unsafe.Pointer(result)), 0)%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegCloseKey(key Handle) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall(procRegCloseKey.Addr(), 1, uintptr(key), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall12(procRegQueryInfoKeyW.Addr(), 12, uintptr(key), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(subkeysLen)), uintptr(unsafe.Pointer(maxSubkeyLen)), uintptr(unsafe.Pointer(maxClassLen)), uintptr(unsafe.Pointer(valuesLen)), uintptr(unsafe.Pointer(maxValueNameLen)), uintptr(unsafe.Pointer(maxValueLen)), uintptr(unsafe.Pointer(saLen)), uintptr(unsafe.Pointer(lastWriteTime)))%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegEnumKeyEx(key Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *Filetime) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall9(procRegEnumKeyExW.Addr(), 8, uintptr(key), uintptr(index), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(lastWriteTime)), 0)%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegQueryValueEx(key Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall6(procRegQueryValueExW.Addr(), 6, uintptr(key), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(valtype)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(buflen)))%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getCurrentProcessId() (pid uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetCurrentProcessId.Addr(), 0, 0, 0, 0)%0A%09pid = uint32(r0)%0A%09return%0A%7D%0A%0Afunc GetConsoleMode(console Handle, mode *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetConsoleMode.Addr(), 2, uintptr(console), uintptr(unsafe.Pointer(mode)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetConsoleMode(console Handle, mode uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetConsoleMode.Addr(), 2, uintptr(console), uintptr(mode), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetConsoleScreenBufferInfo(console Handle, info *ConsoleScreenBufferInfo) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetConsoleScreenBufferInfo.Addr(), 2, uintptr(console), uintptr(unsafe.Pointer(info)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WriteConsole(console Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procWriteConsoleW.Addr(), 5, uintptr(console), uintptr(unsafe.Pointer(buf)), uintptr(towrite), uintptr(unsafe.Pointer(written)), uintptr(unsafe.Pointer(reserved)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ReadConsole(console Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procReadConsoleW.Addr(), 5, uintptr(console), uintptr(unsafe.Pointer(buf)), uintptr(toread), uintptr(unsafe.Pointer(read)), uintptr(unsafe.Pointer(inputControl)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCreateToolhelp32Snapshot.Addr(), 2, uintptr(flags), uintptr(processId), 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Process32First(snapshot Handle, procEntry *ProcessEntry32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procProcess32FirstW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(procEntry)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procProcess32NextW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(procEntry)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procDeviceIoControl.Addr(), 8, uintptr(handle), uintptr(ioControlCode), uintptr(unsafe.Pointer(inBuffer)), uintptr(inBufferSize), uintptr(unsafe.Pointer(outBuffer)), uintptr(outBufferSize), uintptr(unsafe.Pointer(bytesReturned)), uintptr(unsafe.Pointer(overlapped)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCreateSymbolicLinkW.Addr(), 3, uintptr(unsafe.Pointer(symlinkfilename)), uintptr(unsafe.Pointer(targetfilename)), uintptr(flags))%0A%09if r1&0xff == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCreateHardLinkW.Addr(), 3, uintptr(unsafe.Pointer(filename)), uintptr(unsafe.Pointer(existingfilename)), uintptr(reserved))%0A%09if r1&0xff == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetCurrentThreadId() (id uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetCurrentThreadId.Addr(), 0, 0, 0, 0)%0A%09id = uint32(r0)%0A%09return%0A%7D%0A%0Afunc CreateEvent(eventAttrs *SecurityAttributes, manualReset uint32, initialState uint32, name *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCreateEventW.Addr(), 4, uintptr(unsafe.Pointer(eventAttrs)), uintptr(manualReset), uintptr(initialState), uintptr(unsafe.Pointer(name)), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateEventEx(eventAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCreateEventExW.Addr(), 4, uintptr(unsafe.Pointer(eventAttrs)), uintptr(unsafe.Pointer(name)), uintptr(flags), uintptr(desiredAccess), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenEvent(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) %7B%0A%09var _p0 uint32%0A%09if inheritHandle %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r0, _, e1 := syscall.Syscall(procOpenEventW.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(unsafe.Pointer(name)))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetEvent(event Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetEvent.Addr(), 1, uintptr(event), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ResetEvent(event Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procResetEvent.Addr(), 1, uintptr(event), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc PulseEvent(event Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procPulseEvent.Addr(), 1, uintptr(event), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DefineDosDevice(flags uint32, deviceName *uint16, targetPath *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDefineDosDeviceW.Addr(), 3, uintptr(flags), uintptr(unsafe.Pointer(deviceName)), uintptr(unsafe.Pointer(targetPath)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeleteVolumeMountPoint(volumeMountPoint *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDeleteVolumeMountPointW.Addr(), 1, uintptr(unsafe.Pointer(volumeMountPoint)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procFindFirstVolumeW.Addr(), 2, uintptr(unsafe.Pointer(volumeName)), uintptr(bufferLength), 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindFirstVolumeMountPoint(rootPathName *uint16, volumeMountPoint *uint16, bufferLength uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procFindFirstVolumeMountPointW.Addr(), 3, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(bufferLength))%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindNextVolumeW.Addr(), 3, uintptr(findVolume), uintptr(unsafe.Pointer(volumeName)), uintptr(bufferLength))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindNextVolumeMountPointW.Addr(), 3, uintptr(findVolumeMountPoint), uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(bufferLength))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindVolumeClose(findVolume Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindVolumeClose.Addr(), 1, uintptr(findVolume), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindVolumeMountPointClose(findVolumeMountPoint Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindVolumeMountPointClose.Addr(), 1, uintptr(findVolumeMountPoint), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetDriveType(rootPathName *uint16) (driveType uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetDriveTypeW.Addr(), 1, uintptr(unsafe.Pointer(rootPathName)), 0, 0)%0A%09driveType = uint32(r0)%0A%09return%0A%7D%0A%0Afunc GetLogicalDrives() (drivesBitMask uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetLogicalDrives.Addr(), 0, 0, 0, 0)%0A%09drivesBitMask = uint32(r0)%0A%09if drivesBitMask == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetLogicalDriveStrings(bufferLength uint32, buffer *uint16) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetLogicalDriveStringsW.Addr(), 2, uintptr(bufferLength), uintptr(unsafe.Pointer(buffer)), 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumeInformation(rootPathName *uint16, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procGetVolumeInformationW.Addr(), 8, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeNameBuffer)), uintptr(volumeNameSize), uintptr(unsafe.Pointer(volumeNameSerialNumber)), uintptr(unsafe.Pointer(maximumComponentLength)), uintptr(unsafe.Pointer(fileSystemFlags)), uintptr(unsafe.Pointer(fileSystemNameBuffer)), uintptr(fileSystemNameSize), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumeInformationByHandle(file Handle, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procGetVolumeInformationByHandleW.Addr(), 8, uintptr(file), uintptr(unsafe.Pointer(volumeNameBuffer)), uintptr(volumeNameSize), uintptr(unsafe.Pointer(volumeNameSerialNumber)), uintptr(unsafe.Pointer(maximumComponentLength)), uintptr(unsafe.Pointer(fileSystemFlags)), uintptr(unsafe.Pointer(fileSystemNameBuffer)), uintptr(fileSystemNameSize), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumeNameForVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16, bufferlength uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetVolumeNameForVolumeMountPointW.Addr(), 3, uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(unsafe.Pointer(volumeName)), uintptr(bufferlength))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumePathName(fileName *uint16, volumePathName *uint16, bufferLength uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetVolumePathNameW.Addr(), 3, uintptr(unsafe.Pointer(fileName)), uintptr(unsafe.Pointer(volumePathName)), uintptr(bufferLength))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procGetVolumePathNamesForVolumeNameW.Addr(), 4, uintptr(unsafe.Pointer(volumeName)), uintptr(unsafe.Pointer(volumePathNames)), uintptr(bufferLength), uintptr(unsafe.Pointer(returnLength)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc QueryDosDevice(deviceName *uint16, targetPath *uint16, max uint32) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procQueryDosDeviceW.Addr(), 3, uintptr(unsafe.Pointer(deviceName)), uintptr(unsafe.Pointer(targetPath)), uintptr(max))%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetVolumeLabel(rootPathName *uint16, volumeName *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetVolumeLabelW.Addr(), 2, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeName)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetVolumeMountPointW.Addr(), 2, uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(unsafe.Pointer(volumeName)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSAStartup(verreq uint32, data *WSAData) (sockerr error) %7B%0A%09r0, _, _ := syscall.Syscall(procWSAStartup.Addr(), 2, uintptr(verreq), uintptr(unsafe.Pointer(data)), 0)%0A%09if r0 != 0 %7B%0A%09%09sockerr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSACleanup() (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procWSACleanup.Addr(), 0, 0, 0, 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSAIoctl.Addr(), 9, uintptr(s), uintptr(iocc), uintptr(unsafe.Pointer(inbuf)), uintptr(cbif), uintptr(unsafe.Pointer(outbuf)), uintptr(cbob), uintptr(unsafe.Pointer(cbbr)), uintptr(unsafe.Pointer(overlapped)), uintptr(completionRoutine))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socket(af int32, typ int32, protocol int32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procsocket.Addr(), 3, uintptr(af), uintptr(typ), uintptr(protocol))%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procsetsockopt.Addr(), 5, uintptr(s), uintptr(level), uintptr(optname), uintptr(unsafe.Pointer(optval)), uintptr(optlen), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getsockopt(s Handle, level int32, optname int32, optval *byte, optlen *int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procgetsockopt.Addr(), 5, uintptr(s), uintptr(level), uintptr(optname), uintptr(unsafe.Pointer(optval)), uintptr(unsafe.Pointer(optlen)), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc bind(s Handle, name unsafe.Pointer, namelen int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procbind.Addr(), 3, uintptr(s), uintptr(name), uintptr(namelen))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc connect(s Handle, name unsafe.Pointer, namelen int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procconnect.Addr(), 3, uintptr(s), uintptr(name), uintptr(namelen))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procgetsockname.Addr(), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procgetpeername.Addr(), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc listen(s Handle, backlog int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(proclisten.Addr(), 2, uintptr(s), uintptr(backlog), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc shutdown(s Handle, how int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procshutdown.Addr(), 2, uintptr(s), uintptr(how), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Closesocket(s Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procclosesocket.Addr(), 1, uintptr(s), 0, 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procAcceptEx.Addr(), 8, uintptr(ls), uintptr(as), uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(overlapped)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) %7B%0A%09syscall.Syscall9(procGetAcceptExSockaddrs.Addr(), 8, uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(lrsa)), uintptr(unsafe.Pointer(lrsalen)), uintptr(unsafe.Pointer(rrsa)), uintptr(unsafe.Pointer(rrsalen)), 0)%0A%09return%0A%7D%0A%0Afunc WSARecv(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSARecv.Addr(), 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSASend(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSASend.Addr(), 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSARecvFrom(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, from *RawSockaddrAny, fromlen *int32, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSARecvFrom.Addr(), 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSASendTo.Addr(), 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(to)), uintptr(tolen), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetHostByName(name string) (h *Hostent, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = syscall.BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _GetHostByName(_p0)%0A%7D%0A%0Afunc _GetHostByName(name *byte) (h *Hostent, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procgethostbyname.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)%0A%09h = (*Hostent)(unsafe.Pointer(r0))%0A%09if h == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetServByName(name string, proto string) (s *Servent, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = syscall.BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = syscall.BytePtrFromString(proto)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _GetServByName(_p0, _p1)%0A%7D%0A%0Afunc _GetServByName(name *byte, proto *byte) (s *Servent, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procgetservbyname.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(proto)), 0)%0A%09s = (*Servent)(unsafe.Pointer(r0))%0A%09if s == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Ntohs(netshort uint16) (u uint16) %7B%0A%09r0, _, _ := syscall.Syscall(procntohs.Addr(), 1, uintptr(netshort), 0, 0)%0A%09u = uint16(r0)%0A%09return%0A%7D%0A%0Afunc GetProtoByName(name string) (p *Protoent, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = syscall.BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _GetProtoByName(_p0)%0A%7D%0A%0Afunc _GetProtoByName(name *byte) (p *Protoent, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procgetprotobyname.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)%0A%09p = (*Protoent)(unsafe.Pointer(r0))%0A%09if p == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) %7B%0A%09var _p0 *uint16%0A%09_p0, status = syscall.UTF16PtrFromString(name)%0A%09if status != nil %7B%0A%09%09return%0A%09%7D%0A%09return _DnsQuery(_p0, qtype, options, extra, qrs, pr)%0A%7D%0A%0Afunc _DnsQuery(name *uint16, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) %7B%0A%09r0, _, _ := syscall.Syscall6(procDnsQuery_W.Addr(), 6, uintptr(unsafe.Pointer(name)), uintptr(qtype), uintptr(options), uintptr(unsafe.Pointer(extra)), uintptr(unsafe.Pointer(qrs)), uintptr(unsafe.Pointer(pr)))%0A%09if r0 != 0 %7B%0A%09%09status = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DnsRecordListFree(rl *DNSRecord, freetype uint32) %7B%0A%09syscall.Syscall(procDnsRecordListFree.Addr(), 2, uintptr(unsafe.Pointer(rl)), uintptr(freetype), 0)%0A%09return%0A%7D%0A%0Afunc DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) %7B%0A%09r0, _, _ := syscall.Syscall(procDnsNameCompare_W.Addr(), 2, uintptr(unsafe.Pointer(name1)), uintptr(unsafe.Pointer(name2)), 0)%0A%09same = r0 != 0%0A%09return%0A%7D%0A%0Afunc GetAddrInfoW(nodename *uint16, servicename *uint16, hints *AddrinfoW, result **AddrinfoW) (sockerr error) %7B%0A%09r0, _, _ := syscall.Syscall6(procGetAddrInfoW.Addr(), 4, uintptr(unsafe.Pointer(nodename)), uintptr(unsafe.Pointer(servicename)), uintptr(unsafe.Pointer(hints)), uintptr(unsafe.Pointer(result)), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09sockerr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FreeAddrInfoW(addrinfo *AddrinfoW) %7B%0A%09syscall.Syscall(procFreeAddrInfoW.Addr(), 1, uintptr(unsafe.Pointer(addrinfo)), 0, 0)%0A%09return%0A%7D%0A%0Afunc GetIfEntry(pIfRow *MibIfRow) (errcode error) %7B%0A%09r0, _, _ := syscall.Syscall(procGetIfEntry.Addr(), 1, uintptr(unsafe.Pointer(pIfRow)), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09errcode = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode error) %7B%0A%09r0, _, _ := syscall.Syscall(procGetAdaptersInfo.Addr(), 2, uintptr(unsafe.Pointer(ai)), uintptr(unsafe.Pointer(ol)), 0)%0A%09if r0 != 0 %7B%0A%09%09errcode = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetFileCompletionNotificationModes.Addr(), 2, uintptr(handle), uintptr(flags), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSAEnumProtocols(protocols *int32, protocolBuffer *WSAProtocolInfo, bufferLength *uint32) (n int32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procWSAEnumProtocolsW.Addr(), 3, uintptr(unsafe.Pointer(protocols)), uintptr(unsafe.Pointer(protocolBuffer)), uintptr(unsafe.Pointer(bufferLength)))%0A%09n = int32(r0)%0A%09if n == -1 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) %7B%0A%09r0, _, _ := syscall.Syscall6(procGetAdaptersAddresses.Addr(), 5, uintptr(family), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(adapterAddresses)), uintptr(unsafe.Pointer(sizePointer)), 0)%0A%09if r0 != 0 %7B%0A%09%09errcode = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetACP() (acp uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetACP.Addr(), 0, 0, 0, 0)%0A%09acp = uint32(r0)%0A%09return%0A%7D%0A%0Afunc MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procMultiByteToWideChar.Addr(), 6, uintptr(codePage), uintptr(dwFlags), uintptr(unsafe.Pointer(str)), uintptr(nstr), uintptr(unsafe.Pointer(wchar)), uintptr(nwchar))%0A%09nwrite = int32(r0)%0A%09if nwrite == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procTranslateNameW.Addr(), 5, uintptr(unsafe.Pointer(accName)), uintptr(accNameFormat), uintptr(desiredNameFormat), uintptr(unsafe.Pointer(translatedName)), uintptr(unsafe.Pointer(nSize)), 0)%0A%09if r1&0xff == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetUserNameExW.Addr(), 3, uintptr(nameFormat), uintptr(unsafe.Pointer(nameBuffre)), uintptr(unsafe.Pointer(nSize)))%0A%09if r1&0xff == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc NetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) %7B%0A%09r0, _, _ := syscall.Syscall6(procNetUserGetInfo.Addr(), 4, uintptr(unsafe.Pointer(serverName)), uintptr(unsafe.Pointer(userName)), uintptr(level), uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09neterr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc NetGetJoinInformation(server *uint16, name **uint16, bufType *uint32) (neterr error) %7B%0A%09r0, _, _ := syscall.Syscall(procNetGetJoinInformation.Addr(), 3, uintptr(unsafe.Pointer(server)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(bufType)))%0A%09if r0 != 0 %7B%0A%09%09neterr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc NetApiBufferFree(buf *byte) (neterr error) %7B%0A%09r0, _, _ := syscall.Syscall(procNetApiBufferFree.Addr(), 1, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09neterr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procLookupAccountSidW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procLookupAccountNameW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(accountName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(sidLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procConvertSidToStringSidW.Addr(), 2, uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(stringSid)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procConvertStringSidToSidW.Addr(), 2, uintptr(unsafe.Pointer(stringSid)), uintptr(unsafe.Pointer(sid)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetLengthSid(sid *SID) (len uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetLengthSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)%0A%09len = uint32(r0)%0A%09return%0A%7D%0A%0Afunc CopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCopySid.Addr(), 3, uintptr(destSidLen), uintptr(unsafe.Pointer(destSid)), uintptr(unsafe.Pointer(srcSid)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc AllocateAndInitializeSid(identAuth *SidIdentifierAuthority, subAuth byte, subAuth0 uint32, subAuth1 uint32, subAuth2 uint32, subAuth3 uint32, subAuth4 uint32, subAuth5 uint32, subAuth6 uint32, subAuth7 uint32, sid **SID) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall12(procAllocateAndInitializeSid.Addr(), 11, uintptr(unsafe.Pointer(identAuth)), uintptr(subAuth), uintptr(subAuth0), uintptr(subAuth1), uintptr(subAuth2), uintptr(subAuth3), uintptr(subAuth4), uintptr(subAuth5), uintptr(subAuth6), uintptr(subAuth7), uintptr(unsafe.Pointer(sid)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FreeSid(sid *SID) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFreeSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)%0A%09if r1 != 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc EqualSid(sid1 *SID, sid2 *SID) (isEqual bool) %7B%0A%09r0, _, _ := syscall.Syscall(procEqualSid.Addr(), 2, uintptr(unsafe.Pointer(sid1)), uintptr(unsafe.Pointer(sid2)), 0)%0A%09isEqual = r0 != 0%0A%09return%0A%7D%0A%0Afunc checkTokenMembership(tokenHandle Token, sidToCheck *SID, isMember *int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCheckTokenMembership.Addr(), 3, uintptr(tokenHandle), uintptr(unsafe.Pointer(sidToCheck)), uintptr(unsafe.Pointer(isMember)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenProcessToken(h Handle, access uint32, token *Token) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procOpenProcessToken.Addr(), 3, uintptr(h), uintptr(access), uintptr(unsafe.Pointer(token)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procGetTokenInformation.Addr(), 5, uintptr(t), uintptr(infoClass), uintptr(unsafe.Pointer(info)), uintptr(infoLen), uintptr(unsafe.Pointer(returnedLen)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetUserProfileDirectoryW.Addr(), 3, uintptr(t), uintptr(unsafe.Pointer(dir)), uintptr(unsafe.Pointer(dirLen)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A
treehash 79136fa29d6d0e1eefe184862aac30eff47604434ddab55fd74508fbb5871369
