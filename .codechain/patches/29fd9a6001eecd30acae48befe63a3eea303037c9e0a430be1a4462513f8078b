codechain patchfile version 1
treehash 29fd9a6001eecd30acae48befe63a3eea303037c9e0a430be1a4462513f8078b
- f 47c14b7940ca6987436c0ff2f1ca07b5b4c5a679ec09b242dd9a0c1965ab0973 Gopkg.lock
- f 213f45665dec4e489bd0956ea25a68c07545ccc4f5b8aa2bc96a3a45378b2d96 Gopkg.toml
- f a3c852d5cf9b0eca04f59f8e62102f1a5200819277c11425e9c41bcfde121c8f Makefile
+ f f96512c11f09a3223b25c82fe087fe519effb70d41be2dddbef1645251fe29ca Makefile
dmppatch 13
@@ -2,59 +2,60 @@
 ll:%0A
-%09go install -v github.com/frankbraun/codechain/...%0A
+%09env GO111MODULE=on go install -mod vendor -v ./...%0A
 %0A.PH
@@ -157,37 +157,8 @@
 or:%0A
-%09rm -f Gopkg.lock Gopkg.toml%0A
 %09rm 
@@ -172,67 +172,68 @@
 dor%0A
-%09dep init -v%0A%09slimdep -r -v -a github.com/frankbraun/codechain%0A
+%09env GO111MODULE=on go get -u%0A%09env GO111MODULE=on go mod vendor%0A
+ f 752dc7bf3a19f519bf2e72880a027f823ac22e0149b7f223c3ead35e559a51d9 go.mod
dmppatch 2
@@ -0,0 +1,395 @@
+module github.com/frankbraun/codechain%0A%0Arequire (%0A%09github.com/fatih/color v1.7.0%0A%09github.com/mattn/go-colorable v0.0.9 // indirect%0A%09github.com/mattn/go-isatty v0.0.4 // indirect%0A%09github.com/mutecomm/mute v0.0.0-20180427225835-8124193e6371%0A%09github.com/sergi/go-diff v1.0.0%0A%09golang.org/x/crypto v0.0.0-20180910181607-0e37d006457b%0A%09golang.org/x/sys v0.0.0-20180926160741-c2ed4eda69e7 // indirect%0A)%0A
+ f bf1f9185121338477ed45683782d89eeecc3c3a898aed521f0ce9d7659c85719 go.sum
dmppatch 2
@@ -0,0 +1,1321 @@
+github.com/fatih/color v1.7.0 h1:DkWD4oS2D8LGGgTQ6IvwJJXSL5Vp2ffcQg58nFV38Ys=%0Agithub.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=%0Agithub.com/mattn/go-colorable v0.0.9 h1:UVL0vNpWh04HeJXV0KLcaT7r06gOH2l4OW6ddYRUIY4=%0Agithub.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=%0Agithub.com/mattn/go-isatty v0.0.4 h1:bnP0vzxcAdeI1zdubAl5PjU6zsERjGZb7raWodagDYs=%0Agithub.com/mattn/go-isatty v0.0.4/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=%0Agithub.com/mutecomm/mute v0.0.0-20180427225835-8124193e6371 h1:WosDb7JpqWb/83fMUuGh8SqNbks0lHNtn3Ky/kRr9kM=%0Agithub.com/mutecomm/mute v0.0.0-20180427225835-8124193e6371/go.mod h1:V0AN5RERqeAJ0oaqiH0WzgjFmdm2FFT+hmSU1hI1Aq8=%0Agithub.com/sergi/go-diff v1.0.0 h1:Kpca3qRNrduNnOQeazBd0ysaKrUJiIuISHxogkT9RPQ=%0Agithub.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=%0Agolang.org/x/crypto v0.0.0-20180910181607-0e37d006457b h1:2b9XGzhjiYsYPnKXoEfL7klWZQIt8IfyRCz62gCqqlQ=%0Agolang.org/x/crypto v0.0.0-20180910181607-0e37d006457b/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=%0Agolang.org/x/sys v0.0.0-20180926160741-c2ed4eda69e7 h1:bit1t3mgdR35yN0cX0G8orgLtOuyL9Wqxa1mccLB0ig=%0Agolang.org/x/sys v0.0.0-20180926160741-c2ed4eda69e7/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=%0A
- f bf9815c57c4ce33b5742f1561ef3c9993af39aa406d8d90595ec57ca699e3f63 vendor/github.com/fatih/color/color.go
+ f abc3b13187b1d0af6f264b7590a97d9ba44bae86d173f4f1c3a7242180abd767 vendor/github.com/fatih/color/color.go
dmppatch 43
@@ -24,16 +24,22 @@
 %0A%09%22fmt%22%0A
+%09%22io%22%0A
 %09%22os%22%0A%09%22
@@ -1701,16 +1701,306 @@
 hite%0A)%0A%0A
+// Background text colors%0Aconst (%0A%09BgBlack Attribute = iota + 40%0A%09BgRed%0A%09BgGreen%0A%09BgYellow%0A%09BgBlue%0A%09BgMagenta%0A%09BgCyan%0A%09BgWhite%0A)%0A%0A// Background Hi-Intensity text colors%0Aconst (%0A%09BgHiBlack Attribute = iota + 100%0A%09BgHiRed%0A%09BgHiGreen%0A%09BgHiYellow%0A%09BgHiBlue%0A%09BgHiMagenta%0A%09BgHiCyan%0A%09BgHiWhite%0A)%0A%0A
 // New r
@@ -2143,24 +2143,930 @@
 return c%0A%7D%0A%0A
+// Set sets the given parameters immediately. It will change the color of%0A// output with the given SGR parameters until color.Unset() is called.%0Afunc Set(p ...Attribute) *Color %7B%0A%09c := New(p...)%0A%09c.Set()%0A%09return c%0A%7D%0A%0A// Unset resets all escape attributes and clears the output. Usually should%0A// be called after Set().%0Afunc Unset() %7B%0A%09if NoColor %7B%0A%09%09return%0A%09%7D%0A%0A%09fmt.Fprintf(Output, %22%25s%5B%25dm%22, escape, Reset)%0A%7D%0A%0A// Set sets the SGR sequence.%0Afunc (c *Color) Set() *Color %7B%0A%09if c.isNoColorSet() %7B%0A%09%09return c%0A%09%7D%0A%0A%09fmt.Fprintf(Output, c.format())%0A%09return c%0A%7D%0A%0Afunc (c *Color) unset() %7B%0A%09if c.isNoColorSet() %7B%0A%09%09return%0A%09%7D%0A%0A%09Unset()%0A%7D%0A%0Afunc (c *Color) setWriter(w io.Writer) *Color %7B%0A%09if c.isNoColorSet() %7B%0A%09%09return c%0A%09%7D%0A%0A%09fmt.Fprintf(w, c.format())%0A%09return c%0A%7D%0A%0Afunc (c *Color) unsetWriter(w io.Writer) %7B%0A%09if c.isNoColorSet() %7B%0A%09%09return%0A%09%7D%0A%0A%09if NoColor %7B%0A%09%09return%0A%09%7D%0A%0A%09fmt.Fprintf(w, %22%25s%5B%25dm%22, escape, Reset)%0A%7D%0A%0A
 // Add is us
@@ -3307,24 +3307,4665 @@
 return c%0A%7D%0A%0A
+func (c *Color) prepend(value Attribute) %7B%0A%09c.params = append(c.params, 0)%0A%09copy(c.params%5B1:%5D, c.params%5B0:%5D)%0A%09c.params%5B0%5D = value%0A%7D%0A%0A// Fprint formats using the default formats for its operands and writes to w.%0A// Spaces are added between operands when neither is a string.%0A// It returns the number of bytes written and any write error encountered.%0A// On Windows, users should wrap w with colorable.NewColorable() if w is of%0A// type *os.File.%0Afunc (c *Color) Fprint(w io.Writer, a ...interface%7B%7D) (n int, err error) %7B%0A%09c.setWriter(w)%0A%09defer c.unsetWriter(w)%0A%0A%09return fmt.Fprint(w, a...)%0A%7D%0A%0A// Print formats using the default formats for its operands and writes to%0A// standard output. Spaces are added between operands when neither is a%0A// string. It returns the number of bytes written and any write error%0A// encountered. This is the standard fmt.Print() method wrapped with the given%0A// color.%0Afunc (c *Color) Print(a ...interface%7B%7D) (n int, err error) %7B%0A%09c.Set()%0A%09defer c.unset()%0A%0A%09return fmt.Fprint(Output, a...)%0A%7D%0A%0A// Fprintf formats according to a format specifier and writes to w.%0A// It returns the number of bytes written and any write error encountered.%0A// On Windows, users should wrap w with colorable.NewColorable() if w is of%0A// type *os.File.%0Afunc (c *Color) Fprintf(w io.Writer, format string, a ...interface%7B%7D) (n int, err error) %7B%0A%09c.setWriter(w)%0A%09defer c.unsetWriter(w)%0A%0A%09return fmt.Fprintf(w, format, a...)%0A%7D%0A%0A// Printf formats according to a format specifier and writes to standard output.%0A// It returns the number of bytes written and any write error encountered.%0A// This is the standard fmt.Printf() method wrapped with the given color.%0Afunc (c *Color) Printf(format string, a ...interface%7B%7D) (n int, err error) %7B%0A%09c.Set()%0A%09defer c.unset()%0A%0A%09return fmt.Fprintf(Output, format, a...)%0A%7D%0A%0A// Fprintln formats using the default formats for its operands and writes to w.%0A// Spaces are always added between operands and a newline is appended.%0A// On Windows, users should wrap w with colorable.NewColorable() if w is of%0A// type *os.File.%0Afunc (c *Color) Fprintln(w io.Writer, a ...interface%7B%7D) (n int, err error) %7B%0A%09c.setWriter(w)%0A%09defer c.unsetWriter(w)%0A%0A%09return fmt.Fprintln(w, a...)%0A%7D%0A%0A// Println formats using the default formats for its operands and writes to%0A// standard output. Spaces are always added between operands and a newline is%0A// appended. It returns the number of bytes written and any write error%0A// encountered. This is the standard fmt.Print() method wrapped with the given%0A// color.%0Afunc (c *Color) Println(a ...interface%7B%7D) (n int, err error) %7B%0A%09c.Set()%0A%09defer c.unset()%0A%0A%09return fmt.Fprintln(Output, a...)%0A%7D%0A%0A// Sprint is just like Print, but returns a string instead of printing it.%0Afunc (c *Color) Sprint(a ...interface%7B%7D) string %7B%0A%09return c.wrap(fmt.Sprint(a...))%0A%7D%0A%0A// Sprintln is just like Println, but returns a string instead of printing it.%0Afunc (c *Color) Sprintln(a ...interface%7B%7D) string %7B%0A%09return c.wrap(fmt.Sprintln(a...))%0A%7D%0A%0A// Sprintf is just like Printf, but returns a string instead of printing it.%0Afunc (c *Color) Sprintf(format string, a ...interface%7B%7D) string %7B%0A%09return c.wrap(fmt.Sprintf(format, a...))%0A%7D%0A%0A// FprintFunc returns a new function that prints the passed arguments as%0A// colorized with color.Fprint().%0Afunc (c *Color) FprintFunc() func(w io.Writer, a ...interface%7B%7D) %7B%0A%09return func(w io.Writer, a ...interface%7B%7D) %7B%0A%09%09c.Fprint(w, a...)%0A%09%7D%0A%7D%0A%0A// PrintFunc returns a new function that prints the passed arguments as%0A// colorized with color.Print().%0Afunc (c *Color) PrintFunc() func(a ...interface%7B%7D) %7B%0A%09return func(a ...interface%7B%7D) %7B%0A%09%09c.Print(a...)%0A%09%7D%0A%7D%0A%0A// FprintfFunc returns a new function that prints the passed arguments as%0A// colorized with color.Fprintf().%0Afunc (c *Color) FprintfFunc() func(w io.Writer, format string, a ...interface%7B%7D) %7B%0A%09return func(w io.Writer, format string, a ...interface%7B%7D) %7B%0A%09%09c.Fprintf(w, format, a...)%0A%09%7D%0A%7D%0A%0A// PrintfFunc returns a new function that prints the passed arguments as%0A// colorized with color.Printf().%0Afunc (c *Color) PrintfFunc() func(format string, a ...interface%7B%7D) %7B%0A%09return func(format string, a ...interface%7B%7D) %7B%0A%09%09c.Printf(format, a...)%0A%09%7D%0A%7D%0A%0A// FprintlnFunc returns a new function that prints the passed arguments as%0A// colorized with color.Fprintln().%0Afunc (c *Color) FprintlnFunc() func(w io.Writer, a ...interface%7B%7D) %7B%0A%09return func(w io.Writer, a ...interface%7B%7D) %7B%0A%09%09c.Fprintln(w, a...)%0A%09%7D%0A%7D%0A%0A// PrintlnFunc returns a new function that prints the passed arguments as%0A// colorized with color.Println().%0Afunc (c *Color) PrintlnFunc() func(a ...interface%7B%7D) %7B%0A%09return func(a ...interface%7B%7D) %7B%0A%09%09c.Println(a...)%0A%09%7D%0A%7D%0A%0A
 // SprintFun
@@ -8838,16 +8838,391 @@
 )%0A%09%7D%0A%7D%0A%0A
+// SprintlnFunc returns a new function that returns colorized strings for the%0A// given arguments with fmt.Sprintln(). Useful to put into or mix into other%0A// string. Windows users should use this in conjunction with color.Output.%0Afunc (c *Color) SprintlnFunc() func(a ...interface%7B%7D) string %7B%0A%09return func(a ...interface%7B%7D) string %7B%0A%09%09return c.wrap(fmt.Sprintln(a...))%0A%09%7D%0A%7D%0A%0A
 // seque
@@ -9906,24 +9906,482 @@
 , Reset)%0A%7D%0A%0A
+// DisableColor disables the color output. Useful to not change any existing%0A// code and still being able to output. Can be used for flags like%0A// %22--no-color%22. To enable back use EnableColor() method.%0Afunc (c *Color) DisableColor() %7B%0A%09c.noColor = boolPtr(true)%0A%7D%0A%0A// EnableColor enables the color output. Use it in conjunction with%0A// DisableColor(). Otherwise this method has no side effects.%0Afunc (c *Color) EnableColor() %7B%0A%09c.noColor = boolPtr(false)%0A%7D%0A%0A
 func (c *Col
@@ -10580,24 +10580,478 @@
  NoColor%0A%7D%0A%0A
+// Equals returns a boolean value indicating whether two colors are equal.%0Afunc (c *Color) Equals(c2 *Color) bool %7B%0A%09if len(c.params) != len(c2.params) %7B%0A%09%09return false%0A%09%7D%0A%0A%09for _, attr := range c.params %7B%0A%09%09if !c2.attrExists(attr) %7B%0A%09%09%09return false%0A%09%09%7D%0A%09%7D%0A%0A%09return true%0A%7D%0A%0Afunc (c *Color) attrExists(a Attribute) bool %7B%0A%09for _, attr := range c.params %7B%0A%09%09if attr == a %7B%0A%09%09%09return true%0A%09%09%7D%0A%09%7D%0A%0A%09return false%0A%7D%0A%0Afunc boolPtr(v bool) *bool %7B%0A%09return &v%0A%7D%0A%0A
 func getCach
@@ -11215,24 +11215,250 @@
 return c%0A%7D%0A%0A
+func colorPrint(format string, p Attribute, a ...interface%7B%7D) %7B%0A%09c := getCachedColor(p)%0A%0A%09if !strings.HasSuffix(format, %22%5Cn%22) %7B%0A%09%09format += %22%5Cn%22%0A%09%7D%0A%0A%09if len(a) == 0 %7B%0A%09%09c.Print(format)%0A%09%7D else %7B%0A%09%09c.Printf(format, a...)%0A%09%7D%0A%7D%0A%0A
 func colorSt
@@ -11637,16 +11637,1832 @@
 ...)%0A%7D%0A%0A
+// Black is a convenient helper function to print with black foreground. A%0A// newline is appended to format by default.%0Afunc Black(format string, a ...interface%7B%7D) %7B colorPrint(format, FgBlack, a...) %7D%0A%0A// Red is a convenient helper function to print with red foreground. A%0A// newline is appended to format by default.%0Afunc Red(format string, a ...interface%7B%7D) %7B colorPrint(format, FgRed, a...) %7D%0A%0A// Green is a convenient helper function to print with green foreground. A%0A// newline is appended to format by default.%0Afunc Green(format string, a ...interface%7B%7D) %7B colorPrint(format, FgGreen, a...) %7D%0A%0A// Yellow is a convenient helper function to print with yellow foreground.%0A// A newline is appended to format by default.%0Afunc Yellow(format string, a ...interface%7B%7D) %7B colorPrint(format, FgYellow, a...) %7D%0A%0A// Blue is a convenient helper function to print with blue foreground. A%0A// newline is appended to format by default.%0Afunc Blue(format string, a ...interface%7B%7D) %7B colorPrint(format, FgBlue, a...) %7D%0A%0A// Magenta is a convenient helper function to print with magenta foreground.%0A// A newline is appended to format by default.%0Afunc Magenta(format string, a ...interface%7B%7D) %7B colorPrint(format, FgMagenta, a...) %7D%0A%0A// Cyan is a convenient helper function to print with cyan foreground. A%0A// newline is appended to format by default.%0Afunc Cyan(format string, a ...interface%7B%7D) %7B colorPrint(format, FgCyan, a...) %7D%0A%0A// White is a convenient helper function to print with white foreground. A%0A// newline is appended to format by default.%0Afunc White(format string, a ...interface%7B%7D) %7B colorPrint(format, FgWhite, a...) %7D%0A%0A// BlackString is a convenient helper function to return a string with black%0A// foreground.%0Afunc BlackString(format string, a ...interface%7B%7D) string %7B return colorString(format, FgBlack, a...) %7D%0A%0A
 // RedSt
@@ -14822,16 +14822,2004 @@
 ...) %7D%0A%0A
+// HiBlack is a convenient helper function to print with hi-intensity black foreground. A%0A// newline is appended to format by default.%0Afunc HiBlack(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiBlack, a...) %7D%0A%0A// HiRed is a convenient helper function to print with hi-intensity red foreground. A%0A// newline is appended to format by default.%0Afunc HiRed(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiRed, a...) %7D%0A%0A// HiGreen is a convenient helper function to print with hi-intensity green foreground. A%0A// newline is appended to format by default.%0Afunc HiGreen(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiGreen, a...) %7D%0A%0A// HiYellow is a convenient helper function to print with hi-intensity yellow foreground.%0A// A newline is appended to format by default.%0Afunc HiYellow(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiYellow, a...) %7D%0A%0A// HiBlue is a convenient helper function to print with hi-intensity blue foreground. A%0A// newline is appended to format by default.%0Afunc HiBlue(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiBlue, a...) %7D%0A%0A// HiMagenta is a convenient helper function to print with hi-intensity magenta foreground.%0A// A newline is appended to format by default.%0Afunc HiMagenta(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiMagenta, a...) %7D%0A%0A// HiCyan is a convenient helper function to print with hi-intensity cyan foreground. A%0A// newline is appended to format by default.%0Afunc HiCyan(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiCyan, a...) %7D%0A%0A// HiWhite is a convenient helper function to print with hi-intensity white foreground. A%0A// newline is appended to format by default.%0Afunc HiWhite(format string, a ...interface%7B%7D) %7B colorPrint(format, FgHiWhite, a...) %7D%0A%0A// HiBlackString is a convenient helper function to return a string with hi-intensity black%0A// foreground.%0Afunc HiBlackString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiBlack, a...)%0A%7D%0A%0A
 // HiRed
@@ -16996,28 +16996,1326 @@
 ng(format, FgHiRed, a...) %7D%0A
+%0A// HiGreenString is a convenient helper function to return a string with hi-intensity green%0A// foreground.%0Afunc HiGreenString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiGreen, a...)%0A%7D%0A%0A// HiYellowString is a convenient helper function to return a string with hi-intensity yellow%0A// foreground.%0Afunc HiYellowString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiYellow, a...)%0A%7D%0A%0A// HiBlueString is a convenient helper function to return a string with hi-intensity blue%0A// foreground.%0Afunc HiBlueString(format string, a ...interface%7B%7D) string %7B return colorString(format, FgHiBlue, a...) %7D%0A%0A// HiMagentaString is a convenient helper function to return a string with hi-intensity magenta%0A// foreground.%0Afunc HiMagentaString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiMagenta, a...)%0A%7D%0A%0A// HiCyanString is a convenient helper function to return a string with hi-intensity cyan%0A// foreground.%0Afunc HiCyanString(format string, a ...interface%7B%7D) string %7B return colorString(format, FgHiCyan, a...) %7D%0A%0A// HiWhiteString is a convenient helper function to return a string with hi-intensity white%0A// foreground.%0Afunc HiWhiteString(format string, a ...interface%7B%7D) string %7B%0A%09return colorString(format, FgHiWhite, a...)%0A%7D%0A
- f ca2e083a4c3bf68be17cd8b5e17cb96f3719fcc392f83b32a42dd429881b5411 vendor/github.com/mattn/go-colorable/colorable_appengine.go
+ f 425540d3fdc6090883587fde8968420a143d24ebcab357ee87f0142445f44936 vendor/github.com/mattn/go-colorable/colorable_appengine.go
dmppatch 4
@@ -90,16 +90,235 @@
 tty%22%0A)%0A%0A
+// NewColorable return new instance of Writer which handle escape sequence.%0Afunc NewColorable(file *os.File) io.Writer %7B%0A%09if file == nil %7B%0A%09%09panic(%22nil passed instead of *os.File to NewColorable()%22)%0A%09%7D%0A%0A%09return file%0A%7D%0A%0A
 // NewCo
- f 3955dadc91c3ad7f77a077383beec43578e1f6cccd5df1cd8c76ca3795264ad1 vendor/github.com/mattn/go-colorable/colorable_others.go
+ f 4f5fe0d562531fa8d831ae060712cfbfd037ca5937ed348dc42e93fcaa961fa0 vendor/github.com/mattn/go-colorable/colorable_others.go
dmppatch 4
@@ -110,16 +110,235 @@
 tty%22%0A)%0A%0A
+// NewColorable return new instance of Writer which handle escape sequence.%0Afunc NewColorable(file *os.File) io.Writer %7B%0A%09if file == nil %7B%0A%09%09panic(%22nil passed instead of *os.File to NewColorable()%22)%0A%09%7D%0A%0A%09return file%0A%7D%0A%0A
 // NewCo
- f 4fbc91f5a6bbe903aa61fbe9f6baa40a7b0f33979bcba9b4542a588734dc6482 vendor/github.com/mattn/go-colorable/colorable_windows.go
+ f b40f20990dac6e027ae40b990283636e5994c62cbc7ece287b70c00857fd2378 vendor/github.com/mattn/go-colorable/colorable_windows.go
dmppatch 13
@@ -65,23 +65,2330 @@
 t (%0A
+%09%22bytes%22%0A
 %09%22io%22%0A
+%09%22math%22%0A
 %09%22os%22%0A
+%09%22strconv%22%0A%09%22strings%22%0A%09%22syscall%22%0A%09%22unsafe%22%0A%0A%09%22github.com/mattn/go-isatty%22%0A
 )%0A%0A
+const (%0A%09foregroundBlue      = 0x1%0A%09foregroundGreen     = 0x2%0A%09foregroundRed       = 0x4%0A%09foregroundIntensity = 0x8%0A%09foregroundMask      = (foregroundRed %7C foregroundBlue %7C foregroundGreen %7C foregroundIntensity)%0A%09backgroundBlue      = 0x10%0A%09backgroundGreen     = 0x20%0A%09backgroundRed       = 0x40%0A%09backgroundIntensity = 0x80%0A%09backgroundMask      = (backgroundRed %7C backgroundBlue %7C backgroundGreen %7C backgroundIntensity)%0A)%0A%0Atype wchar uint16%0Atype short int16%0Atype dword uint32%0Atype word uint16%0A%0Atype coord struct %7B%0A%09x short%0A%09y short%0A%7D%0A%0Atype smallRect struct %7B%0A%09left   short%0A%09top    short%0A%09right  short%0A%09bottom short%0A%7D%0A%0Atype consoleScreenBufferInfo struct %7B%0A%09size              coord%0A%09cursorPosition    coord%0A%09attributes        word%0A%09window            smallRect%0A%09maximumWindowSize coord%0A%7D%0A%0Atype consoleCursorInfo struct %7B%0A%09size    dword%0A%09visible int32%0A%7D%0A%0Avar (%0A%09kernel32                       = syscall.NewLazyDLL(%22kernel32.dll%22)%0A%09procGetConsoleScreenBufferInfo = kernel32.NewProc(%22GetConsoleScreenBufferInfo%22)%0A%09procSetConsoleTextAttribute    = kernel32.NewProc(%22SetConsoleTextAttribute%22)%0A%09procSetConsoleCursorPosition   = kernel32.NewProc(%22SetConsoleCursorPosition%22)%0A%09procFillConsoleOutputCharacter = kernel32.NewProc(%22FillConsoleOutputCharacterW%22)%0A%09procFillConsoleOutputAttribute = kernel32.NewProc(%22FillConsoleOutputAttribute%22)%0A%09procGetConsoleCursorInfo       = kernel32.NewProc(%22GetConsoleCursorInfo%22)%0A%09procSetConsoleCursorInfo       = kernel32.NewProc(%22SetConsoleCursorInfo%22)%0A%09procSetConsoleTitle            = kernel32.NewProc(%22SetConsoleTitleW%22)%0A)%0A%0A// Writer provide colorable Writer to the console%0Atype Writer struct %7B%0A%09out     io.Writer%0A%09handle  syscall.Handle%0A%09oldattr word%0A%09oldpos  coord%0A%7D%0A%0A// NewColorable return new instance of Writer which handle escape sequence from File.%0Afunc NewColorable(file *os.File) io.Writer %7B%0A%09if file == nil %7B%0A%09%09panic(%22nil passed instead of *os.File to NewColorable()%22)%0A%09%7D%0A%0A%09if isatty.IsTerminal(file.Fd()) %7B%0A%09%09var csbi consoleScreenBufferInfo%0A%09%09handle := syscall.Handle(file.Fd())%0A%09%09procGetConsoleScreenBufferInfo.Call(uintptr(handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09return &Writer%7Bout: file, handle: handle, oldattr: csbi.attributes, oldpos: coord%7B0, 0%7D%7D%0A%09%7D%0A%09return file%0A%7D%0A%0A
 // N
@@ -2710,12 +2710,18005 @@
 s.Stderr)%0A%7D%0A
+%0Avar color256 = map%5Bint%5Dint%7B%0A%090:   0x000000,%0A%091:   0x800000,%0A%092:   0x008000,%0A%093:   0x808000,%0A%094:   0x000080,%0A%095:   0x800080,%0A%096:   0x008080,%0A%097:   0xc0c0c0,%0A%098:   0x808080,%0A%099:   0xff0000,%0A%0910:  0x00ff00,%0A%0911:  0xffff00,%0A%0912:  0x0000ff,%0A%0913:  0xff00ff,%0A%0914:  0x00ffff,%0A%0915:  0xffffff,%0A%0916:  0x000000,%0A%0917:  0x00005f,%0A%0918:  0x000087,%0A%0919:  0x0000af,%0A%0920:  0x0000d7,%0A%0921:  0x0000ff,%0A%0922:  0x005f00,%0A%0923:  0x005f5f,%0A%0924:  0x005f87,%0A%0925:  0x005faf,%0A%0926:  0x005fd7,%0A%0927:  0x005fff,%0A%0928:  0x008700,%0A%0929:  0x00875f,%0A%0930:  0x008787,%0A%0931:  0x0087af,%0A%0932:  0x0087d7,%0A%0933:  0x0087ff,%0A%0934:  0x00af00,%0A%0935:  0x00af5f,%0A%0936:  0x00af87,%0A%0937:  0x00afaf,%0A%0938:  0x00afd7,%0A%0939:  0x00afff,%0A%0940:  0x00d700,%0A%0941:  0x00d75f,%0A%0942:  0x00d787,%0A%0943:  0x00d7af,%0A%0944:  0x00d7d7,%0A%0945:  0x00d7ff,%0A%0946:  0x00ff00,%0A%0947:  0x00ff5f,%0A%0948:  0x00ff87,%0A%0949:  0x00ffaf,%0A%0950:  0x00ffd7,%0A%0951:  0x00ffff,%0A%0952:  0x5f0000,%0A%0953:  0x5f005f,%0A%0954:  0x5f0087,%0A%0955:  0x5f00af,%0A%0956:  0x5f00d7,%0A%0957:  0x5f00ff,%0A%0958:  0x5f5f00,%0A%0959:  0x5f5f5f,%0A%0960:  0x5f5f87,%0A%0961:  0x5f5faf,%0A%0962:  0x5f5fd7,%0A%0963:  0x5f5fff,%0A%0964:  0x5f8700,%0A%0965:  0x5f875f,%0A%0966:  0x5f8787,%0A%0967:  0x5f87af,%0A%0968:  0x5f87d7,%0A%0969:  0x5f87ff,%0A%0970:  0x5faf00,%0A%0971:  0x5faf5f,%0A%0972:  0x5faf87,%0A%0973:  0x5fafaf,%0A%0974:  0x5fafd7,%0A%0975:  0x5fafff,%0A%0976:  0x5fd700,%0A%0977:  0x5fd75f,%0A%0978:  0x5fd787,%0A%0979:  0x5fd7af,%0A%0980:  0x5fd7d7,%0A%0981:  0x5fd7ff,%0A%0982:  0x5fff00,%0A%0983:  0x5fff5f,%0A%0984:  0x5fff87,%0A%0985:  0x5fffaf,%0A%0986:  0x5fffd7,%0A%0987:  0x5fffff,%0A%0988:  0x870000,%0A%0989:  0x87005f,%0A%0990:  0x870087,%0A%0991:  0x8700af,%0A%0992:  0x8700d7,%0A%0993:  0x8700ff,%0A%0994:  0x875f00,%0A%0995:  0x875f5f,%0A%0996:  0x875f87,%0A%0997:  0x875faf,%0A%0998:  0x875fd7,%0A%0999:  0x875fff,%0A%09100: 0x878700,%0A%09101: 0x87875f,%0A%09102: 0x878787,%0A%09103: 0x8787af,%0A%09104: 0x8787d7,%0A%09105: 0x8787ff,%0A%09106: 0x87af00,%0A%09107: 0x87af5f,%0A%09108: 0x87af87,%0A%09109: 0x87afaf,%0A%09110: 0x87afd7,%0A%09111: 0x87afff,%0A%09112: 0x87d700,%0A%09113: 0x87d75f,%0A%09114: 0x87d787,%0A%09115: 0x87d7af,%0A%09116: 0x87d7d7,%0A%09117: 0x87d7ff,%0A%09118: 0x87ff00,%0A%09119: 0x87ff5f,%0A%09120: 0x87ff87,%0A%09121: 0x87ffaf,%0A%09122: 0x87ffd7,%0A%09123: 0x87ffff,%0A%09124: 0xaf0000,%0A%09125: 0xaf005f,%0A%09126: 0xaf0087,%0A%09127: 0xaf00af,%0A%09128: 0xaf00d7,%0A%09129: 0xaf00ff,%0A%09130: 0xaf5f00,%0A%09131: 0xaf5f5f,%0A%09132: 0xaf5f87,%0A%09133: 0xaf5faf,%0A%09134: 0xaf5fd7,%0A%09135: 0xaf5fff,%0A%09136: 0xaf8700,%0A%09137: 0xaf875f,%0A%09138: 0xaf8787,%0A%09139: 0xaf87af,%0A%09140: 0xaf87d7,%0A%09141: 0xaf87ff,%0A%09142: 0xafaf00,%0A%09143: 0xafaf5f,%0A%09144: 0xafaf87,%0A%09145: 0xafafaf,%0A%09146: 0xafafd7,%0A%09147: 0xafafff,%0A%09148: 0xafd700,%0A%09149: 0xafd75f,%0A%09150: 0xafd787,%0A%09151: 0xafd7af,%0A%09152: 0xafd7d7,%0A%09153: 0xafd7ff,%0A%09154: 0xafff00,%0A%09155: 0xafff5f,%0A%09156: 0xafff87,%0A%09157: 0xafffaf,%0A%09158: 0xafffd7,%0A%09159: 0xafffff,%0A%09160: 0xd70000,%0A%09161: 0xd7005f,%0A%09162: 0xd70087,%0A%09163: 0xd700af,%0A%09164: 0xd700d7,%0A%09165: 0xd700ff,%0A%09166: 0xd75f00,%0A%09167: 0xd75f5f,%0A%09168: 0xd75f87,%0A%09169: 0xd75faf,%0A%09170: 0xd75fd7,%0A%09171: 0xd75fff,%0A%09172: 0xd78700,%0A%09173: 0xd7875f,%0A%09174: 0xd78787,%0A%09175: 0xd787af,%0A%09176: 0xd787d7,%0A%09177: 0xd787ff,%0A%09178: 0xd7af00,%0A%09179: 0xd7af5f,%0A%09180: 0xd7af87,%0A%09181: 0xd7afaf,%0A%09182: 0xd7afd7,%0A%09183: 0xd7afff,%0A%09184: 0xd7d700,%0A%09185: 0xd7d75f,%0A%09186: 0xd7d787,%0A%09187: 0xd7d7af,%0A%09188: 0xd7d7d7,%0A%09189: 0xd7d7ff,%0A%09190: 0xd7ff00,%0A%09191: 0xd7ff5f,%0A%09192: 0xd7ff87,%0A%09193: 0xd7ffaf,%0A%09194: 0xd7ffd7,%0A%09195: 0xd7ffff,%0A%09196: 0xff0000,%0A%09197: 0xff005f,%0A%09198: 0xff0087,%0A%09199: 0xff00af,%0A%09200: 0xff00d7,%0A%09201: 0xff00ff,%0A%09202: 0xff5f00,%0A%09203: 0xff5f5f,%0A%09204: 0xff5f87,%0A%09205: 0xff5faf,%0A%09206: 0xff5fd7,%0A%09207: 0xff5fff,%0A%09208: 0xff8700,%0A%09209: 0xff875f,%0A%09210: 0xff8787,%0A%09211: 0xff87af,%0A%09212: 0xff87d7,%0A%09213: 0xff87ff,%0A%09214: 0xffaf00,%0A%09215: 0xffaf5f,%0A%09216: 0xffaf87,%0A%09217: 0xffafaf,%0A%09218: 0xffafd7,%0A%09219: 0xffafff,%0A%09220: 0xffd700,%0A%09221: 0xffd75f,%0A%09222: 0xffd787,%0A%09223: 0xffd7af,%0A%09224: 0xffd7d7,%0A%09225: 0xffd7ff,%0A%09226: 0xffff00,%0A%09227: 0xffff5f,%0A%09228: 0xffff87,%0A%09229: 0xffffaf,%0A%09230: 0xffffd7,%0A%09231: 0xffffff,%0A%09232: 0x080808,%0A%09233: 0x121212,%0A%09234: 0x1c1c1c,%0A%09235: 0x262626,%0A%09236: 0x303030,%0A%09237: 0x3a3a3a,%0A%09238: 0x444444,%0A%09239: 0x4e4e4e,%0A%09240: 0x585858,%0A%09241: 0x626262,%0A%09242: 0x6c6c6c,%0A%09243: 0x767676,%0A%09244: 0x808080,%0A%09245: 0x8a8a8a,%0A%09246: 0x949494,%0A%09247: 0x9e9e9e,%0A%09248: 0xa8a8a8,%0A%09249: 0xb2b2b2,%0A%09250: 0xbcbcbc,%0A%09251: 0xc6c6c6,%0A%09252: 0xd0d0d0,%0A%09253: 0xdadada,%0A%09254: 0xe4e4e4,%0A%09255: 0xeeeeee,%0A%7D%0A%0A// %60%5C033%5D0;TITLESTR%5C007%60%0Afunc doTitleSequence(er *bytes.Reader) error %7B%0A%09var c byte%0A%09var err error%0A%0A%09c, err = er.ReadByte()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if c != '0' && c != '2' %7B%0A%09%09return nil%0A%09%7D%0A%09c, err = er.ReadByte()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if c != ';' %7B%0A%09%09return nil%0A%09%7D%0A%09title := make(%5B%5Dbyte, 0, 80)%0A%09for %7B%0A%09%09c, err = er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09if c == 0x07 %7C%7C c == '%5Cn' %7B%0A%09%09%09break%0A%09%09%7D%0A%09%09title = append(title, c)%0A%09%7D%0A%09if len(title) %3E 0 %7B%0A%09%09title8, err := syscall.UTF16PtrFromString(string(title))%0A%09%09if err == nil %7B%0A%09%09%09procSetConsoleTitle.Call(uintptr(unsafe.Pointer(title8)))%0A%09%09%7D%0A%09%7D%0A%09return nil%0A%7D%0A%0A// Write write data on console%0Afunc (w *Writer) Write(data %5B%5Dbyte) (n int, err error) %7B%0A%09var csbi consoleScreenBufferInfo%0A%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%0A%09er := bytes.NewReader(data)%0A%09var bw %5B1%5Dbyte%0Aloop:%0A%09for %7B%0A%09%09c1, err := er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09break loop%0A%09%09%7D%0A%09%09if c1 != 0x1b %7B%0A%09%09%09bw%5B0%5D = c1%0A%09%09%09w.out.Write(bw%5B:%5D)%0A%09%09%09continue%0A%09%09%7D%0A%09%09c2, err := er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09break loop%0A%09%09%7D%0A%0A%09%09if c2 == '%5D' %7B%0A%09%09%09if err := doTitleSequence(er); err != nil %7B%0A%09%09%09%09break loop%0A%09%09%09%7D%0A%09%09%09continue%0A%09%09%7D%0A%09%09if c2 != 0x5b %7B%0A%09%09%09continue%0A%09%09%7D%0A%0A%09%09var buf bytes.Buffer%0A%09%09var m byte%0A%09%09for %7B%0A%09%09%09c, err := er.ReadByte()%0A%09%09%09if err != nil %7B%0A%09%09%09%09break loop%0A%09%09%09%7D%0A%09%09%09if ('a' %3C= c && c %3C= 'z') %7C%7C ('A' %3C= c && c %3C= 'Z') %7C%7C c == '@' %7B%0A%09%09%09%09m = c%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%09buf.Write(%5B%5Dbyte(string(c)))%0A%09%09%7D%0A%0A%09%09switch m %7B%0A%09%09case 'A':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.y -= short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'B':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.y += short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'C':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x += short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'D':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x -= short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'E':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x = 0%0A%09%09%09csbi.cursorPosition.y += short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'F':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x = 0%0A%09%09%09csbi.cursorPosition.y -= short(n)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'G':%0A%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09if err != nil %7B%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09csbi.cursorPosition.x = short(n - 1)%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'H', 'f':%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09if buf.Len() %3E 0 %7B%0A%09%09%09%09token := strings.Split(buf.String(), %22;%22)%0A%09%09%09%09switch len(token) %7B%0A%09%09%09%09case 1:%0A%09%09%09%09%09n1, err := strconv.Atoi(token%5B0%5D)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09continue%0A%09%09%09%09%09%7D%0A%09%09%09%09%09csbi.cursorPosition.y = short(n1 - 1)%0A%09%09%09%09case 2:%0A%09%09%09%09%09n1, err := strconv.Atoi(token%5B0%5D)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09continue%0A%09%09%09%09%09%7D%0A%09%09%09%09%09n2, err := strconv.Atoi(token%5B1%5D)%0A%09%09%09%09%09if err != nil %7B%0A%09%09%09%09%09%09continue%0A%09%09%09%09%09%7D%0A%09%09%09%09%09csbi.cursorPosition.x = short(n2 - 1)%0A%09%09%09%09%09csbi.cursorPosition.y = short(n1 - 1)%0A%09%09%09%09%7D%0A%09%09%09%7D else %7B%0A%09%09%09%09csbi.cursorPosition.y = 0%0A%09%09%09%7D%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&csbi.cursorPosition)))%0A%09%09case 'J':%0A%09%09%09n := 0%0A%09%09%09if buf.Len() %3E 0 %7B%0A%09%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09continue%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09var count, written dword%0A%09%09%09var cursor coord%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09switch n %7B%0A%09%09%09case 0:%0A%09%09%09%09cursor = coord%7Bx: csbi.cursorPosition.x, y: csbi.cursorPosition.y%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x + (csbi.size.y-csbi.cursorPosition.y)*csbi.size.x)%0A%09%09%09case 1:%0A%09%09%09%09cursor = coord%7Bx: csbi.window.left, y: csbi.window.top%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x + (csbi.window.top-csbi.cursorPosition.y)*csbi.size.x)%0A%09%09%09case 2:%0A%09%09%09%09cursor = coord%7Bx: csbi.window.left, y: csbi.window.top%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x + (csbi.size.y-csbi.cursorPosition.y)*csbi.size.x)%0A%09%09%09%7D%0A%09%09%09procFillConsoleOutputCharacter.Call(uintptr(w.handle), uintptr(' '), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))%0A%09%09%09procFillConsoleOutputAttribute.Call(uintptr(w.handle), uintptr(csbi.attributes), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))%0A%09%09case 'K':%0A%09%09%09n := 0%0A%09%09%09if buf.Len() %3E 0 %7B%0A%09%09%09%09n, err = strconv.Atoi(buf.String())%0A%09%09%09%09if err != nil %7B%0A%09%09%09%09%09continue%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09var cursor coord%0A%09%09%09var count, written dword%0A%09%09%09switch n %7B%0A%09%09%09case 0:%0A%09%09%09%09cursor = coord%7Bx: csbi.cursorPosition.x + 1, y: csbi.cursorPosition.y%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x - 1)%0A%09%09%09case 1:%0A%09%09%09%09cursor = coord%7Bx: csbi.window.left, y: csbi.window.top + csbi.cursorPosition.y%7D%0A%09%09%09%09count = dword(csbi.size.x - csbi.cursorPosition.x)%0A%09%09%09case 2:%0A%09%09%09%09cursor = coord%7Bx: csbi.window.left, y: csbi.window.top + csbi.cursorPosition.y%7D%0A%09%09%09%09count = dword(csbi.size.x)%0A%09%09%09%7D%0A%09%09%09procFillConsoleOutputCharacter.Call(uintptr(w.handle), uintptr(' '), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))%0A%09%09%09procFillConsoleOutputAttribute.Call(uintptr(w.handle), uintptr(csbi.attributes), uintptr(count), *(*uintptr)(unsafe.Pointer(&cursor)), uintptr(unsafe.Pointer(&written)))%0A%09%09case 'm':%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09attr := csbi.attributes%0A%09%09%09cs := buf.String()%0A%09%09%09if cs == %22%22 %7B%0A%09%09%09%09procSetConsoleTextAttribute.Call(uintptr(w.handle), uintptr(w.oldattr))%0A%09%09%09%09continue%0A%09%09%09%7D%0A%09%09%09token := strings.Split(cs, %22;%22)%0A%09%09%09for i := 0; i %3C len(token); i++ %7B%0A%09%09%09%09ns := token%5Bi%5D%0A%09%09%09%09if n, err = strconv.Atoi(ns); err == nil %7B%0A%09%09%09%09%09switch %7B%0A%09%09%09%09%09case n == 0 %7C%7C n == 100:%0A%09%09%09%09%09%09attr = w.oldattr%0A%09%09%09%09%09case 1 %3C= n && n %3C= 5:%0A%09%09%09%09%09%09attr %7C= foregroundIntensity%0A%09%09%09%09%09case n == 7:%0A%09%09%09%09%09%09attr = ((attr & foregroundMask) %3C%3C 4) %7C ((attr & backgroundMask) %3E%3E 4)%0A%09%09%09%09%09case n == 22 %7C%7C n == 25:%0A%09%09%09%09%09%09attr %7C= foregroundIntensity%0A%09%09%09%09%09case n == 27:%0A%09%09%09%09%09%09attr = ((attr & foregroundMask) %3C%3C 4) %7C ((attr & backgroundMask) %3E%3E 4)%0A%09%09%09%09%09case 30 %3C= n && n %3C= 37:%0A%09%09%09%09%09%09attr &= backgroundMask%0A%09%09%09%09%09%09if (n-30)&1 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundRed%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-30)&2 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundGreen%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-30)&4 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundBlue%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case n == 38: // set foreground color.%0A%09%09%09%09%09%09if i %3C len(token)-2 && (token%5Bi+1%5D == %225%22 %7C%7C token%5Bi+1%5D == %2205%22) %7B%0A%09%09%09%09%09%09%09if n256, err := strconv.Atoi(token%5Bi+2%5D); err == nil %7B%0A%09%09%09%09%09%09%09%09if n256foreAttr == nil %7B%0A%09%09%09%09%09%09%09%09%09n256setup()%0A%09%09%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09%09%09attr &= backgroundMask%0A%09%09%09%09%09%09%09%09attr %7C= n256foreAttr%5Bn256%5D%0A%09%09%09%09%09%09%09%09i += 2%0A%09%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09%7D else %7B%0A%09%09%09%09%09%09%09attr = attr & (w.oldattr & backgroundMask)%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case n == 39: // reset foreground color.%0A%09%09%09%09%09%09attr &= backgroundMask%0A%09%09%09%09%09%09attr %7C= w.oldattr & foregroundMask%0A%09%09%09%09%09case 40 %3C= n && n %3C= 47:%0A%09%09%09%09%09%09attr &= foregroundMask%0A%09%09%09%09%09%09if (n-40)&1 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundRed%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-40)&2 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundGreen%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-40)&4 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundBlue%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case n == 48: // set background color.%0A%09%09%09%09%09%09if i %3C len(token)-2 && token%5Bi+1%5D == %225%22 %7B%0A%09%09%09%09%09%09%09if n256, err := strconv.Atoi(token%5Bi+2%5D); err == nil %7B%0A%09%09%09%09%09%09%09%09if n256backAttr == nil %7B%0A%09%09%09%09%09%09%09%09%09n256setup()%0A%09%09%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09%09%09attr &= foregroundMask%0A%09%09%09%09%09%09%09%09attr %7C= n256backAttr%5Bn256%5D%0A%09%09%09%09%09%09%09%09i += 2%0A%09%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09%7D else %7B%0A%09%09%09%09%09%09%09attr = attr & (w.oldattr & foregroundMask)%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case n == 49: // reset foreground color.%0A%09%09%09%09%09%09attr &= foregroundMask%0A%09%09%09%09%09%09attr %7C= w.oldattr & backgroundMask%0A%09%09%09%09%09case 90 %3C= n && n %3C= 97:%0A%09%09%09%09%09%09attr = (attr & backgroundMask)%0A%09%09%09%09%09%09attr %7C= foregroundIntensity%0A%09%09%09%09%09%09if (n-90)&1 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundRed%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-90)&2 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundGreen%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-90)&4 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= foregroundBlue%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09case 100 %3C= n && n %3C= 107:%0A%09%09%09%09%09%09attr = (attr & foregroundMask)%0A%09%09%09%09%09%09attr %7C= backgroundIntensity%0A%09%09%09%09%09%09if (n-100)&1 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundRed%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-100)&2 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundGreen%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%09if (n-100)&4 != 0 %7B%0A%09%09%09%09%09%09%09attr %7C= backgroundBlue%0A%09%09%09%09%09%09%7D%0A%09%09%09%09%09%7D%0A%09%09%09%09%09procSetConsoleTextAttribute.Call(uintptr(w.handle), uintptr(attr))%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09case 'h':%0A%09%09%09var ci consoleCursorInfo%0A%09%09%09cs := buf.String()%0A%09%09%09if cs == %225%3E%22 %7B%0A%09%09%09%09procGetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%09ci.visible = 0%0A%09%09%09%09procSetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%7D else if cs == %22?25%22 %7B%0A%09%09%09%09procGetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%09ci.visible = 1%0A%09%09%09%09procSetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%7D%0A%09%09case 'l':%0A%09%09%09var ci consoleCursorInfo%0A%09%09%09cs := buf.String()%0A%09%09%09if cs == %225%3E%22 %7B%0A%09%09%09%09procGetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%09ci.visible = 1%0A%09%09%09%09procSetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%7D else if cs == %22?25%22 %7B%0A%09%09%09%09procGetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%09ci.visible = 0%0A%09%09%09%09procSetConsoleCursorInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&ci)))%0A%09%09%09%7D%0A%09%09case 's':%0A%09%09%09procGetConsoleScreenBufferInfo.Call(uintptr(w.handle), uintptr(unsafe.Pointer(&csbi)))%0A%09%09%09w.oldpos = csbi.cursorPosition%0A%09%09case 'u':%0A%09%09%09procSetConsoleCursorPosition.Call(uintptr(w.handle), *(*uintptr)(unsafe.Pointer(&w.oldpos)))%0A%09%09%7D%0A%09%7D%0A%0A%09return len(data), nil%0A%7D%0A%0Atype consoleColor struct %7B%0A%09rgb       int%0A%09red       bool%0A%09green     bool%0A%09blue      bool%0A%09intensity bool%0A%7D%0A%0Afunc (c consoleColor) foregroundAttr() (attr word) %7B%0A%09if c.red %7B%0A%09%09attr %7C= foregroundRed%0A%09%7D%0A%09if c.green %7B%0A%09%09attr %7C= foregroundGreen%0A%09%7D%0A%09if c.blue %7B%0A%09%09attr %7C= foregroundBlue%0A%09%7D%0A%09if c.intensity %7B%0A%09%09attr %7C= foregroundIntensity%0A%09%7D%0A%09return%0A%7D%0A%0Afunc (c consoleColor) backgroundAttr() (attr word) %7B%0A%09if c.red %7B%0A%09%09attr %7C= backgroundRed%0A%09%7D%0A%09if c.green %7B%0A%09%09attr %7C= backgroundGreen%0A%09%7D%0A%09if c.blue %7B%0A%09%09attr %7C= backgroundBlue%0A%09%7D%0A%09if c.intensity %7B%0A%09%09attr %7C= backgroundIntensity%0A%09%7D%0A%09return%0A%7D%0A%0Avar color16 = %5B%5DconsoleColor%7B%0A%09%7B0x000000, false, false, false, false%7D,%0A%09%7B0x000080, false, false, true, false%7D,%0A%09%7B0x008000, false, true, false, false%7D,%0A%09%7B0x008080, false, true, true, false%7D,%0A%09%7B0x800000, true, false, false, false%7D,%0A%09%7B0x800080, true, false, true, false%7D,%0A%09%7B0x808000, true, true, false, false%7D,%0A%09%7B0xc0c0c0, true, true, true, false%7D,%0A%09%7B0x808080, false, false, false, true%7D,%0A%09%7B0x0000ff, false, false, true, true%7D,%0A%09%7B0x00ff00, false, true, false, true%7D,%0A%09%7B0x00ffff, false, true, true, true%7D,%0A%09%7B0xff0000, true, false, false, true%7D,%0A%09%7B0xff00ff, true, false, true, true%7D,%0A%09%7B0xffff00, true, true, false, true%7D,%0A%09%7B0xffffff, true, true, true, true%7D,%0A%7D%0A%0Atype hsv struct %7B%0A%09h, s, v float32%0A%7D%0A%0Afunc (a hsv) dist(b hsv) float32 %7B%0A%09dh := a.h - b.h%0A%09switch %7B%0A%09case dh %3E 0.5:%0A%09%09dh = 1 - dh%0A%09case dh %3C -0.5:%0A%09%09dh = -1 - dh%0A%09%7D%0A%09ds := a.s - b.s%0A%09dv := a.v - b.v%0A%09return float32(math.Sqrt(float64(dh*dh + ds*ds + dv*dv)))%0A%7D%0A%0Afunc toHSV(rgb int) hsv %7B%0A%09r, g, b := float32((rgb&0xFF0000)%3E%3E16)/256.0,%0A%09%09float32((rgb&0x00FF00)%3E%3E8)/256.0,%0A%09%09float32(rgb&0x0000FF)/256.0%0A%09min, max := minmax3f(r, g, b)%0A%09h := max - min%0A%09if h %3E 0 %7B%0A%09%09if max == r %7B%0A%09%09%09h = (g - b) / h%0A%09%09%09if h %3C 0 %7B%0A%09%09%09%09h += 6%0A%09%09%09%7D%0A%09%09%7D else if max == g %7B%0A%09%09%09h = 2 + (b-r)/h%0A%09%09%7D else %7B%0A%09%09%09h = 4 + (r-g)/h%0A%09%09%7D%0A%09%7D%0A%09h /= 6.0%0A%09s := max - min%0A%09if max != 0 %7B%0A%09%09s /= max%0A%09%7D%0A%09v := max%0A%09return hsv%7Bh: h, s: s, v: v%7D%0A%7D%0A%0Atype hsvTable %5B%5Dhsv%0A%0Afunc toHSVTable(rgbTable %5B%5DconsoleColor) hsvTable %7B%0A%09t := make(hsvTable, len(rgbTable))%0A%09for i, c := range rgbTable %7B%0A%09%09t%5Bi%5D = toHSV(c.rgb)%0A%09%7D%0A%09return t%0A%7D%0A%0Afunc (t hsvTable) find(rgb int) consoleColor %7B%0A%09hsv := toHSV(rgb)%0A%09n := 7%0A%09l := float32(5.0)%0A%09for i, p := range t %7B%0A%09%09d := hsv.dist(p)%0A%09%09if d %3C l %7B%0A%09%09%09l, n = d, i%0A%09%09%7D%0A%09%7D%0A%09return color16%5Bn%5D%0A%7D%0A%0Afunc minmax3f(a, b, c float32) (min, max float32) %7B%0A%09if a %3C b %7B%0A%09%09if b %3C c %7B%0A%09%09%09return a, c%0A%09%09%7D else if a %3C c %7B%0A%09%09%09return a, b%0A%09%09%7D else %7B%0A%09%09%09return c, b%0A%09%09%7D%0A%09%7D else %7B%0A%09%09if a %3C c %7B%0A%09%09%09return b, c%0A%09%09%7D else if b %3C c %7B%0A%09%09%09return b, a%0A%09%09%7D else %7B%0A%09%09%09return c, a%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Avar n256foreAttr %5B%5Dword%0Avar n256backAttr %5B%5Dword%0A%0Afunc n256setup() %7B%0A%09n256foreAttr = make(%5B%5Dword, 256)%0A%09n256backAttr = make(%5B%5Dword, 256)%0A%09t := toHSVTable(color16)%0A%09for i, rgb := range color256 %7B%0A%09%09c := t.find(rgb)%0A%09%09n256foreAttr%5Bi%5D = c.foregroundAttr()%0A%09%09n256backAttr%5Bi%5D = c.backgroundAttr()%0A%09%7D%0A%7D%0A
- f 7c9807557111debadbb3eee5c5fdaaff2b314500e55b89288df2e3190385574b vendor/github.com/mattn/go-colorable/noncolorable.go
+ f fd2c8c68e345996ff70af73e92e7e9deb8b040f29c77af845362cbec32ff3e82 vendor/github.com/mattn/go-colorable/noncolorable.go
dmppatch 3
@@ -11,8 +11,936 @@
 lorable%0A
+%0Aimport (%0A%09%22bytes%22%0A%09%22io%22%0A)%0A%0A// NonColorable hold writer but remove escape sequence.%0Atype NonColorable struct %7B%0A%09out io.Writer%0A%7D%0A%0A// NewNonColorable return new instance of Writer which remove escape sequence from Writer.%0Afunc NewNonColorable(w io.Writer) io.Writer %7B%0A%09return &NonColorable%7Bout: w%7D%0A%7D%0A%0A// Write write data on console%0Afunc (w *NonColorable) Write(data %5B%5Dbyte) (n int, err error) %7B%0A%09er := bytes.NewReader(data)%0A%09var bw %5B1%5Dbyte%0Aloop:%0A%09for %7B%0A%09%09c1, err := er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09break loop%0A%09%09%7D%0A%09%09if c1 != 0x1b %7B%0A%09%09%09bw%5B0%5D = c1%0A%09%09%09w.out.Write(bw%5B:%5D)%0A%09%09%09continue%0A%09%09%7D%0A%09%09c2, err := er.ReadByte()%0A%09%09if err != nil %7B%0A%09%09%09break loop%0A%09%09%7D%0A%09%09if c2 != 0x5b %7B%0A%09%09%09continue%0A%09%09%7D%0A%0A%09%09var buf bytes.Buffer%0A%09%09for %7B%0A%09%09%09c, err := er.ReadByte()%0A%09%09%09if err != nil %7B%0A%09%09%09%09break loop%0A%09%09%09%7D%0A%09%09%09if ('a' %3C= c && c %3C= 'z') %7C%7C ('A' %3C= c && c %3C= 'Z') %7C%7C c == '@' %7B%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%09buf.Write(%5B%5Dbyte(string(c)))%0A%09%09%7D%0A%09%7D%0A%0A%09return len(data), nil%0A%7D%0A
- f 6c37310d5b7f2207f7a322e03c567bc9f278d9746b84d3a3c250ad439c2c50eb vendor/github.com/mattn/go-isatty/.travis.yml
+ f 71d8792e3b18d51476f8016111f58d6e8bc82e67b3f2c9c266abd03b244300c8 vendor/github.com/mattn/go-isatty/.travis.yml
dmppatch 4
@@ -19,16 +19,39 @@
  - tip%0A%0A
+os:%0A  - linux%0A  - osx%0A%0A
 before_i
- f e670e00bfc232609b71bf895aec5ed2beceee501660a76fe7339d492ef2513c8 vendor/github.com/mattn/go-isatty/isatty_others.go
+ f 5efdc4d1188bb4eb94685ad666f80f4f7ddb3ecf639f52ac1a1f6d0dad7e5b34 vendor/github.com/mattn/go-isatty/isatty_others.go
dmppatch 5
@@ -54,86 +54,84 @@
 ty%0A%0A
-// IsCygwinTerminal() return true if the file descriptor is a cygwin or msys2%0A
+// IsCygwinTerminal return true if the file descriptor is a cygwin or msys2%0A
 // t
- f 1ddbba579f36e77697b08f448dc64d01d690641987bc7227ba46dbd773a3ee6c vendor/github.com/mattn/go-isatty/isatty_windows.go
+ f 405eba4ed581cc4cd10ebb2c608c539c3beeef8628a45b7a128e7d7305fe296c vendor/github.com/mattn/go-isatty/isatty_windows.go
dmppatch 12
@@ -58,16 +58,27 @@
 mport (%0A
+%09%22strings%22%0A
 %09%22syscal
@@ -110,16 +110,383 @@
 afe%22%0A)%0A%0A
+const (%0A%09fileNameInfo uintptr = 2%0A%09fileTypePipe         = 3%0A)%0A%0Avar (%0A%09kernel32                         = syscall.NewLazyDLL(%22kernel32.dll%22)%0A%09procGetConsoleMode               = kernel32.NewProc(%22GetConsoleMode%22)%0A%09procGetFileInformationByHandleEx = kernel32.NewProc(%22GetFileInformationByHandleEx%22)%0A%09procGetFileType                  = kernel32.NewProc(%22GetFileType%22)%0A)%0A%0A
 func ini
@@ -879,16 +879,575 @@
  e == 0%0A
+%7D%0A%0A// Check pipe name is used for cygwin/msys2 pty.%0A// Cygwin/MSYS2 PTY has a name like:%0A//   %5C%7Bcygwin,msys%7D-XXXXXXXXXXXXXXXX-ptyN-%7Bfrom,to%7D-master%0Afunc isCygwinPipeName(name string) bool %7B%0A%09token := strings.Split(name, %22-%22)%0A%09if len(token) %3C 5 %7B%0A%09%09return false%0A%09%7D%0A%0A%09if token%5B0%5D != %60%5Cmsys%60 && token%5B0%5D != %60%5Ccygwin%60 %7B%0A%09%09return false%0A%09%7D%0A%0A%09if token%5B1%5D == %22%22 %7B%0A%09%09return false%0A%09%7D%0A%0A%09if !strings.HasPrefix(token%5B2%5D, %22pty%22) %7B%0A%09%09return false%0A%09%7D%0A%0A%09if token%5B3%5D != %60from%60 && token%5B3%5D != %60to%60 %7B%0A%09%09return false%0A%09%7D%0A%0A%09if token%5B4%5D != %22master%22 %7B%0A%09%09return false%0A%09%7D%0A%0A%09return true%0A
 %7D%0A%0A// Is
- f 1c5406179e1d6a27a258041fabbb7e6097957edaeaca5659ef3334667a686a3f vendor/github.com/sergi/go-diff/diffmatchpatch/diff.go
+ f bab37ded6c08ec95dd05f1186b39a74410744e18dcdb6ba9b8b50a0a308c1d46 vendor/github.com/sergi/go-diff/diffmatchpatch/diff.go
dmppatch 36
@@ -386,16 +386,41 @@
 es%22%0A
+%09%22errors%22%0A%09%22fmt%22%0A%09%22html%22%0A
 %09%22math%22%0A
 %09%22re
@@ -415,16 +415,27 @@
 %09%22math%22%0A
+%09%22net/url%22%0A
 %09%22regexp
@@ -436,16 +436,27 @@
 regexp%22%0A
+%09%22strconv%22%0A
 %09%22string
@@ -6594,24 +6594,546 @@
 the end.%0A%7D%0A%0A
+// DiffBisect finds the 'middle snake' of a diff, split the problem in two and return the recursively constructed diff.%0A// If an invalid UTF-8 sequence is encountered, it will be replaced by the Unicode replacement character.%0A// See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.%0Afunc (dmp *DiffMatchPatch) DiffBisect(text1, text2 string, deadline time.Time) %5B%5DDiff %7B%0A%09// Unused in this code, but retained for interface compatibility.%0A%09return dmp.diffBisect(%5B%5Drune(text1), %5B%5Drune(text2), deadline)%0A%7D%0A%0A
 // diffBisec
@@ -10705,24 +10705,473 @@
 ffsb...)%0A%7D%0A%0A
+// DiffLinesToChars splits two texts into a list of strings, and educes the texts to a string of hashes where each Unicode character represents one line.%0A// It's slightly faster to call DiffLinesToRunes first, followed by DiffMainRunes.%0Afunc (dmp *DiffMatchPatch) DiffLinesToChars(text1, text2 string) (string, string, %5B%5Dstring) %7B%0A%09chars1, chars2, lineArray := dmp.DiffLinesToRunes(text1, text2)%0A%09return string(chars1), string(chars2), lineArray%0A%7D%0A%0A
 // DiffLines
@@ -13459,24 +13459,294 @@
 hydrated%0A%7D%0A%0A
+// DiffCommonPrefix determines the common prefix length of two strings.%0Afunc (dmp *DiffMatchPatch) DiffCommonPrefix(text1, text2 string) int %7B%0A%09// Unused in this code, but retained for interface compatibility.%0A%09return commonPrefixLength(%5B%5Drune(text1), %5B%5Drune(text2))%0A%7D%0A%0A
 // DiffCommo
@@ -16439,16 +16439,542 @@
 rn best%0A
+%7D%0A%0A// DiffHalfMatch checks whether the two texts share a substring which is at least half the length of the longer text. This speedup can produce non-minimal diffs.%0Afunc (dmp *DiffMatchPatch) DiffHalfMatch(text1, text2 string) %5B%5Dstring %7B%0A%09// Unused in this code, but retained for interface compatibility.%0A%09runeSlices := dmp.diffHalfMatch(%5B%5Drune(text1), %5B%5Drune(text2))%0A%09if runeSlices == nil %7B%0A%09%09return nil%0A%09%7D%0A%0A%09result := make(%5B%5Dstring, len(runeSlices))%0A%09for i, r := range runeSlices %7B%0A%09%09result%5Bi%5D = string(r)%0A%09%7D%0A%09return result%0A
 %7D%0A%0Afunc 
@@ -36050,24 +36050,1421 @@
 tChars1)%0A%7D%0A%0A
+// DiffPrettyHtml converts a %5B%5DDiff into a pretty HTML report.%0A// It is intended as an example from which to write one's own display functions.%0Afunc (dmp *DiffMatchPatch) DiffPrettyHtml(diffs %5B%5DDiff) string %7B%0A%09var buff bytes.Buffer%0A%09for _, diff := range diffs %7B%0A%09%09text := strings.Replace(html.EscapeString(diff.Text), %22%5Cn%22, %22&para;%3Cbr%3E%22, -1)%0A%09%09switch diff.Type %7B%0A%09%09case DiffInsert:%0A%09%09%09_, _ = buff.WriteString(%22%3Cins style=%5C%22background:#e6ffe6;%5C%22%3E%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%3C/ins%3E%22)%0A%09%09case DiffDelete:%0A%09%09%09_, _ = buff.WriteString(%22%3Cdel style=%5C%22background:#ffe6e6;%5C%22%3E%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%3C/del%3E%22)%0A%09%09case DiffEqual:%0A%09%09%09_, _ = buff.WriteString(%22%3Cspan%3E%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%3C/span%3E%22)%0A%09%09%7D%0A%09%7D%0A%09return buff.String()%0A%7D%0A%0A// DiffPrettyText converts a %5B%5DDiff into a colored text report.%0Afunc (dmp *DiffMatchPatch) DiffPrettyText(diffs %5B%5DDiff) string %7B%0A%09var buff bytes.Buffer%0A%09for _, diff := range diffs %7B%0A%09%09text := diff.Text%0A%0A%09%09switch diff.Type %7B%0A%09%09case DiffInsert:%0A%09%09%09_, _ = buff.WriteString(%22%5Cx1b%5B32m%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%5Cx1b%5B0m%22)%0A%09%09case DiffDelete:%0A%09%09%09_, _ = buff.WriteString(%22%5Cx1b%5B31m%22)%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%09_, _ = buff.WriteString(%22%5Cx1b%5B0m%22)%0A%09%09case DiffEqual:%0A%09%09%09_, _ = buff.WriteString(text)%0A%09%09%7D%0A%09%7D%0A%0A%09return buff.String()%0A%7D%0A%0A
 // DiffText1
@@ -38718,8 +38718,2944 @@
 htein%0A%7D%0A
+%0A// DiffToDelta crushes the diff into an encoded string which describes the operations required to transform text1 into text2.%0A// E.g. =3%5Ct-2%5Ct+ing  -%3E Keep 3 chars, delete 2 chars, insert 'ing'. Operations are tab-separated.  Inserted text is escaped using %25xx notation.%0Afunc (dmp *DiffMatchPatch) DiffToDelta(diffs %5B%5DDiff) string %7B%0A%09var text bytes.Buffer%0A%09for _, aDiff := range diffs %7B%0A%09%09switch aDiff.Type %7B%0A%09%09case DiffInsert:%0A%09%09%09_, _ = text.WriteString(%22+%22)%0A%09%09%09_, _ = text.WriteString(strings.Replace(url.QueryEscape(aDiff.Text), %22+%22, %22 %22, -1))%0A%09%09%09_, _ = text.WriteString(%22%5Ct%22)%0A%09%09%09break%0A%09%09case DiffDelete:%0A%09%09%09_, _ = text.WriteString(%22-%22)%0A%09%09%09_, _ = text.WriteString(strconv.Itoa(utf8.RuneCountInString(aDiff.Text)))%0A%09%09%09_, _ = text.WriteString(%22%5Ct%22)%0A%09%09%09break%0A%09%09case DiffEqual:%0A%09%09%09_, _ = text.WriteString(%22=%22)%0A%09%09%09_, _ = text.WriteString(strconv.Itoa(utf8.RuneCountInString(aDiff.Text)))%0A%09%09%09_, _ = text.WriteString(%22%5Ct%22)%0A%09%09%09break%0A%09%09%7D%0A%09%7D%0A%09delta := text.String()%0A%09if len(delta) != 0 %7B%0A%09%09// Strip off trailing tab character.%0A%09%09delta = delta%5B0 : utf8.RuneCountInString(delta)-1%5D%0A%09%09delta = unescaper.Replace(delta)%0A%09%7D%0A%09return delta%0A%7D%0A%0A// DiffFromDelta given the original text1, and an encoded string which describes the operations required to transform text1 into text2, comAdde the full diff.%0Afunc (dmp *DiffMatchPatch) DiffFromDelta(text1 string, delta string) (diffs %5B%5DDiff, err error) %7B%0A%09i := 0%0A%09runes := %5B%5Drune(text1)%0A%0A%09for _, token := range strings.Split(delta, %22%5Ct%22) %7B%0A%09%09if len(token) == 0 %7B%0A%09%09%09// Blank tokens are ok (from a trailing %5Ct).%0A%09%09%09continue%0A%09%09%7D%0A%0A%09%09// Each token begins with a one character parameter which specifies the operation of this token (delete, insert, equality).%0A%09%09param := token%5B1:%5D%0A%0A%09%09switch op := token%5B0%5D; op %7B%0A%09%09case '+':%0A%09%09%09// Decode would Diff all %22+%22 to %22 %22%0A%09%09%09param = strings.Replace(param, %22+%22, %22%252b%22, -1)%0A%09%09%09param, err = url.QueryUnescape(param)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return nil, err%0A%09%09%09%7D%0A%09%09%09if !utf8.ValidString(param) %7B%0A%09%09%09%09return nil, fmt.Errorf(%22invalid UTF-8 token: %25q%22, param)%0A%09%09%09%7D%0A%0A%09%09%09diffs = append(diffs, Diff%7BDiffInsert, param%7D)%0A%09%09case '=', '-':%0A%09%09%09n, err := strconv.ParseInt(param, 10, 0)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return nil, err%0A%09%09%09%7D else if n %3C 0 %7B%0A%09%09%09%09return nil, errors.New(%22Negative number in DiffFromDelta: %22 + param)%0A%09%09%09%7D%0A%0A%09%09%09i += int(n)%0A%09%09%09// Break out if we are out of bounds, go1.6 can't handle this very well%0A%09%09%09if i %3E len(runes) %7B%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%09// Remember that string slicing is by byte - we want by rune here.%0A%09%09%09text := string(runes%5Bi-int(n) : i%5D)%0A%0A%09%09%09if op == '=' %7B%0A%09%09%09%09diffs = append(diffs, Diff%7BDiffEqual, text%7D)%0A%09%09%09%7D else %7B%0A%09%09%09%09diffs = append(diffs, Diff%7BDiffDelete, text%7D)%0A%09%09%09%7D%0A%09%09default:%0A%09%09%09// Anything else is an error.%0A%09%09%09return nil, errors.New(%22Invalid diff operation in DiffFromDelta: %22 + string(token%5B0%5D))%0A%09%09%7D%0A%09%7D%0A%0A%09if i != len(runes) %7B%0A%09%09return nil, fmt.Errorf(%22Delta length (%25v) is different from source text length (%25v)%22, i, len(text1))%0A%09%7D%0A%0A%09return diffs, nil%0A%7D%0A
- f 0fad772fd49b66ad4fcc6d18f90d3ff065e7cfb8f3c23126aeca8f245239a5be vendor/golang.org/x/crypto/argon2/argon2.go
+ f 700be0003bc2c074dc1af5138554112cebaf57bd2aebe56151d81eef7c02e1ae vendor/golang.org/x/crypto/argon2/argon2.go
dmppatch 4
@@ -1875,16 +1875,1230 @@
 n2id%0A)%0A%0A
+// Key derives a key from the password, salt, and cost parameters using Argon2i%0A// returning a byte slice of length keyLen that can be used as cryptographic%0A// key. The CPU cost and parallelism degree must be greater than zero.%0A//%0A// For example, you can get a derived key for e.g. AES-256 (which needs a%0A// 32-byte key) by doing:%0A//%0A//      key := argon2.Key(%5B%5Dbyte(%22some password%22), salt, 3, 32*1024, 4, 32)%0A//%0A// The draft RFC recommends%5B2%5D time=3, and memory=32*1024 is a sensible number.%0A// If using that amount of memory (32 MB) is not possible in some contexts then%0A// the time parameter can be increased to compensate.%0A//%0A// The time parameter specifies the number of passes over the memory and the%0A// memory parameter specifies the size of the memory in KiB. For example%0A// memory=32*1024 sets the memory cost to ~32 MB. The number of threads can be%0A// adjusted to the number of available CPUs. The cost parameters should be%0A// increased as memory latency and CPU parallelism increases. Remember to get a%0A// good random salt.%0Afunc Key(password, salt %5B%5Dbyte, time, memory uint32, threads uint8, keyLen uint32) %5B%5Dbyte %7B%0A%09return deriveKey(argon2i, password, salt, nil, nil, time, memory, threads, keyLen)%0A%7D%0A%0A
 // IDKey
- f fb5febceeb42365ad4eb696992a73c831124111c938dc0e13bb94aae2f9edd3b vendor/golang.org/x/crypto/argon2/blamka_generic.go
+ f 64fc08ec2dbd617cad784bb742d3533ee14254489f94dea41849aa6e00f6b5ca vendor/golang.org/x/crypto/argon2/blamka_generic.go
dmppatch 4
@@ -187,16 +187,758 @@
 4 bool%0A%0A
+func processBlockGeneric(out, in1, in2 *block, xor bool) %7B%0A%09var t block%0A%09for i := range t %7B%0A%09%09t%5Bi%5D = in1%5Bi%5D %5E in2%5Bi%5D%0A%09%7D%0A%09for i := 0; i %3C blockLength; i += 16 %7B%0A%09%09blamkaGeneric(%0A%09%09%09&t%5Bi+0%5D, &t%5Bi+1%5D, &t%5Bi+2%5D, &t%5Bi+3%5D,%0A%09%09%09&t%5Bi+4%5D, &t%5Bi+5%5D, &t%5Bi+6%5D, &t%5Bi+7%5D,%0A%09%09%09&t%5Bi+8%5D, &t%5Bi+9%5D, &t%5Bi+10%5D, &t%5Bi+11%5D,%0A%09%09%09&t%5Bi+12%5D, &t%5Bi+13%5D, &t%5Bi+14%5D, &t%5Bi+15%5D,%0A%09%09)%0A%09%7D%0A%09for i := 0; i %3C blockLength/8; i += 2 %7B%0A%09%09blamkaGeneric(%0A%09%09%09&t%5Bi%5D, &t%5Bi+1%5D, &t%5B16+i%5D, &t%5B16+i+1%5D,%0A%09%09%09&t%5B32+i%5D, &t%5B32+i+1%5D, &t%5B48+i%5D, &t%5B48+i+1%5D,%0A%09%09%09&t%5B64+i%5D, &t%5B64+i+1%5D, &t%5B80+i%5D, &t%5B80+i+1%5D,%0A%09%09%09&t%5B96+i%5D, &t%5B96+i+1%5D, &t%5B112+i%5D, &t%5B112+i+1%5D,%0A%09%09)%0A%09%7D%0A%09if xor %7B%0A%09%09for i := range t %7B%0A%09%09%09out%5Bi%5D %5E= in1%5Bi%5D %5E in2%5Bi%5D %5E t%5Bi%5D%0A%09%09%7D%0A%09%7D else %7B%0A%09%09for i := range t %7B%0A%09%09%09out%5Bi%5D = in1%5Bi%5D %5E in2%5Bi%5D %5E t%5Bi%5D%0A%09%09%7D%0A%09%7D%0A%7D%0A%0A
 func bla
- f 21145a7fed7e18ee641198bcf693b79394c89a1f91e0403dbf4344207ecb056d vendor/golang.org/x/crypto/blake2b/blake2b.go
+ f 85b588f12c2e75ea71f745fc38ed2ed76f5b8eece67c8b8b8c09f0d742807051 vendor/golang.org/x/crypto/blake2b/blake2b.go
dmppatch 15
@@ -1396,16 +1396,621 @@
 179,%0A%7D%0A%0A
+// Sum512 returns the BLAKE2b-512 checksum of the data.%0Afunc Sum512(data %5B%5Dbyte) %5BSize%5Dbyte %7B%0A%09var sum %5BSize%5Dbyte%0A%09checkSum(&sum, Size, data)%0A%09return sum%0A%7D%0A%0A// Sum384 returns the BLAKE2b-384 checksum of the data.%0Afunc Sum384(data %5B%5Dbyte) %5BSize384%5Dbyte %7B%0A%09var sum %5BSize%5Dbyte%0A%09var sum384 %5BSize384%5Dbyte%0A%09checkSum(&sum, Size384, data)%0A%09copy(sum384%5B:%5D, sum%5B:Size384%5D)%0A%09return sum384%0A%7D%0A%0A// Sum256 returns the BLAKE2b-256 checksum of the data.%0Afunc Sum256(data %5B%5Dbyte) %5BSize256%5Dbyte %7B%0A%09var sum %5BSize%5Dbyte%0A%09var sum256 %5BSize256%5Dbyte%0A%09checkSum(&sum, Size256, data)%0A%09copy(sum256%5B:%5D, sum%5B:Size256%5D)%0A%09return sum256%0A%7D%0A%0A
 // New51
@@ -3684,16 +3684,627 @@
  nil%0A%7D%0A%0A
+func checkSum(sum *%5BSize%5Dbyte, hashSize int, data %5B%5Dbyte) %7B%0A%09h := iv%0A%09h%5B0%5D %5E= uint64(hashSize) %7C (1 %3C%3C 16) %7C (1 %3C%3C 24)%0A%09var c %5B2%5Duint64%0A%0A%09if length := len(data); length %3E BlockSize %7B%0A%09%09n := length &%5E (BlockSize - 1)%0A%09%09if length == n %7B%0A%09%09%09n -= BlockSize%0A%09%09%7D%0A%09%09hashBlocks(&h, &c, 0, data%5B:n%5D)%0A%09%09data = data%5Bn:%5D%0A%09%7D%0A%0A%09var block %5BBlockSize%5Dbyte%0A%09offset := copy(block%5B:%5D, data)%0A%09remaining := uint64(BlockSize - offset)%0A%09if c%5B0%5D %3C remaining %7B%0A%09%09c%5B1%5D--%0A%09%7D%0A%09c%5B0%5D -= remaining%0A%0A%09hashBlocks(&h, &c, 0xFFFFFFFFFFFFFFFF, block%5B:%5D)%0A%0A%09for i, v := range h%5B:(hashSize+7)/8%5D %7B%0A%09%09binary.LittleEndian.PutUint64(sum%5B8*i:%5D, v)%0A%09%7D%0A%7D%0A%0A
 type dig
@@ -4436,24 +4436,1116 @@
 yLen int%0A%7D%0A%0A
+const (%0A%09magic         = %22b2b%22%0A%09marshaledSize = len(magic) + 8*8 + 2*8 + 1 + BlockSize + 1%0A)%0A%0Afunc (d *digest) MarshalBinary() (%5B%5Dbyte, error) %7B%0A%09if d.keyLen != 0 %7B%0A%09%09return nil, errors.New(%22crypto/blake2b: cannot marshal MACs%22)%0A%09%7D%0A%09b := make(%5B%5Dbyte, 0, marshaledSize)%0A%09b = append(b, magic...)%0A%09for i := 0; i %3C 8; i++ %7B%0A%09%09b = appendUint64(b, d.h%5Bi%5D)%0A%09%7D%0A%09b = appendUint64(b, d.c%5B0%5D)%0A%09b = appendUint64(b, d.c%5B1%5D)%0A%09// Maximum value for size is 64%0A%09b = append(b, byte(d.size))%0A%09b = append(b, d.block%5B:%5D...)%0A%09b = append(b, byte(d.offset))%0A%09return b, nil%0A%7D%0A%0Afunc (d *digest) UnmarshalBinary(b %5B%5Dbyte) error %7B%0A%09if len(b) %3C len(magic) %7C%7C string(b%5B:len(magic)%5D) != magic %7B%0A%09%09return errors.New(%22crypto/blake2b: invalid hash state identifier%22)%0A%09%7D%0A%09if len(b) != marshaledSize %7B%0A%09%09return errors.New(%22crypto/blake2b: invalid hash state size%22)%0A%09%7D%0A%09b = b%5Blen(magic):%5D%0A%09for i := 0; i %3C 8; i++ %7B%0A%09%09b, d.h%5Bi%5D = consumeUint64(b)%0A%09%7D%0A%09b, d.c%5B0%5D = consumeUint64(b)%0A%09b, d.c%5B1%5D = consumeUint64(b)%0A%09d.size = int(b%5B0%5D)%0A%09b = b%5B1:%5D%0A%09copy(d.block%5B:%5D, b%5B:BlockSize%5D)%0A%09b = b%5BBlockSize:%5D%0A%09d.offset = int(b%5B0%5D)%0A%09return nil%0A%7D%0A%0A
 func (d *dig
@@ -6871,24 +6871,484 @@
 t64(hash%5B8*i:%5D, v)%0A%09%7D%0A%7D%0A
+%0Afunc appendUint64(b %5B%5Dbyte, x uint64) %5B%5Dbyte %7B%0A%09var a %5B8%5Dbyte%0A%09binary.BigEndian.PutUint64(a%5B:%5D, x)%0A%09return append(b, a%5B:%5D...)%0A%7D%0A%0Afunc appendUint32(b %5B%5Dbyte, x uint32) %5B%5Dbyte %7B%0A%09var a %5B4%5Dbyte%0A%09binary.BigEndian.PutUint32(a%5B:%5D, x)%0A%09return append(b, a%5B:%5D...)%0A%7D%0A%0Afunc consumeUint64(b %5B%5Dbyte) (%5B%5Dbyte, uint64) %7B%0A%09x := binary.BigEndian.Uint64(b)%0A%09return b%5B8:%5D, x%0A%7D%0A%0Afunc consumeUint32(b %5B%5Dbyte) (%5B%5Dbyte, uint32) %7B%0A%09x := binary.BigEndian.Uint32(b)%0A%09return b%5B4:%5D, x%0A%7D%0A
- f 8c97ceb877b924869456010cd0fe50baf18015589019ae7e5fd3fc19606cb7d5 vendor/golang.org/x/crypto/blake2b/blake2x.go
+ f fbe4a83f26990628538a61b7eebb9e90b20ee66b917e40145b3215eaaa1a1e55 vendor/golang.org/x/crypto/blake2b/blake2x.go
dmppatch 17
@@ -202,11 +202,639 @@
 ry%22%0A
+%09%22errors%22%0A%09%22io%22%0A
 )%0A%0A
+// XOF defines the interface to hash functions that%0A// support arbitrary-length output.%0Atype XOF interface %7B%0A%09// Write absorbs more data into the hash's state. It panics if called%0A%09// after Read.%0A%09io.Writer%0A%0A%09// Read reads more output from the hash. It returns io.EOF if the limit%0A%09// has been reached.%0A%09io.Reader%0A%0A%09// Clone returns a copy of the XOF in its current state.%0A%09Clone() XOF%0A%0A%09// Reset resets the XOF to its initial state.%0A%09Reset()%0A%7D%0A%0A// OutputLengthUnknown can be used as the size argument to NewXOF to indicate%0A// the the length of the output is not known in advance.%0Aconst OutputLengthUnknown = 0%0A%0A
 // m
@@ -1152,16 +1152,859 @@
 ) * 64%0A%0A
+// NewXOF creates a new variable-output-length hash. The hash either produce a%0A// known number of bytes (1 %3C= size %3C 2**32-1), or an unknown number of bytes%0A// (size == OutputLengthUnknown). In the latter case, an absolute limit of%0A// 256GiB applies.%0A//%0A// A non-nil key turns the hash into a MAC. The key must between%0A// zero and 32 bytes long.%0Afunc NewXOF(size uint32, key %5B%5Dbyte) (XOF, error) %7B%0A%09if len(key) %3E Size %7B%0A%09%09return nil, errKeySize%0A%09%7D%0A%09if size == magicUnknownOutputLength %7B%0A%09%09// 2%5E32-1 indicates an unknown number of bytes and thus isn't a%0A%09%09// valid length.%0A%09%09return nil, errors.New(%22blake2b: XOF length too large%22)%0A%09%7D%0A%09if size == OutputLengthUnknown %7B%0A%09%09size = magicUnknownOutputLength%0A%09%7D%0A%09x := &xof%7B%0A%09%09d: digest%7B%0A%09%09%09size:   Size,%0A%09%09%09keyLen: len(key),%0A%09%09%7D,%0A%09%09length: size,%0A%09%7D%0A%09copy(x.d.key%5B:%5D, key)%0A%09x.Reset()%0A%09return x, nil%0A%7D%0A%0A
 type xof
@@ -2325,24 +2325,83 @@
 Write(p)%0A%7D%0A%0A
+func (x *xof) Clone() XOF %7B%0A%09clone := *x%0A%09return &clone%0A%7D%0A%0A
 func (x *xof
@@ -2864,12 +2864,1276 @@
 e = false%0A%7D%0A
+%0Afunc (x *xof) Read(p %5B%5Dbyte) (n int, err error) %7B%0A%09if !x.readMode %7B%0A%09%09x.d.finalize(&x.root)%0A%09%09x.readMode = true%0A%09%7D%0A%0A%09if x.remaining == 0 %7B%0A%09%09return 0, io.EOF%0A%09%7D%0A%0A%09n = len(p)%0A%09if uint64(n) %3E x.remaining %7B%0A%09%09n = int(x.remaining)%0A%09%09p = p%5B:n%5D%0A%09%7D%0A%0A%09if x.offset %3E 0 %7B%0A%09%09blockRemaining := Size - x.offset%0A%09%09if n %3C blockRemaining %7B%0A%09%09%09x.offset += copy(p, x.block%5Bx.offset:%5D)%0A%09%09%09x.remaining -= uint64(n)%0A%09%09%09return%0A%09%09%7D%0A%09%09copy(p, x.block%5Bx.offset:%5D)%0A%09%09p = p%5BblockRemaining:%5D%0A%09%09x.offset = 0%0A%09%09x.remaining -= uint64(blockRemaining)%0A%09%7D%0A%0A%09for len(p) %3E= Size %7B%0A%09%09binary.LittleEndian.PutUint32(x.cfg%5B8:%5D, x.nodeOffset)%0A%09%09x.nodeOffset++%0A%0A%09%09x.d.initConfig(&x.cfg)%0A%09%09x.d.Write(x.root%5B:%5D)%0A%09%09x.d.finalize(&x.block)%0A%0A%09%09copy(p, x.block%5B:%5D)%0A%09%09p = p%5BSize:%5D%0A%09%09x.remaining -= uint64(Size)%0A%09%7D%0A%0A%09if todo := len(p); todo %3E 0 %7B%0A%09%09if x.remaining %3C uint64(Size) %7B%0A%09%09%09x.cfg%5B0%5D = byte(x.remaining)%0A%09%09%7D%0A%09%09binary.LittleEndian.PutUint32(x.cfg%5B8:%5D, x.nodeOffset)%0A%09%09x.nodeOffset++%0A%0A%09%09x.d.initConfig(&x.cfg)%0A%09%09x.d.Write(x.root%5B:%5D)%0A%09%09x.d.finalize(&x.block)%0A%0A%09%09x.offset = copy(p, x.block%5B:todo%5D)%0A%09%09x.remaining -= uint64(todo)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc (d *digest) initConfig(cfg *%5BSize%5Dbyte) %7B%0A%09d.offset, d.c%5B0%5D, d.c%5B1%5D = 0, 0, 0%0A%09for i := range d.h %7B%0A%09%09d.h%5Bi%5D = iv%5Bi%5D %5E binary.LittleEndian.Uint64(cfg%5Bi*8:%5D)%0A%09%7D%0A%7D%0A
- f 98b172afdf7343e21f5a32659f9560a4a3fa17dee220e8d8838c371c313df31f vendor/golang.org/x/crypto/ed25519/ed25519.go
+ f 9d0b067f43ca3f0428c7ec521ce4b05b08244453b68a8d770c19d40fb9c3e877 vendor/golang.org/x/crypto/ed25519/ed25519.go
dmppatch 4
@@ -1519,16 +1519,512 @@
 %5B%5Dbyte%0A%0A
+// Public returns the PublicKey corresponding to priv.%0Afunc (priv PrivateKey) Public() crypto.PublicKey %7B%0A%09publicKey := make(%5B%5Dbyte, PublicKeySize)%0A%09copy(publicKey, priv%5B32:%5D)%0A%09return PublicKey(publicKey)%0A%7D%0A%0A// Seed returns the private key seed corresponding to priv. It is provided for%0A// interoperability with RFC 8032. RFC 8032's private keys correspond to seeds%0A// in this package.%0Afunc (priv PrivateKey) Seed() %5B%5Dbyte %7B%0A%09seed := make(%5B%5Dbyte, SeedSize)%0A%09copy(seed, priv%5B:32%5D)%0A%09return seed%0A%7D%0A%0A
 // Sign 
- f 17c6ee3fe6f13dbfe28260b40c5503c50e2131f3c0fe497abae0ae9b1db9c721 vendor/golang.org/x/crypto/ed25519/internal/edwards25519/const.go
+ f bb43c357b9bc26c3f8f010e5dffcb69590683b627642f0ca03933e4598145b6e vendor/golang.org/x/crypto/ed25519/internal/edwards25519/const.go
dmppatch 4
@@ -767,24 +767,142 @@
 1406482,%0A%7D%0A%0A
+// A is a constant in the Montgomery-form of curve25519.%0Avar A = FieldElement%7B%0A%09486662, 0, 0, 0, 0, 0, 0, 0, 0, 0,%0A%7D%0A%0A
 // bi contai
- f c63c4ad72acb641eae36f01ed60755fb60987d8842e98e13a835a28b595f2076 vendor/golang.org/x/crypto/internal/subtle/aliasing.go
+ f 3417d21c5fdd8193510233ec062e40a2cdb30bc50296313ac4d72c4d00d675c1 vendor/golang.org/x/crypto/internal/subtle/aliasing.go
dmppatch 3
@@ -760,8 +760,503 @@
 -1%5D))%0A%7D%0A
+%0A// InexactOverlap reports whether x and y share memory at any non-corresponding%0A// index. The memory beyond the slice length is ignored. Note that x and y can%0A// have different lengths and still not have any inexact overlap.%0A//%0A// InexactOverlap can be used to implement the requirements of the crypto/cipher%0A// AEAD, Block, BlockMode and Stream interfaces.%0Afunc InexactOverlap(x, y %5B%5Dbyte) bool %7B%0A%09if len(x) == 0 %7C%7C len(y) == 0 %7C%7C &x%5B0%5D == &y%5B0%5D %7B%0A%09%09return false%0A%09%7D%0A%09return AnyOverlap(x, y)%0A%7D%0A
- f 0aa29b1f36e73f505f88ba169e2a4cb8fdfb580e4b1e91b2450b6af80a910ae0 vendor/golang.org/x/crypto/internal/subtle/aliasing_appengine.go
+ f 7795ac254dcf9128ee1030558907c4507df05597a5a3ab32ec987e08940d9c08 vendor/golang.org/x/crypto/internal/subtle/aliasing_appengine.go
dmppatch 3
@@ -890,8 +890,503 @@
 ter()%0A%7D%0A
+%0A// InexactOverlap reports whether x and y share memory at any non-corresponding%0A// index. The memory beyond the slice length is ignored. Note that x and y can%0A// have different lengths and still not have any inexact overlap.%0A//%0A// InexactOverlap can be used to implement the requirements of the crypto/cipher%0A// AEAD, Block, BlockMode and Stream interfaces.%0Afunc InexactOverlap(x, y %5B%5Dbyte) bool %7B%0A%09if len(x) == 0 %7C%7C len(y) == 0 %7C%7C &x%5B0%5D == &y%5B0%5D %7B%0A%09%09return false%0A%09%7D%0A%09return AnyOverlap(x, y)%0A%7D%0A
- f e116d09071dc1de5b22ae5841afb676f275d8e70a8e39f80c807be4da23240c3 vendor/golang.org/x/crypto/poly1305/sum_arm.go
+ f 5da9fa06a7dab609c8c21fb8b4971342c9ab6d1bd74a427368662614541673a4 vendor/golang.org/x/crypto/poly1305/sum_arm.go
dmppatch 4
@@ -210,16 +210,153 @@
 ly1305%0A%0A
+// This function is implemented in sum_arm.s%0A//go:noescape%0Afunc poly1305_auth_armv6(out *%5B16%5Dbyte, m *byte, mlen uint32, key *%5B32%5Dbyte)%0A%0A
 // Sum g
- f 19a3c38ea5e01615170bdb4d4879ec41f123291a1fc1276468213e6611642dbb vendor/golang.org/x/crypto/poly1305/sum_ref.go
+ f 5b172acfbfdb395da9ebc317b048eb4dc1acf44a2dce7110c29f9f6b619685f5 vendor/golang.org/x/crypto/poly1305/sum_ref.go
dmppatch 3
@@ -170,8 +170,4633 @@
 oly1305%0A
+%0Aimport %22encoding/binary%22%0A%0A// sumGeneric generates an authenticator for msg using a one-time key and%0A// puts the 16-byte result into out. This is the generic implementation of%0A// Sum and should be called if no assembly implementation is available.%0Afunc sumGeneric(out *%5BTagSize%5Dbyte, msg %5B%5Dbyte, key *%5B32%5Dbyte) %7B%0A%09var (%0A%09%09h0, h1, h2, h3, h4 uint32 // the hash accumulators%0A%09%09r0, r1, r2, r3, r4 uint64 // the r part of the key%0A%09)%0A%0A%09r0 = uint64(binary.LittleEndian.Uint32(key%5B0:%5D) & 0x3ffffff)%0A%09r1 = uint64((binary.LittleEndian.Uint32(key%5B3:%5D) %3E%3E 2) & 0x3ffff03)%0A%09r2 = uint64((binary.LittleEndian.Uint32(key%5B6:%5D) %3E%3E 4) & 0x3ffc0ff)%0A%09r3 = uint64((binary.LittleEndian.Uint32(key%5B9:%5D) %3E%3E 6) & 0x3f03fff)%0A%09r4 = uint64((binary.LittleEndian.Uint32(key%5B12:%5D) %3E%3E 8) & 0x00fffff)%0A%0A%09R1, R2, R3, R4 := r1*5, r2*5, r3*5, r4*5%0A%0A%09for len(msg) %3E= TagSize %7B%0A%09%09// h += msg%0A%09%09h0 += binary.LittleEndian.Uint32(msg%5B0:%5D) & 0x3ffffff%0A%09%09h1 += (binary.LittleEndian.Uint32(msg%5B3:%5D) %3E%3E 2) & 0x3ffffff%0A%09%09h2 += (binary.LittleEndian.Uint32(msg%5B6:%5D) %3E%3E 4) & 0x3ffffff%0A%09%09h3 += (binary.LittleEndian.Uint32(msg%5B9:%5D) %3E%3E 6) & 0x3ffffff%0A%09%09h4 += (binary.LittleEndian.Uint32(msg%5B12:%5D) %3E%3E 8) %7C (1 %3C%3C 24)%0A%0A%09%09// h *= r%0A%09%09d0 := (uint64(h0) * r0) + (uint64(h1) * R4) + (uint64(h2) * R3) + (uint64(h3) * R2) + (uint64(h4) * R1)%0A%09%09d1 := (d0 %3E%3E 26) + (uint64(h0) * r1) + (uint64(h1) * r0) + (uint64(h2) * R4) + (uint64(h3) * R3) + (uint64(h4) * R2)%0A%09%09d2 := (d1 %3E%3E 26) + (uint64(h0) * r2) + (uint64(h1) * r1) + (uint64(h2) * r0) + (uint64(h3) * R4) + (uint64(h4) * R3)%0A%09%09d3 := (d2 %3E%3E 26) + (uint64(h0) * r3) + (uint64(h1) * r2) + (uint64(h2) * r1) + (uint64(h3) * r0) + (uint64(h4) * R4)%0A%09%09d4 := (d3 %3E%3E 26) + (uint64(h0) * r4) + (uint64(h1) * r3) + (uint64(h2) * r2) + (uint64(h3) * r1) + (uint64(h4) * r0)%0A%0A%09%09// h %25= p%0A%09%09h0 = uint32(d0) & 0x3ffffff%0A%09%09h1 = uint32(d1) & 0x3ffffff%0A%09%09h2 = uint32(d2) & 0x3ffffff%0A%09%09h3 = uint32(d3) & 0x3ffffff%0A%09%09h4 = uint32(d4) & 0x3ffffff%0A%0A%09%09h0 += uint32(d4%3E%3E26) * 5%0A%09%09h1 += h0 %3E%3E 26%0A%09%09h0 = h0 & 0x3ffffff%0A%0A%09%09msg = msg%5BTagSize:%5D%0A%09%7D%0A%0A%09if len(msg) %3E 0 %7B%0A%09%09var block %5BTagSize%5Dbyte%0A%09%09off := copy(block%5B:%5D, msg)%0A%09%09block%5Boff%5D = 0x01%0A%0A%09%09// h += msg%0A%09%09h0 += binary.LittleEndian.Uint32(block%5B0:%5D) & 0x3ffffff%0A%09%09h1 += (binary.LittleEndian.Uint32(block%5B3:%5D) %3E%3E 2) & 0x3ffffff%0A%09%09h2 += (binary.LittleEndian.Uint32(block%5B6:%5D) %3E%3E 4) & 0x3ffffff%0A%09%09h3 += (binary.LittleEndian.Uint32(block%5B9:%5D) %3E%3E 6) & 0x3ffffff%0A%09%09h4 += (binary.LittleEndian.Uint32(block%5B12:%5D) %3E%3E 8)%0A%0A%09%09// h *= r%0A%09%09d0 := (uint64(h0) * r0) + (uint64(h1) * R4) + (uint64(h2) * R3) + (uint64(h3) * R2) + (uint64(h4) * R1)%0A%09%09d1 := (d0 %3E%3E 26) + (uint64(h0) * r1) + (uint64(h1) * r0) + (uint64(h2) * R4) + (uint64(h3) * R3) + (uint64(h4) * R2)%0A%09%09d2 := (d1 %3E%3E 26) + (uint64(h0) * r2) + (uint64(h1) * r1) + (uint64(h2) * r0) + (uint64(h3) * R4) + (uint64(h4) * R3)%0A%09%09d3 := (d2 %3E%3E 26) + (uint64(h0) * r3) + (uint64(h1) * r2) + (uint64(h2) * r1) + (uint64(h3) * r0) + (uint64(h4) * R4)%0A%09%09d4 := (d3 %3E%3E 26) + (uint64(h0) * r4) + (uint64(h1) * r3) + (uint64(h2) * r2) + (uint64(h3) * r1) + (uint64(h4) * r0)%0A%0A%09%09// h %25= p%0A%09%09h0 = uint32(d0) & 0x3ffffff%0A%09%09h1 = uint32(d1) & 0x3ffffff%0A%09%09h2 = uint32(d2) & 0x3ffffff%0A%09%09h3 = uint32(d3) & 0x3ffffff%0A%09%09h4 = uint32(d4) & 0x3ffffff%0A%0A%09%09h0 += uint32(d4%3E%3E26) * 5%0A%09%09h1 += h0 %3E%3E 26%0A%09%09h0 = h0 & 0x3ffffff%0A%09%7D%0A%0A%09// h %25= p reduction%0A%09h2 += h1 %3E%3E 26%0A%09h1 &= 0x3ffffff%0A%09h3 += h2 %3E%3E 26%0A%09h2 &= 0x3ffffff%0A%09h4 += h3 %3E%3E 26%0A%09h3 &= 0x3ffffff%0A%09h0 += 5 * (h4 %3E%3E 26)%0A%09h4 &= 0x3ffffff%0A%09h1 += h0 %3E%3E 26%0A%09h0 &= 0x3ffffff%0A%0A%09// h - p%0A%09t0 := h0 + 5%0A%09t1 := h1 + (t0 %3E%3E 26)%0A%09t2 := h2 + (t1 %3E%3E 26)%0A%09t3 := h3 + (t2 %3E%3E 26)%0A%09t4 := h4 + (t3 %3E%3E 26) - (1 %3C%3C 26)%0A%09t0 &= 0x3ffffff%0A%09t1 &= 0x3ffffff%0A%09t2 &= 0x3ffffff%0A%09t3 &= 0x3ffffff%0A%0A%09// select h if h %3C p else h - p%0A%09t_mask := (t4 %3E%3E 31) - 1%0A%09h_mask := %5Et_mask%0A%09h0 = (h0 & h_mask) %7C (t0 & t_mask)%0A%09h1 = (h1 & h_mask) %7C (t1 & t_mask)%0A%09h2 = (h2 & h_mask) %7C (t2 & t_mask)%0A%09h3 = (h3 & h_mask) %7C (t3 & t_mask)%0A%09h4 = (h4 & h_mask) %7C (t4 & t_mask)%0A%0A%09// h %25= 2%5E128%0A%09h0 %7C= h1 %3C%3C 26%0A%09h1 = ((h1 %3E%3E 6) %7C (h2 %3C%3C 20))%0A%09h2 = ((h2 %3E%3E 12) %7C (h3 %3C%3C 14))%0A%09h3 = ((h3 %3E%3E 18) %7C (h4 %3C%3C 8))%0A%0A%09// s: the s part of the key%0A%09// tag = (h + s) %25 (2%5E128)%0A%09t := uint64(h0) + uint64(binary.LittleEndian.Uint32(key%5B16:%5D))%0A%09h0 = uint32(t)%0A%09t = uint64(h1) + uint64(binary.LittleEndian.Uint32(key%5B20:%5D)) + (t %3E%3E 32)%0A%09h1 = uint32(t)%0A%09t = uint64(h2) + uint64(binary.LittleEndian.Uint32(key%5B24:%5D)) + (t %3E%3E 32)%0A%09h2 = uint32(t)%0A%09t = uint64(h3) + uint64(binary.LittleEndian.Uint32(key%5B28:%5D)) + (t %3E%3E 32)%0A%09h3 = uint32(t)%0A%0A%09binary.LittleEndian.PutUint32(out%5B0:%5D, h0)%0A%09binary.LittleEndian.PutUint32(out%5B4:%5D, h1)%0A%09binary.LittleEndian.PutUint32(out%5B8:%5D, h2)%0A%09binary.LittleEndian.PutUint32(out%5B12:%5D, h3)%0A%7D%0A
- f 253615c13fa52b506ae7073a68d9231af388b9167751d780abb128919390a314 vendor/golang.org/x/crypto/poly1305/sum_s390x.go
+ f 60768a98b4fe6fc8982fe50a0f2408b7abfaa3253ec3a003045f5e44d30a3f5a vendor/golang.org/x/crypto/poly1305/sum_s390x.go
dmppatch 4
@@ -213,16 +213,850 @@
 ly1305%0A%0A
+// hasVectorFacility reports whether the machine supports%0A// the vector facility (vx).%0Afunc hasVectorFacility() bool%0A%0A// hasVMSLFacility reports whether the machine supports%0A// Vector Multiply Sum Logical (VMSL).%0Afunc hasVMSLFacility() bool%0A%0Avar hasVX = hasVectorFacility()%0Avar hasVMSL = hasVMSLFacility()%0A%0A// poly1305vx is an assembly implementation of Poly1305 that uses vector%0A// instructions. It must only be called if the vector facility (vx) is%0A// available.%0A//go:noescape%0Afunc poly1305vx(out *%5B16%5Dbyte, m *byte, mlen uint64, key *%5B32%5Dbyte)%0A%0A// poly1305vmsl is an assembly implementation of Poly1305 that uses vector%0A// instructions, including VMSL. It must only be called if the vector facility (vx) is%0A// available and if VMSL is supported.%0A//go:noescape%0Afunc poly1305vmsl(out *%5B16%5Dbyte, m *byte, mlen uint64, key *%5B32%5Dbyte)%0A%0A
 // Sum g
- f 2c860eecee01e9ab072f72d76daa6060704a5354e0576bff5d185a61455c1c3c vendor/golang.org/x/crypto/salsa20/salsa/salsa208.go
+ f a59ddd01915d7260b1e26fd652ce29879a39cfaa87afde06e65754d7ec1717b6 vendor/golang.org/x/crypto/salsa20/salsa/salsa208.go
dmppatch 3
@@ -167,8 +167,4817 @@
 e salsa%0A
+%0A// Core208 applies the Salsa20/8 core function to the 64-byte array in and puts%0A// the result into the 64-byte array out. The input and output may be the same array.%0Afunc Core208(out *%5B64%5Dbyte, in *%5B64%5Dbyte) %7B%0A%09j0 := uint32(in%5B0%5D) %7C uint32(in%5B1%5D)%3C%3C8 %7C uint32(in%5B2%5D)%3C%3C16 %7C uint32(in%5B3%5D)%3C%3C24%0A%09j1 := uint32(in%5B4%5D) %7C uint32(in%5B5%5D)%3C%3C8 %7C uint32(in%5B6%5D)%3C%3C16 %7C uint32(in%5B7%5D)%3C%3C24%0A%09j2 := uint32(in%5B8%5D) %7C uint32(in%5B9%5D)%3C%3C8 %7C uint32(in%5B10%5D)%3C%3C16 %7C uint32(in%5B11%5D)%3C%3C24%0A%09j3 := uint32(in%5B12%5D) %7C uint32(in%5B13%5D)%3C%3C8 %7C uint32(in%5B14%5D)%3C%3C16 %7C uint32(in%5B15%5D)%3C%3C24%0A%09j4 := uint32(in%5B16%5D) %7C uint32(in%5B17%5D)%3C%3C8 %7C uint32(in%5B18%5D)%3C%3C16 %7C uint32(in%5B19%5D)%3C%3C24%0A%09j5 := uint32(in%5B20%5D) %7C uint32(in%5B21%5D)%3C%3C8 %7C uint32(in%5B22%5D)%3C%3C16 %7C uint32(in%5B23%5D)%3C%3C24%0A%09j6 := uint32(in%5B24%5D) %7C uint32(in%5B25%5D)%3C%3C8 %7C uint32(in%5B26%5D)%3C%3C16 %7C uint32(in%5B27%5D)%3C%3C24%0A%09j7 := uint32(in%5B28%5D) %7C uint32(in%5B29%5D)%3C%3C8 %7C uint32(in%5B30%5D)%3C%3C16 %7C uint32(in%5B31%5D)%3C%3C24%0A%09j8 := uint32(in%5B32%5D) %7C uint32(in%5B33%5D)%3C%3C8 %7C uint32(in%5B34%5D)%3C%3C16 %7C uint32(in%5B35%5D)%3C%3C24%0A%09j9 := uint32(in%5B36%5D) %7C uint32(in%5B37%5D)%3C%3C8 %7C uint32(in%5B38%5D)%3C%3C16 %7C uint32(in%5B39%5D)%3C%3C24%0A%09j10 := uint32(in%5B40%5D) %7C uint32(in%5B41%5D)%3C%3C8 %7C uint32(in%5B42%5D)%3C%3C16 %7C uint32(in%5B43%5D)%3C%3C24%0A%09j11 := uint32(in%5B44%5D) %7C uint32(in%5B45%5D)%3C%3C8 %7C uint32(in%5B46%5D)%3C%3C16 %7C uint32(in%5B47%5D)%3C%3C24%0A%09j12 := uint32(in%5B48%5D) %7C uint32(in%5B49%5D)%3C%3C8 %7C uint32(in%5B50%5D)%3C%3C16 %7C uint32(in%5B51%5D)%3C%3C24%0A%09j13 := uint32(in%5B52%5D) %7C uint32(in%5B53%5D)%3C%3C8 %7C uint32(in%5B54%5D)%3C%3C16 %7C uint32(in%5B55%5D)%3C%3C24%0A%09j14 := uint32(in%5B56%5D) %7C uint32(in%5B57%5D)%3C%3C8 %7C uint32(in%5B58%5D)%3C%3C16 %7C uint32(in%5B59%5D)%3C%3C24%0A%09j15 := uint32(in%5B60%5D) %7C uint32(in%5B61%5D)%3C%3C8 %7C uint32(in%5B62%5D)%3C%3C16 %7C uint32(in%5B63%5D)%3C%3C24%0A%0A%09x0, x1, x2, x3, x4, x5, x6, x7, x8 := j0, j1, j2, j3, j4, j5, j6, j7, j8%0A%09x9, x10, x11, x12, x13, x14, x15 := j9, j10, j11, j12, j13, j14, j15%0A%0A%09for i := 0; i %3C 8; i += 2 %7B%0A%09%09u := x0 + x12%0A%09%09x4 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x4 + x0%0A%09%09x8 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x8 + x4%0A%09%09x12 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x12 + x8%0A%09%09x0 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x5 + x1%0A%09%09x9 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x9 + x5%0A%09%09x13 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x13 + x9%0A%09%09x1 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x1 + x13%0A%09%09x5 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x10 + x6%0A%09%09x14 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x14 + x10%0A%09%09x2 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x2 + x14%0A%09%09x6 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x6 + x2%0A%09%09x10 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x15 + x11%0A%09%09x3 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x3 + x15%0A%09%09x7 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x7 + x3%0A%09%09x11 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x11 + x7%0A%09%09x15 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x0 + x3%0A%09%09x1 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x1 + x0%0A%09%09x2 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x2 + x1%0A%09%09x3 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x3 + x2%0A%09%09x0 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x5 + x4%0A%09%09x6 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x6 + x5%0A%09%09x7 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x7 + x6%0A%09%09x4 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x4 + x7%0A%09%09x5 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x10 + x9%0A%09%09x11 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x11 + x10%0A%09%09x8 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x8 + x11%0A%09%09x9 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x9 + x8%0A%09%09x10 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x15 + x14%0A%09%09x12 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x12 + x15%0A%09%09x13 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x13 + x12%0A%09%09x14 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x14 + x13%0A%09%09x15 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%09%7D%0A%09x0 += j0%0A%09x1 += j1%0A%09x2 += j2%0A%09x3 += j3%0A%09x4 += j4%0A%09x5 += j5%0A%09x6 += j6%0A%09x7 += j7%0A%09x8 += j8%0A%09x9 += j9%0A%09x10 += j10%0A%09x11 += j11%0A%09x12 += j12%0A%09x13 += j13%0A%09x14 += j14%0A%09x15 += j15%0A%0A%09out%5B0%5D = byte(x0)%0A%09out%5B1%5D = byte(x0 %3E%3E 8)%0A%09out%5B2%5D = byte(x0 %3E%3E 16)%0A%09out%5B3%5D = byte(x0 %3E%3E 24)%0A%0A%09out%5B4%5D = byte(x1)%0A%09out%5B5%5D = byte(x1 %3E%3E 8)%0A%09out%5B6%5D = byte(x1 %3E%3E 16)%0A%09out%5B7%5D = byte(x1 %3E%3E 24)%0A%0A%09out%5B8%5D = byte(x2)%0A%09out%5B9%5D = byte(x2 %3E%3E 8)%0A%09out%5B10%5D = byte(x2 %3E%3E 16)%0A%09out%5B11%5D = byte(x2 %3E%3E 24)%0A%0A%09out%5B12%5D = byte(x3)%0A%09out%5B13%5D = byte(x3 %3E%3E 8)%0A%09out%5B14%5D = byte(x3 %3E%3E 16)%0A%09out%5B15%5D = byte(x3 %3E%3E 24)%0A%0A%09out%5B16%5D = byte(x4)%0A%09out%5B17%5D = byte(x4 %3E%3E 8)%0A%09out%5B18%5D = byte(x4 %3E%3E 16)%0A%09out%5B19%5D = byte(x4 %3E%3E 24)%0A%0A%09out%5B20%5D = byte(x5)%0A%09out%5B21%5D = byte(x5 %3E%3E 8)%0A%09out%5B22%5D = byte(x5 %3E%3E 16)%0A%09out%5B23%5D = byte(x5 %3E%3E 24)%0A%0A%09out%5B24%5D = byte(x6)%0A%09out%5B25%5D = byte(x6 %3E%3E 8)%0A%09out%5B26%5D = byte(x6 %3E%3E 16)%0A%09out%5B27%5D = byte(x6 %3E%3E 24)%0A%0A%09out%5B28%5D = byte(x7)%0A%09out%5B29%5D = byte(x7 %3E%3E 8)%0A%09out%5B30%5D = byte(x7 %3E%3E 16)%0A%09out%5B31%5D = byte(x7 %3E%3E 24)%0A%0A%09out%5B32%5D = byte(x8)%0A%09out%5B33%5D = byte(x8 %3E%3E 8)%0A%09out%5B34%5D = byte(x8 %3E%3E 16)%0A%09out%5B35%5D = byte(x8 %3E%3E 24)%0A%0A%09out%5B36%5D = byte(x9)%0A%09out%5B37%5D = byte(x9 %3E%3E 8)%0A%09out%5B38%5D = byte(x9 %3E%3E 16)%0A%09out%5B39%5D = byte(x9 %3E%3E 24)%0A%0A%09out%5B40%5D = byte(x10)%0A%09out%5B41%5D = byte(x10 %3E%3E 8)%0A%09out%5B42%5D = byte(x10 %3E%3E 16)%0A%09out%5B43%5D = byte(x10 %3E%3E 24)%0A%0A%09out%5B44%5D = byte(x11)%0A%09out%5B45%5D = byte(x11 %3E%3E 8)%0A%09out%5B46%5D = byte(x11 %3E%3E 16)%0A%09out%5B47%5D = byte(x11 %3E%3E 24)%0A%0A%09out%5B48%5D = byte(x12)%0A%09out%5B49%5D = byte(x12 %3E%3E 8)%0A%09out%5B50%5D = byte(x12 %3E%3E 16)%0A%09out%5B51%5D = byte(x12 %3E%3E 24)%0A%0A%09out%5B52%5D = byte(x13)%0A%09out%5B53%5D = byte(x13 %3E%3E 8)%0A%09out%5B54%5D = byte(x13 %3E%3E 16)%0A%09out%5B55%5D = byte(x13 %3E%3E 24)%0A%0A%09out%5B56%5D = byte(x14)%0A%09out%5B57%5D = byte(x14 %3E%3E 8)%0A%09out%5B58%5D = byte(x14 %3E%3E 16)%0A%09out%5B59%5D = byte(x14 %3E%3E 24)%0A%0A%09out%5B60%5D = byte(x15)%0A%09out%5B61%5D = byte(x15 %3E%3E 8)%0A%09out%5B62%5D = byte(x15 %3E%3E 16)%0A%09out%5B63%5D = byte(x15 %3E%3E 24)%0A%7D%0A
- f 9b7d8a1cee11301a51b3db2973d43fb46596a3a8f8efa2eb337344d9de216894 vendor/golang.org/x/crypto/salsa20/salsa/salsa20_ref.go
+ f 8f3bf841ea60048812524ec693ce2d97506ef511287ff5de5547ba71f733eaa4 vendor/golang.org/x/crypto/salsa20/salsa/salsa20_ref.go
dmppatch 4
@@ -202,16 +202,4787 @@
  salsa%0A%0A
+const rounds = 20%0A%0A// core applies the Salsa20 core function to 16-byte input in, 32-byte key k,%0A// and 16-byte constant c, and puts the result into 64-byte array out.%0Afunc core(out *%5B64%5Dbyte, in *%5B16%5Dbyte, k *%5B32%5Dbyte, c *%5B16%5Dbyte) %7B%0A%09j0 := uint32(c%5B0%5D) %7C uint32(c%5B1%5D)%3C%3C8 %7C uint32(c%5B2%5D)%3C%3C16 %7C uint32(c%5B3%5D)%3C%3C24%0A%09j1 := uint32(k%5B0%5D) %7C uint32(k%5B1%5D)%3C%3C8 %7C uint32(k%5B2%5D)%3C%3C16 %7C uint32(k%5B3%5D)%3C%3C24%0A%09j2 := uint32(k%5B4%5D) %7C uint32(k%5B5%5D)%3C%3C8 %7C uint32(k%5B6%5D)%3C%3C16 %7C uint32(k%5B7%5D)%3C%3C24%0A%09j3 := uint32(k%5B8%5D) %7C uint32(k%5B9%5D)%3C%3C8 %7C uint32(k%5B10%5D)%3C%3C16 %7C uint32(k%5B11%5D)%3C%3C24%0A%09j4 := uint32(k%5B12%5D) %7C uint32(k%5B13%5D)%3C%3C8 %7C uint32(k%5B14%5D)%3C%3C16 %7C uint32(k%5B15%5D)%3C%3C24%0A%09j5 := uint32(c%5B4%5D) %7C uint32(c%5B5%5D)%3C%3C8 %7C uint32(c%5B6%5D)%3C%3C16 %7C uint32(c%5B7%5D)%3C%3C24%0A%09j6 := uint32(in%5B0%5D) %7C uint32(in%5B1%5D)%3C%3C8 %7C uint32(in%5B2%5D)%3C%3C16 %7C uint32(in%5B3%5D)%3C%3C24%0A%09j7 := uint32(in%5B4%5D) %7C uint32(in%5B5%5D)%3C%3C8 %7C uint32(in%5B6%5D)%3C%3C16 %7C uint32(in%5B7%5D)%3C%3C24%0A%09j8 := uint32(in%5B8%5D) %7C uint32(in%5B9%5D)%3C%3C8 %7C uint32(in%5B10%5D)%3C%3C16 %7C uint32(in%5B11%5D)%3C%3C24%0A%09j9 := uint32(in%5B12%5D) %7C uint32(in%5B13%5D)%3C%3C8 %7C uint32(in%5B14%5D)%3C%3C16 %7C uint32(in%5B15%5D)%3C%3C24%0A%09j10 := uint32(c%5B8%5D) %7C uint32(c%5B9%5D)%3C%3C8 %7C uint32(c%5B10%5D)%3C%3C16 %7C uint32(c%5B11%5D)%3C%3C24%0A%09j11 := uint32(k%5B16%5D) %7C uint32(k%5B17%5D)%3C%3C8 %7C uint32(k%5B18%5D)%3C%3C16 %7C uint32(k%5B19%5D)%3C%3C24%0A%09j12 := uint32(k%5B20%5D) %7C uint32(k%5B21%5D)%3C%3C8 %7C uint32(k%5B22%5D)%3C%3C16 %7C uint32(k%5B23%5D)%3C%3C24%0A%09j13 := uint32(k%5B24%5D) %7C uint32(k%5B25%5D)%3C%3C8 %7C uint32(k%5B26%5D)%3C%3C16 %7C uint32(k%5B27%5D)%3C%3C24%0A%09j14 := uint32(k%5B28%5D) %7C uint32(k%5B29%5D)%3C%3C8 %7C uint32(k%5B30%5D)%3C%3C16 %7C uint32(k%5B31%5D)%3C%3C24%0A%09j15 := uint32(c%5B12%5D) %7C uint32(c%5B13%5D)%3C%3C8 %7C uint32(c%5B14%5D)%3C%3C16 %7C uint32(c%5B15%5D)%3C%3C24%0A%0A%09x0, x1, x2, x3, x4, x5, x6, x7, x8 := j0, j1, j2, j3, j4, j5, j6, j7, j8%0A%09x9, x10, x11, x12, x13, x14, x15 := j9, j10, j11, j12, j13, j14, j15%0A%0A%09for i := 0; i %3C rounds; i += 2 %7B%0A%09%09u := x0 + x12%0A%09%09x4 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x4 + x0%0A%09%09x8 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x8 + x4%0A%09%09x12 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x12 + x8%0A%09%09x0 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x5 + x1%0A%09%09x9 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x9 + x5%0A%09%09x13 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x13 + x9%0A%09%09x1 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x1 + x13%0A%09%09x5 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x10 + x6%0A%09%09x14 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x14 + x10%0A%09%09x2 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x2 + x14%0A%09%09x6 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x6 + x2%0A%09%09x10 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x15 + x11%0A%09%09x3 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x3 + x15%0A%09%09x7 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x7 + x3%0A%09%09x11 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x11 + x7%0A%09%09x15 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x0 + x3%0A%09%09x1 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x1 + x0%0A%09%09x2 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x2 + x1%0A%09%09x3 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x3 + x2%0A%09%09x0 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x5 + x4%0A%09%09x6 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x6 + x5%0A%09%09x7 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x7 + x6%0A%09%09x4 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x4 + x7%0A%09%09x5 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x10 + x9%0A%09%09x11 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x11 + x10%0A%09%09x8 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x8 + x11%0A%09%09x9 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x9 + x8%0A%09%09x10 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%0A%09%09u = x15 + x14%0A%09%09x12 %5E= u%3C%3C7 %7C u%3E%3E(32-7)%0A%09%09u = x12 + x15%0A%09%09x13 %5E= u%3C%3C9 %7C u%3E%3E(32-9)%0A%09%09u = x13 + x12%0A%09%09x14 %5E= u%3C%3C13 %7C u%3E%3E(32-13)%0A%09%09u = x14 + x13%0A%09%09x15 %5E= u%3C%3C18 %7C u%3E%3E(32-18)%0A%09%7D%0A%09x0 += j0%0A%09x1 += j1%0A%09x2 += j2%0A%09x3 += j3%0A%09x4 += j4%0A%09x5 += j5%0A%09x6 += j6%0A%09x7 += j7%0A%09x8 += j8%0A%09x9 += j9%0A%09x10 += j10%0A%09x11 += j11%0A%09x12 += j12%0A%09x13 += j13%0A%09x14 += j14%0A%09x15 += j15%0A%0A%09out%5B0%5D = byte(x0)%0A%09out%5B1%5D = byte(x0 %3E%3E 8)%0A%09out%5B2%5D = byte(x0 %3E%3E 16)%0A%09out%5B3%5D = byte(x0 %3E%3E 24)%0A%0A%09out%5B4%5D = byte(x1)%0A%09out%5B5%5D = byte(x1 %3E%3E 8)%0A%09out%5B6%5D = byte(x1 %3E%3E 16)%0A%09out%5B7%5D = byte(x1 %3E%3E 24)%0A%0A%09out%5B8%5D = byte(x2)%0A%09out%5B9%5D = byte(x2 %3E%3E 8)%0A%09out%5B10%5D = byte(x2 %3E%3E 16)%0A%09out%5B11%5D = byte(x2 %3E%3E 24)%0A%0A%09out%5B12%5D = byte(x3)%0A%09out%5B13%5D = byte(x3 %3E%3E 8)%0A%09out%5B14%5D = byte(x3 %3E%3E 16)%0A%09out%5B15%5D = byte(x3 %3E%3E 24)%0A%0A%09out%5B16%5D = byte(x4)%0A%09out%5B17%5D = byte(x4 %3E%3E 8)%0A%09out%5B18%5D = byte(x4 %3E%3E 16)%0A%09out%5B19%5D = byte(x4 %3E%3E 24)%0A%0A%09out%5B20%5D = byte(x5)%0A%09out%5B21%5D = byte(x5 %3E%3E 8)%0A%09out%5B22%5D = byte(x5 %3E%3E 16)%0A%09out%5B23%5D = byte(x5 %3E%3E 24)%0A%0A%09out%5B24%5D = byte(x6)%0A%09out%5B25%5D = byte(x6 %3E%3E 8)%0A%09out%5B26%5D = byte(x6 %3E%3E 16)%0A%09out%5B27%5D = byte(x6 %3E%3E 24)%0A%0A%09out%5B28%5D = byte(x7)%0A%09out%5B29%5D = byte(x7 %3E%3E 8)%0A%09out%5B30%5D = byte(x7 %3E%3E 16)%0A%09out%5B31%5D = byte(x7 %3E%3E 24)%0A%0A%09out%5B32%5D = byte(x8)%0A%09out%5B33%5D = byte(x8 %3E%3E 8)%0A%09out%5B34%5D = byte(x8 %3E%3E 16)%0A%09out%5B35%5D = byte(x8 %3E%3E 24)%0A%0A%09out%5B36%5D = byte(x9)%0A%09out%5B37%5D = byte(x9 %3E%3E 8)%0A%09out%5B38%5D = byte(x9 %3E%3E 16)%0A%09out%5B39%5D = byte(x9 %3E%3E 24)%0A%0A%09out%5B40%5D = byte(x10)%0A%09out%5B41%5D = byte(x10 %3E%3E 8)%0A%09out%5B42%5D = byte(x10 %3E%3E 16)%0A%09out%5B43%5D = byte(x10 %3E%3E 24)%0A%0A%09out%5B44%5D = byte(x11)%0A%09out%5B45%5D = byte(x11 %3E%3E 8)%0A%09out%5B46%5D = byte(x11 %3E%3E 16)%0A%09out%5B47%5D = byte(x11 %3E%3E 24)%0A%0A%09out%5B48%5D = byte(x12)%0A%09out%5B49%5D = byte(x12 %3E%3E 8)%0A%09out%5B50%5D = byte(x12 %3E%3E 16)%0A%09out%5B51%5D = byte(x12 %3E%3E 24)%0A%0A%09out%5B52%5D = byte(x13)%0A%09out%5B53%5D = byte(x13 %3E%3E 8)%0A%09out%5B54%5D = byte(x13 %3E%3E 16)%0A%09out%5B55%5D = byte(x13 %3E%3E 24)%0A%0A%09out%5B56%5D = byte(x14)%0A%09out%5B57%5D = byte(x14 %3E%3E 8)%0A%09out%5B58%5D = byte(x14 %3E%3E 16)%0A%09out%5B59%5D = byte(x14 %3E%3E 24)%0A%0A%09out%5B60%5D = byte(x15)%0A%09out%5B61%5D = byte(x15 %3E%3E 8)%0A%09out%5B62%5D = byte(x15 %3E%3E 16)%0A%09out%5B63%5D = byte(x15 %3E%3E 24)%0A%7D%0A%0A
 // XORKe
- f ae18df5f10874adfc8587bcb2cb9dfd97fbc04e6bacc2283a0b851da68de83ef vendor/golang.org/x/crypto/ssh/terminal/terminal.go
+ f 3747adee7740c61bfc65b275c7acb33735e8fb34e7d9c62317eff1918eca577c vendor/golang.org/x/crypto/ssh/terminal/terminal.go
dmppatch 32
@@ -501,16 +501,490 @@
 byte%0A%7D%0A%0A
+var vt100EscapeCodes = EscapeCodes%7B%0A%09Black:   %5B%5Dbyte%7BkeyEscape, '%5B', '3', '0', 'm'%7D,%0A%09Red:     %5B%5Dbyte%7BkeyEscape, '%5B', '3', '1', 'm'%7D,%0A%09Green:   %5B%5Dbyte%7BkeyEscape, '%5B', '3', '2', 'm'%7D,%0A%09Yellow:  %5B%5Dbyte%7BkeyEscape, '%5B', '3', '3', 'm'%7D,%0A%09Blue:    %5B%5Dbyte%7BkeyEscape, '%5B', '3', '4', 'm'%7D,%0A%09Magenta: %5B%5Dbyte%7BkeyEscape, '%5B', '3', '5', 'm'%7D,%0A%09Cyan:    %5B%5Dbyte%7BkeyEscape, '%5B', '3', '6', 'm'%7D,%0A%09White:   %5B%5Dbyte%7BkeyEscape, '%5B', '3', '7', 'm'%7D,%0A%0A%09Reset: %5B%5Dbyte%7BkeyEscape, '%5B', '0', 'm'%7D,%0A%7D%0A%0A
 // Termi
@@ -3119,24 +3119,522 @@
 g string%0A%7D%0A%0A
+// NewTerminal runs a VT100 terminal on the given ReadWriter. If the ReadWriter is%0A// a local terminal, that terminal must first have been put into raw mode.%0A// prompt is a string that is written at the start of each input line (i.e.%0A// %22%3E %22).%0Afunc NewTerminal(c io.ReadWriter, prompt string) *Terminal %7B%0A%09return &Terminal%7B%0A%09%09Escape:       &vt100EscapeCodes,%0A%09%09c:            c,%0A%09%09prompt:       %5B%5Drune(prompt),%0A%09%09termWidth:    80,%0A%09%09termHeight:   24,%0A%09%09echo:         true,%0A%09%09historyIndex: -1,%0A%09%7D%0A%7D%0A%0A
 const (%0A%09key
@@ -6088,24 +6088,80 @@
 ta))...)%0A%7D%0A%0A
+var eraseUnderCursor = %5B%5Drune%7B' ', keyEscape, '%5B', 'D'%7D%0A
 var space = 
@@ -7360,16 +7360,107 @@
 vement)%0A
+%7D%0A%0Afunc (t *Terminal) clearLineToRight() %7B%0A%09op := %5B%5Drune%7BkeyEscape, '%5B', 'K'%7D%0A%09t.queue(op)%0A
 %7D%0A%0Aconst
@@ -13668,16 +13668,1406 @@
 %5D%0A%09%7D%0A%7D%0A%0A
+// writeWithCRLF writes buf to w but replaces all occurrences of %5Cn with %5Cr%5Cn.%0Afunc writeWithCRLF(w io.Writer, buf %5B%5Dbyte) (n int, err error) %7B%0A%09for len(buf) %3E 0 %7B%0A%09%09i := bytes.IndexByte(buf, '%5Cn')%0A%09%09todo := len(buf)%0A%09%09if i %3E= 0 %7B%0A%09%09%09todo = i%0A%09%09%7D%0A%0A%09%09var nn int%0A%09%09nn, err = w.Write(buf%5B:todo%5D)%0A%09%09n += nn%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09buf = buf%5Btodo:%5D%0A%0A%09%09if i %3E= 0 %7B%0A%09%09%09if _, err = w.Write(crlf); err != nil %7B%0A%09%09%09%09return n, err%0A%09%09%09%7D%0A%09%09%09n++%0A%09%09%09buf = buf%5B1:%5D%0A%09%09%7D%0A%09%7D%0A%0A%09return n, nil%0A%7D%0A%0Afunc (t *Terminal) Write(buf %5B%5Dbyte) (n int, err error) %7B%0A%09t.lock.Lock()%0A%09defer t.lock.Unlock()%0A%0A%09if t.cursorX == 0 && t.cursorY == 0 %7B%0A%09%09// This is the easy case: there's nothing on the screen that we%0A%09%09// have to move out of the way.%0A%09%09return writeWithCRLF(t.c, buf)%0A%09%7D%0A%0A%09// We have a prompt and possibly user input on the screen. We%0A%09// have to clear it first.%0A%09t.move(0 /* up */, 0 /* down */, t.cursorX /* left */, 0 /* right */)%0A%09t.cursorX = 0%0A%09t.clearLineToRight()%0A%0A%09for t.cursorY %3E 0 %7B%0A%09%09t.move(1 /* up */, 0, 0, 0)%0A%09%09t.cursorY--%0A%09%09t.clearLineToRight()%0A%09%7D%0A%0A%09if _, err = t.c.Write(t.outBuf); err != nil %7B%0A%09%09return%0A%09%7D%0A%09t.outBuf = t.outBuf%5B:0%5D%0A%0A%09if n, err = writeWithCRLF(t.c, buf); err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09t.writeLine(t.prompt)%0A%09if t.echo %7B%0A%09%09t.writeLine(t.line)%0A%09%7D%0A%0A%09t.moveCursorToPos(t.pos)%0A%0A%09if _, err = t.c.Write(t.outBuf); err != nil %7B%0A%09%09return%0A%09%7D%0A%09t.outBuf = t.outBuf%5B:0%5D%0A%09return%0A%7D%0A%0A
 // ReadP
@@ -15416,16 +15416,191 @@
 %09return%0A
+%7D%0A%0A// ReadLine returns a line of input from the terminal.%0Afunc (t *Terminal) ReadLine() (line string, err error) %7B%0A%09t.lock.Lock()%0A%09defer t.lock.Unlock()%0A%0A%09return t.readLine()%0A
 %7D%0A%0Afunc 
@@ -17038,16 +17038,2477 @@
 %5D%0A%09%7D%0A%7D%0A%0A
+// SetPrompt sets the prompt to be used when reading subsequent lines.%0Afunc (t *Terminal) SetPrompt(prompt string) %7B%0A%09t.lock.Lock()%0A%09defer t.lock.Unlock()%0A%0A%09t.prompt = %5B%5Drune(prompt)%0A%7D%0A%0Afunc (t *Terminal) clearAndRepaintLinePlusNPrevious(numPrevLines int) %7B%0A%09// Move cursor to column zero at the start of the line.%0A%09t.move(t.cursorY, 0, t.cursorX, 0)%0A%09t.cursorX, t.cursorY = 0, 0%0A%09t.clearLineToRight()%0A%09for t.cursorY %3C numPrevLines %7B%0A%09%09// Move down a line%0A%09%09t.move(0, 1, 0, 0)%0A%09%09t.cursorY++%0A%09%09t.clearLineToRight()%0A%09%7D%0A%09// Move back to beginning.%0A%09t.move(t.cursorY, 0, 0, 0)%0A%09t.cursorX, t.cursorY = 0, 0%0A%0A%09t.queue(t.prompt)%0A%09t.advanceCursor(visualLength(t.prompt))%0A%09t.writeLine(t.line)%0A%09t.moveCursorToPos(t.pos)%0A%7D%0A%0Afunc (t *Terminal) SetSize(width, height int) error %7B%0A%09t.lock.Lock()%0A%09defer t.lock.Unlock()%0A%0A%09if width == 0 %7B%0A%09%09width = 1%0A%09%7D%0A%0A%09oldWidth := t.termWidth%0A%09t.termWidth, t.termHeight = width, height%0A%0A%09switch %7B%0A%09case width == oldWidth:%0A%09%09// If the width didn't change then nothing else needs to be%0A%09%09// done.%0A%09%09return nil%0A%09case len(t.line) == 0 && t.cursorX == 0 && t.cursorY == 0:%0A%09%09// If there is nothing on current line and no prompt printed,%0A%09%09// just do nothing%0A%09%09return nil%0A%09case width %3C oldWidth:%0A%09%09// Some terminals (e.g. xterm) will truncate lines that were%0A%09%09// too long when shinking. Others, (e.g. gnome-terminal) will%0A%09%09// attempt to wrap them. For the former, repainting t.maxLine%0A%09%09// works great, but that behaviour goes badly wrong in the case%0A%09%09// of the latter because they have doubled every full line.%0A%0A%09%09// We assume that we are working on a terminal that wraps lines%0A%09%09// and adjust the cursor position based on every previous line%0A%09%09// wrapping and turning into two. This causes the prompt on%0A%09%09// xterms to move upwards, which isn't great, but it avoids a%0A%09%09// huge mess with gnome-terminal.%0A%09%09if t.cursorX %3E= t.termWidth %7B%0A%09%09%09t.cursorX = t.termWidth - 1%0A%09%09%7D%0A%09%09t.cursorY *= 2%0A%09%09t.clearAndRepaintLinePlusNPrevious(t.maxLine * 2)%0A%09case width %3E oldWidth:%0A%09%09// If the terminal expands then our position calculations will%0A%09%09// be wrong in the future because we think the cursor is%0A%09%09// %7Ct.pos%7C chars into the string, but there will be a gap at%0A%09%09// the end of any wrapped line.%0A%09%09//%0A%09%09// But the position will actually be correct until we move, so%0A%09%09// we can move back to the beginning and repaint everything.%0A%09%09t.clearAndRepaintLinePlusNPrevious(t.maxLine)%0A%09%7D%0A%0A%09_, err := t.c.Write(t.outBuf)%0A%09t.outBuf = t.outBuf%5B:0%5D%0A%09return err%0A%7D%0A%0A
 type pas
@@ -19975,16 +19975,537 @@
 Error%7B%7D%0A
+%0A// SetBracketedPasteMode requests that the terminal bracket paste operations%0A// with markers. Not all terminals support this but, if it is supported, then%0A// enabling this mode will stop any autocomplete callback from running due to%0A// pastes. Additionally, any lines that are completely pasted will be returned%0A// from ReadLine with the error set to ErrPasteIndicator.%0Afunc (t *Terminal) SetBracketedPasteMode(on bool) %7B%0A%09if on %7B%0A%09%09io.WriteString(t.c, %22%5Cx1b%5B?2004h%22)%0A%09%7D else %7B%0A%09%09io.WriteString(t.c, %22%5Cx1b%5B?2004l%22)%0A%09%7D%0A%7D%0A
 %0A// stRi
- f e6267436512841a548d36ef8845d75574d6f7da763a187ab1bbb971df26dac26 vendor/golang.org/x/crypto/ssh/terminal/util.go
+ f 513a5ef9bc1727048280de2f593c881d948c558a8277c883a3bf8e89c2cffc56 vendor/golang.org/x/crypto/ssh/terminal/util.go
dmppatch 8
@@ -638,16 +638,104 @@
 nix%22%0A)%0A%0A
+// State contains the state of a terminal.%0Atype State struct %7B%0A%09termios unix.Termios%0A%7D%0A%0A
 // IsTer
@@ -901,16 +901,1698 @@
  == nil%0A
+%7D%0A%0A// MakeRaw put the terminal connected to the given file descriptor into raw%0A// mode and returns the previous state of the terminal so that it can be%0A// restored.%0Afunc MakeRaw(fd int) (*State, error) %7B%0A%09termios, err := unix.IoctlGetTermios(fd, ioctlReadTermios)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09oldState := State%7Btermios: *termios%7D%0A%0A%09// This attempts to replicate the behaviour documented for cfmakeraw in%0A%09// the termios(3) manpage.%0A%09termios.Iflag &%5E= unix.IGNBRK %7C unix.BRKINT %7C unix.PARMRK %7C unix.ISTRIP %7C unix.INLCR %7C unix.IGNCR %7C unix.ICRNL %7C unix.IXON%0A%09termios.Oflag &%5E= unix.OPOST%0A%09termios.Lflag &%5E= unix.ECHO %7C unix.ECHONL %7C unix.ICANON %7C unix.ISIG %7C unix.IEXTEN%0A%09termios.Cflag &%5E= unix.CSIZE %7C unix.PARENB%0A%09termios.Cflag %7C= unix.CS8%0A%09termios.Cc%5Bunix.VMIN%5D = 1%0A%09termios.Cc%5Bunix.VTIME%5D = 0%0A%09if err := unix.IoctlSetTermios(fd, ioctlWriteTermios, termios); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return &oldState, nil%0A%7D%0A%0A// GetState returns the current state of a terminal which may be useful to%0A// restore the terminal after a signal.%0Afunc GetState(fd int) (*State, error) %7B%0A%09termios, err := unix.IoctlGetTermios(fd, ioctlReadTermios)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return &State%7Btermios: *termios%7D, nil%0A%7D%0A%0A// Restore restores the terminal connected to the given file descriptor to a%0A// previous state.%0Afunc Restore(fd int, state *State) error %7B%0A%09return unix.IoctlSetTermios(fd, ioctlWriteTermios, &state.termios)%0A%7D%0A%0A// GetSize returns the dimensions of the given terminal.%0Afunc GetSize(fd int) (width, height int, err error) %7B%0A%09ws, err := unix.IoctlGetWinsize(fd, unix.TIOCGWINSZ)%0A%09if err != nil %7B%0A%09%09return -1, -1, err%0A%09%7D%0A%09return int(ws.Col), int(ws.Row), nil%0A
 %7D%0A%0A// pa
- f c4b5fe6279a13825af5529fa241e312358a08282c7acb1074aed02d81f94923b vendor/golang.org/x/crypto/ssh/terminal/util_plan9.go
+ f 7aa624ee81675e4bccfcc2267d38492afa6e0a816b62b0a57a9385e5cc0628a3 vendor/golang.org/x/crypto/ssh/terminal/util_plan9.go
dmppatch 8
@@ -518,16 +518,37 @@
 ime%22%0A)%0A%0A
+type State struct%7B%7D%0A%0A
 // IsTer
@@ -655,16 +655,1031 @@
 n false%0A
+%7D%0A%0A// MakeRaw put the terminal connected to the given file descriptor into raw%0A// mode and returns the previous state of the terminal so that it can be%0A// restored.%0Afunc MakeRaw(fd int) (*State, error) %7B%0A%09return nil, fmt.Errorf(%22terminal: MakeRaw not implemented on %25s/%25s%22, runtime.GOOS, runtime.GOARCH)%0A%7D%0A%0A// GetState returns the current state of a terminal which may be useful to%0A// restore the terminal after a signal.%0Afunc GetState(fd int) (*State, error) %7B%0A%09return nil, fmt.Errorf(%22terminal: GetState not implemented on %25s/%25s%22, runtime.GOOS, runtime.GOARCH)%0A%7D%0A%0A// Restore restores the terminal connected to the given file descriptor to a%0A// previous state.%0Afunc Restore(fd int, state *State) error %7B%0A%09return fmt.Errorf(%22terminal: Restore not implemented on %25s/%25s%22, runtime.GOOS, runtime.GOARCH)%0A%7D%0A%0A// GetSize returns the dimensions of the given terminal.%0Afunc GetSize(fd int) (width, height int, err error) %7B%0A%09return 0, 0, fmt.Errorf(%22terminal: GetSize not implemented on %25s/%25s%22, runtime.GOOS, runtime.GOARCH)%0A
 %7D%0A%0A// Re
- f cd284cdd21bc2f51b1d2373aa81e03fe8e52f49b7064a1418314245e671b0556 vendor/golang.org/x/crypto/ssh/terminal/util_solaris.go
+ f 40ad0ee2d8359ce17390a9eeb62cfee0fbced86e06e9a71564dc5f22f4286dda vendor/golang.org/x/crypto/ssh/terminal/util_solaris.go
dmppatch 13
@@ -244,16 +244,41 @@
 mport (%0A
+%09%22golang.org/x/sys/unix%22%0A
 %09%22io%22%0A%09%22
@@ -290,36 +290,98 @@
 ll%22%0A
-%0A%09%22golang.org/x/sys/unix%22%0A
 )%0A
+%0A// State contains the state of a terminal.%0Atype State struct %7B%0A%09termios unix.Termios%0A%7D%0A
 %0A// 
@@ -1605,12 +1605,1628 @@
  ret, nil%0A%7D%0A
+%0A// MakeRaw puts the terminal connected to the given file descriptor into raw%0A// mode and returns the previous state of the terminal so that it can be%0A// restored.%0A// see http://cr.illumos.org/~webrev/andy_js/1060/%0Afunc MakeRaw(fd int) (*State, error) %7B%0A%09termios, err := unix.IoctlGetTermios(fd, unix.TCGETS)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09oldState := State%7Btermios: *termios%7D%0A%0A%09termios.Iflag &%5E= unix.IGNBRK %7C unix.BRKINT %7C unix.PARMRK %7C unix.ISTRIP %7C unix.INLCR %7C unix.IGNCR %7C unix.ICRNL %7C unix.IXON%0A%09termios.Oflag &%5E= unix.OPOST%0A%09termios.Lflag &%5E= unix.ECHO %7C unix.ECHONL %7C unix.ICANON %7C unix.ISIG %7C unix.IEXTEN%0A%09termios.Cflag &%5E= unix.CSIZE %7C unix.PARENB%0A%09termios.Cflag %7C= unix.CS8%0A%09termios.Cc%5Bunix.VMIN%5D = 1%0A%09termios.Cc%5Bunix.VTIME%5D = 0%0A%0A%09if err := unix.IoctlSetTermios(fd, unix.TCSETS, termios); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return &oldState, nil%0A%7D%0A%0A// Restore restores the terminal connected to the given file descriptor to a%0A// previous state.%0Afunc Restore(fd int, oldState *State) error %7B%0A%09return unix.IoctlSetTermios(fd, unix.TCSETS, &oldState.termios)%0A%7D%0A%0A// GetState returns the current state of a terminal which may be useful to%0A// restore the terminal after a signal.%0Afunc GetState(fd int) (*State, error) %7B%0A%09termios, err := unix.IoctlGetTermios(fd, unix.TCGETS)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return &State%7Btermios: *termios%7D, nil%0A%7D%0A%0A// GetSize returns the dimensions of the given terminal.%0Afunc GetSize(fd int) (width, height int, err error) %7B%0A%09ws, err := unix.IoctlGetWinsize(fd, unix.TIOCGWINSZ)%0A%09if err != nil %7B%0A%09%09return 0, 0, err%0A%09%7D%0A%09return int(ws.Col), int(ws.Row), nil%0A%7D%0A
- f b28bfe2c7af717cbb3baa0cea9fb2ec9c83fdbdd82c51bd44c70ea95aabad7e0 vendor/golang.org/x/crypto/ssh/terminal/util_windows.go
+ f ea6477d201bcd31283ea3b6df583534625e96c25eaa18414f20fa059dc306980 vendor/golang.org/x/crypto/ssh/terminal/util_windows.go
dmppatch 8
@@ -554,16 +554,52 @@
 ows%22%0A)%0A%0A
+type State struct %7B%0A%09mode uint32%0A%7D%0A%0A
 // IsTer
@@ -782,16 +782,1393 @@
  == nil%0A
+%7D%0A%0A// MakeRaw put the terminal connected to the given file descriptor into raw%0A// mode and returns the previous state of the terminal so that it can be%0A// restored.%0Afunc MakeRaw(fd int) (*State, error) %7B%0A%09var st uint32%0A%09if err := windows.GetConsoleMode(windows.Handle(fd), &st); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09raw := st &%5E (windows.ENABLE_ECHO_INPUT %7C windows.ENABLE_PROCESSED_INPUT %7C windows.ENABLE_LINE_INPUT %7C windows.ENABLE_PROCESSED_OUTPUT)%0A%09if err := windows.SetConsoleMode(windows.Handle(fd), raw); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &State%7Bst%7D, nil%0A%7D%0A%0A// GetState returns the current state of a terminal which may be useful to%0A// restore the terminal after a signal.%0Afunc GetState(fd int) (*State, error) %7B%0A%09var st uint32%0A%09if err := windows.GetConsoleMode(windows.Handle(fd), &st); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &State%7Bst%7D, nil%0A%7D%0A%0A// Restore restores the terminal connected to the given file descriptor to a%0A// previous state.%0Afunc Restore(fd int, state *State) error %7B%0A%09return windows.SetConsoleMode(windows.Handle(fd), state.mode)%0A%7D%0A%0A// GetSize returns the dimensions of the given terminal.%0Afunc GetSize(fd int) (width, height int, err error) %7B%0A%09var info windows.ConsoleScreenBufferInfo%0A%09if err := windows.GetConsoleScreenBufferInfo(windows.Handle(fd), &info); err != nil %7B%0A%09%09return 0, 0, err%0A%09%7D%0A%09return int(info.Size.X), int(info.Size.Y), nil%0A
 %7D%0A%0A// Re
- f d94f089f80133e7ff1428a9b547ad535048b9a5097befa920550bc705a7f6c22 vendor/golang.org/x/sys/cpu/cpu_gccgo.go
+ f bd5d1935113d1e40748858119b360d742432aac9ecd3c9a0ac79e1e71ddbbd1c vendor/golang.org/x/sys/cpu/cpu_gccgo.go
dmppatch 8
@@ -212,16 +212,120 @@
 ge cpu%0A%0A
+//extern gccgoGetCpuidCount%0Afunc gccgoGetCpuidCount(eaxArg, ecxArg uint32, eax, ebx, ecx, edx *uint32)%0A%0A
 func cpu
@@ -476,16 +476,73 @@
  c, d%0A%7D%0A
+%0A//extern gccgoXgetbv%0Afunc gccgoXgetbv(eax, edx *uint32)%0A
 %0Afunc xg
- f 632f32382f04c4a56968fa45ffd85eef6d40704588f78e9e03c4e44854945b05 vendor/golang.org/x/sys/unix/affinity_linux.go
+ f 430f118c29bb27ee715f7a781876fb4d0f98ad8e8a71d07d4bd6e1bb8aa33f91 vendor/golang.org/x/sys/unix/affinity_linux.go
dmppatch 3
@@ -193,8 +193,3085 @@
 ge unix%0A
+%0Aimport (%0A%09%22unsafe%22%0A)%0A%0Aconst cpuSetSize = _CPU_SETSIZE / _NCPUBITS%0A%0A// CPUSet represents a CPU affinity mask.%0Atype CPUSet %5BcpuSetSize%5DcpuMask%0A%0Afunc schedAffinity(trap uintptr, pid int, set *CPUSet) error %7B%0A%09_, _, e := RawSyscall(trap, uintptr(pid), uintptr(unsafe.Sizeof(*set)), uintptr(unsafe.Pointer(set)))%0A%09if e != 0 %7B%0A%09%09return errnoErr(e)%0A%09%7D%0A%09return nil%0A%7D%0A%0A// SchedGetaffinity gets the CPU affinity mask of the thread specified by pid.%0A// If pid is 0 the calling thread is used.%0Afunc SchedGetaffinity(pid int, set *CPUSet) error %7B%0A%09return schedAffinity(SYS_SCHED_GETAFFINITY, pid, set)%0A%7D%0A%0A// SchedSetaffinity sets the CPU affinity mask of the thread specified by pid.%0A// If pid is 0 the calling thread is used.%0Afunc SchedSetaffinity(pid int, set *CPUSet) error %7B%0A%09return schedAffinity(SYS_SCHED_SETAFFINITY, pid, set)%0A%7D%0A%0A// Zero clears the set s, so that it contains no CPUs.%0Afunc (s *CPUSet) Zero() %7B%0A%09for i := range s %7B%0A%09%09s%5Bi%5D = 0%0A%09%7D%0A%7D%0A%0Afunc cpuBitsIndex(cpu int) int %7B%0A%09return cpu / _NCPUBITS%0A%7D%0A%0Afunc cpuBitsMask(cpu int) cpuMask %7B%0A%09return cpuMask(1 %3C%3C (uint(cpu) %25 _NCPUBITS))%0A%7D%0A%0A// Set adds cpu to the set s.%0Afunc (s *CPUSet) Set(cpu int) %7B%0A%09i := cpuBitsIndex(cpu)%0A%09if i %3C len(s) %7B%0A%09%09s%5Bi%5D %7C= cpuBitsMask(cpu)%0A%09%7D%0A%7D%0A%0A// Clear removes cpu from the set s.%0Afunc (s *CPUSet) Clear(cpu int) %7B%0A%09i := cpuBitsIndex(cpu)%0A%09if i %3C len(s) %7B%0A%09%09s%5Bi%5D &%5E= cpuBitsMask(cpu)%0A%09%7D%0A%7D%0A%0A// IsSet reports whether cpu is in the set s.%0Afunc (s *CPUSet) IsSet(cpu int) bool %7B%0A%09i := cpuBitsIndex(cpu)%0A%09if i %3C len(s) %7B%0A%09%09return s%5Bi%5D&cpuBitsMask(cpu) != 0%0A%09%7D%0A%09return false%0A%7D%0A%0A// Count returns the number of CPUs in the set s.%0Afunc (s *CPUSet) Count() int %7B%0A%09c := 0%0A%09for _, b := range s %7B%0A%09%09c += onesCount64(uint64(b))%0A%09%7D%0A%09return c%0A%7D%0A%0A// onesCount64 is a copy of Go 1.9's math/bits.OnesCount64.%0A// Once this package can require Go 1.9, we can delete this%0A// and update the caller to use bits.OnesCount64.%0Afunc onesCount64(x uint64) int %7B%0A%09const m0 = 0x5555555555555555 // 01010101 ...%0A%09const m1 = 0x3333333333333333 // 00110011 ...%0A%09const m2 = 0x0f0f0f0f0f0f0f0f // 00001111 ...%0A%09const m3 = 0x00ff00ff00ff00ff // etc.%0A%09const m4 = 0x0000ffff0000ffff%0A%0A%09// Implementation: Parallel summing of adjacent bits.%0A%09// See %22Hacker's Delight%22, Chap. 5: Counting Bits.%0A%09// The following pattern shows the general approach:%0A%09//%0A%09//   x = x%3E%3E1&(m0&m) + x&(m0&m)%0A%09//   x = x%3E%3E2&(m1&m) + x&(m1&m)%0A%09//   x = x%3E%3E4&(m2&m) + x&(m2&m)%0A%09//   x = x%3E%3E8&(m3&m) + x&(m3&m)%0A%09//   x = x%3E%3E16&(m4&m) + x&(m4&m)%0A%09//   x = x%3E%3E32&(m5&m) + x&(m5&m)%0A%09//   return int(x)%0A%09//%0A%09// Masking (& operations) can be left away when there's no%0A%09// danger that a field's sum will carry over into the next%0A%09// field: Since the result cannot be %3E 64, 8 bits is enough%0A%09// and we can ignore the masks for the shifts by 8 and up.%0A%09// Per %22Hacker's Delight%22, the first line can be simplified%0A%09// more, but it saves at best one instruction, so we leave%0A%09// it alone for clarity.%0A%09const m = 1%3C%3C64 - 1%0A%09x = x%3E%3E1&(m0&m) + x&(m0&m)%0A%09x = x%3E%3E2&(m1&m) + x&(m1&m)%0A%09x = (x%3E%3E4 + x) & (m2 & m)%0A%09x += x %3E%3E 8%0A%09x += x %3E%3E 16%0A%09x += x %3E%3E 32%0A%09return int(x) & (1%3C%3C7 - 1)%0A%7D%0A
- f fa9a0541bb7261ec1488c613b12934af04e7fe07c759e79d0e0c0d5b21a67349 vendor/golang.org/x/sys/unix/aliases.go
+ f 3269423037681f1aa129d3bc3f2f8e05029fbc98f2929f458ae4053c235b6db5 vendor/golang.org/x/sys/unix/aliases.go
dmppatch 8
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 // +
@@ -251,8 +251,122 @@
 ge unix%0A
+%0Aimport %22syscall%22%0A%0Atype Signal = syscall.Signal%0Atype Errno = syscall.Errno%0Atype SysProcAttr = syscall.SysProcAttr%0A
- f 9a429983fa81f3e25ce3af1d56fcfc9a2f56ee8c8937a9f1859504ac19dae5ac vendor/golang.org/x/sys/unix/bluetooth_linux.go
+ f 78d49e3efc5dddf1c9a7fe0391cd9343d5e9be3d64f2ff73adebb94909c59aee vendor/golang.org/x/sys/unix/bluetooth_linux.go
dmppatch 3
@@ -201,8 +201,455 @@
 ge unix%0A
+%0A// Bluetooth Protocols%0Aconst (%0A%09BTPROTO_L2CAP  = 0%0A%09BTPROTO_HCI    = 1%0A%09BTPROTO_SCO    = 2%0A%09BTPROTO_RFCOMM = 3%0A%09BTPROTO_BNEP   = 4%0A%09BTPROTO_CMTP   = 5%0A%09BTPROTO_HIDP   = 6%0A%09BTPROTO_AVDTP  = 7%0A)%0A%0Aconst (%0A%09HCI_CHANNEL_RAW     = 0%0A%09HCI_CHANNEL_USER    = 1%0A%09HCI_CHANNEL_MONITOR = 2%0A%09HCI_CHANNEL_CONTROL = 3%0A)%0A%0A// Socketoption Level%0Aconst (%0A%09SOL_BLUETOOTH = 0x112%0A%09SOL_HCI       = 0x0%0A%09SOL_L2CAP     = 0x6%0A%09SOL_RFCOMM    = 0x12%0A%09SOL_SCO       = 0x11%0A)%0A
- f 4cdb68b7e38ddb3777810c50c8b8cff28bf70d068e35309fc22774ca37b93bdb vendor/golang.org/x/sys/unix/cap_freebsd.go
+ f fae1a8af18386a11fb86bdb212bd64198fe63209524919d5ddbe560d582a4003 vendor/golang.org/x/sys/unix/cap_freebsd.go
dmppatch 3
@@ -185,8 +185,4946 @@
 ge unix%0A
+%0Aimport (%0A%09%22errors%22%0A%09%22fmt%22%0A)%0A%0A// Go implementation of C mostly found in /usr/src/sys/kern/subr_capability.c%0A%0Aconst (%0A%09// This is the version of CapRights this package understands. See C implementation for parallels.%0A%09capRightsGoVersion = CAP_RIGHTS_VERSION_00%0A%09capArSizeMin       = CAP_RIGHTS_VERSION_00 + 2%0A%09capArSizeMax       = capRightsGoVersion + 2%0A)%0A%0Avar (%0A%09bit2idx = %5B%5Dint%7B%0A%09%09-1, 0, 1, -1, 2, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1,%0A%09%094, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,%0A%09%7D%0A)%0A%0Afunc capidxbit(right uint64) int %7B%0A%09return int((right %3E%3E 57) & 0x1f)%0A%7D%0A%0Afunc rightToIndex(right uint64) (int, error) %7B%0A%09idx := capidxbit(right)%0A%09if idx %3C 0 %7C%7C idx %3E= len(bit2idx) %7B%0A%09%09return -2, fmt.Errorf(%22index for right 0x%25x out of range%22, right)%0A%09%7D%0A%09return bit2idx%5Bidx%5D, nil%0A%7D%0A%0Afunc caprver(right uint64) int %7B%0A%09return int(right %3E%3E 62)%0A%7D%0A%0Afunc capver(rights *CapRights) int %7B%0A%09return caprver(rights.Rights%5B0%5D)%0A%7D%0A%0Afunc caparsize(rights *CapRights) int %7B%0A%09return capver(rights) + 2%0A%7D%0A%0A// CapRightsSet sets the permissions in setrights in rights.%0Afunc CapRightsSet(rights *CapRights, setrights %5B%5Duint64) error %7B%0A%09// This is essentially a copy of cap_rights_vset()%0A%09if capver(rights) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09return fmt.Errorf(%22bad rights version %25d%22, capver(rights))%0A%09%7D%0A%0A%09n := caparsize(rights)%0A%09if n %3C capArSizeMin %7C%7C n %3E capArSizeMax %7B%0A%09%09return errors.New(%22bad rights size%22)%0A%09%7D%0A%0A%09for _, right := range setrights %7B%0A%09%09if caprver(right) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09%09return errors.New(%22bad right version%22)%0A%09%09%7D%0A%09%09i, err := rightToIndex(right)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09if i %3E= n %7B%0A%09%09%09return errors.New(%22index overflow%22)%0A%09%09%7D%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return errors.New(%22index mismatch%22)%0A%09%09%7D%0A%09%09rights.Rights%5Bi%5D %7C= right%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return errors.New(%22index mismatch (after assign)%22)%0A%09%09%7D%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A// CapRightsClear clears the permissions in clearrights from rights.%0Afunc CapRightsClear(rights *CapRights, clearrights %5B%5Duint64) error %7B%0A%09// This is essentially a copy of cap_rights_vclear()%0A%09if capver(rights) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09return fmt.Errorf(%22bad rights version %25d%22, capver(rights))%0A%09%7D%0A%0A%09n := caparsize(rights)%0A%09if n %3C capArSizeMin %7C%7C n %3E capArSizeMax %7B%0A%09%09return errors.New(%22bad rights size%22)%0A%09%7D%0A%0A%09for _, right := range clearrights %7B%0A%09%09if caprver(right) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09%09return errors.New(%22bad right version%22)%0A%09%09%7D%0A%09%09i, err := rightToIndex(right)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09if i %3E= n %7B%0A%09%09%09return errors.New(%22index overflow%22)%0A%09%09%7D%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return errors.New(%22index mismatch%22)%0A%09%09%7D%0A%09%09rights.Rights%5Bi%5D &= %5E(right & 0x01FFFFFFFFFFFFFF)%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return errors.New(%22index mismatch (after assign)%22)%0A%09%09%7D%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A// CapRightsIsSet checks whether all the permissions in setrights are present in rights.%0Afunc CapRightsIsSet(rights *CapRights, setrights %5B%5Duint64) (bool, error) %7B%0A%09// This is essentially a copy of cap_rights_is_vset()%0A%09if capver(rights) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09return false, fmt.Errorf(%22bad rights version %25d%22, capver(rights))%0A%09%7D%0A%0A%09n := caparsize(rights)%0A%09if n %3C capArSizeMin %7C%7C n %3E capArSizeMax %7B%0A%09%09return false, errors.New(%22bad rights size%22)%0A%09%7D%0A%0A%09for _, right := range setrights %7B%0A%09%09if caprver(right) != CAP_RIGHTS_VERSION_00 %7B%0A%09%09%09return false, errors.New(%22bad right version%22)%0A%09%09%7D%0A%09%09i, err := rightToIndex(right)%0A%09%09if err != nil %7B%0A%09%09%09return false, err%0A%09%09%7D%0A%09%09if i %3E= n %7B%0A%09%09%09return false, errors.New(%22index overflow%22)%0A%09%09%7D%0A%09%09if capidxbit(rights.Rights%5Bi%5D) != capidxbit(right) %7B%0A%09%09%09return false, errors.New(%22index mismatch%22)%0A%09%09%7D%0A%09%09if (rights.Rights%5Bi%5D & right) != right %7B%0A%09%09%09return false, nil%0A%09%09%7D%0A%09%7D%0A%0A%09return true, nil%0A%7D%0A%0Afunc capright(idx uint64, bit uint64) uint64 %7B%0A%09return ((1 %3C%3C (57 + idx)) %7C bit)%0A%7D%0A%0A// CapRightsInit returns a pointer to an initialised CapRights structure filled with rights.%0A// See man cap_rights_init(3) and rights(4).%0Afunc CapRightsInit(rights %5B%5Duint64) (*CapRights, error) %7B%0A%09var r CapRights%0A%09r.Rights%5B0%5D = (capRightsGoVersion %3C%3C 62) %7C capright(0, 0)%0A%09r.Rights%5B1%5D = capright(1, 0)%0A%0A%09err := CapRightsSet(&r, rights)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &r, nil%0A%7D%0A%0A// CapRightsLimit reduces the operations permitted on fd to at most those contained in rights.%0A// The capability rights on fd can never be increased by CapRightsLimit.%0A// See man cap_rights_limit(2) and rights(4).%0Afunc CapRightsLimit(fd uintptr, rights *CapRights) error %7B%0A%09return capRightsLimit(int(fd), rights)%0A%7D%0A%0A// CapRightsGet returns a CapRights structure containing the operations permitted on fd.%0A// See man cap_rights_get(3) and rights(4).%0Afunc CapRightsGet(fd uintptr) (*CapRights, error) %7B%0A%09r, err := CapRightsInit(nil)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09err = capRightsGet(capRightsGoVersion, int(fd), r)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return r, nil%0A%7D%0A
- f fc1f821c973ec87ce63f020c8063ce9b67780d5244916bc06a77403cb7c388a5 vendor/golang.org/x/sys/unix/constants.go
+ f a7034e2ae43d6530b8ec28e07d645b918dc747448a1625547c45ae5542cf4f3f vendor/golang.org/x/sys/unix/constants.go
dmppatch 8
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 %0Apac
@@ -235,8 +235,55 @@
 ge unix%0A
+%0Aconst (%0A%09R_OK = 0x4%0A%09W_OK = 0x2%0A%09X_OK = 0x1%0A)%0A
+ f c2923a64bf5bb8c49da291d2f655972d563245d668b7032ea7e09e15e685916f vendor/golang.org/x/sys/unix/dev_aix_ppc.go
dmppatch 2
@@ -0,0 +1,745 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build aix%0A// +build ppc%0A%0A// Functions to access/create device major and minor numbers matching the%0A// encoding used by AIX.%0A%0Apackage unix%0A%0A// Major returns the major component of a Linux device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev %3E%3E 16) & 0xffff)%0A%7D%0A%0A// Minor returns the minor component of a Linux device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32(dev & 0xffff)%0A%7D%0A%0A// Mkdev returns a Linux device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09return uint64(((major) %3C%3C 16) %7C (minor))%0A%7D%0A
+ f 43fdf5e18ae1da43c73807edff6bfd7d8a75b4af05ba7d7796f49c2c06a4eafc vendor/golang.org/x/sys/unix/dev_aix_ppc64.go
dmppatch 2
@@ -0,0 +1,864 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build aix%0A// +build ppc64%0A%0A// Functions to access/create device major and minor numbers matching the%0A// encoding used AIX.%0A%0Apackage unix%0A%0A// Major returns the major component of a Linux device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev & 0x3fffffff00000000) %3E%3E 32)%0A%7D%0A%0A// Minor returns the minor component of a Linux device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32((dev & 0x00000000ffffffff) %3E%3E 0)%0A%7D%0A%0A// Mkdev returns a Linux device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09var DEVNO64 uint64%0A%09DEVNO64 = 0x8000000000000000%0A%09return ((uint64(major) %3C%3C 32) %7C (uint64(minor) & 0x00000000FFFFFFFF) %7C DEVNO64)%0A%7D%0A
- f e8c574e028fff08d3fed91dc5d2856da6f745c7ee3c34486f55cc8a50548b92c vendor/golang.org/x/sys/unix/dev_darwin.go
+ f 9a0bc8af77b4325bb10b651e00b8f7974cc972d0e5456a370f2c46a56181ada7 vendor/golang.org/x/sys/unix/dev_darwin.go
dmppatch 3
@@ -290,8 +290,458 @@
 ge unix%0A
+%0A// Major returns the major component of a Darwin device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev %3E%3E 24) & 0xff)%0A%7D%0A%0A// Minor returns the minor component of a Darwin device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32(dev & 0xffffff)%0A%7D%0A%0A// Mkdev returns a Darwin device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09return (uint64(major) %3C%3C 24) %7C uint64(minor)%0A%7D%0A
- f 528eaf29c5fa7a3c3fd4f62042cc9d476f947ca0c08f67685d7dc1d60cc54081 vendor/golang.org/x/sys/unix/dev_dragonfly.go
+ f 125802ffd01c98daddf86bd57960f51f7dadccb15b530c48e6a24f4f1c697fba vendor/golang.org/x/sys/unix/dev_dragonfly.go
dmppatch 3
@@ -555,8 +555,476 @@
 ge unix%0A
+%0A// Major returns the major component of a DragonFlyBSD device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev %3E%3E 8) & 0xff)%0A%7D%0A%0A// Minor returns the minor component of a DragonFlyBSD device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32(dev & 0xffff00ff)%0A%7D%0A%0A// Mkdev returns a DragonFlyBSD device number generated from the given major and%0A// minor components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09return (uint64(major) %3C%3C 8) %7C uint64(minor)%0A%7D%0A
- f 9ae2273463798970e55edabf57fc7456dbbdfd052ea070bfd7df5c52b236395b vendor/golang.org/x/sys/unix/dev_freebsd.go
+ f c246eb43233fd2e714c85e84407a084da2823d5a64e61313fd393d34589ef0f3 vendor/golang.org/x/sys/unix/dev_freebsd.go
dmppatch 3
@@ -553,8 +553,461 @@
 ge unix%0A
+%0A// Major returns the major component of a FreeBSD device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev %3E%3E 8) & 0xff)%0A%7D%0A%0A// Minor returns the minor component of a FreeBSD device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32(dev & 0xffff00ff)%0A%7D%0A%0A// Mkdev returns a FreeBSD device number generated from the given major and%0A// minor components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09return (uint64(major) %3C%3C 8) %7C uint64(minor)%0A%7D%0A
- f c12d7b6fb0ea50420523167b2e5c4dd1d2cc2be4b6ccb7e3a26f31ed763f1ba7 vendor/golang.org/x/sys/unix/dev_linux.go
+ f eec381cf025f58965728544dae5df9394d6bebc7e68572e429814c87ee6dd284 vendor/golang.org/x/sys/unix/dev_linux.go
dmppatch 3
@@ -825,8 +825,755 @@
 ge unix%0A
+%0A// Major returns the major component of a Linux device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09major := uint32((dev & 0x00000000000fff00) %3E%3E 8)%0A%09major %7C= uint32((dev & 0xfffff00000000000) %3E%3E 32)%0A%09return major%0A%7D%0A%0A// Minor returns the minor component of a Linux device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09minor := uint32((dev & 0x00000000000000ff) %3E%3E 0)%0A%09minor %7C= uint32((dev & 0x00000ffffff00000) %3E%3E 12)%0A%09return minor%0A%7D%0A%0A// Mkdev returns a Linux device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09dev := (uint64(major) & 0x00000fff) %3C%3C 8%0A%09dev %7C= (uint64(major) & 0xfffff000) %3C%3C 32%0A%09dev %7C= (uint64(minor) & 0x000000ff) %3C%3C 0%0A%09dev %7C= (uint64(minor) & 0xffffff00) %3C%3C 12%0A%09return dev%0A%7D%0A
- f 2c5bd95c55012a1200d863c802174d768ec0b962f1f6b88433c1c21517710a69 vendor/golang.org/x/sys/unix/dev_netbsd.go
+ f f712a720bab3f9598c897c45e389c6666998899b963c05892fc2e12179cf1ca4 vendor/golang.org/x/sys/unix/dev_netbsd.go
dmppatch 3
@@ -290,8 +290,624 @@
 ge unix%0A
+%0A// Major returns the major component of a NetBSD device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev & 0x000fff00) %3E%3E 8)%0A%7D%0A%0A// Minor returns the minor component of a NetBSD device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09minor := uint32((dev & 0x000000ff) %3E%3E 0)%0A%09minor %7C= uint32((dev & 0xfff00000) %3E%3E 12)%0A%09return minor%0A%7D%0A%0A// Mkdev returns a NetBSD device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09dev := (uint64(major) %3C%3C 8) & 0x000fff00%0A%09dev %7C= (uint64(minor) %3C%3C 12) & 0xfff00000%0A%09dev %7C= (uint64(minor) %3C%3C 0) & 0x000000ff%0A%09return dev%0A%7D%0A
- f 604b9a30ca60bc163c083846e94a623dd86d9d489668f71d7f034eab1198295b vendor/golang.org/x/sys/unix/dev_openbsd.go
+ f bc0456ed97d8bb58bed6b4b70959e04215d3393596d92b33a7aa515238349dd1 vendor/golang.org/x/sys/unix/dev_openbsd.go
dmppatch 3
@@ -291,8 +291,628 @@
 ge unix%0A
+%0A// Major returns the major component of an OpenBSD device number.%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32((dev & 0x0000ff00) %3E%3E 8)%0A%7D%0A%0A// Minor returns the minor component of an OpenBSD device number.%0Afunc Minor(dev uint64) uint32 %7B%0A%09minor := uint32((dev & 0x000000ff) %3E%3E 0)%0A%09minor %7C= uint32((dev & 0xffff0000) %3E%3E 8)%0A%09return minor%0A%7D%0A%0A// Mkdev returns an OpenBSD device number generated from the given major and minor%0A// components.%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09dev := (uint64(major) %3C%3C 8) & 0x0000ff00%0A%09dev %7C= (uint64(minor) %3C%3C 8) & 0xffff0000%0A%09dev %7C= (uint64(minor) %3C%3C 0) & 0x000000ff%0A%09return dev%0A%7D%0A
- f e24ffc4bf870b889f8d26caa5af4afc1e3c8b7a9db671d66624fe6b24e77c4bb vendor/golang.org/x/sys/unix/dirent.go
+ f e42035994052f717ef4f09fedff3c2e9b3808acb2d356d9612aee8bf50cee84c vendor/golang.org/x/sys/unix/dirent.go
dmppatch 8
@@ -157,77 +157,81 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux nacl netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux nacl netbsd openbsd solaris%0A
 %0Apac
@@ -240,8 +240,385 @@
 ge unix%0A
+%0Aimport %22syscall%22%0A%0A// ParseDirent parses up to max directory entries in buf,%0A// appending the names to names. It returns the number of%0A// bytes consumed from buf, the number of entries added%0A// to names, and the new names slice.%0Afunc ParseDirent(buf %5B%5Dbyte, max int, names %5B%5Dstring) (consumed int, count int, newnames %5B%5Dstring) %7B%0A%09return syscall.ParseDirent(buf, max, names)%0A%7D%0A
- f 37380b50d3e387c70b6449b305e2d786632e569efefc4a18a1e97a877e7130e9 vendor/golang.org/x/sys/unix/endian_big.go
+ f 07489e8cd37eb6bb970f0cd9aff6102417bfe69554ca45974d2ce7d74dd22c2e vendor/golang.org/x/sys/unix/endian_big.go
dmppatch 3
@@ -203,8 +203,34 @@
 ge unix%0A
+%0Aconst isBigEndian = true%0A
- f 14ca932669680f38969d5306f258c2d6cea57bec53bc654f9479dc37eba6d0aa vendor/golang.org/x/sys/unix/endian_little.go
+ f 4e495d33e52ee0a56687e3b5c336e33e11f019ed3af271cb8c11f52662843e7a vendor/golang.org/x/sys/unix/endian_little.go
dmppatch 3
@@ -232,8 +232,35 @@
 ge unix%0A
+%0Aconst isBigEndian = false%0A
- f bce22c907c300bf21cd5f98852d00fce64c1ec1601eb384dd1babcccd9f04073 vendor/golang.org/x/sys/unix/env_unix.go
+ f 37e409c6745f3634ec41dc174c31fe7948c1250cb9bba2586552883a94d3bc41 vendor/golang.org/x/sys/unix/env_unix.go
dmppatch 8
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 %0A// 
@@ -267,8 +267,350 @@
 ge unix%0A
+%0Aimport %22syscall%22%0A%0Afunc Getenv(key string) (value string, found bool) %7B%0A%09return syscall.Getenv(key)%0A%7D%0A%0Afunc Setenv(key, value string) error %7B%0A%09return syscall.Setenv(key, value)%0A%7D%0A%0Afunc Clearenv() %7B%0A%09syscall.Clearenv()%0A%7D%0A%0Afunc Environ() %5B%5Dstring %7B%0A%09return syscall.Environ()%0A%7D%0A%0Afunc Unsetenv(key string) error %7B%0A%09return syscall.Unsetenv(key)%0A%7D%0A
- f 985a567300adc129e0c6665439e37d0c5855d200873d38e38b5429e152c14a40 vendor/golang.org/x/sys/unix/errors_freebsd_386.go
+ f c1fb0bf2e2a804523aa39c08268db83456bc7fac89b0acad0dc7d60647fa7698 vendor/golang.org/x/sys/unix/errors_freebsd_386.go
dmppatch 3
@@ -290,8 +290,9118 @@
 ge unix%0A
+%0Aconst (%0A%09IFF_SMART                         = 0x20%0A%09IFT_1822                          = 0x2%0A%09IFT_A12MPPSWITCH                  = 0x82%0A%09IFT_AAL2                          = 0xbb%0A%09IFT_AAL5                          = 0x31%0A%09IFT_ADSL                          = 0x5e%0A%09IFT_AFLANE8023                    = 0x3b%0A%09IFT_AFLANE8025                    = 0x3c%0A%09IFT_ARAP                          = 0x58%0A%09IFT_ARCNET                        = 0x23%0A%09IFT_ARCNETPLUS                    = 0x24%0A%09IFT_ASYNC                         = 0x54%0A%09IFT_ATM                           = 0x25%0A%09IFT_ATMDXI                        = 0x69%0A%09IFT_ATMFUNI                       = 0x6a%0A%09IFT_ATMIMA                        = 0x6b%0A%09IFT_ATMLOGICAL                    = 0x50%0A%09IFT_ATMRADIO                      = 0xbd%0A%09IFT_ATMSUBINTERFACE               = 0x86%0A%09IFT_ATMVCIENDPT                   = 0xc2%0A%09IFT_ATMVIRTUAL                    = 0x95%0A%09IFT_BGPPOLICYACCOUNTING           = 0xa2%0A%09IFT_BSC                           = 0x53%0A%09IFT_CCTEMUL                       = 0x3d%0A%09IFT_CEPT                          = 0x13%0A%09IFT_CES                           = 0x85%0A%09IFT_CHANNEL                       = 0x46%0A%09IFT_CNR                           = 0x55%0A%09IFT_COFFEE                        = 0x84%0A%09IFT_COMPOSITELINK                 = 0x9b%0A%09IFT_DCN                           = 0x8d%0A%09IFT_DIGITALPOWERLINE              = 0x8a%0A%09IFT_DIGITALWRAPPEROVERHEADCHANNEL = 0xba%0A%09IFT_DLSW                          = 0x4a%0A%09IFT_DOCSCABLEDOWNSTREAM           = 0x80%0A%09IFT_DOCSCABLEMACLAYER             = 0x7f%0A%09IFT_DOCSCABLEUPSTREAM             = 0x81%0A%09IFT_DS0                           = 0x51%0A%09IFT_DS0BUNDLE                     = 0x52%0A%09IFT_DS1FDL                        = 0xaa%0A%09IFT_DS3                           = 0x1e%0A%09IFT_DTM                           = 0x8c%0A%09IFT_DVBASILN                      = 0xac%0A%09IFT_DVBASIOUT                     = 0xad%0A%09IFT_DVBRCCDOWNSTREAM              = 0x93%0A%09IFT_DVBRCCMACLAYER                = 0x92%0A%09IFT_DVBRCCUPSTREAM                = 0x94%0A%09IFT_ENC                           = 0xf4%0A%09IFT_EON                           = 0x19%0A%09IFT_EPLRS                         = 0x57%0A%09IFT_ESCON                         = 0x49%0A%09IFT_ETHER                         = 0x6%0A%09IFT_FAITH                         = 0xf2%0A%09IFT_FAST                          = 0x7d%0A%09IFT_FASTETHER                     = 0x3e%0A%09IFT_FASTETHERFX                   = 0x45%0A%09IFT_FDDI                          = 0xf%0A%09IFT_FIBRECHANNEL                  = 0x38%0A%09IFT_FRAMERELAYINTERCONNECT        = 0x3a%0A%09IFT_FRAMERELAYMPI                 = 0x5c%0A%09IFT_FRDLCIENDPT                   = 0xc1%0A%09IFT_FRELAY                        = 0x20%0A%09IFT_FRELAYDCE                     = 0x2c%0A%09IFT_FRF16MFRBUNDLE                = 0xa3%0A%09IFT_FRFORWARD                     = 0x9e%0A%09IFT_G703AT2MB                     = 0x43%0A%09IFT_G703AT64K                     = 0x42%0A%09IFT_GIF                           = 0xf0%0A%09IFT_GIGABITETHERNET               = 0x75%0A%09IFT_GR303IDT                      = 0xb2%0A%09IFT_GR303RDT                      = 0xb1%0A%09IFT_H323GATEKEEPER                = 0xa4%0A%09IFT_H323PROXY                     = 0xa5%0A%09IFT_HDH1822                       = 0x3%0A%09IFT_HDLC                          = 0x76%0A%09IFT_HDSL2                         = 0xa8%0A%09IFT_HIPERLAN2                     = 0xb7%0A%09IFT_HIPPI                         = 0x2f%0A%09IFT_HIPPIINTERFACE                = 0x39%0A%09IFT_HOSTPAD                       = 0x5a%0A%09IFT_HSSI                          = 0x2e%0A%09IFT_HY                            = 0xe%0A%09IFT_IBM370PARCHAN                 = 0x48%0A%09IFT_IDSL                          = 0x9a%0A%09IFT_IEEE80211                     = 0x47%0A%09IFT_IEEE80212                     = 0x37%0A%09IFT_IEEE8023ADLAG                 = 0xa1%0A%09IFT_IFGSN                         = 0x91%0A%09IFT_IMT                           = 0xbe%0A%09IFT_INTERLEAVE                    = 0x7c%0A%09IFT_IP                            = 0x7e%0A%09IFT_IPFORWARD                     = 0x8e%0A%09IFT_IPOVERATM                     = 0x72%0A%09IFT_IPOVERCDLC                    = 0x6d%0A%09IFT_IPOVERCLAW                    = 0x6e%0A%09IFT_IPSWITCH                      = 0x4e%0A%09IFT_IPXIP                         = 0xf9%0A%09IFT_ISDN                          = 0x3f%0A%09IFT_ISDNBASIC                     = 0x14%0A%09IFT_ISDNPRIMARY                   = 0x15%0A%09IFT_ISDNS                         = 0x4b%0A%09IFT_ISDNU                         = 0x4c%0A%09IFT_ISO88022LLC                   = 0x29%0A%09IFT_ISO88023                      = 0x7%0A%09IFT_ISO88024                      = 0x8%0A%09IFT_ISO88025                      = 0x9%0A%09IFT_ISO88025CRFPINT               = 0x62%0A%09IFT_ISO88025DTR                   = 0x56%0A%09IFT_ISO88025FIBER                 = 0x73%0A%09IFT_ISO88026                      = 0xa%0A%09IFT_ISUP                          = 0xb3%0A%09IFT_L3IPXVLAN                     = 0x89%0A%09IFT_LAPB                          = 0x10%0A%09IFT_LAPD                          = 0x4d%0A%09IFT_LAPF                          = 0x77%0A%09IFT_LOCALTALK                     = 0x2a%0A%09IFT_LOOP                          = 0x18%0A%09IFT_MEDIAMAILOVERIP               = 0x8b%0A%09IFT_MFSIGLINK                     = 0xa7%0A%09IFT_MIOX25                        = 0x26%0A%09IFT_MODEM                         = 0x30%0A%09IFT_MPC                           = 0x71%0A%09IFT_MPLS                          = 0xa6%0A%09IFT_MPLSTUNNEL                    = 0x96%0A%09IFT_MSDSL                         = 0x8f%0A%09IFT_MVL                           = 0xbf%0A%09IFT_MYRINET                       = 0x63%0A%09IFT_NFAS                          = 0xaf%0A%09IFT_NSIP                          = 0x1b%0A%09IFT_OPTICALCHANNEL                = 0xc3%0A%09IFT_OPTICALTRANSPORT              = 0xc4%0A%09IFT_OTHER                         = 0x1%0A%09IFT_P10                           = 0xc%0A%09IFT_P80                           = 0xd%0A%09IFT_PARA                          = 0x22%0A%09IFT_PFLOG                         = 0xf6%0A%09IFT_PFSYNC                        = 0xf7%0A%09IFT_PLC                           = 0xae%0A%09IFT_POS                           = 0xab%0A%09IFT_PPPMULTILINKBUNDLE            = 0x6c%0A%09IFT_PROPBWAP2MP                   = 0xb8%0A%09IFT_PROPCNLS                      = 0x59%0A%09IFT_PROPDOCSWIRELESSDOWNSTREAM    = 0xb5%0A%09IFT_PROPDOCSWIRELESSMACLAYER      = 0xb4%0A%09IFT_PROPDOCSWIRELESSUPSTREAM      = 0xb6%0A%09IFT_PROPMUX                       = 0x36%0A%09IFT_PROPWIRELESSP2P               = 0x9d%0A%09IFT_PTPSERIAL                     = 0x16%0A%09IFT_PVC                           = 0xf1%0A%09IFT_QLLC                          = 0x44%0A%09IFT_RADIOMAC                      = 0xbc%0A%09IFT_RADSL                         = 0x5f%0A%09IFT_REACHDSL                      = 0xc0%0A%09IFT_RFC1483                       = 0x9f%0A%09IFT_RS232                         = 0x21%0A%09IFT_RSRB                          = 0x4f%0A%09IFT_SDLC                          = 0x11%0A%09IFT_SDSL                          = 0x60%0A%09IFT_SHDSL                         = 0xa9%0A%09IFT_SIP                           = 0x1f%0A%09IFT_SLIP                          = 0x1c%0A%09IFT_SMDSDXI                       = 0x2b%0A%09IFT_SMDSICIP                      = 0x34%0A%09IFT_SONET                         = 0x27%0A%09IFT_SONETOVERHEADCHANNEL          = 0xb9%0A%09IFT_SONETPATH                     = 0x32%0A%09IFT_SONETVT                       = 0x33%0A%09IFT_SRP                           = 0x97%0A%09IFT_SS7SIGLINK                    = 0x9c%0A%09IFT_STACKTOSTACK                  = 0x6f%0A%09IFT_STARLAN                       = 0xb%0A%09IFT_STF                           = 0xd7%0A%09IFT_T1                            = 0x12%0A%09IFT_TDLC                          = 0x74%0A%09IFT_TERMPAD                       = 0x5b%0A%09IFT_TR008                         = 0xb0%0A%09IFT_TRANSPHDLC                    = 0x7b%0A%09IFT_TUNNEL                        = 0x83%0A%09IFT_ULTRA                         = 0x1d%0A%09IFT_USB                           = 0xa0%0A%09IFT_V11                           = 0x40%0A%09IFT_V35                           = 0x2d%0A%09IFT_V36                           = 0x41%0A%09IFT_V37                           = 0x78%0A%09IFT_VDSL                          = 0x61%0A%09IFT_VIRTUALIPADDRESS              = 0x70%0A%09IFT_VOICEEM                       = 0x64%0A%09IFT_VOICEENCAP                    = 0x67%0A%09IFT_VOICEFXO                      = 0x65%0A%09IFT_VOICEFXS                      = 0x66%0A%09IFT_VOICEOVERATM                  = 0x98%0A%09IFT_VOICEOVERFRAMERELAY           = 0x99%0A%09IFT_VOICEOVERIP                   = 0x68%0A%09IFT_X213                          = 0x5d%0A%09IFT_X25                           = 0x5%0A%09IFT_X25DDN                        = 0x4%0A%09IFT_X25HUNTGROUP                  = 0x7a%0A%09IFT_X25MLP                        = 0x79%0A%09IFT_X25PLE                        = 0x28%0A%09IFT_XETHER                        = 0x1a%0A%09IPPROTO_MAXID                     = 0x34%0A%09IPV6_FAITH                        = 0x1d%0A%09IP_FAITH                          = 0x16%0A%09MAP_NORESERVE                     = 0x40%0A%09MAP_RENAME                        = 0x20%0A%09NET_RT_MAXID                      = 0x6%0A%09RTF_PRCLONING                     = 0x10000%0A%09RTM_OLDADD                        = 0x9%0A%09RTM_OLDDEL                        = 0xa%0A%09SIOCADDRT                         = 0x8030720a%0A%09SIOCALIFADDR                      = 0x8118691b%0A%09SIOCDELRT                         = 0x8030720b%0A%09SIOCDLIFADDR                      = 0x8118691d%0A%09SIOCGLIFADDR                      = 0xc118691c%0A%09SIOCGLIFPHYADDR                   = 0xc118694b%0A%09SIOCSLIFPHYADDR                   = 0x8118694a%0A)%0A
- f 985a567300adc129e0c6665439e37d0c5855d200873d38e38b5429e152c14a40 vendor/golang.org/x/sys/unix/errors_freebsd_amd64.go
+ f de71ca04c23dc02b252f1adda6dd9104f326f74dbbb3fb014b67ce68fc8f1fb8 vendor/golang.org/x/sys/unix/errors_freebsd_amd64.go
dmppatch 3
@@ -290,8 +290,9118 @@
 ge unix%0A
+%0Aconst (%0A%09IFF_SMART                         = 0x20%0A%09IFT_1822                          = 0x2%0A%09IFT_A12MPPSWITCH                  = 0x82%0A%09IFT_AAL2                          = 0xbb%0A%09IFT_AAL5                          = 0x31%0A%09IFT_ADSL                          = 0x5e%0A%09IFT_AFLANE8023                    = 0x3b%0A%09IFT_AFLANE8025                    = 0x3c%0A%09IFT_ARAP                          = 0x58%0A%09IFT_ARCNET                        = 0x23%0A%09IFT_ARCNETPLUS                    = 0x24%0A%09IFT_ASYNC                         = 0x54%0A%09IFT_ATM                           = 0x25%0A%09IFT_ATMDXI                        = 0x69%0A%09IFT_ATMFUNI                       = 0x6a%0A%09IFT_ATMIMA                        = 0x6b%0A%09IFT_ATMLOGICAL                    = 0x50%0A%09IFT_ATMRADIO                      = 0xbd%0A%09IFT_ATMSUBINTERFACE               = 0x86%0A%09IFT_ATMVCIENDPT                   = 0xc2%0A%09IFT_ATMVIRTUAL                    = 0x95%0A%09IFT_BGPPOLICYACCOUNTING           = 0xa2%0A%09IFT_BSC                           = 0x53%0A%09IFT_CCTEMUL                       = 0x3d%0A%09IFT_CEPT                          = 0x13%0A%09IFT_CES                           = 0x85%0A%09IFT_CHANNEL                       = 0x46%0A%09IFT_CNR                           = 0x55%0A%09IFT_COFFEE                        = 0x84%0A%09IFT_COMPOSITELINK                 = 0x9b%0A%09IFT_DCN                           = 0x8d%0A%09IFT_DIGITALPOWERLINE              = 0x8a%0A%09IFT_DIGITALWRAPPEROVERHEADCHANNEL = 0xba%0A%09IFT_DLSW                          = 0x4a%0A%09IFT_DOCSCABLEDOWNSTREAM           = 0x80%0A%09IFT_DOCSCABLEMACLAYER             = 0x7f%0A%09IFT_DOCSCABLEUPSTREAM             = 0x81%0A%09IFT_DS0                           = 0x51%0A%09IFT_DS0BUNDLE                     = 0x52%0A%09IFT_DS1FDL                        = 0xaa%0A%09IFT_DS3                           = 0x1e%0A%09IFT_DTM                           = 0x8c%0A%09IFT_DVBASILN                      = 0xac%0A%09IFT_DVBASIOUT                     = 0xad%0A%09IFT_DVBRCCDOWNSTREAM              = 0x93%0A%09IFT_DVBRCCMACLAYER                = 0x92%0A%09IFT_DVBRCCUPSTREAM                = 0x94%0A%09IFT_ENC                           = 0xf4%0A%09IFT_EON                           = 0x19%0A%09IFT_EPLRS                         = 0x57%0A%09IFT_ESCON                         = 0x49%0A%09IFT_ETHER                         = 0x6%0A%09IFT_FAITH                         = 0xf2%0A%09IFT_FAST                          = 0x7d%0A%09IFT_FASTETHER                     = 0x3e%0A%09IFT_FASTETHERFX                   = 0x45%0A%09IFT_FDDI                          = 0xf%0A%09IFT_FIBRECHANNEL                  = 0x38%0A%09IFT_FRAMERELAYINTERCONNECT        = 0x3a%0A%09IFT_FRAMERELAYMPI                 = 0x5c%0A%09IFT_FRDLCIENDPT                   = 0xc1%0A%09IFT_FRELAY                        = 0x20%0A%09IFT_FRELAYDCE                     = 0x2c%0A%09IFT_FRF16MFRBUNDLE                = 0xa3%0A%09IFT_FRFORWARD                     = 0x9e%0A%09IFT_G703AT2MB                     = 0x43%0A%09IFT_G703AT64K                     = 0x42%0A%09IFT_GIF                           = 0xf0%0A%09IFT_GIGABITETHERNET               = 0x75%0A%09IFT_GR303IDT                      = 0xb2%0A%09IFT_GR303RDT                      = 0xb1%0A%09IFT_H323GATEKEEPER                = 0xa4%0A%09IFT_H323PROXY                     = 0xa5%0A%09IFT_HDH1822                       = 0x3%0A%09IFT_HDLC                          = 0x76%0A%09IFT_HDSL2                         = 0xa8%0A%09IFT_HIPERLAN2                     = 0xb7%0A%09IFT_HIPPI                         = 0x2f%0A%09IFT_HIPPIINTERFACE                = 0x39%0A%09IFT_HOSTPAD                       = 0x5a%0A%09IFT_HSSI                          = 0x2e%0A%09IFT_HY                            = 0xe%0A%09IFT_IBM370PARCHAN                 = 0x48%0A%09IFT_IDSL                          = 0x9a%0A%09IFT_IEEE80211                     = 0x47%0A%09IFT_IEEE80212                     = 0x37%0A%09IFT_IEEE8023ADLAG                 = 0xa1%0A%09IFT_IFGSN                         = 0x91%0A%09IFT_IMT                           = 0xbe%0A%09IFT_INTERLEAVE                    = 0x7c%0A%09IFT_IP                            = 0x7e%0A%09IFT_IPFORWARD                     = 0x8e%0A%09IFT_IPOVERATM                     = 0x72%0A%09IFT_IPOVERCDLC                    = 0x6d%0A%09IFT_IPOVERCLAW                    = 0x6e%0A%09IFT_IPSWITCH                      = 0x4e%0A%09IFT_IPXIP                         = 0xf9%0A%09IFT_ISDN                          = 0x3f%0A%09IFT_ISDNBASIC                     = 0x14%0A%09IFT_ISDNPRIMARY                   = 0x15%0A%09IFT_ISDNS                         = 0x4b%0A%09IFT_ISDNU                         = 0x4c%0A%09IFT_ISO88022LLC                   = 0x29%0A%09IFT_ISO88023                      = 0x7%0A%09IFT_ISO88024                      = 0x8%0A%09IFT_ISO88025                      = 0x9%0A%09IFT_ISO88025CRFPINT               = 0x62%0A%09IFT_ISO88025DTR                   = 0x56%0A%09IFT_ISO88025FIBER                 = 0x73%0A%09IFT_ISO88026                      = 0xa%0A%09IFT_ISUP                          = 0xb3%0A%09IFT_L3IPXVLAN                     = 0x89%0A%09IFT_LAPB                          = 0x10%0A%09IFT_LAPD                          = 0x4d%0A%09IFT_LAPF                          = 0x77%0A%09IFT_LOCALTALK                     = 0x2a%0A%09IFT_LOOP                          = 0x18%0A%09IFT_MEDIAMAILOVERIP               = 0x8b%0A%09IFT_MFSIGLINK                     = 0xa7%0A%09IFT_MIOX25                        = 0x26%0A%09IFT_MODEM                         = 0x30%0A%09IFT_MPC                           = 0x71%0A%09IFT_MPLS                          = 0xa6%0A%09IFT_MPLSTUNNEL                    = 0x96%0A%09IFT_MSDSL                         = 0x8f%0A%09IFT_MVL                           = 0xbf%0A%09IFT_MYRINET                       = 0x63%0A%09IFT_NFAS                          = 0xaf%0A%09IFT_NSIP                          = 0x1b%0A%09IFT_OPTICALCHANNEL                = 0xc3%0A%09IFT_OPTICALTRANSPORT              = 0xc4%0A%09IFT_OTHER                         = 0x1%0A%09IFT_P10                           = 0xc%0A%09IFT_P80                           = 0xd%0A%09IFT_PARA                          = 0x22%0A%09IFT_PFLOG                         = 0xf6%0A%09IFT_PFSYNC                        = 0xf7%0A%09IFT_PLC                           = 0xae%0A%09IFT_POS                           = 0xab%0A%09IFT_PPPMULTILINKBUNDLE            = 0x6c%0A%09IFT_PROPBWAP2MP                   = 0xb8%0A%09IFT_PROPCNLS                      = 0x59%0A%09IFT_PROPDOCSWIRELESSDOWNSTREAM    = 0xb5%0A%09IFT_PROPDOCSWIRELESSMACLAYER      = 0xb4%0A%09IFT_PROPDOCSWIRELESSUPSTREAM      = 0xb6%0A%09IFT_PROPMUX                       = 0x36%0A%09IFT_PROPWIRELESSP2P               = 0x9d%0A%09IFT_PTPSERIAL                     = 0x16%0A%09IFT_PVC                           = 0xf1%0A%09IFT_QLLC                          = 0x44%0A%09IFT_RADIOMAC                      = 0xbc%0A%09IFT_RADSL                         = 0x5f%0A%09IFT_REACHDSL                      = 0xc0%0A%09IFT_RFC1483                       = 0x9f%0A%09IFT_RS232                         = 0x21%0A%09IFT_RSRB                          = 0x4f%0A%09IFT_SDLC                          = 0x11%0A%09IFT_SDSL                          = 0x60%0A%09IFT_SHDSL                         = 0xa9%0A%09IFT_SIP                           = 0x1f%0A%09IFT_SLIP                          = 0x1c%0A%09IFT_SMDSDXI                       = 0x2b%0A%09IFT_SMDSICIP                      = 0x34%0A%09IFT_SONET                         = 0x27%0A%09IFT_SONETOVERHEADCHANNEL          = 0xb9%0A%09IFT_SONETPATH                     = 0x32%0A%09IFT_SONETVT                       = 0x33%0A%09IFT_SRP                           = 0x97%0A%09IFT_SS7SIGLINK                    = 0x9c%0A%09IFT_STACKTOSTACK                  = 0x6f%0A%09IFT_STARLAN                       = 0xb%0A%09IFT_STF                           = 0xd7%0A%09IFT_T1                            = 0x12%0A%09IFT_TDLC                          = 0x74%0A%09IFT_TERMPAD                       = 0x5b%0A%09IFT_TR008                         = 0xb0%0A%09IFT_TRANSPHDLC                    = 0x7b%0A%09IFT_TUNNEL                        = 0x83%0A%09IFT_ULTRA                         = 0x1d%0A%09IFT_USB                           = 0xa0%0A%09IFT_V11                           = 0x40%0A%09IFT_V35                           = 0x2d%0A%09IFT_V36                           = 0x41%0A%09IFT_V37                           = 0x78%0A%09IFT_VDSL                          = 0x61%0A%09IFT_VIRTUALIPADDRESS              = 0x70%0A%09IFT_VOICEEM                       = 0x64%0A%09IFT_VOICEENCAP                    = 0x67%0A%09IFT_VOICEFXO                      = 0x65%0A%09IFT_VOICEFXS                      = 0x66%0A%09IFT_VOICEOVERATM                  = 0x98%0A%09IFT_VOICEOVERFRAMERELAY           = 0x99%0A%09IFT_VOICEOVERIP                   = 0x68%0A%09IFT_X213                          = 0x5d%0A%09IFT_X25                           = 0x5%0A%09IFT_X25DDN                        = 0x4%0A%09IFT_X25HUNTGROUP                  = 0x7a%0A%09IFT_X25MLP                        = 0x79%0A%09IFT_X25PLE                        = 0x28%0A%09IFT_XETHER                        = 0x1a%0A%09IPPROTO_MAXID                     = 0x34%0A%09IPV6_FAITH                        = 0x1d%0A%09IP_FAITH                          = 0x16%0A%09MAP_NORESERVE                     = 0x40%0A%09MAP_RENAME                        = 0x20%0A%09NET_RT_MAXID                      = 0x6%0A%09RTF_PRCLONING                     = 0x10000%0A%09RTM_OLDADD                        = 0x9%0A%09RTM_OLDDEL                        = 0xa%0A%09SIOCADDRT                         = 0x8040720a%0A%09SIOCALIFADDR                      = 0x8118691b%0A%09SIOCDELRT                         = 0x8040720b%0A%09SIOCDLIFADDR                      = 0x8118691d%0A%09SIOCGLIFADDR                      = 0xc118691c%0A%09SIOCGLIFPHYADDR                   = 0xc118694b%0A%09SIOCSLIFPHYADDR                   = 0x8118694a%0A)%0A
- f 0f842d7683103c125db1d1d7372a7bbcf00277f3e85a4b209273ccc3834835d7 vendor/golang.org/x/sys/unix/errors_freebsd_arm.go
+ f 06b313cc0ecad484868d8d940a6a2b50ae5bc122f2907fa5cd9bba44e27382fb vendor/golang.org/x/sys/unix/errors_freebsd_arm.go
dmppatch 3
@@ -166,8 +166,8872 @@
 ge unix%0A
+%0Aconst (%0A%09IFT_1822                          = 0x2%0A%09IFT_A12MPPSWITCH                  = 0x82%0A%09IFT_AAL2                          = 0xbb%0A%09IFT_AAL5                          = 0x31%0A%09IFT_ADSL                          = 0x5e%0A%09IFT_AFLANE8023                    = 0x3b%0A%09IFT_AFLANE8025                    = 0x3c%0A%09IFT_ARAP                          = 0x58%0A%09IFT_ARCNET                        = 0x23%0A%09IFT_ARCNETPLUS                    = 0x24%0A%09IFT_ASYNC                         = 0x54%0A%09IFT_ATM                           = 0x25%0A%09IFT_ATMDXI                        = 0x69%0A%09IFT_ATMFUNI                       = 0x6a%0A%09IFT_ATMIMA                        = 0x6b%0A%09IFT_ATMLOGICAL                    = 0x50%0A%09IFT_ATMRADIO                      = 0xbd%0A%09IFT_ATMSUBINTERFACE               = 0x86%0A%09IFT_ATMVCIENDPT                   = 0xc2%0A%09IFT_ATMVIRTUAL                    = 0x95%0A%09IFT_BGPPOLICYACCOUNTING           = 0xa2%0A%09IFT_BSC                           = 0x53%0A%09IFT_CCTEMUL                       = 0x3d%0A%09IFT_CEPT                          = 0x13%0A%09IFT_CES                           = 0x85%0A%09IFT_CHANNEL                       = 0x46%0A%09IFT_CNR                           = 0x55%0A%09IFT_COFFEE                        = 0x84%0A%09IFT_COMPOSITELINK                 = 0x9b%0A%09IFT_DCN                           = 0x8d%0A%09IFT_DIGITALPOWERLINE              = 0x8a%0A%09IFT_DIGITALWRAPPEROVERHEADCHANNEL = 0xba%0A%09IFT_DLSW                          = 0x4a%0A%09IFT_DOCSCABLEDOWNSTREAM           = 0x80%0A%09IFT_DOCSCABLEMACLAYER             = 0x7f%0A%09IFT_DOCSCABLEUPSTREAM             = 0x81%0A%09IFT_DS0                           = 0x51%0A%09IFT_DS0BUNDLE                     = 0x52%0A%09IFT_DS1FDL                        = 0xaa%0A%09IFT_DS3                           = 0x1e%0A%09IFT_DTM                           = 0x8c%0A%09IFT_DVBASILN                      = 0xac%0A%09IFT_DVBASIOUT                     = 0xad%0A%09IFT_DVBRCCDOWNSTREAM              = 0x93%0A%09IFT_DVBRCCMACLAYER                = 0x92%0A%09IFT_DVBRCCUPSTREAM                = 0x94%0A%09IFT_ENC                           = 0xf4%0A%09IFT_EON                           = 0x19%0A%09IFT_EPLRS                         = 0x57%0A%09IFT_ESCON                         = 0x49%0A%09IFT_ETHER                         = 0x6%0A%09IFT_FAST                          = 0x7d%0A%09IFT_FASTETHER                     = 0x3e%0A%09IFT_FASTETHERFX                   = 0x45%0A%09IFT_FDDI                          = 0xf%0A%09IFT_FIBRECHANNEL                  = 0x38%0A%09IFT_FRAMERELAYINTERCONNECT        = 0x3a%0A%09IFT_FRAMERELAYMPI                 = 0x5c%0A%09IFT_FRDLCIENDPT                   = 0xc1%0A%09IFT_FRELAY                        = 0x20%0A%09IFT_FRELAYDCE                     = 0x2c%0A%09IFT_FRF16MFRBUNDLE                = 0xa3%0A%09IFT_FRFORWARD                     = 0x9e%0A%09IFT_G703AT2MB                     = 0x43%0A%09IFT_G703AT64K                     = 0x42%0A%09IFT_GIF                           = 0xf0%0A%09IFT_GIGABITETHERNET               = 0x75%0A%09IFT_GR303IDT                      = 0xb2%0A%09IFT_GR303RDT                      = 0xb1%0A%09IFT_H323GATEKEEPER                = 0xa4%0A%09IFT_H323PROXY                     = 0xa5%0A%09IFT_HDH1822                       = 0x3%0A%09IFT_HDLC                          = 0x76%0A%09IFT_HDSL2                         = 0xa8%0A%09IFT_HIPERLAN2                     = 0xb7%0A%09IFT_HIPPI                         = 0x2f%0A%09IFT_HIPPIINTERFACE                = 0x39%0A%09IFT_HOSTPAD                       = 0x5a%0A%09IFT_HSSI                          = 0x2e%0A%09IFT_HY                            = 0xe%0A%09IFT_IBM370PARCHAN                 = 0x48%0A%09IFT_IDSL                          = 0x9a%0A%09IFT_IEEE80211                     = 0x47%0A%09IFT_IEEE80212                     = 0x37%0A%09IFT_IEEE8023ADLAG                 = 0xa1%0A%09IFT_IFGSN                         = 0x91%0A%09IFT_IMT                           = 0xbe%0A%09IFT_INTERLEAVE                    = 0x7c%0A%09IFT_IP                            = 0x7e%0A%09IFT_IPFORWARD                     = 0x8e%0A%09IFT_IPOVERATM                     = 0x72%0A%09IFT_IPOVERCDLC                    = 0x6d%0A%09IFT_IPOVERCLAW                    = 0x6e%0A%09IFT_IPSWITCH                      = 0x4e%0A%09IFT_ISDN                          = 0x3f%0A%09IFT_ISDNBASIC                     = 0x14%0A%09IFT_ISDNPRIMARY                   = 0x15%0A%09IFT_ISDNS                         = 0x4b%0A%09IFT_ISDNU                         = 0x4c%0A%09IFT_ISO88022LLC                   = 0x29%0A%09IFT_ISO88023                      = 0x7%0A%09IFT_ISO88024                      = 0x8%0A%09IFT_ISO88025                      = 0x9%0A%09IFT_ISO88025CRFPINT               = 0x62%0A%09IFT_ISO88025DTR                   = 0x56%0A%09IFT_ISO88025FIBER                 = 0x73%0A%09IFT_ISO88026                      = 0xa%0A%09IFT_ISUP                          = 0xb3%0A%09IFT_L3IPXVLAN                     = 0x89%0A%09IFT_LAPB                          = 0x10%0A%09IFT_LAPD                          = 0x4d%0A%09IFT_LAPF                          = 0x77%0A%09IFT_LOCALTALK                     = 0x2a%0A%09IFT_LOOP                          = 0x18%0A%09IFT_MEDIAMAILOVERIP               = 0x8b%0A%09IFT_MFSIGLINK                     = 0xa7%0A%09IFT_MIOX25                        = 0x26%0A%09IFT_MODEM                         = 0x30%0A%09IFT_MPC                           = 0x71%0A%09IFT_MPLS                          = 0xa6%0A%09IFT_MPLSTUNNEL                    = 0x96%0A%09IFT_MSDSL                         = 0x8f%0A%09IFT_MVL                           = 0xbf%0A%09IFT_MYRINET                       = 0x63%0A%09IFT_NFAS                          = 0xaf%0A%09IFT_NSIP                          = 0x1b%0A%09IFT_OPTICALCHANNEL                = 0xc3%0A%09IFT_OPTICALTRANSPORT              = 0xc4%0A%09IFT_OTHER                         = 0x1%0A%09IFT_P10                           = 0xc%0A%09IFT_P80                           = 0xd%0A%09IFT_PARA                          = 0x22%0A%09IFT_PFLOG                         = 0xf6%0A%09IFT_PFSYNC                        = 0xf7%0A%09IFT_PLC                           = 0xae%0A%09IFT_POS                           = 0xab%0A%09IFT_PPPMULTILINKBUNDLE            = 0x6c%0A%09IFT_PROPBWAP2MP                   = 0xb8%0A%09IFT_PROPCNLS                      = 0x59%0A%09IFT_PROPDOCSWIRELESSDOWNSTREAM    = 0xb5%0A%09IFT_PROPDOCSWIRELESSMACLAYER      = 0xb4%0A%09IFT_PROPDOCSWIRELESSUPSTREAM      = 0xb6%0A%09IFT_PROPMUX                       = 0x36%0A%09IFT_PROPWIRELESSP2P               = 0x9d%0A%09IFT_PTPSERIAL                     = 0x16%0A%09IFT_PVC                           = 0xf1%0A%09IFT_QLLC                          = 0x44%0A%09IFT_RADIOMAC                      = 0xbc%0A%09IFT_RADSL                         = 0x5f%0A%09IFT_REACHDSL                      = 0xc0%0A%09IFT_RFC1483                       = 0x9f%0A%09IFT_RS232                         = 0x21%0A%09IFT_RSRB                          = 0x4f%0A%09IFT_SDLC                          = 0x11%0A%09IFT_SDSL                          = 0x60%0A%09IFT_SHDSL                         = 0xa9%0A%09IFT_SIP                           = 0x1f%0A%09IFT_SLIP                          = 0x1c%0A%09IFT_SMDSDXI                       = 0x2b%0A%09IFT_SMDSICIP                      = 0x34%0A%09IFT_SONET                         = 0x27%0A%09IFT_SONETOVERHEADCHANNEL          = 0xb9%0A%09IFT_SONETPATH                     = 0x32%0A%09IFT_SONETVT                       = 0x33%0A%09IFT_SRP                           = 0x97%0A%09IFT_SS7SIGLINK                    = 0x9c%0A%09IFT_STACKTOSTACK                  = 0x6f%0A%09IFT_STARLAN                       = 0xb%0A%09IFT_STF                           = 0xd7%0A%09IFT_T1                            = 0x12%0A%09IFT_TDLC                          = 0x74%0A%09IFT_TERMPAD                       = 0x5b%0A%09IFT_TR008                         = 0xb0%0A%09IFT_TRANSPHDLC                    = 0x7b%0A%09IFT_TUNNEL                        = 0x83%0A%09IFT_ULTRA                         = 0x1d%0A%09IFT_USB                           = 0xa0%0A%09IFT_V11                           = 0x40%0A%09IFT_V35                           = 0x2d%0A%09IFT_V36                           = 0x41%0A%09IFT_V37                           = 0x78%0A%09IFT_VDSL                          = 0x61%0A%09IFT_VIRTUALIPADDRESS              = 0x70%0A%09IFT_VOICEEM                       = 0x64%0A%09IFT_VOICEENCAP                    = 0x67%0A%09IFT_VOICEFXO                      = 0x65%0A%09IFT_VOICEFXS                      = 0x66%0A%09IFT_VOICEOVERATM                  = 0x98%0A%09IFT_VOICEOVERFRAMERELAY           = 0x99%0A%09IFT_VOICEOVERIP                   = 0x68%0A%09IFT_X213                          = 0x5d%0A%09IFT_X25                           = 0x5%0A%09IFT_X25DDN                        = 0x4%0A%09IFT_X25HUNTGROUP                  = 0x7a%0A%09IFT_X25MLP                        = 0x79%0A%09IFT_X25PLE                        = 0x28%0A%09IFT_XETHER                        = 0x1a%0A%0A%09// missing constants on FreeBSD-11.1-RELEASE, copied from old values in ztypes_freebsd_arm.go%0A%09IFF_SMART       = 0x20%0A%09IFT_FAITH       = 0xf2%0A%09IFT_IPXIP       = 0xf9%0A%09IPPROTO_MAXID   = 0x34%0A%09IPV6_FAITH      = 0x1d%0A%09IP_FAITH        = 0x16%0A%09MAP_NORESERVE   = 0x40%0A%09MAP_RENAME      = 0x20%0A%09NET_RT_MAXID    = 0x6%0A%09RTF_PRCLONING   = 0x10000%0A%09RTM_OLDADD      = 0x9%0A%09RTM_OLDDEL      = 0xa%0A%09SIOCADDRT       = 0x8030720a%0A%09SIOCALIFADDR    = 0x8118691b%0A%09SIOCDELRT       = 0x8030720b%0A%09SIOCDLIFADDR    = 0x8118691d%0A%09SIOCGLIFADDR    = 0xc118691c%0A%09SIOCGLIFPHYADDR = 0xc118694b%0A%09SIOCSLIFPHYADDR = 0x8118694a%0A)%0A
- f 7ca4758ccd5fe2f1fd39249cbe8ce35d0086857d9082fac5b79f3a44e141d1f9 vendor/golang.org/x/sys/unix/fcntl.go
+ f ff2a8ab3892f86e784b06da3b73e243e79e2e2d8ae863486cf990b16bb1be189 vendor/golang.org/x/sys/unix/fcntl.go
dmppatch 3
@@ -223,8 +223,765 @@
 ge unix%0A
+%0Aimport %22unsafe%22%0A%0A// fcntl64Syscall is usually SYS_FCNTL, but is overridden on 32-bit Linux%0A// systems by flock_linux_32bit.go to be SYS_FCNTL64.%0Avar fcntl64Syscall uintptr = SYS_FCNTL%0A%0A// FcntlInt performs a fcntl syscall on fd with the provided command and argument.%0Afunc FcntlInt(fd uintptr, cmd, arg int) (int, error) %7B%0A%09valptr, _, errno := Syscall(fcntl64Syscall, fd, uintptr(cmd), uintptr(arg))%0A%09var err error%0A%09if errno != 0 %7B%0A%09%09err = errno%0A%09%7D%0A%09return int(valptr), err%0A%7D%0A%0A// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.%0Afunc FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error %7B%0A%09_, _, errno := Syscall(fcntl64Syscall, fd, uintptr(cmd), uintptr(unsafe.Pointer(lk)))%0A%09if errno == 0 %7B%0A%09%09return nil%0A%09%7D%0A%09return errno%0A%7D%0A
- f 5bb3a51468ee90f80dcbe339093f2b9cd74db146efdbe4a36a6f224935547807 vendor/golang.org/x/sys/unix/gccgo.go
+ f ecc5184d887471f6d3d3e57badb21e007c7a7ffe63a6d5f806ad2157c9b921bf vendor/golang.org/x/sys/unix/gccgo.go
dmppatch 11
@@ -169,16 +169,31 @@
 d gccgo%0A
+// +build !aix%0A
 %0Apackage
@@ -217,16 +217,566 @@
 scall%22%0A%0A
+// We can't use the gc-syntax .s files for gccgo. On the plus side%0A// much of the functionality can be written directly in Go.%0A%0A//extern gccgoRealSyscallNoError%0Afunc realSyscallNoError(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r uintptr)%0A%0A//extern gccgoRealSyscall%0Afunc realSyscall(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r, errno uintptr)%0A%0Afunc SyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr) %7B%0A%09syscall.Entersyscall()%0A%09r := realSyscallNoError(trap, a1, a2, a3, 0, 0, 0, 0, 0, 0)%0A%09syscall.Exitsyscall()%0A%09return r, 0%0A%7D%0A%0A
 func Sys
@@ -989,8 +989,1020 @@
 rrno)%0A%7D%0A
+%0Afunc Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno) %7B%0A%09syscall.Entersyscall()%0A%09r, errno := realSyscall(trap, a1, a2, a3, a4, a5, a6, 0, 0, 0)%0A%09syscall.Exitsyscall()%0A%09return r, 0, syscall.Errno(errno)%0A%7D%0A%0Afunc Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno) %7B%0A%09syscall.Entersyscall()%0A%09r, errno := realSyscall(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)%0A%09syscall.Exitsyscall()%0A%09return r, 0, syscall.Errno(errno)%0A%7D%0A%0Afunc RawSyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr) %7B%0A%09r := realSyscallNoError(trap, a1, a2, a3, 0, 0, 0, 0, 0, 0)%0A%09return r, 0%0A%7D%0A%0Afunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno) %7B%0A%09r, errno := realSyscall(trap, a1, a2, a3, 0, 0, 0, 0, 0, 0)%0A%09return r, 0, syscall.Errno(errno)%0A%7D%0A%0Afunc RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno) %7B%0A%09r, errno := realSyscall(trap, a1, a2, a3, a4, a5, a6, 0, 0, 0)%0A%09return r, 0, syscall.Errno(errno)%0A%7D%0A
- f 548adaa1b0276f12a64fde689ef9893addf9eba9215dfe2a86b8ad851703af6d vendor/golang.org/x/sys/unix/gccgo_c.c
+ f bc010b36833151c304cd5b40b79dadba2fda52db01df90f6f9154b3a016a0492 vendor/golang.org/x/sys/unix/gccgo_c.c
dmppatch 4
@@ -169,16 +169,31 @@
 d gccgo%0A
+// +build !aix%0A
 %0A#includ
- f 326ce7701ed9eeba853c492c833765bc99fa1091ba909df5b3588f81b17aa413 vendor/golang.org/x/sys/unix/gccgo_linux_amd64.go
+ f 743d504a2e0b8f36ffb9618c184b518c6bf45302f9b01a9d5b269bd22d7aba10 vendor/golang.org/x/sys/unix/gccgo_linux_amd64.go
dmppatch 3
@@ -195,8 +195,235 @@
 ge unix%0A
+%0Aimport %22syscall%22%0A%0A//extern gettimeofday%0Afunc realGettimeofday(*Timeval, *byte) int32%0A%0Afunc gettimeofday(tv *Timeval) (err syscall.Errno) %7B%0A%09r := realGettimeofday(tv, nil)%0A%09if r %3C 0 %7B%0A%09%09return syscall.GetErrno()%0A%09%7D%0A%09return 0%0A%7D%0A
- f 6e2f76cfa24736b83c40d5e6d9211d39cc13f21280cab23c9761a1e43e5660ac vendor/golang.org/x/sys/unix/ioctl.go
+ f 05d45bdcb06795864530c8395390da85296cc7cbe3b7b1856e2d132bfa4621ea vendor/golang.org/x/sys/unix/ioctl.go
dmppatch 9
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 %0Apac
@@ -253,16 +253,388 @@
 untime%22%0A
+%0A// IoctlSetWinsize performs an ioctl on fd with a *Winsize argument.%0A//%0A// To change fd's window size, the req argument should be TIOCSWINSZ.%0Afunc IoctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A%09// TODO: if we get the chance, remove the req parameter and%0A%09// hardcode TIOCSWINSZ.%0A%09err := ioctlSetWinsize(fd, req, value)%0A%09runtime.KeepAlive(value)%0A%09return err%0A%7D%0A
 %0A// Ioct
- x 31610507e10e0deea94da65dae37e2526320dca16e1945fa3420b5fc67cad34d vendor/golang.org/x/sys/unix/mkall.sh
+ f f28a62c2f424fe194369c2b68fc758680950d941898c42bb21e917df83b56237 vendor/golang.org/x/sys/unix/mkall.sh
dmppatch 4
@@ -1406,24 +1406,284 @@
 %09exit 1%0A%09;;%0A
+aix_ppc)%0A%09mkerrors=%22$mkerrors -maix32%22%0A%09mksyscall=%22perl mksyscall_aix.pl -aix%22%0A%09mktypes=%22GOARCH=$GOARCH go tool cgo -godefs%22%0A%09;;%0Aaix_ppc64)%0A%09mkerrors=%22$mkerrors -maix64%22%0A%09mksyscall=%22perl mksyscall_aix.pl -aix%22%0A%09mktypes=%22GOARCH=$GOARCH go tool cgo -godefs%22%0A%09;;%0A
 darwin_386)%0A
- x e14e040f5256064bdf88e7d3056b44b27bdaeb5714a9f5458fd9a4cc6300ac17 vendor/golang.org/x/sys/unix/mkerrors.sh
+ f 34c06eb85693cf5e26c26ad7fddfd028d7b27f56bd0273163d21cf2f979f8692 vendor/golang.org/x/sys/unix/mkerrors.sh
dmppatch 85
@@ -770,21 +770,76 @@
 fi%0A%0A
-CC=$%7BCC:-cc%7D%0A
+if %5B%5B %22$GOOS%22 = %22aix%22 %5D%5D; then%0A%09CC=$%7BCC:-gcc%7D%0Aelse%0A%09CC=$%7BCC:-cc%7D%0Afi%0A
 %0Aif 
@@ -968,16 +968,293 @@
 uname)%0A%0A
+includes_AIX='%0A#include %3Cnet/if.h%3E%0A#include %3Cnet/netopt.h%3E%0A#include %3Cnetinet/ip_mroute.h%3E%0A#include %3Csys/protosw.h%3E%0A#include %3Csys/stropts.h%3E%0A#include %3Csys/mman.h%3E%0A#include %3Csys/poll.h%3E%0A#include %3Csys/termio.h%3E%0A#include %3Ctermios.h%3E%0A#include %3Cfcntl.h%3E%0A%0A#define AF_LOCAL AF_UNIX%0A'%0A%0A
 includes
@@ -1904,32 +1904,54 @@
  %3Csys/sockio.h%3E%0A
+#include %3Csys/stat.h%3E%0A
 #include %3Csys/sy
@@ -1972,32 +1972,55 @@
 de %3Csys/mman.h%3E%0A
+#include %3Csys/mount.h%3E%0A
 #include %3Csys/wa
@@ -2403,32 +2403,54 @@
  %3Csys/sockio.h%3E%0A
+#include %3Csys/stat.h%3E%0A
 #include %3Csys/sy
@@ -4505,24 +4505,49 @@
 ux/magic.h%3E%0A
+#include %3Clinux/memfd.h%3E%0A
 #include %3Cli
@@ -5108,24 +5108,76 @@
 inux/rtc.h%3E%0A
+#include %3Clinux/if_xdp.h%3E%0A#include %3Cmtd/ubi-user.h%3E%0A
 #include %3Cne
@@ -5803,16 +5803,209 @@
      64%0A
+%0A// XDP socket constants do not appear to be picked up otherwise.%0A// Copied from samples/bpf/xdpsock_user.c.%0A#ifndef SOL_XDP%0A#define SOL_XDP 283%0A#endif%0A%0A#ifndef AF_XDP%0A#define AF_XDP 44%0A#endif%0A
 '%0A%0Ainclu
@@ -6125,32 +6125,55 @@
 de %3Csys/mman.h%3E%0A
+#include %3Csys/mount.h%3E%0A
 #include %3Csys/so
@@ -6699,32 +6699,55 @@
 de %3Csys/mman.h%3E%0A
+#include %3Csys/mount.h%3E%0A
 #include %3Csys/so
@@ -7665,32 +7665,54 @@
  %3Csys/sockio.h%3E%0A
+#include %3Csys/stat.h%3E%0A
 #include %3Csys/mm
@@ -9088,24 +9088,48 @@
 NG/ %7Bnext%7D%0A%0A
+%09%09$2 !~ /%5EECCAPBITS/ &&%0A
 %09%09$2 !~ /%5EET
@@ -10036,126 +10036,130 @@
  %7C%7C%0A
-%09%09$2 ~ /%5E(AF%7CSOCK%7CSO%7CSOL%7CIPPROTO%7CIP%7CIPV6%7CICMP6%7CTCP%7CEVFILT%7CNOTE%7CEV%7CSHUT%7CPROT%7CMAP%7CT?PACKET%7CMSG%7CSCM%7CMCL%7CDT%7CMADV%7CPR)_/ %7C%7C%0A
+%09%09$2 ~ /%5E(AF%7CSOCK%7CSO%7CSOL%7CIPPROTO%7CIP%7CIPV6%7CICMP6%7CTCP%7CEVFILT%7CNOTE%7CEV%7CSHUT%7CPROT%7CMAP%7CMFD%7CT?PACKET%7CMSG%7CSCM%7CMCL%7CDT%7CMADV%7CPR)_/ %7C%7C%0A
 %09%09$2
@@ -10440,24 +10440,46 @@
 TL_VERS/ %7C%7C%0A
+%09%09$2 !~ %22MNT_BITS%22 &&%0A
 %09%09$2 ~ /%5E(MS
@@ -11590,24 +11590,54 @@
 SPLICE_/ %7C%7C%0A
+%09%09$2 ~ /%5ESYNC_FILE_RANGE_/ %7C%7C%0A
 %09%09$2 !~ /%5EAU
@@ -11661,41 +11661,69 @@
  &&%0A
-%09%09$2 ~ /%5E%5BA-Z0-9_%5D+_MAGIC2?$/ %7C%7C%0A
+%09%09$2 !~ /IOC_MAGIC/ &&%0A%09%09$2 ~ /%5E%5BA-Z%5D%5BA-Z0-9_%5D+_MAGIC2?$/ %7C%7C%0A
 %09%09$2
@@ -11885,24 +11885,50 @@
 %5ERENAME/ %7C%7C%0A
+%09%09$2 ~ /%5EUBI_IOC%5BA-Z%5D/ %7C%7C%0A
 %09%09$2 ~ /%5EUTI
@@ -12118,24 +12118,42 @@
 ~ /%5ENFN/ %7C%7C%0A
+%09%09$2 ~ /%5EXDP_/ %7C%7C%0A
 %09%09$2 ~ /%5E(HD
@@ -12791,50 +12791,59 @@
 ' %7C%0A
-%09egrep -v '(SIGSTKSIZE%7CSIGSTKSZ%7CSIGRT)' %7C%0A
+%09egrep -v '(SIGSTKSIZE%7CSIGSTKSZ%7CSIGRT%7CSIGMAX64)' %7C%0A
 %09sor
@@ -13174,50 +13174,59 @@
 ' %7C%0A
-%09egrep -v '(SIGSTKSIZE%7CSIGSTKSZ%7CSIGRT)' %7C%0A
+%09egrep -v '(SIGSTKSIZE%7CSIGSTKSZ%7CSIGRT%7CSIGMAX64)' %7C%0A
 %09sor
- x 30b934152968c24329f9dd2eb6414b6dae1338a23c7ef94cde7887065bb706ab vendor/golang.org/x/sys/unix/mksyscall.pl
+ f 30b934152968c24329f9dd2eb6414b6dae1338a23c7ef94cde7887065bb706ab vendor/golang.org/x/sys/unix/mksyscall.pl
+ f 677df933b45ade152e8aa7b319f2a139c1904733d48516043f901e9f7f9821fb vendor/golang.org/x/sys/unix/mksyscall_aix.pl
dmppatch 2
@@ -0,0 +1,9374 @@
+#!/usr/bin/env perl%0A# Copyright 2018 The Go Authors. All rights reserved.%0A# Use of this source code is governed by a BSD-style%0A# license that can be found in the LICENSE file.%0A%0A# This program reads a file containing function prototypes%0A# (like syscall_aix.go) and generates system call bodies.%0A# The prototypes are marked by lines beginning with %22//sys%22%0A# and read like func declarations if //sys is replaced by func, but:%0A#%09* The parameter lists must give a name for each argument.%0A#%09  This includes return parameters.%0A#%09* The parameter lists must give a type for each argument:%0A#%09  the (x, y, z int) shorthand is not allowed.%0A#%09* If the return parameter is an error number, it must be named err.%0A#%09* If go func name needs to be different than its libc name,%0A#%09* or the function is not in libc, name could be specified%0A#%09* at the end, after %22=%22 sign, like%0A#%09  //sys getsockopt(s int, level int, name int, val uintptr, vallen *_Socklen) (err error) = libsocket.getsockopt%0A%0Ause strict;%0A%0Amy $cmdline = %22mksyscall_aix.pl %22 . join(' ', @ARGV);%0Amy $errors = 0;%0Amy $_32bit = %22%22;%0Amy $tags = %22%22;  # build tags%0Amy $aix = 0;%0Amy $solaris = 0;%0A%0Abinmode STDOUT;%0A%0Aif($ARGV%5B0%5D eq %22-b32%22) %7B%0A%09$_32bit = %22big-endian%22;%0A%09shift;%0A%7D elsif($ARGV%5B0%5D eq %22-l32%22) %7B%0A%09$_32bit = %22little-endian%22;%0A%09shift;%0A%7D%0Aif($ARGV%5B0%5D eq %22-aix%22) %7B%0A%09$aix = 1;%0A%09shift;%0A%7D%0Aif($ARGV%5B0%5D eq %22-tags%22) %7B%0A%09shift;%0A%09$tags = $ARGV%5B0%5D;%0A%09shift;%0A%7D%0A%0Aif($ARGV%5B0%5D =~ /%5E-/) %7B%0A%09print STDERR %22usage: mksyscall_aix.pl %5B-b32 %7C -l32%5D %5B-tags x,y%5D %5Bfile ...%5D%5Cn%22;%0A%09exit 1;%0A%7D%0A%0Asub parseparamlist($) %7B%0A%09my ($list) = @_;%0A%09$list =~ s/%5E%5Cs*//;%0A%09$list =~ s/%5Cs*$//;%0A%09if($list eq %22%22) %7B%0A%09%09return ();%0A%09%7D%0A%09return split(/%5Cs*,%5Cs*/, $list);%0A%7D%0A%0Asub parseparam($) %7B%0A%09my ($p) = @_;%0A%09if($p !~ /%5E(%5CS*) (%5CS*)$/) %7B%0A%09%09print STDERR %22$ARGV:$.: malformed parameter: $p%5Cn%22;%0A%09%09$errors = 1;%0A%09%09return (%22xx%22, %22int%22);%0A%09%7D%0A%09return ($1, $2);%0A%7D%0A%0Amy $package = %22%22;%0Amy $text = %22%22;%0Amy $c_extern = %22/*%5Cn#include %3Cstdint.h%3E%5Cn%22;%0Amy @vars = ();%0Awhile(%3C%3E) %7B%0A%09chomp;%0A%09s/%5Cs+/ /g;%0A%09s/%5E%5Cs+//;%0A%09s/%5Cs+$//;%0A%09$package = $1 if !$package && /%5Epackage (%5CS+)$/;%0A%09my $nonblock = /%5E%5C/%5C/sysnb /;%0A%09next if !/%5E%5C/%5C/sys / && !$nonblock;%0A%0A%09# Line must be of the form%0A%09# func Open(path string, mode int, perm int) (fd int, err error)%0A%09# Split into name, in params, out params.%0A%09if(!/%5E%5C/%5C/sys(nb)? (%5Cw+)%5C((%5B%5E()%5D*)%5C)%5Cs*(?:%5C((%5B%5E()%5D+)%5C))?%5Cs*(?:=%5Cs*(?:(%5Cw*)%5C.)?(%5Cw*))?$/) %7B%0A%09%09print STDERR %22$ARGV:$.: malformed //sys declaration%5Cn%22;%0A%09%09$errors = 1;%0A%09%09next;%0A%09%7D%0A%09my ($nb, $func, $in, $out, $modname, $sysname) = ($1, $2, $3, $4, $5, $6);%0A%0A%09# Split argument lists on comma.%0A%09my @in = parseparamlist($in);%0A%09my @out = parseparamlist($out);%0A%0A%09$in = join(', ', @in);%0A%09$out = join(', ', @out);%0A%0A%09# Try in vain to keep people from editing this file.%0A%09# The theory is that they jump into the middle of the file%0A%09# without reading the header.%0A%09$text .= %22// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%5Cn%5Cn%22;%0A%0A%09# Check if value return, err return available%0A%09my $errvar = %22%22;%0A%09my $retvar = %22%22;%0A%09my $rettype = %22%22;%0A%09foreach my $p (@out) %7B%0A%09%09my ($name, $type) = parseparam($p);%0A%09%09if($type eq %22error%22) %7B%0A%09%09%09$errvar = $name;%0A%09%09%7D else %7B%0A%09%09%09$retvar = $name;%0A%09%09%09$rettype = $type;%0A%09%09%7D%0A%09%7D%0A%0A%09# System call name.%0A%09#if($func ne %22fcntl%22) %7B%0A%0A%09if($sysname eq %22%22) %7B%0A%09%09$sysname = %22$func%22;%0A%09%7D%0A%0A%09$sysname =~ s/(%5Ba-z%5D)(%5BA-Z%5D)/$%7B1%7D_$2/g;%0A%09$sysname =~ y/A-Z/a-z/; # All libc functions are lowercase.%0A%0A%09my $C_rettype = %22%22;%0A%09if($rettype eq %22unsafe.Pointer%22) %7B%0A%09%09$C_rettype = %22uintptr_t%22;%0A%09%7D elsif($rettype eq %22uintptr%22) %7B%0A%09%09$C_rettype = %22uintptr_t%22;%0A%09%7D elsif($rettype =~ /%5E_/) %7B%0A%09%09$C_rettype = %22uintptr_t%22;%0A%09%7D elsif($rettype eq %22int%22) %7B%0A%09%09$C_rettype = %22int%22;%0A%09%7D elsif($rettype eq %22int32%22) %7B%0A%09%09$C_rettype = %22int%22;%0A%09%7D elsif($rettype eq %22int64%22) %7B%0A%09%09$C_rettype = %22long long%22;%0A%09%7D elsif($rettype eq %22uint32%22) %7B%0A%09%09$C_rettype = %22unsigned int%22;%0A%09%7D elsif($rettype eq %22uint64%22) %7B%0A%09%09$C_rettype = %22unsigned long long%22;%0A%09%7D else %7B%0A%09%09$C_rettype = %22int%22;%0A%09%7D%0A%09if($sysname eq %22exit%22) %7B%0A%09%09$C_rettype = %22void%22;%0A%09%7D%0A%0A%09# Change types to c%0A%09my @c_in = ();%0A%09foreach my $p (@in) %7B%0A%09%09my ($name, $type) = parseparam($p);%0A%09%09if($type =~ /%5E%5C*/) %7B%0A%09%09%09push @c_in, %22uintptr_t%22;%0A%09%09%09%7D elsif($type eq %22string%22) %7B%0A%09%09%09push @c_in, %22uintptr_t%22;%0A%09%09%7D elsif($type =~ /%5E%5C%5B%5C%5D(.*)/) %7B%0A%09%09%09push @c_in, %22uintptr_t%22, %22size_t%22;%0A%09%09%7D elsif($type eq %22unsafe.Pointer%22) %7B%0A%09%09%09push @c_in, %22uintptr_t%22;%0A%09%09%7D elsif($type eq %22uintptr%22) %7B%0A%09%09%09push @c_in, %22uintptr_t%22;%0A%09%09%7D elsif($type =~ /%5E_/) %7B%0A%09%09%09push @c_in, %22uintptr_t%22;%0A%09%09%7D elsif($type eq %22int%22) %7B%0A%09%09%09push @c_in, %22int%22;%0A%09%09%7D elsif($type eq %22int32%22) %7B%0A%09%09%09push @c_in, %22int%22;%0A%09%09%7D elsif($type eq %22int64%22) %7B%0A%09%09%09push @c_in, %22long long%22;%0A%09%09%7D elsif($type eq %22uint32%22) %7B%0A%09%09%09push @c_in, %22unsigned int%22;%0A%09%09%7D elsif($type eq %22uint64%22) %7B%0A%09%09%09push @c_in, %22unsigned long long%22;%0A%09%09%7D else %7B%0A%09%09%09push @c_in, %22int%22;%0A%09%09%7D%0A%09%7D%0A%0A%09if ($func ne %22fcntl%22 && $func ne %22FcntlInt%22 && $func ne %22readlen%22 && $func ne %22writelen%22) %7B%0A%09%09# Imports of system calls from libc%0A%09%09$c_extern .= %22$C_rettype $sysname%22;%0A%09%09my $c_in = join(', ', @c_in);%0A%09%09$c_extern .= %22($c_in);%5Cn%22;%0A%09%7D%0A%0A%09# So file name.%0A%09if($aix) %7B%0A%09%09if($modname eq %22%22) %7B%0A%09%09%09$modname = %22libc.a/shr_64.o%22;%0A%09%09%7D else %7B%0A%09%09%09print STDERR %22$func: only syscall using libc are available%5Cn%22;%0A%09%09%09$errors = 1;%0A%09%09%09next;%0A%09%09%7D%0A%09%7D%0A%0A%09my $strconvfunc = %22C.CString%22;%0A%09my $strconvtype = %22*byte%22;%0A%0A%09# Go function header.%0A%09if($out ne %22%22) %7B%0A%09%09$out = %22 ($out)%22;%0A%09%7D%0A%09if($text ne %22%22) %7B%0A%09%09$text .= %22%5Cn%22%0A%09%7D%0A%0A%09$text .= sprintf %22func %25s(%25s)%25s %7B%5Cn%22, $func, join(', ', @in), $out ;%0A%0A%09# Prepare arguments to call.%0A%09my @args = ();%0A%09my $n = 0;%0A%09my $arg_n = 0;%0A%09foreach my $p (@in) %7B%0A%09%09my ($name, $type) = parseparam($p);%0A%09%09if($type =~ /%5E%5C*/) %7B%0A%09%09%09push @args, %22C.uintptr_t(uintptr(unsafe.Pointer($name)))%22;%0A%09%09%7D elsif($type eq %22string%22 && $errvar ne %22%22) %7B%0A%09%09%09$text .= %22%5Ct_p$n := uintptr(unsafe.Pointer($strconvfunc($name)))%5Cn%22;%0A%09%09%09push @args, %22C.uintptr_t(_p$n)%22;%0A%09%09%09$n++;%0A%09%09%7D elsif($type eq %22string%22) %7B%0A%09%09%09print STDERR %22$ARGV:$.: $func uses string arguments, but has no error return%5Cn%22;%0A%09%09%09$text .= %22%5Ct_p$n := uintptr(unsafe.Pointer($strconvfunc($name)))%5Cn%22;%0A%09%09%09push @args, %22C.uintptr_t(_p$n)%22;%0A%09%09%09$n++;%0A%09%09%7D elsif($type =~ /%5E%5C%5B%5C%5D(.*)/) %7B%0A%09%09%09# Convert slice into pointer, length.%0A%09%09%09# Have to be careful not to take address of &a%5B0%5D if len == 0:%0A%09%09%09# pass nil in that case.%0A%09%09%09$text .= %22%5Ctvar _p$n *$1%5Cn%22;%0A%09%09%09$text .= %22%5Ctif len($name) %3E 0 %7B%5Cn%5Ct%5Ct_p$n = %5C&$name%5C%5B0%5D%5Cn%5Ct%7D%5Cn%22;%0A%09%09%09push @args, %22C.uintptr_t(uintptr(unsafe.Pointer(_p$n)))%22;%0A%09%09%09$n++;%0A%09%09%09$text .= %22%5Ctvar _p$n int%5Cn%22;%0A%09%09%09$text .= %22%5Ct_p$n = len($name)%5Cn%22;%0A%09%09%09push @args, %22C.size_t(_p$n)%22;%0A%09%09%09$n++;%0A%09%09%7D elsif($type eq %22int64%22 && $_32bit ne %22%22) %7B%0A%09%09%09if($_32bit eq %22big-endian%22) %7B%0A%09%09%09%09push @args, %22uintptr($name %3E%3E 32)%22, %22uintptr($name)%22;%0A%09%09%09%7D else %7B%0A%09%09%09%09push @args, %22uintptr($name)%22, %22uintptr($name %3E%3E 32)%22;%0A%09%09%09%7D%0A%09%09%09$n++;%0A%09%09%7D elsif($type eq %22bool%22) %7B%0A%09%09%09$text .= %22%5Ctvar _p$n uint32%5Cn%22;%0A%09%09%09$text .= %22%5Ctif $name %7B%5Cn%5Ct%5Ct_p$n = 1%5Cn%5Ct%7D else %7B%5Cn%5Ct%5Ct_p$n = 0%5Cn%5Ct%7D%5Cn%22;%0A%09%09%09push @args, %22_p$n%22;%0A%09%09%09$n++;%0A%09%09%7D elsif($type =~ /%5E_/) %7B%0A%09%09%09push @args, %22C.uintptr_t(uintptr($name))%22;%0A%09%09%7D elsif($type eq %22unsafe.Pointer%22) %7B%0A%09%09%09push @args, %22C.uintptr_t(uintptr($name))%22;%0A%09%09%7D elsif($type eq %22int%22) %7B%0A%09%09%09if (($arg_n == 2) && (($func eq %22readlen%22) %7C%7C ($func eq %22writelen%22))) %7B%0A%09%09%09%09push @args, %22C.size_t($name)%22;%0A%09%09%09%7D elsif ($arg_n == 0 && $func eq %22fcntl%22) %7B%0A%09%09%09%09push @args, %22C.uintptr_t($name)%22;%0A%09%09%09%7D elsif (($arg_n == 2) && (($func eq %22fcntl%22) %7C%7C ($func eq %22FcntlInt%22))) %7B%0A%09%09%09%09push @args, %22C.uintptr_t($name)%22;%0A%09%09%09%7D else %7B%0A%09%09%09%09push @args, %22C.int($name)%22;%0A%09%09%09%7D%0A%09%09%7D elsif($type eq %22int32%22) %7B%0A%09%09%09push @args, %22C.int($name)%22;%0A%09%09%7D elsif($type eq %22int64%22) %7B%0A%09%09%09push @args, %22C.longlong($name)%22;%0A%09%09%7D elsif($type eq %22uint32%22) %7B%0A%09%09%09push @args, %22C.uint($name)%22;%0A%09%09%7D elsif($type eq %22uint64%22) %7B%0A%09%09%09push @args, %22C.ulonglong($name)%22;%0A%09%09%7D elsif($type eq %22uintptr%22) %7B%0A%09%09%09push @args, %22C.uintptr_t($name)%22;%0A%09%09%7D else %7B%0A%09%09%09push @args, %22C.int($name)%22;%0A%09%09%7D%0A%09%09$arg_n++;%0A%09%7D%0A%09my $nargs = @args;%0A%0A%0A%09# Determine which form to use; pad args with zeros.%0A%09if ($nonblock) %7B%0A%09%7D%0A%0A%09my $args = join(', ', @args);%0A%09my $call = %22%22;%0A%09if ($sysname eq %22exit%22) %7B%0A%09%09if ($errvar ne %22%22) %7B%0A%09%09%09$call .= %22er :=%22;%0A%09%09%7D else %7B%0A%09%09%09$call .= %22%22;%0A%09%09%7D%0A%09%7D  elsif ($errvar ne %22%22) %7B%0A%09%09$call .= %22r0,er :=%22;%0A%09%7D  elsif ($retvar ne %22%22) %7B%0A%09%09$call .= %22r0,_ :=%22;%0A%09%7D  else %7B%0A%09%09$call .= %22%22%0A%09%7D%0A%09$call .= %22C.$sysname($args)%22;%0A%0A%09# Assign return values.%0A%09my $body = %22%22;%0A%09my $failexpr = %22%22;%0A%0A%09for(my $i=0; $i%3C@out; $i++) %7B%0A%09%09my $p = $out%5B$i%5D;%0A%09%09my ($name, $type) = parseparam($p);%0A%09%09my $reg = %22%22;%0A%09%09if($name eq %22err%22) %7B%0A%09%09%09$reg = %22e1%22;%0A%09%09%7D else %7B%0A%09%09%09$reg = %22r0%22;%0A%09%09%7D%0A%09%09if($reg ne %22e1%22 ) %7B%0A%09%09%09%09%09%09$body .= %22%5Ct$name = $type($reg)%5Cn%22;%0A%09%09%7D%0A%09%7D%0A%0A%09# verify return%0A%09if ($sysname ne %22exit%22 && $errvar ne %22%22) %7B%0A%09%09if ($C_rettype =~ /%5Euintptr/) %7B%0A%09%09%09$body .= %22%5Ctif %5C(uintptr%5C(r0%5C) ==%5C%5Euintptr%5C(0%5C) && er != nil%5C) %7B%5Cn%22;%0A%09%09%09$body .= %22%5Ct%5Ct$errvar = er%5Cn%22;%0A%09%09%09$body .= %22%5Ct%7D%5Cn%22;%0A%09%09%7D else %7B%0A%09%09%09$body .= %22%5Ctif %5C(r0 ==-1 && er != nil%5C) %7B%5Cn%22;%0A%09%09%09$body .= %22%5Ct%5Ct$errvar = er%5Cn%22;%0A%09%09%09$body .= %22%5Ct%7D%5Cn%22;%0A%09%09%7D%0A%09%7D elsif ($errvar ne %22%22) %7B%0A%09%09$body .= %22%5Ctif %5C(er != nil%5C) %7B%5Cn%22;%0A%09%09$body .= %22%5Ct%5Ct$errvar = er%5Cn%22;%0A%09%09$body .= %22%5Ct%7D%5Cn%22;%0A%09%7D%0A%0A%09$text .= %22%5Ct$call%5Cn%22;%0A%09$text .= $body;%0A%0A%09$text .= %22%5Ctreturn%5Cn%22;%0A%09$text .= %22%7D%5Cn%22;%0A%7D%0A%0Aif($errors) %7B%0A%09exit 1;%0A%7D%0A%0Aprint %3C%3CEOF;%0A// $cmdline%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build $tags%0A%0Apackage $package%0A%0A%0A$c_extern%0A*/%0Aimport %22C%22%0Aimport (%0A%09%22unsafe%22%0A%09%22syscall%22%0A)%0A%0A%0AEOF%0A%0Aprint %22import %5C%22golang.org/x/sys/unix%5C%22%5Cn%22 if $package ne %22unix%22;%0A%0Achomp($_=%3C%3CEOF);%0A%0A$text%0AEOF%0Aprint $_;%0Aexit 0;%0A
- x 655c784175de20c55aa6fb859e71abc2f53c3d379087d386968ee8fee124b3ff vendor/golang.org/x/sys/unix/mksyscall_solaris.pl
+ f 655c784175de20c55aa6fb859e71abc2f53c3d379087d386968ee8fee124b3ff vendor/golang.org/x/sys/unix/mksyscall_solaris.pl
- x cf1feccd0bbad9100f93be41fff04fb169e0464b362e04cbc58994aed5789b69 vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl
+ f cf1feccd0bbad9100f93be41fff04fb169e0464b362e04cbc58994aed5789b69 vendor/golang.org/x/sys/unix/mksysctl_openbsd.pl
- x dfd487bbf8e4752cc19c8ed33aaef1a816c74031e9054513ef9fe1dbacc2a56b vendor/golang.org/x/sys/unix/mksysnum_darwin.pl
+ f dfd487bbf8e4752cc19c8ed33aaef1a816c74031e9054513ef9fe1dbacc2a56b vendor/golang.org/x/sys/unix/mksysnum_darwin.pl
- x 8ad0456d42fce68880c9498a2d026dacb20eb4b8f7e20949da6620c37e25f488 vendor/golang.org/x/sys/unix/mksysnum_dragonfly.pl
+ f 8ad0456d42fce68880c9498a2d026dacb20eb4b8f7e20949da6620c37e25f488 vendor/golang.org/x/sys/unix/mksysnum_dragonfly.pl
- x 956003a84b27e28caad7d23185437db9810405f9d326bca82e0baa2c551ec6c9 vendor/golang.org/x/sys/unix/mksysnum_freebsd.pl
+ f b90d41860c5d7a913e43bf025f4cc23955606e2c589842f3d558865226763786 vendor/golang.org/x/sys/unix/mksysnum_freebsd.pl
dmppatch 5
@@ -650,59 +650,66 @@
 %3E)%7B%0A
-%09if(/%5E(%5B0-9%5D+)%5Cs+%5CS+%5Cs+STD%5Cs+(%7B %5CS+%5Cs+(%5Cw+).*)$/)%7B%0A
+%09if(/%5E(%5B0-9%5D+)%5Cs+%5CS+%5Cs+(?:NO)?STD%5Cs+(%7B %5CS+%5Cs+(%5Cw+).*)$/)%7B%0A
 %09%09my
- x d0737e6437a4c7921f49855fd82c9b1408a36b91cc4f4fa85753da9baf23ffbf vendor/golang.org/x/sys/unix/mksysnum_netbsd.pl
+ f d0737e6437a4c7921f49855fd82c9b1408a36b91cc4f4fa85753da9baf23ffbf vendor/golang.org/x/sys/unix/mksysnum_netbsd.pl
- x c5b8ee73385e4e31f977d9a0c01fc4c0e30145a0d31d168f3413da661c428f12 vendor/golang.org/x/sys/unix/mksysnum_openbsd.pl
+ f c5b8ee73385e4e31f977d9a0c01fc4c0e30145a0d31d168f3413da661c428f12 vendor/golang.org/x/sys/unix/mksysnum_openbsd.pl
- f 73cef153f42a96b37a335ca369aaad3f7941b7b7b708f06ca0e28a337fc6f039 vendor/golang.org/x/sys/unix/openbsd_pledge.go
+ f 272140aa95c53646a0deffd14739ebb9c1ffa6ab5766534dfead304180a0ad49 vendor/golang.org/x/sys/unix/openbsd_pledge.go
dmppatch 3
@@ -209,8 +209,2036 @@
 ge unix%0A
+%0Aimport (%0A%09%22errors%22%0A%09%22fmt%22%0A%09%22strconv%22%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Aconst (%0A%09_SYS_PLEDGE = 108%0A)%0A%0A// Pledge implements the pledge syscall.%0A//%0A// The pledge syscall does not accept execpromises on OpenBSD releases%0A// before 6.3.%0A//%0A// execpromises must be empty when Pledge is called on OpenBSD%0A// releases predating 6.3, otherwise an error will be returned.%0A//%0A// For more information see pledge(2).%0Afunc Pledge(promises, execpromises string) error %7B%0A%09maj, min, err := majmin()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// If OpenBSD %3C= 5.9, pledge is not available.%0A%09if (maj == 5 && min != 9) %7C%7C maj %3C 5 %7B%0A%09%09return fmt.Errorf(%22pledge syscall is not available on OpenBSD %25d.%25d%22, maj, min)%0A%09%7D%0A%0A%09// If OpenBSD %3C= 6.2 and execpromises is not empty%0A%09// return an error - execpromises is not available before 6.3%0A%09if (maj %3C 6 %7C%7C (maj == 6 && min %3C= 2)) && execpromises != %22%22 %7B%0A%09%09return fmt.Errorf(%22cannot use execpromises on OpenBSD %25d.%25d%22, maj, min)%0A%09%7D%0A%0A%09pptr, err := syscall.BytePtrFromString(promises)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// This variable will hold either a nil unsafe.Pointer or%0A%09// an unsafe.Pointer to a string (execpromises).%0A%09var expr unsafe.Pointer%0A%0A%09// If we're running on OpenBSD %3E 6.2, pass execpromises to the syscall.%0A%09if maj %3E 6 %7C%7C (maj == 6 && min %3E 2) %7B%0A%09%09exptr, err := syscall.BytePtrFromString(execpromises)%0A%09%09if err != nil %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09expr = unsafe.Pointer(exptr)%0A%09%7D%0A%0A%09_, _, e := syscall.Syscall(_SYS_PLEDGE, uintptr(unsafe.Pointer(pptr)), uintptr(expr), 0)%0A%09if e != 0 %7B%0A%09%09return e%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A// majmin returns major and minor version number for an OpenBSD system.%0Afunc majmin() (major int, minor int, err error) %7B%0A%09var v Utsname%0A%09err = Uname(&v)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09major, err = strconv.Atoi(string(v.Release%5B0%5D))%0A%09if err != nil %7B%0A%09%09err = errors.New(%22cannot parse major version number returned by uname%22)%0A%09%09return%0A%09%7D%0A%0A%09minor, err = strconv.Atoi(string(v.Release%5B2%5D))%0A%09if err != nil %7B%0A%09%09err = errors.New(%22cannot parse minor version number returned by uname%22)%0A%09%09return%0A%09%7D%0A%0A%09return%0A%7D%0A
- f 9b22298a2373aaaca3de3ab8a7380beec95c973b8bd8c4ca0184f76deedbbce2 vendor/golang.org/x/sys/unix/pagesize_unix.go
+ f dd0516d9bcec4a46829ecf9b5899d7ae1c4dcc0b6de27933ba8dc9278c7856cf vendor/golang.org/x/sys/unix/pagesize_unix.go
dmppatch 8
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 %0A// 
@@ -284,8 +284,84 @@
 ge unix%0A
+%0Aimport %22syscall%22%0A%0Afunc Getpagesize() int %7B%0A%09return syscall.Getpagesize()%0A%7D%0A
- f f65de6dc7ea28b9a6c791519440d8d731ca4a89cab3db3c41e342b0762d2f169 vendor/golang.org/x/sys/unix/race.go
+ f 2b7d22204270835d550741a4d1e143d7fcaf7b624070eaf0bc3db43af02db178 vendor/golang.org/x/sys/unix/race.go
dmppatch 4
@@ -343,16 +343,184 @@
 ddr)%0A%7D%0A%0A
+func raceReleaseMerge(addr unsafe.Pointer) %7B%0A%09runtime.RaceReleaseMerge(addr)%0A%7D%0A%0Afunc raceReadRange(addr unsafe.Pointer, len int) %7B%0A%09runtime.RaceReadRange(addr, len)%0A%7D%0A%0A
 func rac
- f 6b45a95193f69ce7ae2ed3eb030087981c7d4a964a7271b31ce7ed9473a8b4c4 vendor/golang.org/x/sys/unix/race0.go
+ f 32e481eb1663a60e308c7b8273f034cd210cd152ecd085d8e6f0469e59cf9d30 vendor/golang.org/x/sys/unix/race0.go
dmppatch 9
@@ -157,90 +157,94 @@
 e.%0A%0A
-// +build darwin,!race linux,!race freebsd,!race netbsd openbsd solaris dragonfly%0A
+// +build aix darwin,!race linux,!race freebsd,!race netbsd openbsd solaris dragonfly%0A
 %0Apac
@@ -343,16 +343,118 @@
 nter) %7B%0A
+%7D%0A%0Afunc raceReleaseMerge(addr unsafe.Pointer) %7B%0A%7D%0A%0Afunc raceReadRange(addr unsafe.Pointer, len int) %7B%0A
 %7D%0A%0Afunc 
- f d9f35e6b5cefd654e0a3fe2f89cf77ec946e16e06e96b04a70c53a73592b05a1 vendor/golang.org/x/sys/unix/sockcmsg_linux.go
+ f af158b5f4a3a069a11f95c789628544f9f0c09f961e36c204f34eb9bc1eb8144 vendor/golang.org/x/sys/unix/sockcmsg_linux.go
dmppatch 3
@@ -194,8 +194,878 @@
 ge unix%0A
+%0Aimport %22unsafe%22%0A%0A// UnixCredentials encodes credentials into a socket control message%0A// for sending to another process. This can be used for%0A// authentication.%0Afunc UnixCredentials(ucred *Ucred) %5B%5Dbyte %7B%0A%09b := make(%5B%5Dbyte, CmsgSpace(SizeofUcred))%0A%09h := (*Cmsghdr)(unsafe.Pointer(&b%5B0%5D))%0A%09h.Level = SOL_SOCKET%0A%09h.Type = SCM_CREDENTIALS%0A%09h.SetLen(CmsgLen(SizeofUcred))%0A%09*((*Ucred)(cmsgData(h))) = *ucred%0A%09return b%0A%7D%0A%0A// ParseUnixCredentials decodes a socket control message that contains%0A// credentials in a Ucred structure. To receive such a message, the%0A// SO_PASSCRED option must be enabled on the socket.%0Afunc ParseUnixCredentials(m *SocketControlMessage) (*Ucred, error) %7B%0A%09if m.Header.Level != SOL_SOCKET %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09if m.Header.Type != SCM_CREDENTIALS %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09ucred := *(*Ucred)(unsafe.Pointer(&m.Data%5B0%5D))%0A%09return &ucred, nil%0A%7D%0A
- f d79d5b4a28307466235bf632057b837d1d0890093f725d342599277f562aa1db vendor/golang.org/x/sys/unix/sockcmsg_unix.go
+ f 1968dac259623672e5de2e064ab978a381db09ff4c06f27f31985bb3c2a8a72b vendor/golang.org/x/sys/unix/sockcmsg_unix.go
dmppatch 8
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 %0A// 
@@ -263,8 +263,2746 @@
 ge unix%0A
+%0Aimport %22unsafe%22%0A%0A// Round the length of a raw sockaddr up to align it properly.%0Afunc cmsgAlignOf(salen int) int %7B%0A%09salign := sizeofPtr%0A%09// NOTE: It seems like 64-bit Darwin, DragonFly BSD and%0A%09// Solaris kernels still require 32-bit aligned access to%0A%09// network subsystem.%0A%09if darwin64Bit %7C%7C dragonfly64Bit %7C%7C solaris64Bit %7B%0A%09%09salign = 4%0A%09%7D%0A%09return (salen + salign - 1) & %5E(salign - 1)%0A%7D%0A%0A// CmsgLen returns the value to store in the Len field of the Cmsghdr%0A// structure, taking into account any necessary alignment.%0Afunc CmsgLen(datalen int) int %7B%0A%09return cmsgAlignOf(SizeofCmsghdr) + datalen%0A%7D%0A%0A// CmsgSpace returns the number of bytes an ancillary element with%0A// payload of the passed data length occupies.%0Afunc CmsgSpace(datalen int) int %7B%0A%09return cmsgAlignOf(SizeofCmsghdr) + cmsgAlignOf(datalen)%0A%7D%0A%0Afunc cmsgData(h *Cmsghdr) unsafe.Pointer %7B%0A%09return unsafe.Pointer(uintptr(unsafe.Pointer(h)) + uintptr(cmsgAlignOf(SizeofCmsghdr)))%0A%7D%0A%0A// SocketControlMessage represents a socket control message.%0Atype SocketControlMessage struct %7B%0A%09Header Cmsghdr%0A%09Data   %5B%5Dbyte%0A%7D%0A%0A// ParseSocketControlMessage parses b as an array of socket control%0A// messages.%0Afunc ParseSocketControlMessage(b %5B%5Dbyte) (%5B%5DSocketControlMessage, error) %7B%0A%09var msgs %5B%5DSocketControlMessage%0A%09i := 0%0A%09for i+CmsgLen(0) %3C= len(b) %7B%0A%09%09h, dbuf, err := socketControlMessageHeaderAndData(b%5Bi:%5D)%0A%09%09if err != nil %7B%0A%09%09%09return nil, err%0A%09%09%7D%0A%09%09m := SocketControlMessage%7BHeader: *h, Data: dbuf%7D%0A%09%09msgs = append(msgs, m)%0A%09%09i += cmsgAlignOf(int(h.Len))%0A%09%7D%0A%09return msgs, nil%0A%7D%0A%0Afunc socketControlMessageHeaderAndData(b %5B%5Dbyte) (*Cmsghdr, %5B%5Dbyte, error) %7B%0A%09h := (*Cmsghdr)(unsafe.Pointer(&b%5B0%5D))%0A%09if h.Len %3C SizeofCmsghdr %7C%7C uint64(h.Len) %3E uint64(len(b)) %7B%0A%09%09return nil, nil, EINVAL%0A%09%7D%0A%09return h, b%5BcmsgAlignOf(SizeofCmsghdr):h.Len%5D, nil%0A%7D%0A%0A// UnixRights encodes a set of open file descriptors into a socket%0A// control message for sending to another process.%0Afunc UnixRights(fds ...int) %5B%5Dbyte %7B%0A%09datalen := len(fds) * 4%0A%09b := make(%5B%5Dbyte, CmsgSpace(datalen))%0A%09h := (*Cmsghdr)(unsafe.Pointer(&b%5B0%5D))%0A%09h.Level = SOL_SOCKET%0A%09h.Type = SCM_RIGHTS%0A%09h.SetLen(CmsgLen(datalen))%0A%09data := cmsgData(h)%0A%09for _, fd := range fds %7B%0A%09%09*(*int32)(data) = int32(fd)%0A%09%09data = unsafe.Pointer(uintptr(data) + 4)%0A%09%7D%0A%09return b%0A%7D%0A%0A// ParseUnixRights decodes a socket control message that contains an%0A// integer array of open file descriptors from another process.%0Afunc ParseUnixRights(m *SocketControlMessage) (%5B%5Dint, error) %7B%0A%09if m.Header.Level != SOL_SOCKET %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09if m.Header.Type != SCM_RIGHTS %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09fds := make(%5B%5Dint, len(m.Data)%3E%3E2)%0A%09for i, j := 0, 0; i %3C len(m.Data); i += 4 %7B%0A%09%09fds%5Bj%5D = int(*(*int32)(unsafe.Pointer(&m.Data%5Bi%5D)))%0A%09%09j++%0A%09%7D%0A%09return fds, nil%0A%7D%0A
- f 2d02a0676e9c504b468c5637d14b56852364a2dff3915f24ea06a369f47e7b73 vendor/golang.org/x/sys/unix/str.go
+ f dc743a40166ce093b6051af2e8e2e53d51c519dd19bfaa671418cfc15613733a vendor/golang.org/x/sys/unix/str.go
dmppatch 8
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 %0Apac
@@ -235,8 +235,381 @@
 ge unix%0A
+%0Afunc itoa(val int) string %7B // do it here rather than with fmt to avoid dependency%0A%09if val %3C 0 %7B%0A%09%09return %22-%22 + uitoa(uint(-val))%0A%09%7D%0A%09return uitoa(uint(val))%0A%7D%0A%0Afunc uitoa(val uint) string %7B%0A%09var buf %5B32%5Dbyte // big enough for int64%0A%09i := len(buf) - 1%0A%09for val %3E= 10 %7B%0A%09%09buf%5Bi%5D = byte(val%2510 + '0')%0A%09%09i--%0A%09%09val /= 10%0A%09%7D%0A%09buf%5Bi%5D = byte(val + '0')%0A%09return string(buf%5Bi:%5D)%0A%7D%0A
- f 449f8cd5f363d829aa1352021c59d94bd59dd01dfe541eb0ca6fa022aafb88fb vendor/golang.org/x/sys/unix/syscall.go
+ f 3f7141e7bca4b7125e0ea8f10255893f57e965f4fd53472f2a34f52b49d4b7d0 vendor/golang.org/x/sys/unix/syscall.go
dmppatch 9
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 %0A// 
@@ -1252,16 +1252,687 @@
 s/unix%22%0A
+%0Aimport %22strings%22%0A%0A// ByteSliceFromString returns a NUL-terminated slice of bytes%0A// containing the text of s. If s contains a NUL byte at any%0A// location, it returns (nil, EINVAL).%0Afunc ByteSliceFromString(s string) (%5B%5Dbyte, error) %7B%0A%09if strings.IndexByte(s, 0) != -1 %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%09a := make(%5B%5Dbyte, len(s)+1)%0A%09copy(a, s)%0A%09return a, nil%0A%7D%0A%0A// BytePtrFromString returns a pointer to a NUL-terminated array of%0A// bytes containing the text of s. If s contains a NUL byte at any%0A// location, it returns (nil, EINVAL).%0Afunc BytePtrFromString(s string) (*byte, error) %7B%0A%09a, err := ByteSliceFromString(s)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &a%5B0%5D, nil%0A%7D%0A
 %0A// Sing
+ f 41173a2fe5992f12d21cb98e488bbc4b5f4fb469a1da5046265070b47ca86679 vendor/golang.org/x/sys/unix/syscall_aix.go
dmppatch 2
@@ -0,0 +1,16375 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build aix%0A%0A// Aix system calls.%0A// This file is compiled as ordinary Go code,%0A// but it is also input to mksyscall,%0A// which parses the //sys lines and generates system call stubs.%0A// Note that sometimes we use a lowercase //sys name and%0A// wrap it in our own nicer implementation.%0A%0Apackage unix%0A%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0A/*%0A * Wrapped%0A */%0A%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0Afunc Utimes(path string, tv %5B%5DTimeval) error %7B%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flag int) (err error)%0Afunc UtimesNano(path string, ts %5B%5DTimespec) error %7B%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%7D%0A%0Afunc UtimesNanoAt(dirfd int, path string, ts %5B%5DTimespec, flags int) error %7B%0A%09if ts == nil %7B%0A%09%09return utimensat(dirfd, path, nil, flags)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimensat(dirfd, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), flags)%0A%7D%0A%0Afunc (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet4, nil%0A%7D%0A%0Afunc (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET6%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09sa.raw.Scope_id = sa.ZoneId%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet6, nil%0A%7D%0A%0Afunc (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09name := sa.Name%0A%09n := len(name)%0A%09if n %3E len(sa.raw.Path) %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09if n == len(sa.raw.Path) && name%5B0%5D != '@' %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_UNIX%0A%09for i := 0; i %3C n; i++ %7B%0A%09%09sa.raw.Path%5Bi%5D = uint8(name%5Bi%5D)%0A%09%7D%0A%09// length is family (uint16), name, NUL.%0A%09sl := _Socklen(2)%0A%09if n %3E 0 %7B%0A%09%09sl += _Socklen(n) + 1%0A%09%7D%0A%09if sa.raw.Path%5B0%5D == '@' %7B%0A%09%09sa.raw.Path%5B0%5D = 0%0A%09%09// Don't count trailing NUL for abstract address.%0A%09%09sl--%0A%09%7D%0A%0A%09return unsafe.Pointer(&sa.raw), sl, nil%0A%7D%0A%0Afunc Getsockname(fd int) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if err = getsockname(fd, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return anyToSockaddr(fd, &rsa)%0A%7D%0A%0A//sys%09getcwd(buf %5B%5Dbyte) (err error)%0A%0Aconst ImplementsGetwd = true%0A%0Afunc Getwd() (ret string, err error) %7B%0A%09for len := uint64(4096); ; len *= 2 %7B%0A%09%09b := make(%5B%5Dbyte, len)%0A%09%09err := getcwd(b)%0A%09%09if err == nil %7B%0A%09%09%09i := 0%0A%09%09%09for b%5Bi%5D != 0 %7B%0A%09%09%09%09i++%0A%09%09%09%7D%0A%09%09%09return string(b%5B0:i%5D), nil%0A%09%09%7D%0A%09%09if err != ERANGE %7B%0A%09%09%09return %22%22, err%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09err = getcwd(buf)%0A%09if err == nil %7B%0A%09%09i := 0%0A%09%09for buf%5Bi%5D != 0 %7B%0A%09%09%09i++%0A%09%09%7D%0A%09%09n = i + 1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getgroups() (gids %5B%5Dint, err error) %7B%0A%09n, err := getgroups(0, nil)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n == 0 %7B%0A%09%09return nil, nil%0A%09%7D%0A%0A%09// Sanity check group count. Max is 16 on BSD.%0A%09if n %3C 0 %7C%7C n %3E 1000 %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, n)%0A%09n, err = getgroups(n, &a%5B0%5D)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09gids = make(%5B%5Dint, n)%0A%09for i, v := range a%5B0:n%5D %7B%0A%09%09gids%5Bi%5D = int(v)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setgroups(gids %5B%5Dint) (err error) %7B%0A%09if len(gids) == 0 %7B%0A%09%09return setgroups(0, nil)%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, len(gids))%0A%09for i, v := range gids %7B%0A%09%09a%5Bi%5D = _Gid_t(v)%0A%09%7D%0A%09return setgroups(len(a), &a%5B0%5D)%0A%7D%0A%0A/*%0A * Socket%0A */%0A%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A%0Afunc Accept(fd int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept(fd, &rsa, &len)%0A%09if nfd == -1 %7B%0A%09%09return%0A%09%7D%0A%09sa, err = anyToSockaddr(fd, &rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Recvmsg(fd int, p, oob %5B%5Dbyte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) %7B%0A%09// Recvmsg not implemented on AIX%0A%09sa := new(SockaddrUnix)%0A%09return -1, -1, -1, sa, ENOSYS%0A%7D%0A%0Afunc Sendmsg(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (err error) %7B%0A%09_, err = SendmsgN(fd, p, oob, to, flags)%0A%09return%0A%7D%0A%0Afunc SendmsgN(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (n int, err error) %7B%0A%09// SendmsgN not implemented on AIX%0A%09return -1, ENOSYS%0A%7D%0A%0Afunc anyToSockaddr(fd int, rsa *RawSockaddrAny) (Sockaddr, error) %7B%0A%09switch rsa.Addr.Family %7B%0A%0A%09case AF_UNIX:%0A%09%09pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrUnix)%0A%0A%09%09// Some versions of AIX have a bug in getsockname (see IV78655).%0A%09%09// We can't rely on sa.Len being set correctly.%0A%09%09n := SizeofSockaddrUnix - 3 // substract leading Family, Len, terminating NUL.%0A%09%09for i := 0; i %3C n; i++ %7B%0A%09%09%09if pp.Path%5Bi%5D == 0 %7B%0A%09%09%09%09n = i%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%7D%0A%0A%09%09bytes := (*%5B10000%5Dbyte)(unsafe.Pointer(&pp.Path%5B0%5D))%5B0:n%5D%0A%09%09sa.Name = string(bytes)%0A%09%09return sa, nil%0A%0A%09case AF_INET:%0A%09%09pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet4)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_INET6:%0A%09%09pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet6)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09sa.ZoneId = pp.Scope_id%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%09%7D%0A%09return nil, EAFNOSUPPORT%0A%7D%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09err = gettimeofday(tv, nil)%0A%09return%0A%7D%0A%0A// TODO%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09return -1, ENOSYS%0A%7D%0A%0A//sys%09getdirent(fd int, buf %5B%5Dbyte) (n int, err error)%0Afunc ReadDirent(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09return getdirent(fd, buf)%0A%7D%0A%0A//sys%09wait4(pid Pid_t, status *_C_int, options int, rusage *Rusage) (wpid Pid_t, err error)%0Afunc Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09var status _C_int%0A%09var r Pid_t%0A%09err = ERESTART%0A%09// AIX wait4 may return with ERESTART errno, while the processus is still%0A%09// active.%0A%09for err == ERESTART %7B%0A%09%09r, err = wait4(Pid_t(pid), &status, options, rusage)%0A%09%7D%0A%09wpid = int(r)%0A%09if wstatus != nil %7B%0A%09%09*wstatus = WaitStatus(status)%0A%09%7D%0A%09return%0A%7D%0A%0A/*%0A * Wait%0A */%0A%0Atype WaitStatus uint32%0A%0Afunc (w WaitStatus) Stopped() bool %7B return w&0x40 != 0 %7D%0Afunc (w WaitStatus) StopSignal() syscall.Signal %7B%0A%09if !w.Stopped() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w%3E%3E8) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) Exited() bool %7B return w&0xFF == 0 %7D%0Afunc (w WaitStatus) ExitStatus() int %7B%0A%09if !w.Exited() %7B%0A%09%09return -1%0A%09%7D%0A%09return int((w %3E%3E 8) & 0xFF)%0A%7D%0A%0Afunc (w WaitStatus) Signaled() bool %7B return w&0x40 == 0 && w&0xFF != 0 %7D%0Afunc (w WaitStatus) Signal() syscall.Signal %7B%0A%09if !w.Signaled() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w%3E%3E16) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) Continued() bool %7B return w&0x01000000 != 0 %7D%0A%0Afunc (w WaitStatus) CoreDump() bool %7B return w&0x200 != 0 %7D%0A%0Afunc (w WaitStatus) TrapCause() int %7B return -1 %7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc ioctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0Afunc ioctlSetTermios(fd int, req uint, value *Termios) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0Afunc IoctlGetTermios(fd int, req uint) (*Termios, error) %7B%0A%09var value Termios%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A// fcntl must never be called with cmd=F_DUP2FD because it doesn't work on AIX%0A// There is no way to create a custom fcntl and to keep //sys fcntl easily,%0A// Therefore, the programmer must call dup2 instead of fcntl in this case.%0A%0A// FcntlInt performs a fcntl syscall on fd with the provided command and argument.%0A//sys%09FcntlInt(fd uintptr, cmd int, arg int) (r int,err error) = fcntl%0A%0A// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.%0A//sys%09FcntlFlock(fd uintptr, cmd int, lk *Flock_t) (err error) = fcntl%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09return syscall.Flock(fd, how)%0A%7D%0A%0A/*%0A * Direct access%0A */%0A%0A//sys%09Acct(path string) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(oldfd int) (fd int, err error)%0A//sys%09Dup3(oldfd int, newfd int, flags int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Faccessat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fallocate(fd int, mode uint32, off int64, len int64) (err error)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)%0A//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A//sys%09Fdatasync(fd int) (err error)%0A//sys%09Fsync(fd int) (err error)%0A// readdir_r%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A%0A//sys%09Getpgrp() (pid int)%0A%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Kill(pid int, sig syscall.Signal) (err error)%0A//sys%09Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) = syslog%0A//sys%09Mkdir(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mkdirat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Mknodat(dirfd int, path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys   Open(path string, mode int, perm uint32) (fd int, err error) = open64%0A//sys   Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Removexattr(path string, attr string) (err error)%0A//sys%09Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)%0A//sys%09Setdomainname(p %5B%5Dbyte) (err error)%0A//sys%09Sethostname(p %5B%5Dbyte) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tv *Timeval) (err error)%0A%0A//sys%09Setuid(uid int) (err error)%0A//sys%09Setgid(uid int) (err error)%0A%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sys%09Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error)%0A//sys%09Sync()%0A//sys%09Tee(rfd int, wfd int, len int, flags int) (n int64, err error)%0A//sysnb%09Times(tms *Tms) (ticks uintptr, err error)%0A//sysnb%09Umask(mask int) (oldmask int)%0A//sysnb%09Uname(buf *Utsname) (err error)%0A//TODO umount%0A// //sys%09Unmount(target string, flags int) (err error) = umount%0A//sys   Unlink(path string) (err error)%0A//sys   Unlinkat(dirfd int, path string, flags int) (err error)%0A//sys%09Unshare(flags int) (err error)%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09readlen(fd int, p *byte, np int) (n int, err error) = read%0A//sys%09writelen(fd int, p *byte, np int) (n int, err error) = write%0A%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = posix_fadvise64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = fstatat%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = pread64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = pwrite64%0A//TODO Select%0A// //sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)%0A//sys%09Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A%0A//sys%09munmap(addr uintptr, length uintptr) (err error)%0A%0Avar mapper = &mmapper%7B%0A%09active: make(map%5B*byte%5D%5B%5Dbyte),%0A%09mmap:   mmap,%0A%09munmap: munmap,%0A%7D%0A%0Afunc Mmap(fd int, offset int64, length int, prot int, flags int) (data %5B%5Dbyte, err error) %7B%0A%09return mapper.Mmap(fd, offset, length, prot, flags)%0A%7D%0A%0Afunc Munmap(b %5B%5Dbyte) (err error) %7B%0A%09return mapper.Munmap(b)%0A%7D%0A%0A//sys%09Madvise(b %5B%5Dbyte, advice int) (err error)%0A//sys%09Mprotect(b %5B%5Dbyte, prot int) (err error)%0A//sys%09Mlock(b %5B%5Dbyte) (err error)%0A//sys%09Mlockall(flags int) (err error)%0A//sys%09Msync(b %5B%5Dbyte, flags int) (err error)%0A//sys%09Munlock(b %5B%5Dbyte) (err error)%0A//sys%09Munlockall() (err error)%0A%0A//sysnb pipe(p *%5B2%5D_C_int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A%0A//sys%09gettimeofday(tv *Timeval, tzp *Timezone) (err error)%0A//sysnb%09Time(t *Time_t) (tt Time_t, err error)%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A
+ f 4ff83e174cce91475183c62dbb70f83008c0eac465ba21851bd6cb77efd405af vendor/golang.org/x/sys/unix/syscall_aix_ppc.go
dmppatch 2
@@ -0,0 +1,965 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build aix%0A// +build ppc%0A%0Apackage unix%0A%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error) = getrlimit64%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error) = setrlimit64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = lseek64%0A%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
+ f 3a2131a3c7a1e85ff4086d3480b0f9367e50abd319a7bd331be0953366aeead8 vendor/golang.org/x/sys/unix/syscall_aix_ppc64.go
dmppatch 2
@@ -0,0 +1,932 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build aix%0A// +build ppc64%0A%0Apackage unix%0A%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = lseek%0A%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) = mmap64%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int64(sec), Usec: int32(usec)%7D%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f f0a144a5444fa685418379a03e1d79986007a30e17199e85b06c25c66d2a806d vendor/golang.org/x/sys/unix/syscall_bsd.go
+ f 729fec93503a4c011329712f64e41b3aabe68e00e4aaf2a791ed1ed97809ecaf vendor/golang.org/x/sys/unix/syscall_bsd.go
dmppatch 3
@@ -483,8 +483,15534 @@
 ge unix%0A
+%0Aimport (%0A%09%22runtime%22%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0A/*%0A * Wrapped%0A */%0A%0A//sysnb%09getgroups(ngid int, gid *_Gid_t) (n int, err error)%0A//sysnb%09setgroups(ngid int, gid *_Gid_t) (err error)%0A%0Afunc Getgroups() (gids %5B%5Dint, err error) %7B%0A%09n, err := getgroups(0, nil)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n == 0 %7B%0A%09%09return nil, nil%0A%09%7D%0A%0A%09// Sanity check group count. Max is 16 on BSD.%0A%09if n %3C 0 %7C%7C n %3E 1000 %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, n)%0A%09n, err = getgroups(n, &a%5B0%5D)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09gids = make(%5B%5Dint, n)%0A%09for i, v := range a%5B0:n%5D %7B%0A%09%09gids%5Bi%5D = int(v)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setgroups(gids %5B%5Dint) (err error) %7B%0A%09if len(gids) == 0 %7B%0A%09%09return setgroups(0, nil)%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, len(gids))%0A%09for i, v := range gids %7B%0A%09%09a%5Bi%5D = _Gid_t(v)%0A%09%7D%0A%09return setgroups(len(a), &a%5B0%5D)%0A%7D%0A%0Afunc ReadDirent(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09// Final argument is (basep *uintptr) and the syscall doesn't take nil.%0A%09// 64 bits should be enough. (32 bits isn't even on 386). Since the%0A%09// actual system call is getdirentries64, 64 is a good guess.%0A%09// TODO(rsc): Can we use a single global basep for all calls?%0A%09var base = (*uintptr)(unsafe.Pointer(new(uint64)))%0A%09return Getdirentries(fd, buf, base)%0A%7D%0A%0A// Wait status is 7 bits at bottom, either 0 (exited),%0A// 0x7F (stopped), or a signal number that caused an exit.%0A// The 0x80 bit is whether there was a core dump.%0A// An extra number (exit code, signal causing a stop)%0A// is in the high bits.%0A%0Atype WaitStatus uint32%0A%0Aconst (%0A%09mask  = 0x7F%0A%09core  = 0x80%0A%09shift = 8%0A%0A%09exited  = 0%0A%09stopped = 0x7F%0A)%0A%0Afunc (w WaitStatus) Exited() bool %7B return w&mask == exited %7D%0A%0Afunc (w WaitStatus) ExitStatus() int %7B%0A%09if w&mask != exited %7B%0A%09%09return -1%0A%09%7D%0A%09return int(w %3E%3E shift)%0A%7D%0A%0Afunc (w WaitStatus) Signaled() bool %7B return w&mask != stopped && w&mask != 0 %7D%0A%0Afunc (w WaitStatus) Signal() syscall.Signal %7B%0A%09sig := syscall.Signal(w & mask)%0A%09if sig == stopped %7C%7C sig == 0 %7B%0A%09%09return -1%0A%09%7D%0A%09return sig%0A%7D%0A%0Afunc (w WaitStatus) CoreDump() bool %7B return w.Signaled() && w&core != 0 %7D%0A%0Afunc (w WaitStatus) Stopped() bool %7B return w&mask == stopped && syscall.Signal(w%3E%3Eshift) != SIGSTOP %7D%0A%0Afunc (w WaitStatus) Continued() bool %7B return w&mask == stopped && syscall.Signal(w%3E%3Eshift) == SIGSTOP %7D%0A%0Afunc (w WaitStatus) StopSignal() syscall.Signal %7B%0A%09if !w.Stopped() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w%3E%3Eshift) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) TrapCause() int %7B return -1 %7D%0A%0A//sys%09wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error)%0A%0Afunc Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09var status _C_int%0A%09wpid, err = wait4(pid, &status, options, rusage)%0A%09if wstatus != nil %7B%0A%09%09*wstatus = WaitStatus(status)%0A%09%7D%0A%09return%0A%7D%0A%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09Shutdown(s int, how int) (err error)%0A%0Afunc (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Len = SizeofSockaddrInet4%0A%09sa.raw.Family = AF_INET%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), _Socklen(sa.raw.Len), nil%0A%7D%0A%0Afunc (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Len = SizeofSockaddrInet6%0A%09sa.raw.Family = AF_INET6%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09sa.raw.Scope_id = sa.ZoneId%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), _Socklen(sa.raw.Len), nil%0A%7D%0A%0Afunc (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09name := sa.Name%0A%09n := len(name)%0A%09if n %3E= len(sa.raw.Path) %7C%7C n == 0 %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Len = byte(3 + n) // 2 for Family, Len; 1 for NUL%0A%09sa.raw.Family = AF_UNIX%0A%09for i := 0; i %3C n; i++ %7B%0A%09%09sa.raw.Path%5Bi%5D = int8(name%5Bi%5D)%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), _Socklen(sa.raw.Len), nil%0A%7D%0A%0Afunc (sa *SockaddrDatalink) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Index == 0 %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Len = sa.Len%0A%09sa.raw.Family = AF_LINK%0A%09sa.raw.Index = sa.Index%0A%09sa.raw.Type = sa.Type%0A%09sa.raw.Nlen = sa.Nlen%0A%09sa.raw.Alen = sa.Alen%0A%09sa.raw.Slen = sa.Slen%0A%09for i := 0; i %3C len(sa.raw.Data); i++ %7B%0A%09%09sa.raw.Data%5Bi%5D = sa.Data%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrDatalink, nil%0A%7D%0A%0Afunc anyToSockaddr(fd int, rsa *RawSockaddrAny) (Sockaddr, error) %7B%0A%09switch rsa.Addr.Family %7B%0A%09case AF_LINK:%0A%09%09pp := (*RawSockaddrDatalink)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrDatalink)%0A%09%09sa.Len = pp.Len%0A%09%09sa.Family = pp.Family%0A%09%09sa.Index = pp.Index%0A%09%09sa.Type = pp.Type%0A%09%09sa.Nlen = pp.Nlen%0A%09%09sa.Alen = pp.Alen%0A%09%09sa.Slen = pp.Slen%0A%09%09for i := 0; i %3C len(sa.Data); i++ %7B%0A%09%09%09sa.Data%5Bi%5D = pp.Data%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_UNIX:%0A%09%09pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))%0A%09%09if pp.Len %3C 2 %7C%7C pp.Len %3E SizeofSockaddrUnix %7B%0A%09%09%09return nil, EINVAL%0A%09%09%7D%0A%09%09sa := new(SockaddrUnix)%0A%0A%09%09// Some BSDs include the trailing NUL in the length, whereas%0A%09%09// others do not. Work around this by subtracting the leading%0A%09%09// family and len. The path is then scanned to see if a NUL%0A%09%09// terminator still exists within the length.%0A%09%09n := int(pp.Len) - 2 // subtract leading Family, Len%0A%09%09for i := 0; i %3C n; i++ %7B%0A%09%09%09if pp.Path%5Bi%5D == 0 %7B%0A%09%09%09%09// found early NUL; assume Len included the NUL%0A%09%09%09%09// or was overestimating.%0A%09%09%09%09n = i%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%7D%0A%09%09bytes := (*%5B10000%5Dbyte)(unsafe.Pointer(&pp.Path%5B0%5D))%5B0:n%5D%0A%09%09sa.Name = string(bytes)%0A%09%09return sa, nil%0A%0A%09case AF_INET:%0A%09%09pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet4)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_INET6:%0A%09%09pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet6)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09sa.ZoneId = pp.Scope_id%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%09%7D%0A%09return nil, EAFNOSUPPORT%0A%7D%0A%0Afunc Accept(fd int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept(fd, &rsa, &len)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09if runtime.GOOS == %22darwin%22 && len == 0 %7B%0A%09%09// Accepted socket has no address.%0A%09%09// This is likely due to a bug in xnu kernels,%0A%09%09// where instead of ECONNABORTED error socket%0A%09%09// is accepted, but has no address.%0A%09%09Close(nfd)%0A%09%09return 0, nil, ECONNABORTED%0A%09%7D%0A%09sa, err = anyToSockaddr(fd, &rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getsockname(fd int) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if err = getsockname(fd, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09// TODO(jsing): DragonFly has a %22bug%22 (see issue 3349), which should be%0A%09// reported upstream.%0A%09if runtime.GOOS == %22dragonfly%22 && rsa.Addr.Family == AF_UNSPEC && rsa.Addr.Len == 0 %7B%0A%09%09rsa.Addr.Family = AF_UNIX%0A%09%09rsa.Addr.Len = SizeofSockaddrUnix%0A%09%7D%0A%09return anyToSockaddr(fd, &rsa)%0A%7D%0A%0A//sysnb socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A%0A// GetsockoptString returns the string value of the socket option opt for the%0A// socket associated with fd at the given socket level.%0Afunc GetsockoptString(fd, level, opt int) (string, error) %7B%0A%09buf := make(%5B%5Dbyte, 256)%0A%09vallen := _Socklen(len(buf))%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&buf%5B0%5D), &vallen)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09return string(buf%5B:vallen-1%5D), nil%0A%7D%0A%0A//sys   recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys   sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A%0Afunc Recvmsg(fd int, p, oob %5B%5Dbyte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) %7B%0A%09var msg Msghdr%0A%09var rsa RawSockaddrAny%0A%09msg.Name = (*byte)(unsafe.Pointer(&rsa))%0A%09msg.Namelen = uint32(SizeofSockaddrAny)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = (*byte)(unsafe.Pointer(&p%5B0%5D))%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy byte%0A%09if len(oob) %3E 0 %7B%0A%09%09// receive at least one normal byte%0A%09%09if len(p) == 0 %7B%0A%09%09%09iov.Base = &dummy%0A%09%09%09iov.SetLen(1)%0A%09%09%7D%0A%09%09msg.Control = (*byte)(unsafe.Pointer(&oob%5B0%5D))%0A%09%09msg.SetControllen(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = recvmsg(fd, &msg, flags); err != nil %7B%0A%09%09return%0A%09%7D%0A%09oobn = int(msg.Controllen)%0A%09recvflags = int(msg.Flags)%0A%09// source address is only specified if the socket is unconnected%0A%09if rsa.Addr.Family != AF_UNSPEC %7B%0A%09%09from, err = anyToSockaddr(fd, &rsa)%0A%09%7D%0A%09return%0A%7D%0A%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A%0Afunc Sendmsg(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (err error) %7B%0A%09_, err = SendmsgN(fd, p, oob, to, flags)%0A%09return%0A%7D%0A%0Afunc SendmsgN(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (n int, err error) %7B%0A%09var ptr unsafe.Pointer%0A%09var salen _Socklen%0A%09if to != nil %7B%0A%09%09ptr, salen, err = to.sockaddr()%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%7D%0A%09var msg Msghdr%0A%09msg.Name = (*byte)(unsafe.Pointer(ptr))%0A%09msg.Namelen = uint32(salen)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = (*byte)(unsafe.Pointer(&p%5B0%5D))%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy byte%0A%09if len(oob) %3E 0 %7B%0A%09%09// send at least one normal byte%0A%09%09if len(p) == 0 %7B%0A%09%09%09iov.Base = &dummy%0A%09%09%09iov.SetLen(1)%0A%09%09%7D%0A%09%09msg.Control = (*byte)(unsafe.Pointer(&oob%5B0%5D))%0A%09%09msg.SetControllen(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = sendmsg(fd, &msg, flags); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if len(oob) %3E 0 && len(p) == 0 %7B%0A%09%09n = 0%0A%09%7D%0A%09return n, nil%0A%7D%0A%0A//sys%09kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error)%0A%0Afunc Kevent(kq int, changes, events %5B%5DKevent_t, timeout *Timespec) (n int, err error) %7B%0A%09var change, event unsafe.Pointer%0A%09if len(changes) %3E 0 %7B%0A%09%09change = unsafe.Pointer(&changes%5B0%5D)%0A%09%7D%0A%09if len(events) %3E 0 %7B%0A%09%09event = unsafe.Pointer(&events%5B0%5D)%0A%09%7D%0A%09return kevent(kq, change, len(changes), event, len(events), timeout)%0A%7D%0A%0A//sys%09sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) = SYS___SYSCTL%0A%0A// sysctlmib translates name to mib number and appends any additional args.%0Afunc sysctlmib(name string, args ...int) (%5B%5D_C_int, error) %7B%0A%09// Translate name to mib number.%0A%09mib, err := nametomib(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09for _, a := range args %7B%0A%09%09mib = append(mib, _C_int(a))%0A%09%7D%0A%0A%09return mib, nil%0A%7D%0A%0Afunc Sysctl(name string) (string, error) %7B%0A%09return SysctlArgs(name)%0A%7D%0A%0Afunc SysctlArgs(name string, args ...int) (string, error) %7B%0A%09buf, err := SysctlRaw(name, args...)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := len(buf)%0A%0A%09// Throw away terminating NUL.%0A%09if n %3E 0 && buf%5Bn-1%5D == '%5Cx00' %7B%0A%09%09n--%0A%09%7D%0A%09return string(buf%5B0:n%5D), nil%0A%7D%0A%0Afunc SysctlUint32(name string) (uint32, error) %7B%0A%09return SysctlUint32Args(name)%0A%7D%0A%0Afunc SysctlUint32Args(name string, args ...int) (uint32, error) %7B%0A%09mib, err := sysctlmib(name, args...)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%0A%09n := uintptr(4)%0A%09buf := make(%5B%5Dbyte, 4)%0A%09if err := sysctl(mib, &buf%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if n != 4 %7B%0A%09%09return 0, EIO%0A%09%7D%0A%09return *(*uint32)(unsafe.Pointer(&buf%5B0%5D)), nil%0A%7D%0A%0Afunc SysctlUint64(name string, args ...int) (uint64, error) %7B%0A%09mib, err := sysctlmib(name, args...)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%0A%09n := uintptr(8)%0A%09buf := make(%5B%5Dbyte, 8)%0A%09if err := sysctl(mib, &buf%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if n != 8 %7B%0A%09%09return 0, EIO%0A%09%7D%0A%09return *(*uint64)(unsafe.Pointer(&buf%5B0%5D)), nil%0A%7D%0A%0Afunc SysctlRaw(name string, args ...int) (%5B%5Dbyte, error) %7B%0A%09mib, err := sysctlmib(name, args...)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Find size.%0A%09n := uintptr(0)%0A%09if err := sysctl(mib, nil, &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n == 0 %7B%0A%09%09return nil, nil%0A%09%7D%0A%0A%09// Read into buffer of that size.%0A%09buf := make(%5B%5Dbyte, n)%0A%09if err := sysctl(mib, &buf%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// The actual call may return less than the original reported required%0A%09// size so ensure we deal with that.%0A%09return buf%5B:n%5D, nil%0A%7D%0A%0A//sys%09utimes(path string, timeval *%5B2%5DTimeval) (err error)%0A%0Afunc Utimes(path string, tv %5B%5DTimeval) error %7B%0A%09if tv == nil %7B%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc UtimesNano(path string, ts %5B%5DTimespec) error %7B%0A%09if ts == nil %7B%0A%09%09err := utimensat(AT_FDCWD, path, nil, 0)%0A%09%09if err != ENOSYS %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09// Darwin setattrlist can set nanosecond timestamps%0A%09err := setattrlistTimes(path, ts, 0)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09err = utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09// Not as efficient as it could be because Timespec and%0A%09// Timeval have different types in the different OSes%0A%09tv := %5B2%5DTimeval%7B%0A%09%09NsecToTimeval(TimespecToNsec(ts%5B0%5D)),%0A%09%09NsecToTimeval(TimespecToNsec(ts%5B1%5D)),%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc UtimesNanoAt(dirfd int, path string, ts %5B%5DTimespec, flags int) error %7B%0A%09if ts == nil %7B%0A%09%09return utimensat(dirfd, path, nil, flags)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09err := setattrlistTimes(path, ts, flags)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09return utimensat(dirfd, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), flags)%0A%7D%0A%0A//sys%09futimes(fd int, timeval *%5B2%5DTimeval) (err error)%0A%0Afunc Futimes(fd int, tv %5B%5DTimeval) error %7B%0A%09if tv == nil %7B%0A%09%09return futimes(fd, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return futimes(fd, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0A//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A%0A//sys   poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A%0A// TODO: wrap%0A//%09Acct(name nil-string) (err error)%0A//%09Gethostuuid(uuid *byte, timeout *Timespec) (err error)%0A//%09Ptrace(req int, pid int, addr uintptr, data int) (ret uintptr, err error)%0A%0Avar mapper = &mmapper%7B%0A%09active: make(map%5B*byte%5D%5B%5Dbyte),%0A%09mmap:   mmap,%0A%09munmap: munmap,%0A%7D%0A%0Afunc Mmap(fd int, offset int64, length int, prot int, flags int) (data %5B%5Dbyte, err error) %7B%0A%09return mapper.Mmap(fd, offset, length, prot, flags)%0A%7D%0A%0Afunc Munmap(b %5B%5Dbyte) (err error) %7B%0A%09return mapper.Munmap(b)%0A%7D%0A%0A//sys%09Madvise(b %5B%5Dbyte, behav int) (err error)%0A//sys%09Mlock(b %5B%5Dbyte) (err error)%0A//sys%09Mlockall(flags int) (err error)%0A//sys%09Mprotect(b %5B%5Dbyte, prot int) (err error)%0A//sys%09Msync(b %5B%5Dbyte, flags int) (err error)%0A//sys%09Munlock(b %5B%5Dbyte) (err error)%0A//sys%09Munlockall() (err error)%0A
- f 80f51fbe92fe4d1368dbdb79be20b90edc41346d1b214b52800ef3c44a1376e5 vendor/golang.org/x/sys/unix/syscall_darwin.go
+ f c00acf8a089b73b371660c4e8754451ddcdb72a90ac0f26ba017301986c6c7a4 vendor/golang.org/x/sys/unix/syscall_darwin.go
dmppatch 15
@@ -512,16 +512,37 @@
 mport (%0A
+%09%22errors%22%0A%09%22syscall%22%0A
 %09%22unsafe
@@ -546,16 +546,9372 @@
 afe%22%0A)%0A%0A
+const ImplementsGetwd = true%0A%0Afunc Getwd() (string, error) %7B%0A%09buf := make(%5B%5Dbyte, 2048)%0A%09attrs, err := getAttrList(%22.%22, attrList%7BCommonAttr: attrCmnFullpath%7D, buf, 0)%0A%09if err == nil && len(attrs) == 1 && len(attrs%5B0%5D) %3E= 2 %7B%0A%09%09wd := string(attrs%5B0%5D)%0A%09%09// Sanity check that it's an absolute path and ends%0A%09%09// in a null byte, which we then strip.%0A%09%09if wd%5B0%5D == '/' && wd%5Blen(wd)-1%5D == 0 %7B%0A%09%09%09return wd%5B:len(wd)-1%5D, nil%0A%09%09%7D%0A%09%7D%0A%09// If pkg/os/getwd.go gets ENOTSUP, it will fall back to the%0A%09// slow algorithm.%0A%09return %22%22, ENOTSUP%0A%7D%0A%0A// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0A// Translate %22kern.hostname%22 to %5B%5D_C_int%7B0,1,2,3%7D.%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09const siz = unsafe.Sizeof(mib%5B0%5D)%0A%0A%09// NOTE(rsc): It seems strange to set the buffer to have%0A%09// size CTL_MAXNAME+2 but use only CTL_MAXNAME%0A%09// as the size. I don't know why the +2 is here, but the%0A%09// kernel uses +2 for its own implementation of this function.%0A%09// I am scared that if we don't include the +2 here, the kernel%0A%09// will silently write 2 words farther than we specify%0A%09// and we'll get memory corruption.%0A%09var buf %5BCTL_MAXNAME + 2%5D_C_int%0A%09n := uintptr(CTL_MAXNAME) * siz%0A%0A%09p := (*byte)(unsafe.Pointer(&buf%5B0%5D))%0A%09bytes, err := ByteSliceFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Magic sysctl: %22setting%22 0.3 to a string name%0A%09// lets you read back the array of integers form.%0A%09if err = sysctl(%5B%5D_C_int%7B0, 3%7D, p, &n, &bytes%5B0%5D, uintptr(len(name))); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return buf%5B0 : n/siz%5D, nil%0A%7D%0A%0A//sys   ptrace(request int, pid int, addr uintptr, data uintptr) (err error)%0Afunc PtraceAttach(pid int) (err error) %7B return ptrace(PT_ATTACH, pid, 0, 0) %7D%0Afunc PtraceDetach(pid int) (err error) %7B return ptrace(PT_DETACH, pid, 0, 0) %7D%0A%0Aconst (%0A%09attrBitMapCount = 5%0A%09attrCmnFullpath = 0x08000000%0A)%0A%0Atype attrList struct %7B%0A%09bitmapCount uint16%0A%09_           uint16%0A%09CommonAttr  uint32%0A%09VolAttr     uint32%0A%09DirAttr     uint32%0A%09FileAttr    uint32%0A%09Forkattr    uint32%0A%7D%0A%0Afunc getAttrList(path string, attrList attrList, attrBuf %5B%5Dbyte, options uint) (attrs %5B%5D%5B%5Dbyte, err error) %7B%0A%09if len(attrBuf) %3C 4 %7B%0A%09%09return nil, errors.New(%22attrBuf too small%22)%0A%09%7D%0A%09attrList.bitmapCount = attrBitMapCount%0A%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09_, _, e1 := Syscall6(%0A%09%09SYS_GETATTRLIST,%0A%09%09uintptr(unsafe.Pointer(_p0)),%0A%09%09uintptr(unsafe.Pointer(&attrList)),%0A%09%09uintptr(unsafe.Pointer(&attrBuf%5B0%5D)),%0A%09%09uintptr(len(attrBuf)),%0A%09%09uintptr(options),%0A%09%090,%0A%09)%0A%09if e1 != 0 %7B%0A%09%09return nil, e1%0A%09%7D%0A%09size := *(*uint32)(unsafe.Pointer(&attrBuf%5B0%5D))%0A%0A%09// dat is the section of attrBuf that contains valid data,%0A%09// without the 4 byte length header. All attribute offsets%0A%09// are relative to dat.%0A%09dat := attrBuf%0A%09if int(size) %3C len(attrBuf) %7B%0A%09%09dat = dat%5B:size%5D%0A%09%7D%0A%09dat = dat%5B4:%5D // remove length prefix%0A%0A%09for i := uint32(0); int(i) %3C len(dat); %7B%0A%09%09header := dat%5Bi:%5D%0A%09%09if len(header) %3C 8 %7B%0A%09%09%09return attrs, errors.New(%22truncated attribute header%22)%0A%09%09%7D%0A%09%09datOff := *(*int32)(unsafe.Pointer(&header%5B0%5D))%0A%09%09attrLen := *(*uint32)(unsafe.Pointer(&header%5B4%5D))%0A%09%09if datOff %3C 0 %7C%7C uint32(datOff)+attrLen %3E uint32(len(dat)) %7B%0A%09%09%09return attrs, errors.New(%22truncated results; attrBuf too small%22)%0A%09%09%7D%0A%09%09end := uint32(datOff) + attrLen%0A%09%09attrs = append(attrs, dat%5BdatOff:end%5D)%0A%09%09i = end%0A%09%09if r := i %25 4; r != 0 %7B%0A%09%09%09i += (4 - r)%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0A//sysnb pipe() (r int, w int, err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09p%5B0%5D, p%5B1%5D, err = pipe()%0A%09return%0A%7D%0A%0Afunc Getfsstat(buf %5B%5DStatfs_t, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09var bufsize uintptr%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%09bufsize = unsafe.Sizeof(Statfs_t%7B%7D) * uintptr(len(buf))%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETFSSTAT64, uintptr(_p0), bufsize, uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc xattrPointer(dest %5B%5Dbyte) *byte %7B%0A%09// It's only when dest is set to NULL that the OS X implementations of%0A%09// getxattr() and listxattr() return the current sizes of the named attributes.%0A%09// An empty byte array is not sufficient. To maintain the same behaviour as the%0A%09// linux implementation, we wrap around the system calls and pass in NULL when%0A%09// dest is empty.%0A%09var destp *byte%0A%09if len(dest) %3E 0 %7B%0A%09%09destp = &dest%5B0%5D%0A%09%7D%0A%09return destp%0A%7D%0A%0A//sys%09getxattr(path string, attr string, dest *byte, size int, position uint32, options int) (sz int, err error)%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09return getxattr(path, attr, xattrPointer(dest), len(dest), 0, 0)%0A%7D%0A%0Afunc Lgetxattr(link string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09return getxattr(link, attr, xattrPointer(dest), len(dest), 0, XATTR_NOFOLLOW)%0A%7D%0A%0A//sys%09fgetxattr(fd int, attr string, dest *byte, size int, position uint32, options int) (sz int, err error)%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09return fgetxattr(fd, attr, xattrPointer(dest), len(dest), 0, 0)%0A%7D%0A%0A//sys%09setxattr(path string, attr string, data *byte, size int, position uint32, options int) (err error)%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09// The parameters for the OS X implementation vary slightly compared to the%0A%09// linux system call, specifically the position parameter:%0A%09//%0A%09//  linux:%0A%09//      int setxattr(%0A%09//          const char *path,%0A%09//          const char *name,%0A%09//          const void *value,%0A%09//          size_t size,%0A%09//          int flags%0A%09//      );%0A%09//%0A%09//  darwin:%0A%09//      int setxattr(%0A%09//          const char *path,%0A%09//          const char *name,%0A%09//          void *value,%0A%09//          size_t size,%0A%09//          u_int32_t position,%0A%09//          int options%0A%09//      );%0A%09//%0A%09// position specifies the offset within the extended attribute. In the%0A%09// current implementation, only the resource fork extended attribute makes%0A%09// use of this argument. For all others, position is reserved. We simply%0A%09// default to setting it to zero.%0A%09return setxattr(path, attr, xattrPointer(data), len(data), 0, flags)%0A%7D%0A%0Afunc Lsetxattr(link string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09return setxattr(link, attr, xattrPointer(data), len(data), 0, flags%7CXATTR_NOFOLLOW)%0A%7D%0A%0A//sys%09fsetxattr(fd int, attr string, data *byte, size int, position uint32, options int) (err error)%0A%0Afunc Fsetxattr(fd int, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09return fsetxattr(fd, attr, xattrPointer(data), len(data), 0, 0)%0A%7D%0A%0A//sys%09removexattr(path string, attr string, options int) (err error)%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09// We wrap around and explicitly zero out the options provided to the OS X%0A%09// implementation of removexattr, we do so for interoperability with the%0A%09// linux variant.%0A%09return removexattr(path, attr, 0)%0A%7D%0A%0Afunc Lremovexattr(link string, attr string) (err error) %7B%0A%09return removexattr(link, attr, XATTR_NOFOLLOW)%0A%7D%0A%0A//sys%09fremovexattr(fd int, attr string, options int) (err error)%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09return fremovexattr(fd, attr, 0)%0A%7D%0A%0A//sys%09listxattr(path string, dest *byte, size int, options int) (sz int, err error)%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09return listxattr(path, xattrPointer(dest), len(dest), 0)%0A%7D%0A%0Afunc Llistxattr(link string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09return listxattr(link, xattrPointer(dest), len(dest), XATTR_NOFOLLOW)%0A%7D%0A%0A//sys%09flistxattr(fd int, dest *byte, size int, options int) (sz int, err error)%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09return flistxattr(fd, xattrPointer(dest), len(dest), 0)%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09_p0, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09var attrList attrList%0A%09attrList.bitmapCount = ATTR_BIT_MAP_COUNT%0A%09attrList.CommonAttr = ATTR_CMN_MODTIME %7C ATTR_CMN_ACCTIME%0A%0A%09// order is mtime, atime: the opposite of Chtimes%0A%09attributes := %5B2%5DTimespec%7Btimes%5B1%5D, times%5B0%5D%7D%0A%09options := 0%0A%09if flags&AT_SYMLINK_NOFOLLOW != 0 %7B%0A%09%09options %7C= FSOPT_NOFOLLOW%0A%09%7D%0A%09_, _, e1 := Syscall6(%0A%09%09SYS_SETATTRLIST,%0A%09%09uintptr(unsafe.Pointer(_p0)),%0A%09%09uintptr(unsafe.Pointer(&attrList)),%0A%09%09uintptr(unsafe.Pointer(&attributes)),%0A%09%09uintptr(unsafe.Sizeof(attributes)),%0A%09%09uintptr(options),%0A%09%090,%0A%09)%0A%09if e1 != 0 %7B%0A%09%09return e1%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) error %7B%0A%09// Darwin doesn't support SYS_UTIMENSAT%0A%09return ENOSYS%0A%7D%0A%0A/*%0A * Wrapped%0A */%0A%0A//sys%09kill(pid int, signum int, posix int) (err error)%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B return kill(pid, int(signum), 1) %7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc ioctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A
 func ioc
@@ -10019,24 +10019,443 @@
 value)))%0A%7D%0A%0A
+// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func IoctlGe
@@ -10578,28 +10578,9011 @@
 ue)))%0A%09return &value, err%0A%7D%0A
+%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctl(mib, &uname.Sysname%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctl(mib, &uname.Nodename%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctl(mib, &uname.Release%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctl(mib, &uname.Version%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctl(mib, &uname.Machine%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exchangedata(path1 string, path2 string, options int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Faccessat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sys%09Fstatfs(fd int, stat *Statfs_t) (err error) = SYS_FSTATFS64%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sys%09Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) = SYS_GETDIRENTRIES64%0A//sys%09Getdtablesize() (size int)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09Issetugid() (tainted bool)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkdirat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Renameat(fromfd int, from string, tofd int, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sys%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Setlogin(name string) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sys%09Setprivexec(flag int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error) = SYS_STAT64%0A//sys%09Statfs(path string, stat *Statfs_t) (err error) = SYS_STATFS64%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Symlinkat(oldpath string, newdirfd int, newpath string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Undelete(path string) (err error)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unlinkat(dirfd int, path string, flags int) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys   mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys   munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A%0A/*%0A * Unimplemented%0A */%0A// Profil%0A// Sigaction%0A// Sigprocmask%0A// Getlogin%0A// Sigpending%0A// Sigaltstack%0A// Ioctl%0A// Reboot%0A// Execve%0A// Vfork%0A// Sbrk%0A// Sstk%0A// Ovadvise%0A// Mincore%0A// Setitimer%0A// Swapon%0A// Select%0A// Sigsuspend%0A// Readv%0A// Writev%0A// Nfssvc%0A// Getfh%0A// Quotactl%0A// Mount%0A// Csops%0A// Waitid%0A// Add_profil%0A// Kdebug_trace%0A// Sigreturn%0A// Atsocket%0A// Kqueue_from_portset_np%0A// Kqueue_portset%0A// Getattrlist%0A// Setattrlist%0A// Getdirentriesattr%0A// Searchfs%0A// Delete%0A// Copyfile%0A// Watchevent%0A// Waitevent%0A// Modwatch%0A// Fsctl%0A// Initgroups%0A// Posix_spawn%0A// Nfsclnt%0A// Fhopen%0A// Minherit%0A// Semsys%0A// Msgsys%0A// Shmsys%0A// Semctl%0A// Semget%0A// Semop%0A// Msgctl%0A// Msgget%0A// Msgsnd%0A// Msgrcv%0A// Shmat%0A// Shmctl%0A// Shmdt%0A// Shmget%0A// Shm_open%0A// Shm_unlink%0A// Sem_open%0A// Sem_close%0A// Sem_unlink%0A// Sem_wait%0A// Sem_trywait%0A// Sem_post%0A// Sem_getvalue%0A// Sem_init%0A// Sem_destroy%0A// Open_extended%0A// Umask_extended%0A// Stat_extended%0A// Lstat_extended%0A// Fstat_extended%0A// Chmod_extended%0A// Fchmod_extended%0A// Access_extended%0A// Settid%0A// Gettid%0A// Setsgroups%0A// Getsgroups%0A// Setwgroups%0A// Getwgroups%0A// Mkfifo_extended%0A// Mkdir_extended%0A// Identitysvc%0A// Shared_region_check_np%0A// Shared_region_map_np%0A// __pthread_mutex_destroy%0A// __pthread_mutex_init%0A// __pthread_mutex_lock%0A// __pthread_mutex_trylock%0A// __pthread_mutex_unlock%0A// __pthread_cond_init%0A// __pthread_cond_destroy%0A// __pthread_cond_broadcast%0A// __pthread_cond_signal%0A// Setsid_with_pid%0A// __pthread_cond_timedwait%0A// Aio_fsync%0A// Aio_return%0A// Aio_suspend%0A// Aio_cancel%0A// Aio_error%0A// Aio_read%0A// Aio_write%0A// Lio_listio%0A// __pthread_cond_wait%0A// Iopolicysys%0A// __pthread_kill%0A// __pthread_sigmask%0A// __sigwait%0A// __disable_threadsignal%0A// __pthread_markcancel%0A// __pthread_canceled%0A// __semwait_signal%0A// Proc_info%0A// sendfile%0A// Stat64_extended%0A// Lstat64_extended%0A// Fstat64_extended%0A// __pthread_chdir%0A// __pthread_fchdir%0A// Audit%0A// Auditon%0A// Getauid%0A// Setauid%0A// Getaudit%0A// Setaudit%0A// Getaudit_addr%0A// Setaudit_addr%0A// Auditctl%0A// Bsdthread_create%0A// Bsdthread_terminate%0A// Stack_snapshot%0A// Bsdthread_register%0A// Workq_open%0A// Workq_ops%0A// __mac_execve%0A// __mac_syscall%0A// __mac_get_file%0A// __mac_set_file%0A// __mac_get_link%0A// __mac_set_link%0A// __mac_get_proc%0A// __mac_set_proc%0A// __mac_get_fd%0A// __mac_set_fd%0A// __mac_get_pid%0A// __mac_get_lcid%0A// __mac_get_lctx%0A// __mac_set_lctx%0A// Setlcid%0A// Read_nocancel%0A// Write_nocancel%0A// Open_nocancel%0A// Close_nocancel%0A// Wait4_nocancel%0A// Recvmsg_nocancel%0A// Sendmsg_nocancel%0A// Recvfrom_nocancel%0A// Accept_nocancel%0A// Fcntl_nocancel%0A// Select_nocancel%0A// Fsync_nocancel%0A// Connect_nocancel%0A// Sigsuspend_nocancel%0A// Readv_nocancel%0A// Writev_nocancel%0A// Sendto_nocancel%0A// Pread_nocancel%0A// Pwrite_nocancel%0A// Waitid_nocancel%0A// Poll_nocancel%0A// Msgsnd_nocancel%0A// Msgrcv_nocancel%0A// Sem_wait_nocancel%0A// Aio_suspend_nocancel%0A// __sigwait_nocancel%0A// __semwait_signal_nocancel%0A// __mac_mount%0A// __mac_get_mount%0A// __mac_getfsstat%0A
- f f8e68826c636141b2520bd1ef89b4e029994751f9e4a981ccd89f4feff99192a vendor/golang.org/x/sys/unix/syscall_darwin_386.go
+ f 395021048a759f7303d722dba61a5e015308b990c0c3d2d0ae15c5081fbc193c vendor/golang.org/x/sys/unix/syscall_darwin_386.go
dmppatch 3
@@ -188,8 +188,1543 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09gettimeofday(tp *Timeval) (sec int32, usec int32, err error)%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09// The tv passed to gettimeofday must be non-nil%0A%09// but is otherwise unused. The answers come back%0A%09// in the two registers.%0A%09sec, usec, err := gettimeofday(tv)%0A%09tv.Sec = int32(sec)%0A%09tv.Usec = int32(usec)%0A%09return err%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var length = uint64(count)%0A%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(*offset%3E%3E32), uintptr(unsafe.Pointer(&length)), 0, 0, 0, 0)%0A%0A%09written = int(length)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0A// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions%0A// of darwin/386 the syscall is called sysctl instead of __sysctl.%0Aconst SYS___SYSCTL = SYS_SYSCTL%0A
- f b423cadba8f15723f8eefae05d919fddbf91bb34c2ef88c7e257292c3e8bf83c vendor/golang.org/x/sys/unix/syscall_darwin_amd64.go
+ f 1ffa9e27faa404a7506ea1358ae69333c001323c582f2afe6e18e5582ade0a60 vendor/golang.org/x/sys/unix/syscall_darwin_amd64.go
dmppatch 3
@@ -190,8 +190,1482 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09gettimeofday(tp *Timeval) (sec int64, usec int32, err error)%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09// The tv passed to gettimeofday must be non-nil%0A%09// but is otherwise unused. The answers come back%0A%09// in the two registers.%0A%09sec, usec, err := gettimeofday(tv)%0A%09tv.Sec = sec%0A%09tv.Usec = usec%0A%09return err%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var length = uint64(count)%0A%0A%09_, _, e1 := Syscall6(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(unsafe.Pointer(&length)), 0, 0)%0A%0A%09written = int(length)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0A// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions%0A// of darwin/amd64 the syscall is called sysctl instead of __sysctl.%0Aconst SYS___SYSCTL = SYS_SYSCTL%0A
- f 4a21088d9836ce36d1b091d5a51d2c2d91302b0f270a8d923b857cb95f12730a vendor/golang.org/x/sys/unix/syscall_darwin_arm.go
+ f e3007635e9c073e8d69e47879f9daeec216836fe9eae382038b726b6aa9ed243 vendor/golang.org/x/sys/unix/syscall_darwin_arm.go
dmppatch 3
@@ -166,8 +166,1550 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09gettimeofday(tp *Timeval) (sec int32, usec int32, err error)%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09// The tv passed to gettimeofday must be non-nil%0A%09// but is otherwise unused. The answers come back%0A%09// in the two registers.%0A%09sec, usec, err := gettimeofday(tv)%0A%09tv.Sec = int32(sec)%0A%09tv.Usec = int32(usec)%0A%09return err%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var length = uint64(count)%0A%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(*offset%3E%3E32), uintptr(unsafe.Pointer(&length)), 0, 0, 0, 0)%0A%0A%09written = int(length)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno) // sic%0A%0A// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions%0A// of darwin/arm the syscall is called sysctl instead of __sysctl.%0Aconst SYS___SYSCTL = SYS_SYSCTL%0A
- f b4247f13543c30b1db978356df9b335110b2e034793850b1aea1d9b6c8792e60 vendor/golang.org/x/sys/unix/syscall_darwin_arm64.go
+ f 3ff0176780fe143c878e633f13d9b464d764f860f19d77d719b45777deaafa51 vendor/golang.org/x/sys/unix/syscall_darwin_arm64.go
dmppatch 3
@@ -190,8 +190,1489 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09gettimeofday(tp *Timeval) (sec int64, usec int32, err error)%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09// The tv passed to gettimeofday must be non-nil%0A%09// but is otherwise unused. The answers come back%0A%09// in the two registers.%0A%09sec, usec, err := gettimeofday(tv)%0A%09tv.Sec = sec%0A%09tv.Usec = usec%0A%09return err%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var length = uint64(count)%0A%0A%09_, _, e1 := Syscall6(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(unsafe.Pointer(&length)), 0, 0)%0A%0A%09written = int(length)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno) // sic%0A%0A// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions%0A// of darwin/arm64 the syscall is called sysctl instead of __sysctl.%0Aconst SYS___SYSCTL = SYS_SYSCTL%0A
- f 194707e3dc851b21f0b2715aa66a53857a38ce2e67070a53a7f24f845ee3486b vendor/golang.org/x/sys/unix/syscall_dragonfly.go
+ f 27c3d83aa59884480b348b94beed7c293631d7e63834c049aa2e7b1088482cd8 vendor/golang.org/x/sys/unix/syscall_dragonfly.go
dmppatch 11
@@ -522,16 +522,3403 @@
 nsafe%22%0A%0A
+// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%09Rcf    uint16%0A%09Route  %5B16%5Duint16%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0A// Translate %22kern.hostname%22 to %5B%5D_C_int%7B0,1,2,3%7D.%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09const siz = unsafe.Sizeof(mib%5B0%5D)%0A%0A%09// NOTE(rsc): It seems strange to set the buffer to have%0A%09// size CTL_MAXNAME+2 but use only CTL_MAXNAME%0A%09// as the size. I don't know why the +2 is here, but the%0A%09// kernel uses +2 for its own implementation of this function.%0A%09// I am scared that if we don't include the +2 here, the kernel%0A%09// will silently write 2 words farther than we specify%0A%09// and we'll get memory corruption.%0A%09var buf %5BCTL_MAXNAME + 2%5D_C_int%0A%09n := uintptr(CTL_MAXNAME) * siz%0A%0A%09p := (*byte)(unsafe.Pointer(&buf%5B0%5D))%0A%09bytes, err := ByteSliceFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Magic sysctl: %22setting%22 0.3 to a string name%0A%09// lets you read back the array of integers form.%0A%09if err = sysctl(%5B%5D_C_int%7B0, 3%7D, p, &n, &bytes%5B0%5D, uintptr(len(name))); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return buf%5B0 : n/siz%5D, nil%0A%7D%0A%0A//sysnb pipe() (r int, w int, err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09p%5B0%5D, p%5B1%5D, err = pipe()%0A%09return%0A%7D%0A%0A//sys%09extpread(fd int, p %5B%5Dbyte, flags int, offset int64) (n int, err error)%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09return extpread(fd, p, 0, offset)%0A%7D%0A%0A//sys%09extpwrite(fd int, p %5B%5Dbyte, flags int, offset int64) (n int, err error)%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09return extpwrite(fd, p, 0, offset)%0A%7D%0A%0Afunc Accept4(fd, flags int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept4(fd, &rsa, &len, flags)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09if len %3E SizeofSockaddrAny %7B%0A%09%09panic(%22RawSockaddrAny too small%22)%0A%09%7D%0A%09sa, err = anyToSockaddr(fd, &rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error) = SYS___GETCWD%0A%0Afunc Getwd() (string, error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09_, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0Afunc Getfsstat(buf %5B%5DStatfs_t, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09var bufsize uintptr%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%09bufsize = unsafe.Sizeof(Statfs_t%7B%7D) * uintptr(len(buf))%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(_p0), bufsize, uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09// used on Darwin for UtimesNano%0A%09return ENOSYS%0A%7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc ioctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A
 func ioc
@@ -4026,24 +4026,443 @@
 value)))%0A%7D%0A%0A
+// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func IoctlGe
@@ -4585,28 +4585,9077 @@
 ue)))%0A%09return &value, err%0A%7D%0A
+%0Afunc sysctlUname(mib %5B%5D_C_int, old *byte, oldlen *uintptr) error %7B%0A%09err := sysctl(mib, old, oldlen, nil, 0)%0A%09if err != nil %7B%0A%09%09// Utsname members on Dragonfly are only 32 bytes and%0A%09%09// the syscall returns ENOMEM in case the actual value%0A%09%09// is longer.%0A%09%09if err == ENOMEM %7B%0A%09%09%09err = nil%0A%09%09%7D%0A%09%7D%0A%09return err%0A%7D%0A%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctlUname(mib, &uname.Sysname%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09uname.Sysname%5Bunsafe.Sizeof(uname.Sysname)-1%5D = 0%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctlUname(mib, &uname.Nodename%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09uname.Nodename%5Bunsafe.Sizeof(uname.Nodename)-1%5D = 0%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctlUname(mib, &uname.Release%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09uname.Release%5Bunsafe.Sizeof(uname.Release)-1%5D = 0%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctlUname(mib, &uname.Version%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctlUname(mib, &uname.Machine%5B0%5D, &n); err != nil %7B%0A%09%09return err%0A%09%7D%0A%09uname.Machine%5Bunsafe.Sizeof(uname.Machine)-1%5D = 0%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatfs(fd int, stat *Statfs_t) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sys%09Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error)%0A//sys%09Getdtablesize() (size int)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Issetugid() (tainted bool)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Setlogin(name string) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, stat *Statfs_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Undelete(path string) (err error)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys   mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys   munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A//sys%09accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error)%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0A/*%0A * Unimplemented%0A * TODO(jsing): Update this list for DragonFly.%0A */%0A// Profil%0A// Sigaction%0A// Sigprocmask%0A// Getlogin%0A// Sigpending%0A// Sigaltstack%0A// Reboot%0A// Execve%0A// Vfork%0A// Sbrk%0A// Sstk%0A// Ovadvise%0A// Mincore%0A// Setitimer%0A// Swapon%0A// Select%0A// Sigsuspend%0A// Readv%0A// Writev%0A// Nfssvc%0A// Getfh%0A// Quotactl%0A// Mount%0A// Csops%0A// Waitid%0A// Add_profil%0A// Kdebug_trace%0A// Sigreturn%0A// Atsocket%0A// Kqueue_from_portset_np%0A// Kqueue_portset%0A// Getattrlist%0A// Setattrlist%0A// Getdirentriesattr%0A// Searchfs%0A// Delete%0A// Copyfile%0A// Watchevent%0A// Waitevent%0A// Modwatch%0A// Getxattr%0A// Fgetxattr%0A// Setxattr%0A// Fsetxattr%0A// Removexattr%0A// Fremovexattr%0A// Listxattr%0A// Flistxattr%0A// Fsctl%0A// Initgroups%0A// Posix_spawn%0A// Nfsclnt%0A// Fhopen%0A// Minherit%0A// Semsys%0A// Msgsys%0A// Shmsys%0A// Semctl%0A// Semget%0A// Semop%0A// Msgctl%0A// Msgget%0A// Msgsnd%0A// Msgrcv%0A// Shmat%0A// Shmctl%0A// Shmdt%0A// Shmget%0A// Shm_open%0A// Shm_unlink%0A// Sem_open%0A// Sem_close%0A// Sem_unlink%0A// Sem_wait%0A// Sem_trywait%0A// Sem_post%0A// Sem_getvalue%0A// Sem_init%0A// Sem_destroy%0A// Open_extended%0A// Umask_extended%0A// Stat_extended%0A// Lstat_extended%0A// Fstat_extended%0A// Chmod_extended%0A// Fchmod_extended%0A// Access_extended%0A// Settid%0A// Gettid%0A// Setsgroups%0A// Getsgroups%0A// Setwgroups%0A// Getwgroups%0A// Mkfifo_extended%0A// Mkdir_extended%0A// Identitysvc%0A// Shared_region_check_np%0A// Shared_region_map_np%0A// __pthread_mutex_destroy%0A// __pthread_mutex_init%0A// __pthread_mutex_lock%0A// __pthread_mutex_trylock%0A// __pthread_mutex_unlock%0A// __pthread_cond_init%0A// __pthread_cond_destroy%0A// __pthread_cond_broadcast%0A// __pthread_cond_signal%0A// Setsid_with_pid%0A// __pthread_cond_timedwait%0A// Aio_fsync%0A// Aio_return%0A// Aio_suspend%0A// Aio_cancel%0A// Aio_error%0A// Aio_read%0A// Aio_write%0A// Lio_listio%0A// __pthread_cond_wait%0A// Iopolicysys%0A// __pthread_kill%0A// __pthread_sigmask%0A// __sigwait%0A// __disable_threadsignal%0A// __pthread_markcancel%0A// __pthread_canceled%0A// __semwait_signal%0A// Proc_info%0A// Stat64_extended%0A// Lstat64_extended%0A// Fstat64_extended%0A// __pthread_chdir%0A// __pthread_fchdir%0A// Audit%0A// Auditon%0A// Getauid%0A// Setauid%0A// Getaudit%0A// Setaudit%0A// Getaudit_addr%0A// Setaudit_addr%0A// Auditctl%0A// Bsdthread_create%0A// Bsdthread_terminate%0A// Stack_snapshot%0A// Bsdthread_register%0A// Workq_open%0A// Workq_ops%0A// __mac_execve%0A// __mac_syscall%0A// __mac_get_file%0A// __mac_set_file%0A// __mac_get_link%0A// __mac_set_link%0A// __mac_get_proc%0A// __mac_set_proc%0A// __mac_get_fd%0A// __mac_set_fd%0A// __mac_get_pid%0A// __mac_get_lcid%0A// __mac_get_lctx%0A// __mac_set_lctx%0A// Setlcid%0A// Read_nocancel%0A// Write_nocancel%0A// Open_nocancel%0A// Close_nocancel%0A// Wait4_nocancel%0A// Recvmsg_nocancel%0A// Sendmsg_nocancel%0A// Recvfrom_nocancel%0A// Accept_nocancel%0A// Fcntl_nocancel%0A// Select_nocancel%0A// Fsync_nocancel%0A// Connect_nocancel%0A// Sigsuspend_nocancel%0A// Readv_nocancel%0A// Writev_nocancel%0A// Sendto_nocancel%0A// Pread_nocancel%0A// Pwrite_nocancel%0A// Waitid_nocancel%0A// Msgsnd_nocancel%0A// Msgrcv_nocancel%0A// Sem_wait_nocancel%0A// Aio_suspend_nocancel%0A// __sigwait_nocancel%0A// __semwait_signal_nocancel%0A// __mac_mount%0A// __mac_get_mount%0A// __mac_getfsstat%0A
- f 4525ee4331f0819d238b182fcfc69a8790596c65d01862c77d5210620cca9e48 vendor/golang.org/x/sys/unix/syscall_dragonfly_amd64.go
+ f f9bf6375f05a9c574048563c659cb0a8de466efc794a51ead3033b0f60344c2d vendor/golang.org/x/sys/unix/syscall_dragonfly_amd64.go
dmppatch 3
@@ -193,8 +193,1000 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var writtenOut uint64 = 0%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(count), 0, uintptr(unsafe.Pointer(&writtenOut)), 0, 0, 0)%0A%0A%09written = int(writtenOut)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f 582d72a1c3a7b7d88ca3ab1a53dc6303572d102074191cb6867029addb2c624a vendor/golang.org/x/sys/unix/syscall_freebsd.go
+ f 80ee5ed2a26dbb25d2cd1230f9cae0f02c8cf1e9dc302833280c60a48ddc38da vendor/golang.org/x/sys/unix/syscall_freebsd.go
dmppatch 11
@@ -526,16 +526,3508 @@
 afe%22%0A)%0A%0A
+// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B46%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0A// Translate %22kern.hostname%22 to %5B%5D_C_int%7B0,1,2,3%7D.%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09const siz = unsafe.Sizeof(mib%5B0%5D)%0A%0A%09// NOTE(rsc): It seems strange to set the buffer to have%0A%09// size CTL_MAXNAME+2 but use only CTL_MAXNAME%0A%09// as the size. I don't know why the +2 is here, but the%0A%09// kernel uses +2 for its own implementation of this function.%0A%09// I am scared that if we don't include the +2 here, the kernel%0A%09// will silently write 2 words farther than we specify%0A%09// and we'll get memory corruption.%0A%09var buf %5BCTL_MAXNAME + 2%5D_C_int%0A%09n := uintptr(CTL_MAXNAME) * siz%0A%0A%09p := (*byte)(unsafe.Pointer(&buf%5B0%5D))%0A%09bytes, err := ByteSliceFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Magic sysctl: %22setting%22 0.3 to a string name%0A%09// lets you read back the array of integers form.%0A%09if err = sysctl(%5B%5D_C_int%7B0, 3%7D, p, &n, &bytes%5B0%5D, uintptr(len(name))); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return buf%5B0 : n/siz%5D, nil%0A%7D%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09return Pipe2(p, 0)%0A%7D%0A%0A//sysnb%09pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) error %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err := pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return err%0A%7D%0A%0Afunc GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error) %7B%0A%09var value IPMreqn%0A%09vallen := _Socklen(SizeofIPMreqn)%0A%09errno := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, errno%0A%7D%0A%0Afunc SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(mreq), unsafe.Sizeof(*mreq))%0A%7D%0A%0Afunc Accept4(fd, flags int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept4(fd, &rsa, &len, flags)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09if len %3E SizeofSockaddrAny %7B%0A%09%09panic(%22RawSockaddrAny too small%22)%0A%09%7D%0A%09sa, err = anyToSockaddr(fd, &rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error) = SYS___GETCWD%0A%0Afunc Getwd() (string, error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09_, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0Afunc Getfsstat(buf %5B%5DStatfs_t, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09var bufsize uintptr%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%09bufsize = unsafe.Sizeof(Statfs_t%7B%7D) * uintptr(len(buf))%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(_p0), bufsize, uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09// used on Darwin for UtimesNano%0A%09return ENOSYS%0A%7D%0A%0A//sys   ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc ioctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A
 func ioc
@@ -4135,24 +4135,443 @@
 value)))%0A%7D%0A%0A
+// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func IoctlGe
@@ -4694,28 +4694,10803 @@
 ue)))%0A%09return &value, err%0A%7D%0A
+%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctl(mib, &uname.Sysname%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctl(mib, &uname.Nodename%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctl(mib, &uname.Release%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctl(mib, &uname.Version%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctl(mib, &uname.Machine%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09CapEnter() (err error)%0A//sys%09capRightsGet(version int, fd int, rightsp *CapRights) (err error) = SYS___CAP_RIGHTS_GET%0A//sys%09capRightsLimit(fd int, rightsp *CapRights) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exit(code int)%0A//sys%09ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error)%0A//sys%09ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error)%0A//sys%09ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error)%0A//sys%09ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_POSIX_FADVISE%0A//sys%09Faccessat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatfs(fd int, stat *Statfs_t) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sys%09Getdents(fd int, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error)%0A//sys%09Getdtablesize() (size int)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Issetugid() (tainted bool)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkdirat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Openat(fdat int, path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Renameat(fromfd int, from string, tofd int, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Setlogin(name string) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, stat *Statfs_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Symlinkat(oldpath string, newdirfd int, newpath string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Undelete(path string) (err error)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unlinkat(dirfd int, path string, flags int) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys   mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys   munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A//sys%09accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error)%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0A/*%0A * Unimplemented%0A */%0A// Profil%0A// Sigaction%0A// Sigprocmask%0A// Getlogin%0A// Sigpending%0A// Sigaltstack%0A// Ioctl%0A// Reboot%0A// Execve%0A// Vfork%0A// Sbrk%0A// Sstk%0A// Ovadvise%0A// Mincore%0A// Setitimer%0A// Swapon%0A// Select%0A// Sigsuspend%0A// Readv%0A// Writev%0A// Nfssvc%0A// Getfh%0A// Quotactl%0A// Mount%0A// Csops%0A// Waitid%0A// Add_profil%0A// Kdebug_trace%0A// Sigreturn%0A// Atsocket%0A// Kqueue_from_portset_np%0A// Kqueue_portset%0A// Getattrlist%0A// Setattrlist%0A// Getdirentriesattr%0A// Searchfs%0A// Delete%0A// Copyfile%0A// Watchevent%0A// Waitevent%0A// Modwatch%0A// Fsctl%0A// Initgroups%0A// Posix_spawn%0A// Nfsclnt%0A// Fhopen%0A// Minherit%0A// Semsys%0A// Msgsys%0A// Shmsys%0A// Semctl%0A// Semget%0A// Semop%0A// Msgctl%0A// Msgget%0A// Msgsnd%0A// Msgrcv%0A// Shmat%0A// Shmctl%0A// Shmdt%0A// Shmget%0A// Shm_open%0A// Shm_unlink%0A// Sem_open%0A// Sem_close%0A// Sem_unlink%0A// Sem_wait%0A// Sem_trywait%0A// Sem_post%0A// Sem_getvalue%0A// Sem_init%0A// Sem_destroy%0A// Open_extended%0A// Umask_extended%0A// Stat_extended%0A// Lstat_extended%0A// Fstat_extended%0A// Chmod_extended%0A// Fchmod_extended%0A// Access_extended%0A// Settid%0A// Gettid%0A// Setsgroups%0A// Getsgroups%0A// Setwgroups%0A// Getwgroups%0A// Mkfifo_extended%0A// Mkdir_extended%0A// Identitysvc%0A// Shared_region_check_np%0A// Shared_region_map_np%0A// __pthread_mutex_destroy%0A// __pthread_mutex_init%0A// __pthread_mutex_lock%0A// __pthread_mutex_trylock%0A// __pthread_mutex_unlock%0A// __pthread_cond_init%0A// __pthread_cond_destroy%0A// __pthread_cond_broadcast%0A// __pthread_cond_signal%0A// Setsid_with_pid%0A// __pthread_cond_timedwait%0A// Aio_fsync%0A// Aio_return%0A// Aio_suspend%0A// Aio_cancel%0A// Aio_error%0A// Aio_read%0A// Aio_write%0A// Lio_listio%0A// __pthread_cond_wait%0A// Iopolicysys%0A// __pthread_kill%0A// __pthread_sigmask%0A// __sigwait%0A// __disable_threadsignal%0A// __pthread_markcancel%0A// __pthread_canceled%0A// __semwait_signal%0A// Proc_info%0A// Stat64_extended%0A// Lstat64_extended%0A// Fstat64_extended%0A// __pthread_chdir%0A// __pthread_fchdir%0A// Audit%0A// Auditon%0A// Getauid%0A// Setauid%0A// Getaudit%0A// Setaudit%0A// Getaudit_addr%0A// Setaudit_addr%0A// Auditctl%0A// Bsdthread_create%0A// Bsdthread_terminate%0A// Stack_snapshot%0A// Bsdthread_register%0A// Workq_open%0A// Workq_ops%0A// __mac_execve%0A// __mac_syscall%0A// __mac_get_file%0A// __mac_set_file%0A// __mac_get_link%0A// __mac_set_link%0A// __mac_get_proc%0A// __mac_set_proc%0A// __mac_get_fd%0A// __mac_set_fd%0A// __mac_get_pid%0A// __mac_get_lcid%0A// __mac_get_lctx%0A// __mac_set_lctx%0A// Setlcid%0A// Read_nocancel%0A// Write_nocancel%0A// Open_nocancel%0A// Close_nocancel%0A// Wait4_nocancel%0A// Recvmsg_nocancel%0A// Sendmsg_nocancel%0A// Recvfrom_nocancel%0A// Accept_nocancel%0A// Fcntl_nocancel%0A// Select_nocancel%0A// Fsync_nocancel%0A// Connect_nocancel%0A// Sigsuspend_nocancel%0A// Readv_nocancel%0A// Writev_nocancel%0A// Sendto_nocancel%0A// Pread_nocancel%0A// Pwrite_nocancel%0A// Waitid_nocancel%0A// Poll_nocancel%0A// Msgsnd_nocancel%0A// Msgrcv_nocancel%0A// Sem_wait_nocancel%0A// Aio_suspend_nocancel%0A// __sigwait_nocancel%0A// __semwait_signal_nocancel%0A// __mac_mount%0A// __mac_get_mount%0A// __mac_getfsstat%0A
- f d18f59e7c62c1b738cf10a92ccdaf3b667843eee41e173d4bc5ae644adf34602 vendor/golang.org/x/sys/unix/syscall_freebsd_386.go
+ f c8b06c4db0d2073dd8a464624a99252506cd9c4fedf4ea0567d2c1309c3bc23d vendor/golang.org/x/sys/unix/syscall_freebsd_386.go
dmppatch 3
@@ -189,8 +189,1049 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var writtenOut uint64 = 0%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr((*offset)%3E%3E32), uintptr(count), 0, uintptr(unsafe.Pointer(&writtenOut)), 0, 0)%0A%0A%09written = int(writtenOut)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f b17c6a9fc27f71b5f68c3f385789786fc0c1091e13d5f32120b30995e13ea1db vendor/golang.org/x/sys/unix/syscall_freebsd_amd64.go
+ f 042258a5988192f1af6e708c7ee3d253164093760bda50e033eb9b8d48e113cb vendor/golang.org/x/sys/unix/syscall_freebsd_amd64.go
dmppatch 3
@@ -191,8 +191,1000 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var writtenOut uint64 = 0%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr(count), 0, uintptr(unsafe.Pointer(&writtenOut)), 0, 0, 0)%0A%0A%09written = int(writtenOut)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f b9fd66cbbd7262d7b9fa8b5a2ea7d40de429baf5c5bc67c5dbac03e57604becd vendor/golang.org/x/sys/unix/syscall_freebsd_arm.go
+ f 9be12b4c28b4451faa8be73f2a1ffa10dd7d6d4bf5d5ed9f6a47c448deaf63f6 vendor/golang.org/x/sys/unix/syscall_freebsd_arm.go
dmppatch 3
@@ -189,8 +189,1035 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09var writtenOut uint64 = 0%0A%09_, _, e1 := Syscall9(SYS_SENDFILE, uintptr(infd), uintptr(outfd), uintptr(*offset), uintptr((*offset)%3E%3E32), uintptr(count), 0, uintptr(unsafe.Pointer(&writtenOut)), 0, 0)%0A%0A%09written = int(writtenOut)%0A%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Syscall9(num, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f 647bf4107088cf00e1b63d64841d472467bf517b57001bd2a90a81cf6f4e8509 vendor/golang.org/x/sys/unix/syscall_linux.go
+ f 05e4796f6584a14a4a1d49b7d5545d6f87a0b031f1fbb7f443cf2f16e5be9d5d vendor/golang.org/x/sys/unix/syscall_linux.go
dmppatch 15
@@ -450,16 +450,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -474,16 +474,1467 @@
 afe%22%0A)%0A%0A
+/*%0A * Wrapped%0A */%0A%0Afunc Access(path string, mode uint32) (err error) %7B%0A%09return Faccessat(AT_FDCWD, path, mode, 0)%0A%7D%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09return Fchmodat(AT_FDCWD, path, mode, 0)%0A%7D%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09return Fchownat(AT_FDCWD, path, uid, gid, 0)%0A%7D%0A%0Afunc Creat(path string, mode uint32) (fd int, err error) %7B%0A%09return Open(path, O_CREAT%7CO_WRONLY%7CO_TRUNC, mode)%0A%7D%0A%0A//sys%09fchmodat(dirfd int, path string, mode uint32) (err error)%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09// Linux fchmodat doesn't support the flags parameter. Mimick glibc's behavior%0A%09// and check the flags. Otherwise the mode would be applied to the symlink%0A%09// destination which is not what the user expects.%0A%09if flags&%5EAT_SYMLINK_NOFOLLOW != 0 %7B%0A%09%09return EINVAL%0A%09%7D else if flags&AT_SYMLINK_NOFOLLOW != 0 %7B%0A%09%09return EOPNOTSUPP%0A%09%7D%0A%09return fchmodat(dirfd, path, mode)%0A%7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc ioctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A
 func ioc
@@ -2042,24 +2042,443 @@
 value)))%0A%7D%0A%0A
+// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func IoctlGe
@@ -2601,28 +2601,43944 @@
 ue)))%0A%09return &value, err%0A%7D%0A
+%0A//sys%09Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error)%0A%0Afunc Link(oldpath string, newpath string) (err error) %7B%0A%09return Linkat(AT_FDCWD, oldpath, AT_FDCWD, newpath, 0)%0A%7D%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09return Mkdirat(AT_FDCWD, path, mode)%0A%7D%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09return Mknodat(AT_FDCWD, path, mode, dev)%0A%7D%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09return openat(AT_FDCWD, path, mode%7CO_LARGEFILE, perm)%0A%7D%0A%0A//sys%09openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)%0A%0Afunc Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09return openat(dirfd, path, flags%7CO_LARGEFILE, mode)%0A%7D%0A%0A//sys%09ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error)%0A%0Afunc Ppoll(fds %5B%5DPollFd, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return ppoll(nil, 0, timeout, sigmask)%0A%09%7D%0A%09return ppoll(&fds%5B0%5D, len(fds), timeout, sigmask)%0A%7D%0A%0A//sys%09Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error)%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09return Readlinkat(AT_FDCWD, path, buf)%0A%7D%0A%0Afunc Rename(oldpath string, newpath string) (err error) %7B%0A%09return Renameat(AT_FDCWD, oldpath, AT_FDCWD, newpath)%0A%7D%0A%0Afunc Rmdir(path string) error %7B%0A%09return Unlinkat(AT_FDCWD, path, AT_REMOVEDIR)%0A%7D%0A%0A//sys%09Symlinkat(oldpath string, newdirfd int, newpath string) (err error)%0A%0Afunc Symlink(oldpath string, newpath string) (err error) %7B%0A%09return Symlinkat(oldpath, AT_FDCWD, newpath)%0A%7D%0A%0Afunc Unlink(path string) error %7B%0A%09return Unlinkat(AT_FDCWD, path, 0)%0A%7D%0A%0A//sys%09Unlinkat(dirfd int, path string, flags int) (err error)%0A%0Afunc Utimes(path string, tv %5B%5DTimeval) error %7B%0A%09if tv == nil %7B%0A%09%09err := utimensat(AT_FDCWD, path, nil, 0)%0A%09%09if err != ENOSYS %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var ts %5B2%5DTimespec%0A%09ts%5B0%5D = NsecToTimespec(TimevalToNsec(tv%5B0%5D))%0A%09ts%5B1%5D = NsecToTimespec(TimevalToNsec(tv%5B1%5D))%0A%09err := utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0Afunc UtimesNano(path string, ts %5B%5DTimespec) error %7B%0A%09if ts == nil %7B%0A%09%09err := utimensat(AT_FDCWD, path, nil, 0)%0A%09%09if err != ENOSYS %7B%0A%09%09%09return err%0A%09%09%7D%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09err := utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%09// If the utimensat syscall isn't available (utimensat was added to Linux%0A%09// in 2.6.22, Released, 8 July 2007) then fall back to utimes%0A%09var tv %5B2%5DTimeval%0A%09for i := 0; i %3C 2; i++ %7B%0A%09%09tv%5Bi%5D = NsecToTimeval(TimespecToNsec(ts%5Bi%5D))%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc UtimesNanoAt(dirfd int, path string, ts %5B%5DTimespec, flags int) error %7B%0A%09if ts == nil %7B%0A%09%09return utimensat(dirfd, path, nil, flags)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimensat(dirfd, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), flags)%0A%7D%0A%0Afunc Futimesat(dirfd int, path string, tv %5B%5DTimeval) error %7B%0A%09if tv == nil %7B%0A%09%09return futimesat(dirfd, path, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return futimesat(dirfd, path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc Futimes(fd int, tv %5B%5DTimeval) (err error) %7B%0A%09// Believe it or not, this is the best we can do on Linux%0A%09// (and is what glibc does).%0A%09return Utimes(%22/proc/self/fd/%22+itoa(fd), tv)%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error)%0A%0Afunc Getwd() (wd string, err error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09n, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09// Getcwd returns the number of bytes written to buf, including the NUL.%0A%09if n %3C 1 %7C%7C n %3E len(buf) %7C%7C buf%5Bn-1%5D != 0 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B0 : n-1%5D), nil%0A%7D%0A%0Afunc Getgroups() (gids %5B%5Dint, err error) %7B%0A%09n, err := getgroups(0, nil)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09if n == 0 %7B%0A%09%09return nil, nil%0A%09%7D%0A%0A%09// Sanity check group count. Max is 1%3C%3C16 on Linux.%0A%09if n %3C 0 %7C%7C n %3E 1%3C%3C20 %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, n)%0A%09n, err = getgroups(n, &a%5B0%5D)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09gids = make(%5B%5Dint, n)%0A%09for i, v := range a%5B0:n%5D %7B%0A%09%09gids%5Bi%5D = int(v)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setgroups(gids %5B%5Dint) (err error) %7B%0A%09if len(gids) == 0 %7B%0A%09%09return setgroups(0, nil)%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, len(gids))%0A%09for i, v := range gids %7B%0A%09%09a%5Bi%5D = _Gid_t(v)%0A%09%7D%0A%09return setgroups(len(a), &a%5B0%5D)%0A%7D%0A%0Atype WaitStatus uint32%0A%0A// Wait status is 7 bits at bottom, either 0 (exited),%0A// 0x7F (stopped), or a signal number that caused an exit.%0A// The 0x80 bit is whether there was a core dump.%0A// An extra number (exit code, signal causing a stop)%0A// is in the high bits. At least that's the idea.%0A// There are various irregularities. For example, the%0A// %22continued%22 status is 0xFFFF, distinguishing itself%0A// from stopped via the core dump bit.%0A%0Aconst (%0A%09mask    = 0x7F%0A%09core    = 0x80%0A%09exited  = 0x00%0A%09stopped = 0x7F%0A%09shift   = 8%0A)%0A%0Afunc (w WaitStatus) Exited() bool %7B return w&mask == exited %7D%0A%0Afunc (w WaitStatus) Signaled() bool %7B return w&mask != stopped && w&mask != exited %7D%0A%0Afunc (w WaitStatus) Stopped() bool %7B return w&0xFF == stopped %7D%0A%0Afunc (w WaitStatus) Continued() bool %7B return w == 0xFFFF %7D%0A%0Afunc (w WaitStatus) CoreDump() bool %7B return w.Signaled() && w&core != 0 %7D%0A%0Afunc (w WaitStatus) ExitStatus() int %7B%0A%09if !w.Exited() %7B%0A%09%09return -1%0A%09%7D%0A%09return int(w%3E%3Eshift) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) Signal() syscall.Signal %7B%0A%09if !w.Signaled() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w & mask)%0A%7D%0A%0Afunc (w WaitStatus) StopSignal() syscall.Signal %7B%0A%09if !w.Stopped() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w%3E%3Eshift) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) TrapCause() int %7B%0A%09if w.StopSignal() != SIGTRAP %7B%0A%09%09return -1%0A%09%7D%0A%09return int(w%3E%3Eshift) %3E%3E 8%0A%7D%0A%0A//sys%09wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error)%0A%0Afunc Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09var status _C_int%0A%09wpid, err = wait4(pid, &status, options, rusage)%0A%09if wstatus != nil %7B%0A%09%09*wstatus = WaitStatus(status)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkfifo(path string, mode uint32) error %7B%0A%09return Mknod(path, mode%7CS_IFIFO, 0)%0A%7D%0A%0Afunc Mkfifoat(dirfd int, path string, mode uint32) error %7B%0A%09return Mknodat(dirfd, path, mode%7CS_IFIFO, 0)%0A%7D%0A%0Afunc (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet4, nil%0A%7D%0A%0Afunc (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET6%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09sa.raw.Scope_id = sa.ZoneId%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet6, nil%0A%7D%0A%0Afunc (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09name := sa.Name%0A%09n := len(name)%0A%09if n %3E= len(sa.raw.Path) %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_UNIX%0A%09for i := 0; i %3C n; i++ %7B%0A%09%09sa.raw.Path%5Bi%5D = int8(name%5Bi%5D)%0A%09%7D%0A%09// length is family (uint16), name, NUL.%0A%09sl := _Socklen(2)%0A%09if n %3E 0 %7B%0A%09%09sl += _Socklen(n) + 1%0A%09%7D%0A%09if sa.raw.Path%5B0%5D == '@' %7B%0A%09%09sa.raw.Path%5B0%5D = 0%0A%09%09// Don't count trailing NUL for abstract address.%0A%09%09sl--%0A%09%7D%0A%0A%09return unsafe.Pointer(&sa.raw), sl, nil%0A%7D%0A%0A// SockaddrLinklayer implements the Sockaddr interface for AF_PACKET type sockets.%0Atype SockaddrLinklayer struct %7B%0A%09Protocol uint16%0A%09Ifindex  int%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Dbyte%0A%09raw      RawSockaddrLinklayer%0A%7D%0A%0Afunc (sa *SockaddrLinklayer) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Ifindex %3C 0 %7C%7C sa.Ifindex %3E 0x7fffffff %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_PACKET%0A%09sa.raw.Protocol = sa.Protocol%0A%09sa.raw.Ifindex = int32(sa.Ifindex)%0A%09sa.raw.Hatype = sa.Hatype%0A%09sa.raw.Pkttype = sa.Pkttype%0A%09sa.raw.Halen = sa.Halen%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrLinklayer, nil%0A%7D%0A%0A// SockaddrNetlink implements the Sockaddr interface for AF_NETLINK type sockets.%0Atype SockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%09raw    RawSockaddrNetlink%0A%7D%0A%0Afunc (sa *SockaddrNetlink) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_NETLINK%0A%09sa.raw.Pad = sa.Pad%0A%09sa.raw.Pid = sa.Pid%0A%09sa.raw.Groups = sa.Groups%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrNetlink, nil%0A%7D%0A%0A// SockaddrHCI implements the Sockaddr interface for AF_BLUETOOTH type sockets%0A// using the HCI protocol.%0Atype SockaddrHCI struct %7B%0A%09Dev     uint16%0A%09Channel uint16%0A%09raw     RawSockaddrHCI%0A%7D%0A%0Afunc (sa *SockaddrHCI) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_BLUETOOTH%0A%09sa.raw.Dev = sa.Dev%0A%09sa.raw.Channel = sa.Channel%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrHCI, nil%0A%7D%0A%0A// SockaddrL2 implements the Sockaddr interface for AF_BLUETOOTH type sockets%0A// using the L2CAP protocol.%0Atype SockaddrL2 struct %7B%0A%09PSM      uint16%0A%09CID      uint16%0A%09Addr     %5B6%5Duint8%0A%09AddrType uint8%0A%09raw      RawSockaddrL2%0A%7D%0A%0Afunc (sa *SockaddrL2) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_BLUETOOTH%0A%09psm := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Psm))%0A%09psm%5B0%5D = byte(sa.PSM)%0A%09psm%5B1%5D = byte(sa.PSM %3E%3E 8)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Bdaddr%5Bi%5D = sa.Addr%5Blen(sa.Addr)-1-i%5D%0A%09%7D%0A%09cid := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Cid))%0A%09cid%5B0%5D = byte(sa.CID)%0A%09cid%5B1%5D = byte(sa.CID %3E%3E 8)%0A%09sa.raw.Bdaddr_type = sa.AddrType%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrL2, nil%0A%7D%0A%0A// SockaddrRFCOMM implements the Sockaddr interface for AF_BLUETOOTH type sockets%0A// using the RFCOMM protocol.%0A//%0A// Server example:%0A//%0A//      fd, _ := Socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM)%0A//      _ = unix.Bind(fd, &unix.SockaddrRFCOMM%7B%0A//      %09Channel: 1,%0A//      %09Addr:    %5B6%5Duint8%7B0, 0, 0, 0, 0, 0%7D, // BDADDR_ANY or 00:00:00:00:00:00%0A//      %7D)%0A//      _ = Listen(fd, 1)%0A//      nfd, sa, _ := Accept(fd)%0A//      fmt.Printf(%22conn addr=%25v fd=%25d%22, sa.(*unix.SockaddrRFCOMM).Addr, nfd)%0A//      Read(nfd, buf)%0A//%0A// Client example:%0A//%0A//      fd, _ := Socket(AF_BLUETOOTH, SOCK_STREAM, BTPROTO_RFCOMM)%0A//      _ = Connect(fd, &SockaddrRFCOMM%7B%0A//      %09Channel: 1,%0A//      %09Addr:    %5B6%5Dbyte%7B0x11, 0x22, 0x33, 0xaa, 0xbb, 0xcc%7D, // CC:BB:AA:33:22:11%0A//      %7D)%0A//      Write(fd, %5B%5Dbyte(%60hello%60))%0Atype SockaddrRFCOMM struct %7B%0A%09// Addr represents a bluetooth address, byte ordering is little-endian.%0A%09Addr %5B6%5Duint8%0A%0A%09// Channel is a designated bluetooth channel, only 1-30 are available for use.%0A%09// Since Linux 2.6.7 and further zero value is the first available channel.%0A%09Channel uint8%0A%0A%09raw RawSockaddrRFCOMM%0A%7D%0A%0Afunc (sa *SockaddrRFCOMM) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_BLUETOOTH%0A%09sa.raw.Channel = sa.Channel%0A%09sa.raw.Bdaddr = sa.Addr%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrRFCOMM, nil%0A%7D%0A%0A// SockaddrCAN implements the Sockaddr interface for AF_CAN type sockets.%0A// The RxID and TxID fields are used for transport protocol addressing in%0A// (CAN_TP16, CAN_TP20, CAN_MCNET, and CAN_ISOTP), they can be left with%0A// zero values for CAN_RAW and CAN_BCM sockets as they have no meaning.%0A//%0A// The SockaddrCAN struct must be bound to the socket file descriptor%0A// using Bind before the CAN socket can be used.%0A//%0A//      // Read one raw CAN frame%0A//      fd, _ := Socket(AF_CAN, SOCK_RAW, CAN_RAW)%0A//      addr := &SockaddrCAN%7BIfindex: index%7D%0A//      Bind(fd, addr)%0A//      frame := make(%5B%5Dbyte, 16)%0A//      Read(fd, frame)%0A//%0A// The full SocketCAN documentation can be found in the linux kernel%0A// archives at: https://www.kernel.org/doc/Documentation/networking/can.txt%0Atype SockaddrCAN struct %7B%0A%09Ifindex int%0A%09RxID    uint32%0A%09TxID    uint32%0A%09raw     RawSockaddrCAN%0A%7D%0A%0Afunc (sa *SockaddrCAN) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Ifindex %3C 0 %7C%7C sa.Ifindex %3E 0x7fffffff %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_CAN%0A%09sa.raw.Ifindex = int32(sa.Ifindex)%0A%09rx := (*%5B4%5Dbyte)(unsafe.Pointer(&sa.RxID))%0A%09for i := 0; i %3C 4; i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = rx%5Bi%5D%0A%09%7D%0A%09tx := (*%5B4%5Dbyte)(unsafe.Pointer(&sa.TxID))%0A%09for i := 0; i %3C 4; i++ %7B%0A%09%09sa.raw.Addr%5Bi+4%5D = tx%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrCAN, nil%0A%7D%0A%0A// SockaddrALG implements the Sockaddr interface for AF_ALG type sockets.%0A// SockaddrALG enables userspace access to the Linux kernel's cryptography%0A// subsystem. The Type and Name fields specify which type of hash or cipher%0A// should be used with a given socket.%0A//%0A// To create a file descriptor that provides access to a hash or cipher, both%0A// Bind and Accept must be used. Once the setup process is complete, input%0A// data can be written to the socket, processed by the kernel, and then read%0A// back as hash output or ciphertext.%0A//%0A// Here is an example of using an AF_ALG socket with SHA1 hashing.%0A// The initial socket setup process is as follows:%0A//%0A//      // Open a socket to perform SHA1 hashing.%0A//      fd, _ := unix.Socket(unix.AF_ALG, unix.SOCK_SEQPACKET, 0)%0A//      addr := &unix.SockaddrALG%7BType: %22hash%22, Name: %22sha1%22%7D%0A//      unix.Bind(fd, addr)%0A//      // Note: unix.Accept does not work at this time; must invoke accept()%0A//      // manually using unix.Syscall.%0A//      hashfd, _, _ := unix.Syscall(unix.SYS_ACCEPT, uintptr(fd), 0, 0)%0A//%0A// Once a file descriptor has been returned from Accept, it may be used to%0A// perform SHA1 hashing. The descriptor is not safe for concurrent use, but%0A// may be re-used repeatedly with subsequent Write and Read operations.%0A//%0A// When hashing a small byte slice or string, a single Write and Read may%0A// be used:%0A//%0A//      // Assume hashfd is already configured using the setup process.%0A//      hash := os.NewFile(hashfd, %22sha1%22)%0A//      // Hash an input string and read the results. Each Write discards%0A//      // previous hash state. Read always reads the current state.%0A//      b := make(%5B%5Dbyte, 20)%0A//      for i := 0; i %3C 2; i++ %7B%0A//          io.WriteString(hash, %22Hello, world.%22)%0A//          hash.Read(b)%0A//          fmt.Println(hex.EncodeToString(b))%0A//      %7D%0A//      // Output:%0A//      // 2ae01472317d1935a84797ec1983ae243fc6aa28%0A//      // 2ae01472317d1935a84797ec1983ae243fc6aa28%0A//%0A// For hashing larger byte slices, or byte streams such as those read from%0A// a file or socket, use Sendto with MSG_MORE to instruct the kernel to update%0A// the hash digest instead of creating a new one for a given chunk and finalizing it.%0A//%0A//      // Assume hashfd and addr are already configured using the setup process.%0A//      hash := os.NewFile(hashfd, %22sha1%22)%0A//      // Hash the contents of a file.%0A//      f, _ := os.Open(%22/tmp/linux-4.10-rc7.tar.xz%22)%0A//      b := make(%5B%5Dbyte, 4096)%0A//      for %7B%0A//          n, err := f.Read(b)%0A//          if err == io.EOF %7B%0A//              break%0A//          %7D%0A//          unix.Sendto(hashfd, b%5B:n%5D, unix.MSG_MORE, addr)%0A//      %7D%0A//      hash.Read(b)%0A//      fmt.Println(hex.EncodeToString(b))%0A//      // Output: 85cdcad0c06eef66f805ecce353bec9accbeecc5%0A//%0A// For more information, see: http://www.chronox.de/crypto-API/crypto/userspace-if.html.%0Atype SockaddrALG struct %7B%0A%09Type    string%0A%09Name    string%0A%09Feature uint32%0A%09Mask    uint32%0A%09raw     RawSockaddrALG%0A%7D%0A%0Afunc (sa *SockaddrALG) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09// Leave room for NUL byte terminator.%0A%09if len(sa.Type) %3E 13 %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09if len(sa.Name) %3E 63 %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%0A%09sa.raw.Family = AF_ALG%0A%09sa.raw.Feat = sa.Feature%0A%09sa.raw.Mask = sa.Mask%0A%0A%09typ, err := ByteSliceFromString(sa.Type)%0A%09if err != nil %7B%0A%09%09return nil, 0, err%0A%09%7D%0A%09name, err := ByteSliceFromString(sa.Name)%0A%09if err != nil %7B%0A%09%09return nil, 0, err%0A%09%7D%0A%0A%09copy(sa.raw.Type%5B:%5D, typ)%0A%09copy(sa.raw.Name%5B:%5D, name)%0A%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrALG, nil%0A%7D%0A%0A// SockaddrVM implements the Sockaddr interface for AF_VSOCK type sockets.%0A// SockaddrVM provides access to Linux VM sockets: a mechanism that enables%0A// bidirectional communication between a hypervisor and its guest virtual%0A// machines.%0Atype SockaddrVM struct %7B%0A%09// CID and Port specify a context ID and port address for a VM socket.%0A%09// Guests have a unique CID, and hosts may have a well-known CID of:%0A%09//  - VMADDR_CID_HYPERVISOR: refers to the hypervisor process.%0A%09//  - VMADDR_CID_HOST: refers to other processes on the host.%0A%09CID  uint32%0A%09Port uint32%0A%09raw  RawSockaddrVM%0A%7D%0A%0Afunc (sa *SockaddrVM) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_VSOCK%0A%09sa.raw.Port = sa.Port%0A%09sa.raw.Cid = sa.CID%0A%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrVM, nil%0A%7D%0A%0Atype SockaddrXDP struct %7B%0A%09Flags        uint16%0A%09Ifindex      uint32%0A%09QueueID      uint32%0A%09SharedUmemFD uint32%0A%09raw          RawSockaddrXDP%0A%7D%0A%0Afunc (sa *SockaddrXDP) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09sa.raw.Family = AF_XDP%0A%09sa.raw.Flags = sa.Flags%0A%09sa.raw.Ifindex = sa.Ifindex%0A%09sa.raw.Queue_id = sa.QueueID%0A%09sa.raw.Shared_umem_fd = sa.SharedUmemFD%0A%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrXDP, nil%0A%7D%0A%0Afunc anyToSockaddr(fd int, rsa *RawSockaddrAny) (Sockaddr, error) %7B%0A%09switch rsa.Addr.Family %7B%0A%09case AF_NETLINK:%0A%09%09pp := (*RawSockaddrNetlink)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrNetlink)%0A%09%09sa.Family = pp.Family%0A%09%09sa.Pad = pp.Pad%0A%09%09sa.Pid = pp.Pid%0A%09%09sa.Groups = pp.Groups%0A%09%09return sa, nil%0A%0A%09case AF_PACKET:%0A%09%09pp := (*RawSockaddrLinklayer)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrLinklayer)%0A%09%09sa.Protocol = pp.Protocol%0A%09%09sa.Ifindex = int(pp.Ifindex)%0A%09%09sa.Hatype = pp.Hatype%0A%09%09sa.Pkttype = pp.Pkttype%0A%09%09sa.Halen = pp.Halen%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_UNIX:%0A%09%09pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrUnix)%0A%09%09if pp.Path%5B0%5D == 0 %7B%0A%09%09%09// %22Abstract%22 Unix domain socket.%0A%09%09%09// Rewrite leading NUL as @ for textual display.%0A%09%09%09// (This is the standard convention.)%0A%09%09%09// Not friendly to overwrite in place,%0A%09%09%09// but the callers below don't care.%0A%09%09%09pp.Path%5B0%5D = '@'%0A%09%09%7D%0A%0A%09%09// Assume path ends at NUL.%0A%09%09// This is not technically the Linux semantics for%0A%09%09// abstract Unix domain sockets--they are supposed%0A%09%09// to be uninterpreted fixed-size binary blobs--but%0A%09%09// everyone uses this convention.%0A%09%09n := 0%0A%09%09for n %3C len(pp.Path) && pp.Path%5Bn%5D != 0 %7B%0A%09%09%09n++%0A%09%09%7D%0A%09%09bytes := (*%5B10000%5Dbyte)(unsafe.Pointer(&pp.Path%5B0%5D))%5B0:n%5D%0A%09%09sa.Name = string(bytes)%0A%09%09return sa, nil%0A%0A%09case AF_INET:%0A%09%09pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet4)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_INET6:%0A%09%09pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet6)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09sa.ZoneId = pp.Scope_id%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_VSOCK:%0A%09%09pp := (*RawSockaddrVM)(unsafe.Pointer(rsa))%0A%09%09sa := &SockaddrVM%7B%0A%09%09%09CID:  pp.Cid,%0A%09%09%09Port: pp.Port,%0A%09%09%7D%0A%09%09return sa, nil%0A%09case AF_BLUETOOTH:%0A%09%09proto, err := GetsockoptInt(fd, SOL_SOCKET, SO_PROTOCOL)%0A%09%09if err != nil %7B%0A%09%09%09return nil, err%0A%09%09%7D%0A%09%09// only BTPROTO_L2CAP and BTPROTO_RFCOMM can accept connections%0A%09%09switch proto %7B%0A%09%09case BTPROTO_L2CAP:%0A%09%09%09pp := (*RawSockaddrL2)(unsafe.Pointer(rsa))%0A%09%09%09sa := &SockaddrL2%7B%0A%09%09%09%09PSM:      pp.Psm,%0A%09%09%09%09CID:      pp.Cid,%0A%09%09%09%09Addr:     pp.Bdaddr,%0A%09%09%09%09AddrType: pp.Bdaddr_type,%0A%09%09%09%7D%0A%09%09%09return sa, nil%0A%09%09case BTPROTO_RFCOMM:%0A%09%09%09pp := (*RawSockaddrRFCOMM)(unsafe.Pointer(rsa))%0A%09%09%09sa := &SockaddrRFCOMM%7B%0A%09%09%09%09Channel: pp.Channel,%0A%09%09%09%09Addr:    pp.Bdaddr,%0A%09%09%09%7D%0A%09%09%09return sa, nil%0A%09%09%7D%0A%09case AF_XDP:%0A%09%09pp := (*RawSockaddrXDP)(unsafe.Pointer(rsa))%0A%09%09sa := &SockaddrXDP%7B%0A%09%09%09Flags:        pp.Flags,%0A%09%09%09Ifindex:      pp.Ifindex,%0A%09%09%09QueueID:      pp.Queue_id,%0A%09%09%09SharedUmemFD: pp.Shared_umem_fd,%0A%09%09%7D%0A%09%09return sa, nil%0A%09%7D%0A%09return nil, EAFNOSUPPORT%0A%7D%0A%0Afunc Accept(fd int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept(fd, &rsa, &len)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09sa, err = anyToSockaddr(fd, &rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept4(fd, &rsa, &len, flags)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09if len %3E SizeofSockaddrAny %7B%0A%09%09panic(%22RawSockaddrAny too small%22)%0A%09%7D%0A%09sa, err = anyToSockaddr(fd, &rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getsockname(fd int) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if err = getsockname(fd, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return anyToSockaddr(fd, &rsa)%0A%7D%0A%0Afunc GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error) %7B%0A%09var value IPMreqn%0A%09vallen := _Socklen(SizeofIPMreqn)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptUcred(fd, level, opt int) (*Ucred, error) %7B%0A%09var value Ucred%0A%09vallen := _Socklen(SizeofUcred)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptTCPInfo(fd, level, opt int) (*TCPInfo, error) %7B%0A%09var value TCPInfo%0A%09vallen := _Socklen(SizeofTCPInfo)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0A// GetsockoptString returns the string value of the socket option opt for the%0A// socket associated with fd at the given socket level.%0Afunc GetsockoptString(fd, level, opt int) (string, error) %7B%0A%09buf := make(%5B%5Dbyte, 256)%0A%09vallen := _Socklen(len(buf))%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&buf%5B0%5D), &vallen)%0A%09if err != nil %7B%0A%09%09if err == ERANGE %7B%0A%09%09%09buf = make(%5B%5Dbyte, vallen)%0A%09%09%09err = getsockopt(fd, level, opt, unsafe.Pointer(&buf%5B0%5D), &vallen)%0A%09%09%7D%0A%09%09if err != nil %7B%0A%09%09%09return %22%22, err%0A%09%09%7D%0A%09%7D%0A%09return string(buf%5B:vallen-1%5D), nil%0A%7D%0A%0Afunc SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(mreq), unsafe.Sizeof(*mreq))%0A%7D%0A%0A// Keyctl Commands (http://man7.org/linux/man-pages/man2/keyctl.2.html)%0A%0A// KeyctlInt calls keyctl commands in which each argument is an int.%0A// These commands are KEYCTL_REVOKE, KEYCTL_CHOWN, KEYCTL_CLEAR, KEYCTL_LINK,%0A// KEYCTL_UNLINK, KEYCTL_NEGATE, KEYCTL_SET_REQKEY_KEYRING, KEYCTL_SET_TIMEOUT,%0A// KEYCTL_ASSUME_AUTHORITY, KEYCTL_SESSION_TO_PARENT, KEYCTL_REJECT,%0A// KEYCTL_INVALIDATE, and KEYCTL_GET_PERSISTENT.%0A//sys%09KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlBuffer calls keyctl commands in which the third and fourth%0A// arguments are a buffer and its length, respectively.%0A// These commands are KEYCTL_UPDATE, KEYCTL_READ, and KEYCTL_INSTANTIATE.%0A//sys%09KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlString calls keyctl commands which return a string.%0A// These commands are KEYCTL_DESCRIBE and KEYCTL_GET_SECURITY.%0Afunc KeyctlString(cmd int, id int) (string, error) %7B%0A%09// We must loop as the string data may change in between the syscalls.%0A%09// We could allocate a large buffer here to reduce the chance that the%0A%09// syscall needs to be called twice; however, this is unnecessary as%0A%09// the performance loss is negligible.%0A%09var buffer %5B%5Dbyte%0A%09for %7B%0A%09%09// Try to fill the buffer with data%0A%09%09length, err := KeyctlBuffer(cmd, id, buffer, 0)%0A%09%09if err != nil %7B%0A%09%09%09return %22%22, err%0A%09%09%7D%0A%0A%09%09// Check if the data was written%0A%09%09if length %3C= len(buffer) %7B%0A%09%09%09// Exclude the null terminator%0A%09%09%09return string(buffer%5B:length-1%5D), nil%0A%09%09%7D%0A%0A%09%09// Make a bigger buffer if needed%0A%09%09buffer = make(%5B%5Dbyte, length)%0A%09%7D%0A%7D%0A%0A// Keyctl commands with special signatures.%0A%0A// KeyctlGetKeyringID implements the KEYCTL_GET_KEYRING_ID command.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_get_keyring_ID.3.html%0Afunc KeyctlGetKeyringID(id int, create bool) (ringid int, err error) %7B%0A%09createInt := 0%0A%09if create %7B%0A%09%09createInt = 1%0A%09%7D%0A%09return KeyctlInt(KEYCTL_GET_KEYRING_ID, id, createInt, 0, 0)%0A%7D%0A%0A// KeyctlSetperm implements the KEYCTL_SETPERM command. The perm value is the%0A// key handle permission mask as described in the %22keyctl setperm%22 section of%0A// http://man7.org/linux/man-pages/man1/keyctl.1.html.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_setperm.3.html%0Afunc KeyctlSetperm(id int, perm uint32) error %7B%0A%09_, err := KeyctlInt(KEYCTL_SETPERM, id, int(perm), 0, 0)%0A%09return err%0A%7D%0A%0A//sys%09keyctlJoin(cmd int, arg2 string) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlJoinSessionKeyring implements the KEYCTL_JOIN_SESSION_KEYRING command.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_join_session_keyring.3.html%0Afunc KeyctlJoinSessionKeyring(name string) (ringid int, err error) %7B%0A%09return keyctlJoin(KEYCTL_JOIN_SESSION_KEYRING, name)%0A%7D%0A%0A//sys%09keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlSearch implements the KEYCTL_SEARCH command.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_search.3.html%0Afunc KeyctlSearch(ringid int, keyType, description string, destRingid int) (id int, err error) %7B%0A%09return keyctlSearch(KEYCTL_SEARCH, ringid, keyType, description, destRingid)%0A%7D%0A%0A//sys%09keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) = SYS_KEYCTL%0A%0A// KeyctlInstantiateIOV implements the KEYCTL_INSTANTIATE_IOV command. This%0A// command is similar to KEYCTL_INSTANTIATE, except that the payload is a slice%0A// of Iovec (each of which represents a buffer) instead of a single buffer.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_instantiate_iov.3.html%0Afunc KeyctlInstantiateIOV(id int, payload %5B%5DIovec, ringid int) error %7B%0A%09return keyctlIOV(KEYCTL_INSTANTIATE_IOV, id, payload, ringid)%0A%7D%0A%0A//sys%09keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) = SYS_KEYCTL%0A%0A// KeyctlDHCompute implements the KEYCTL_DH_COMPUTE command. This command%0A// computes a Diffie-Hellman shared secret based on the provide params. The%0A// secret is written to the provided buffer and the returned size is the number%0A// of bytes written (returning an error if there is insufficient space in the%0A// buffer). If a nil buffer is passed in, this function returns the minimum%0A// buffer length needed to store the appropriate data. Note that this differs%0A// from KEYCTL_READ's behavior which always returns the requested payload size.%0A// See the full documentation at:%0A// http://man7.org/linux/man-pages/man3/keyctl_dh_compute.3.html%0Afunc KeyctlDHCompute(params *KeyctlDHParams, buffer %5B%5Dbyte) (size int, err error) %7B%0A%09return keyctlDH(KEYCTL_DH_COMPUTE, params, buffer)%0A%7D%0A%0Afunc Recvmsg(fd int, p, oob %5B%5Dbyte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) %7B%0A%09var msg Msghdr%0A%09var rsa RawSockaddrAny%0A%09msg.Name = (*byte)(unsafe.Pointer(&rsa))%0A%09msg.Namelen = uint32(SizeofSockaddrAny)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = &p%5B0%5D%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy byte%0A%09if len(oob) %3E 0 %7B%0A%09%09if len(p) == 0 %7B%0A%09%09%09var sockType int%0A%09%09%09sockType, err = GetsockoptInt(fd, SOL_SOCKET, SO_TYPE)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return%0A%09%09%09%7D%0A%09%09%09// receive at least one normal byte%0A%09%09%09if sockType != SOCK_DGRAM %7B%0A%09%09%09%09iov.Base = &dummy%0A%09%09%09%09iov.SetLen(1)%0A%09%09%09%7D%0A%09%09%7D%0A%09%09msg.Control = &oob%5B0%5D%0A%09%09msg.SetControllen(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = recvmsg(fd, &msg, flags); err != nil %7B%0A%09%09return%0A%09%7D%0A%09oobn = int(msg.Controllen)%0A%09recvflags = int(msg.Flags)%0A%09// source address is only specified if the socket is unconnected%0A%09if rsa.Addr.Family != AF_UNSPEC %7B%0A%09%09from, err = anyToSockaddr(fd, &rsa)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sendmsg(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (err error) %7B%0A%09_, err = SendmsgN(fd, p, oob, to, flags)%0A%09return%0A%7D%0A%0Afunc SendmsgN(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (n int, err error) %7B%0A%09var ptr unsafe.Pointer%0A%09var salen _Socklen%0A%09if to != nil %7B%0A%09%09var err error%0A%09%09ptr, salen, err = to.sockaddr()%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%7D%0A%09var msg Msghdr%0A%09msg.Name = (*byte)(ptr)%0A%09msg.Namelen = uint32(salen)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = &p%5B0%5D%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy byte%0A%09if len(oob) %3E 0 %7B%0A%09%09if len(p) == 0 %7B%0A%09%09%09var sockType int%0A%09%09%09sockType, err = GetsockoptInt(fd, SOL_SOCKET, SO_TYPE)%0A%09%09%09if err != nil %7B%0A%09%09%09%09return 0, err%0A%09%09%09%7D%0A%09%09%09// send at least one normal byte%0A%09%09%09if sockType != SOCK_DGRAM %7B%0A%09%09%09%09iov.Base = &dummy%0A%09%09%09%09iov.SetLen(1)%0A%09%09%09%7D%0A%09%09%7D%0A%09%09msg.Control = &oob%5B0%5D%0A%09%09msg.SetControllen(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = sendmsg(fd, &msg, flags); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if len(oob) %3E 0 && len(p) == 0 %7B%0A%09%09n = 0%0A%09%7D%0A%09return n, nil%0A%7D%0A%0A// BindToDevice binds the socket associated with fd to device.%0Afunc BindToDevice(fd int, device string) (err error) %7B%0A%09return SetsockoptString(fd, SOL_SOCKET, SO_BINDTODEVICE, device)%0A%7D%0A%0A//sys%09ptrace(request int, pid int, addr uintptr, data uintptr) (err error)%0A%0Afunc ptracePeek(req int, pid int, addr uintptr, out %5B%5Dbyte) (count int, err error) %7B%0A%09// The peek requests are machine-size oriented, so we wrap it%0A%09// to retrieve arbitrary-length data.%0A%0A%09// The ptrace syscall differs from glibc's ptrace.%0A%09// Peeks returns the word in *data, not as the return value.%0A%0A%09var buf %5BsizeofPtr%5Dbyte%0A%0A%09// Leading edge. PEEKTEXT/PEEKDATA don't require aligned%0A%09// access (PEEKUSER warns that it might), but if we don't%0A%09// align our reads, we might straddle an unmapped page%0A%09// boundary and not get the bytes leading up to the page%0A%09// boundary.%0A%09n := 0%0A%09if addr%25sizeofPtr != 0 %7B%0A%09%09err = ptrace(req, pid, addr-addr%25sizeofPtr, uintptr(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%09n += copy(out, buf%5Baddr%25sizeofPtr:%5D)%0A%09%09out = out%5Bn:%5D%0A%09%7D%0A%0A%09// Remainder.%0A%09for len(out) %3E 0 %7B%0A%09%09// We use an internal buffer to guarantee alignment.%0A%09%09// It's not documented if this is necessary, but we're paranoid.%0A%09%09err = ptrace(req, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09copied := copy(out, buf%5B0:%5D)%0A%09%09n += copied%0A%09%09out = out%5Bcopied:%5D%0A%09%7D%0A%0A%09return n, nil%0A%7D%0A%0Afunc PtracePeekText(pid int, addr uintptr, out %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePeek(PTRACE_PEEKTEXT, pid, addr, out)%0A%7D%0A%0Afunc PtracePeekData(pid int, addr uintptr, out %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePeek(PTRACE_PEEKDATA, pid, addr, out)%0A%7D%0A%0Afunc PtracePeekUser(pid int, addr uintptr, out %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePeek(PTRACE_PEEKUSR, pid, addr, out)%0A%7D%0A%0Afunc ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data %5B%5Dbyte) (count int, err error) %7B%0A%09// As for ptracePeek, we need to align our accesses to deal%0A%09// with the possibility of straddling an invalid page.%0A%0A%09// Leading edge.%0A%09n := 0%0A%09if addr%25sizeofPtr != 0 %7B%0A%09%09var buf %5BsizeofPtr%5Dbyte%0A%09%09err = ptrace(peekReq, pid, addr-addr%25sizeofPtr, uintptr(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%09n += copy(buf%5Baddr%25sizeofPtr:%5D, data)%0A%09%09word := *((*uintptr)(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09err = ptrace(pokeReq, pid, addr-addr%25sizeofPtr, word)%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%09data = data%5Bn:%5D%0A%09%7D%0A%0A%09// Interior.%0A%09for len(data) %3E sizeofPtr %7B%0A%09%09word := *((*uintptr)(unsafe.Pointer(&data%5B0%5D)))%0A%09%09err = ptrace(pokeReq, pid, addr+uintptr(n), word)%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09n += sizeofPtr%0A%09%09data = data%5BsizeofPtr:%5D%0A%09%7D%0A%0A%09// Trailing edge.%0A%09if len(data) %3E 0 %7B%0A%09%09var buf %5BsizeofPtr%5Dbyte%0A%09%09err = ptrace(peekReq, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09copy(buf%5B0:%5D, data)%0A%09%09word := *((*uintptr)(unsafe.Pointer(&buf%5B0%5D)))%0A%09%09err = ptrace(pokeReq, pid, addr+uintptr(n), word)%0A%09%09if err != nil %7B%0A%09%09%09return n, err%0A%09%09%7D%0A%09%09n += len(data)%0A%09%7D%0A%0A%09return n, nil%0A%7D%0A%0Afunc PtracePokeText(pid int, addr uintptr, data %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePoke(PTRACE_POKETEXT, PTRACE_PEEKTEXT, pid, addr, data)%0A%7D%0A%0Afunc PtracePokeData(pid int, addr uintptr, data %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePoke(PTRACE_POKEDATA, PTRACE_PEEKDATA, pid, addr, data)%0A%7D%0A%0Afunc PtracePokeUser(pid int, addr uintptr, data %5B%5Dbyte) (count int, err error) %7B%0A%09return ptracePoke(PTRACE_POKEUSR, PTRACE_PEEKUSR, pid, addr, data)%0A%7D%0A%0Afunc PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0Afunc PtraceSetRegs(pid int, regs *PtraceRegs) (err error) %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0Afunc PtraceSetOptions(pid int, options int) (err error) %7B%0A%09return ptrace(PTRACE_SETOPTIONS, pid, 0, uintptr(options))%0A%7D%0A%0Afunc PtraceGetEventMsg(pid int) (msg uint, err error) %7B%0A%09var data _C_long%0A%09err = ptrace(PTRACE_GETEVENTMSG, pid, 0, uintptr(unsafe.Pointer(&data)))%0A%09msg = uint(data)%0A%09return%0A%7D%0A%0Afunc PtraceCont(pid int, signal int) (err error) %7B%0A%09return ptrace(PTRACE_CONT, pid, 0, uintptr(signal))%0A%7D%0A%0Afunc PtraceSyscall(pid int, signal int) (err error) %7B%0A%09return ptrace(PTRACE_SYSCALL, pid, 0, uintptr(signal))%0A%7D%0A%0Afunc PtraceSingleStep(pid int) (err error) %7B return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) %7D%0A%0Afunc PtraceAttach(pid int) (err error) %7B return ptrace(PTRACE_ATTACH, pid, 0, 0) %7D%0A%0Afunc PtraceDetach(pid int) (err error) %7B return ptrace(PTRACE_DETACH, pid, 0, 0) %7D%0A%0A//sys%09reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error)%0A%0Afunc Reboot(cmd int) (err error) %7B%0A%09return reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, cmd, %22%22)%0A%7D%0A%0Afunc ReadDirent(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09return Getdents(fd, buf)%0A%7D%0A%0A//sys%09mount(source string, target string, fstype string, flags uintptr, data *byte) (err error)%0A%0Afunc Mount(source string, target string, fstype string, flags uintptr, data string) (err error) %7B%0A%09// Certain file systems get rather angry and EINVAL if you give%0A%09// them an empty string of data, rather than NULL.%0A%09if data == %22%22 %7B%0A%09%09return mount(source, target, fstype, flags, nil)%0A%09%7D%0A%09datap, err := BytePtrFromString(data)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return mount(source, target, fstype, flags, datap)%0A%7D%0A%0A// Sendto%0A// Recvfrom%0A// Socketpair%0A%0A/*%0A * Direct access%0A */%0A//sys%09Acct(path string) (err error)%0A//sys%09AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error)%0A//sys%09Adjtimex(buf *Timex) (state int, err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09ClockGettime(clockid int32, time *Timespec) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)%0A//sys%09Dup(oldfd int) (fd int, err error)%0A//sys%09Dup3(oldfd int, newfd int, flags int) (err error)%0A//sysnb%09EpollCreate1(flag int) (fd int, err error)%0A//sysnb%09EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)%0A//sys%09Eventfd(initval uint, flags int) (fd int, err error) = SYS_EVENTFD2%0A//sys%09Exit(code int) = SYS_EXIT_GROUP%0A//sys%09Fallocate(fd int, mode uint32, off int64, len int64) (err error)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)%0A//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A//sys%09Fdatasync(fd int) (err error)%0A//sys%09Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fremovexattr(fd int, attr string) (err error)%0A//sys%09Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Getdents(fd int, buf %5B%5Dbyte) (n int, err error) = SYS_GETDENTS64%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A%0Afunc Getpgrp() (pid int) %7B%0A%09pid, _ = Getpgid(0)%0A%09return%0A%7D%0A%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sys%09Getrandom(buf %5B%5Dbyte, flags int) (n int, err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettid() (tid int)%0A//sys%09Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)%0A//sysnb%09InotifyInit1(flags int) (fd int, err error)%0A//sysnb%09InotifyRmWatch(fd int, watchdesc uint32) (success int, err error)%0A//sysnb%09Kill(pid int, sig syscall.Signal) (err error)%0A//sys%09Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) = SYS_SYSLOG%0A//sys%09Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09Listxattr(path string, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error)%0A//sys%09Lremovexattr(path string, attr string) (err error)%0A//sys%09Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error)%0A//sys%09MemfdCreate(name string, flags int) (fd int, err error)%0A//sys%09Mkdirat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mknodat(dirfd int, path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error)%0A//sys%09PivotRoot(newroot string, putold string) (err error) = SYS_PIVOT_ROOT%0A//sysnb prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) = SYS_PRLIMIT64%0A//sys   Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error)%0A//sys%09Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) = SYS_PSELECT6%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Removexattr(path string, attr string) (err error)%0A//sys%09Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)%0A//sys%09Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error)%0A//sys%09RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error)%0A//sys%09Setdomainname(p %5B%5Dbyte) (err error)%0A//sys%09Sethostname(p %5B%5Dbyte) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tv *Timeval) (err error)%0A//sys%09Setns(fd int, nstype int) (err error)%0A%0A// issue 1435.%0A// On linux Setuid and Setgid only affects the current thread, not the process.%0A// This does not match what most callers expect so we must return an error%0A// here rather than letting the caller think that the call succeeded.%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09return EOPNOTSUPP%0A%7D%0A%0Afunc Setgid(uid int) (err error) %7B%0A%09return EOPNOTSUPP%0A%7D%0A%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sys%09Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error)%0A//sys%09Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error)%0A//sys%09Sync()%0A//sys%09Syncfs(fd int) (err error)%0A//sysnb%09Sysinfo(info *Sysinfo_t) (err error)%0A//sys%09Tee(rfd int, wfd int, len int, flags int) (n int64, err error)%0A//sysnb%09Tgkill(tgid int, tid int, sig syscall.Signal) (err error)%0A//sysnb%09Times(tms *Tms) (ticks uintptr, err error)%0A//sysnb%09Umask(mask int) (oldmask int)%0A//sysnb%09Uname(buf *Utsname) (err error)%0A//sys%09Unmount(target string, flags int) (err error) = SYS_UMOUNT2%0A//sys%09Unshare(flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09exitThread(code int) (err error) = SYS_EXIT%0A//sys%09readlen(fd int, p *byte, np int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, p *byte, np int) (n int, err error) = SYS_WRITE%0A%0A// mmap varies by architecture; see syscall_linux_*.go.%0A//sys%09munmap(addr uintptr, length uintptr) (err error)%0A%0Avar mapper = &mmapper%7B%0A%09active: make(map%5B*byte%5D%5B%5Dbyte),%0A%09mmap:   mmap,%0A%09munmap: munmap,%0A%7D%0A%0Afunc Mmap(fd int, offset int64, length int, prot int, flags int) (data %5B%5Dbyte, err error) %7B%0A%09return mapper.Mmap(fd, offset, length, prot, flags)%0A%7D%0A%0Afunc Munmap(b %5B%5Dbyte) (err error) %7B%0A%09return mapper.Munmap(b)%0A%7D%0A%0A//sys%09Madvise(b %5B%5Dbyte, advice int) (err error)%0A//sys%09Mprotect(b %5B%5Dbyte, prot int) (err error)%0A//sys%09Mlock(b %5B%5Dbyte) (err error)%0A//sys%09Mlockall(flags int) (err error)%0A//sys%09Msync(b %5B%5Dbyte, flags int) (err error)%0A//sys%09Munlock(b %5B%5Dbyte) (err error)%0A//sys%09Munlockall() (err error)%0A%0A// Vmsplice splices user pages from a slice of Iovecs into a pipe specified by fd,%0A// using the specified flags.%0Afunc Vmsplice(fd int, iovs %5B%5DIovec, flags int) (int, error) %7B%0A%09n, _, errno := Syscall6(%0A%09%09SYS_VMSPLICE,%0A%09%09uintptr(fd),%0A%09%09uintptr(unsafe.Pointer(&iovs%5B0%5D)),%0A%09%09uintptr(len(iovs)),%0A%09%09uintptr(flags),%0A%09%090,%0A%09%090,%0A%09)%0A%09if errno != 0 %7B%0A%09%09return 0, syscall.Errno(errno)%0A%09%7D%0A%0A%09return int(n), nil%0A%7D%0A%0A//sys%09faccessat(dirfd int, path string, mode uint32) (err error)%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09if flags & %5E(AT_SYMLINK_NOFOLLOW%7CAT_EACCESS) != 0 %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09// The Linux kernel faccessat system call does not take any flags.%0A%09// The glibc faccessat implements the flags itself; see%0A%09// https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/faccessat.c;hb=HEAD%0A%09// Because people naturally expect syscall.Faccessat to act%0A%09// like C faccessat, we do the same.%0A%0A%09if flags == 0 %7B%0A%09%09return faccessat(dirfd, path, mode)%0A%09%7D%0A%0A%09var st Stat_t%0A%09if err := Fstatat(dirfd, path, &st, flags&AT_SYMLINK_NOFOLLOW); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mode &= 7%0A%09if mode == 0 %7B%0A%09%09return nil%0A%09%7D%0A%0A%09var uid int%0A%09if flags&AT_EACCESS != 0 %7B%0A%09%09uid = Geteuid()%0A%09%7D else %7B%0A%09%09uid = Getuid()%0A%09%7D%0A%0A%09if uid == 0 %7B%0A%09%09if mode&1 == 0 %7B%0A%09%09%09// Root can read and write any file.%0A%09%09%09return nil%0A%09%09%7D%0A%09%09if st.Mode&0111 != 0 %7B%0A%09%09%09// Root can execute any file that anybody can execute.%0A%09%09%09return nil%0A%09%09%7D%0A%09%09return EACCES%0A%09%7D%0A%0A%09var fmode uint32%0A%09if uint32(uid) == st.Uid %7B%0A%09%09fmode = (st.Mode %3E%3E 6) & 7%0A%09%7D else %7B%0A%09%09var gid int%0A%09%09if flags&AT_EACCESS != 0 %7B%0A%09%09%09gid = Getegid()%0A%09%09%7D else %7B%0A%09%09%09gid = Getgid()%0A%09%09%7D%0A%0A%09%09if uint32(gid) == st.Gid %7B%0A%09%09%09fmode = (st.Mode %3E%3E 3) & 7%0A%09%09%7D else %7B%0A%09%09%09fmode = st.Mode & 7%0A%09%09%7D%0A%09%7D%0A%0A%09if fmode&mode == mode %7B%0A%09%09return nil%0A%09%7D%0A%0A%09return EACCES%0A%7D%0A%0A/*%0A * Unimplemented%0A */%0A// AfsSyscall%0A// Alarm%0A// ArchPrctl%0A// Brk%0A// Capget%0A// Capset%0A// ClockGetres%0A// ClockNanosleep%0A// ClockSettime%0A// Clone%0A// CreateModule%0A// DeleteModule%0A// EpollCtlOld%0A// EpollPwait%0A// EpollWaitOld%0A// Execve%0A// Fork%0A// Futex%0A// GetKernelSyms%0A// GetMempolicy%0A// GetRobustList%0A// GetThreadArea%0A// Getitimer%0A// Getpmsg%0A// IoCancel%0A// IoDestroy%0A// IoGetevents%0A// IoSetup%0A// IoSubmit%0A// IoprioGet%0A// IoprioSet%0A// KexecLoad%0A// LookupDcookie%0A// Mbind%0A// MigratePages%0A// Mincore%0A// ModifyLdt%0A// Mount%0A// MovePages%0A// MqGetsetattr%0A// MqNotify%0A// MqOpen%0A// MqTimedreceive%0A// MqTimedsend%0A// MqUnlink%0A// Mremap%0A// Msgctl%0A// Msgget%0A// Msgrcv%0A// Msgsnd%0A// Nfsservctl%0A// Personality%0A// Pselect6%0A// Ptrace%0A// Putpmsg%0A// QueryModule%0A// Quotactl%0A// Readahead%0A// Readv%0A// RemapFilePages%0A// RestartSyscall%0A// RtSigaction%0A// RtSigpending%0A// RtSigprocmask%0A// RtSigqueueinfo%0A// RtSigreturn%0A// RtSigsuspend%0A// RtSigtimedwait%0A// SchedGetPriorityMax%0A// SchedGetPriorityMin%0A// SchedGetparam%0A// SchedGetscheduler%0A// SchedRrGetInterval%0A// SchedSetparam%0A// SchedYield%0A// Security%0A// Semctl%0A// Semget%0A// Semop%0A// Semtimedop%0A// SetMempolicy%0A// SetRobustList%0A// SetThreadArea%0A// SetTidAddress%0A// Shmat%0A// Shmctl%0A// Shmdt%0A// Shmget%0A// Sigaltstack%0A// Signalfd%0A// Swapoff%0A// Swapon%0A// Sysfs%0A// TimerCreate%0A// TimerDelete%0A// TimerGetoverrun%0A// TimerGettime%0A// TimerSettime%0A// Timerfd%0A// Tkill (obsolete)%0A// Tuxcall%0A// Umount2%0A// Uselib%0A// Utimensat%0A// Vfork%0A// Vhangup%0A// Vserver%0A// Waitid%0A// _Sysctl%0A
- f 95bd961a24c17e2daa7b52bf348cfb0e784577d3dbac1032855d12cbe8f2354d vendor/golang.org/x/sys/unix/syscall_linux_386.go
+ f fd39cde02c43ea5cf2a3ad6d4c45f31dd712ce33858960527092e685d11f84ea vendor/golang.org/x/sys/unix/syscall_linux_386.go
dmppatch 3
@@ -304,8 +304,10477 @@
 ge unix%0A
+%0Aimport (%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb%09pipe(p *%5B2%5D_C_int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A// 64-bit file system and 32-bit uid calls%0A// (386 default is 32-bit file system and 16-bit uid).%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sysnb%09EpollCreate(size int) (fd int, err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64_64%0A//sys%09Fchown(fd int, uid int, gid int) (err error) = SYS_FCHOWN32%0A//sys%09Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sys%09Ftruncate(fd int, length int64) (err error) = SYS_FTRUNCATE64%0A//sysnb%09Getegid() (egid int) = SYS_GETEGID32%0A//sysnb%09Geteuid() (euid int) = SYS_GETEUID32%0A//sysnb%09Getgid() (gid int) = SYS_GETGID32%0A//sysnb%09Getuid() (uid int) = SYS_GETUID32%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Ioperm(from int, num int, on int) (err error)%0A//sys%09Iopl(level int) (err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error) = SYS_LCHOWN32%0A//sys%09Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64%0A//sys%09Setfsgid(gid int) (err error) = SYS_SETFSGID32%0A//sys%09Setfsuid(uid int) (err error) = SYS_SETFSUID32%0A//sysnb%09Setregid(rgid int, egid int) (err error) = SYS_SETREGID32%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error) = SYS_SETRESGID32%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error) = SYS_SETRESUID32%0A//sysnb%09Setreuid(ruid int, euid int) (err error) = SYS_SETREUID32%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error) = SYS_STAT64%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error) = SYS_TRUNCATE64%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error) = SYS_GETGROUPS32%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error) = SYS_SETGROUPS32%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT%0A%0A//sys%09mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error)%0A//sys%09Pause() (err error)%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09page := uintptr(offset / 4096)%0A%09if offset != int64(page)*4096 %7B%0A%09%09return 0, EINVAL%0A%09%7D%0A%09return mmap2(addr, length, prot, flags, fd, page)%0A%7D%0A%0Atype rlimit32 struct %7B%0A%09Cur uint32%0A%09Max uint32%0A%7D%0A%0A//sysnb getrlimit(resource int, rlim *rlimit32) (err error) = SYS_GETRLIMIT%0A%0Aconst rlimInf32 = %5Euint32(0)%0Aconst rlimInf64 = %5Euint64(0)%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, nil, rlim)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09err = getrlimit(resource, &rl)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09if rl.Cur == rlimInf32 %7B%0A%09%09rlim.Cur = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Cur = uint64(rl.Cur)%0A%09%7D%0A%0A%09if rl.Max == rlimInf32 %7B%0A%09%09rlim.Max = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Max = uint64(rl.Max)%0A%09%7D%0A%09return%0A%7D%0A%0A//sysnb setrlimit(resource int, rlim *rlimit32) (err error) = SYS_SETRLIMIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, rlim, nil)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09if rlim.Cur == rlimInf64 %7B%0A%09%09rl.Cur = rlimInf32%0A%09%7D else if rlim.Cur %3C uint64(rlimInf32) %7B%0A%09%09rl.Cur = uint32(rlim.Cur)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%09if rlim.Max == rlimInf64 %7B%0A%09%09rl.Max = rlimInf32%0A%09%7D else if rlim.Max %3C uint64(rlimInf32) %7B%0A%09%09rl.Max = uint32(rlim.Max)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09return setrlimit(resource, &rl)%0A%7D%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09newoffset, errno := seek(fd, offset, whence)%0A%09if errno != 0 %7B%0A%09%09return 0, errno%0A%09%7D%0A%09return newoffset, nil%0A%7D%0A%0A//sys%09futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Time(t *Time_t) (tt Time_t, err error)%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0A// On x86 Linux, all the socket calls go through an extra indirection,%0A// I think because the 5-register system call interface can't handle%0A// the 6-argument calls like sendto and recvfrom. Instead the%0A// arguments to the underlying system call are the number below%0A// and a pointer to an array of uintptr. We hide the pointer in the%0A// socketcall assembly to avoid allocation on every system call.%0A%0Aconst (%0A%09// see linux/net.h%0A%09_SOCKET      = 1%0A%09_BIND        = 2%0A%09_CONNECT     = 3%0A%09_LISTEN      = 4%0A%09_ACCEPT      = 5%0A%09_GETSOCKNAME = 6%0A%09_GETPEERNAME = 7%0A%09_SOCKETPAIR  = 8%0A%09_SEND        = 9%0A%09_RECV        = 10%0A%09_SENDTO      = 11%0A%09_RECVFROM    = 12%0A%09_SHUTDOWN    = 13%0A%09_SETSOCKOPT  = 14%0A%09_GETSOCKOPT  = 15%0A%09_SENDMSG     = 16%0A%09_RECVMSG     = 17%0A%09_ACCEPT4     = 18%0A%09_RECVMMSG    = 19%0A%09_SENDMMSG    = 20%0A)%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09fd, e := socketcall(_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09fd, e := socketcall(_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockname(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, e := rawsocketcall(_GETSOCKNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getpeername(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, e := rawsocketcall(_GETPEERNAME, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socketpair(domain int, typ int, flags int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, e := rawsocketcall(_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(flags), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, e := socketcall(_BIND, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, e := socketcall(_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09fd, e := rawsocketcall(_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, e := socketcall(_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, e := socketcall(_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), vallen, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc recvfrom(s int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var base uintptr%0A%09if len(p) %3E 0 %7B%0A%09%09base = uintptr(unsafe.Pointer(&p%5B0%5D))%0A%09%7D%0A%09n, e := socketcall(_RECVFROM, uintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendto(s int, p %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var base uintptr%0A%09if len(p) %3E 0 %7B%0A%09%09base = uintptr(unsafe.Pointer(&p%5B0%5D))%0A%09%7D%0A%09_, e := socketcall(_SENDTO, uintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09n, e := socketcall(_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09n, e := socketcall(_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, e := socketcall(_LISTEN, uintptr(s), uintptr(n), 0, 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Shutdown(s, how int) (err error) %7B%0A%09_, e := socketcall(_SHUTDOWN, uintptr(s), uintptr(how), 0, 0, 0, 0)%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e := Syscall(SYS_FSTATFS64, uintptr(fd), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09pathp, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09_, _, e := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(pathp)), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return uint64(uint32(r.Eip)) %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Eip = int32(pc) %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 9286c57c303a4efad3ed9aab8d5cecee89766851a809bb025ae72144fbea6b9a vendor/golang.org/x/sys/unix/syscall_linux_amd64.go
+ f e83caa0edf302bb976dc7b4cd67706729c16f51f5ac78cae4d9753432370a2a6 vendor/golang.org/x/sys/unix/syscall_linux_amd64.go
dmppatch 3
@@ -189,8 +189,5463 @@
 ge unix%0A
+%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sysnb%09EpollCreate(size int) (fd int, err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_NEWFSTATAT%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Ioperm(from int, num int, on int) (err error)%0A//sys%09Iopl(level int) (err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout != nil %7B%0A%09%09ts = &Timespec%7BSec: timeout.Sec, Nsec: timeout.Usec * 1000%7D%0A%09%7D%0A%09return Pselect(nfd, r, w, e, ts, nil)%0A%7D%0A%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09// Use fstatat, because Android's seccomp policy blocks stat.%0A%09return Fstatat(AT_FDCWD, path, stat, 0)%0A%7D%0A%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0A//sys%09futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error)%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09errno := gettimeofday(tv)%0A%09if errno != 0 %7B%0A%09%09return errno%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09var tv Timeval%0A%09errno := gettimeofday(&tv)%0A%09if errno != 0 %7B%0A%09%09return 0, errno%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0A//sysnb%09pipe(p *%5B2%5D_C_int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Rip %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Rip = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 859b81608f7f5a054126310ac19905df48098711ec0b8781c42cb39a7cb62df7 vendor/golang.org/x/sys/unix/syscall_linux_amd64_gc.go
+ f 8b643c0f69d3b05c3a365bdf68f03d3b3fa73270a6cfe1c13dab86397edc968a vendor/golang.org/x/sys/unix/syscall_linux_amd64_gc.go
dmppatch 3
@@ -206,8 +206,92 @@
 ge unix%0A
+%0Aimport %22syscall%22%0A%0A//go:noescape%0Afunc gettimeofday(tv *Timeval) (err syscall.Errno)%0A
- f 40c7d74ce70c97b61767bbff4417c615d60b35e10d359fe61b39a224de46fedf vendor/golang.org/x/sys/unix/syscall_linux_arm.go
+ f 71baaba144e18d3eab3b5b0fca50481ac7123ba459adc2df0472a56e0b6bd9db vendor/golang.org/x/sys/unix/syscall_linux_arm.go
dmppatch 3
@@ -187,8 +187,7694 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A// Underlying system call writes to newoffset via pointer.%0A// Implemented in assembly to avoid allocation.%0Afunc seek(fd int, offset int64, whence int) (newoffset int64, err syscall.Errno)%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09newoffset, errno := seek(fd, offset, whence)%0A%09if errno != 0 %7B%0A%09%09return 0, errno%0A%09%7D%0A%09return newoffset, nil%0A%7D%0A%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error) = SYS_GETGROUPS32%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error) = SYS_SETGROUPS32%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09socketpair(domain int, typ int, flags int, fd *%5B2%5Dint32) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A%0A// 64-bit file system and 32-bit uid calls%0A// (16-bit uid calls are not always supported in newer kernels)%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sysnb%09EpollCreate(size int) (fd int, err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error) = SYS_FCHOWN32%0A//sys%09Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sysnb%09Getegid() (egid int) = SYS_GETEGID32%0A//sysnb%09Geteuid() (euid int) = SYS_GETEUID32%0A//sysnb%09Getgid() (gid int) = SYS_GETGID32%0A//sysnb%09Getuid() (uid int) = SYS_GETUID32%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error) = SYS_LCHOWN32%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64%0A//sys%09Pause() (err error)%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT%0A//sys%09Setfsgid(gid int) (err error) = SYS_SETFSGID32%0A//sys%09Setfsuid(uid int) (err error) = SYS_SETFSUID32%0A//sysnb%09Setregid(rgid int, egid int) (err error) = SYS_SETREGID32%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error) = SYS_SETRESGID32%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error) = SYS_SETRESUID32%0A//sysnb%09Setreuid(ruid int, euid int) (err error) = SYS_SETREUID32%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error) = SYS_STAT64%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A%0A//sys%09futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc Time(t *Time_t) (Time_t, error) %7B%0A%09var tv Timeval%0A%09err := Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0Afunc Utime(path string, buf *Utimbuf) error %7B%0A%09tv := %5B%5DTimeval%7B%0A%09%09%7BSec: buf.Actime%7D,%0A%09%09%7BSec: buf.Modtime%7D,%0A%09%7D%0A%09return Utimes(path, tv)%0A%7D%0A%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0A//sys   Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys   Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Truncate(path string, length int64) (err error) = SYS_TRUNCATE64%0A//sys%09Ftruncate(fd int, length int64) (err error) = SYS_FTRUNCATE64%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_ARM_FADVISE64_64, uintptr(fd), uintptr(advice), uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A//sys%09mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error)%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e := Syscall(SYS_FSTATFS64, uintptr(fd), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09pathp, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09_, _, e := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(pathp)), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = e%0A%09%7D%0A%09return%0A%7D%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09page := uintptr(offset / 4096)%0A%09if offset != int64(page)*4096 %7B%0A%09%09return 0, EINVAL%0A%09%7D%0A%09return mmap2(addr, length, prot, flags, fd, page)%0A%7D%0A%0Atype rlimit32 struct %7B%0A%09Cur uint32%0A%09Max uint32%0A%7D%0A%0A//sysnb getrlimit(resource int, rlim *rlimit32) (err error) = SYS_UGETRLIMIT%0A%0Aconst rlimInf32 = %5Euint32(0)%0Aconst rlimInf64 = %5Euint64(0)%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, nil, rlim)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09err = getrlimit(resource, &rl)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09if rl.Cur == rlimInf32 %7B%0A%09%09rlim.Cur = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Cur = uint64(rl.Cur)%0A%09%7D%0A%0A%09if rl.Max == rlimInf32 %7B%0A%09%09rlim.Max = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Max = uint64(rl.Max)%0A%09%7D%0A%09return%0A%7D%0A%0A//sysnb setrlimit(resource int, rlim *rlimit32) (err error) = SYS_SETRLIMIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, rlim, nil)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09if rlim.Cur == rlimInf64 %7B%0A%09%09rl.Cur = rlimInf32%0A%09%7D else if rlim.Cur %3C uint64(rlimInf32) %7B%0A%09%09rl.Cur = uint32(rlim.Cur)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%09if rlim.Max == rlimInf64 %7B%0A%09%09rl.Max = rlimInf32%0A%09%7D else if rlim.Max %3C uint64(rlimInf32) %7B%0A%09%09rl.Max = uint32(rlim.Max)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09return setrlimit(resource, &rl)%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return uint64(r.Uregs%5B15%5D) %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Uregs%5B15%5D = uint32(pc) %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 0b9fb5c7a7ae5d791299c60ee527208e4f053ee1b2d525bb8ab58dd0c47d93d5 vendor/golang.org/x/sys/unix/syscall_linux_arm64.go
+ f 12590292babc083e7707c53eaabd0b7130f8c9e2ed86fb0fad19259f838c0fc8 vendor/golang.org/x/sys/unix/syscall_linux_arm64.go
dmppatch 3
@@ -189,8 +189,6188 @@
 ge unix%0A
+%0Aimport %22unsafe%22%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09if size %3C= 0 %7B%0A%09%09return -1, EINVAL%0A%09%7D%0A%09return EpollCreate1(0)%0A%7D%0A%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) = SYS_EPOLL_PWAIT%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout != nil %7B%0A%09%09ts = &Timespec%7BSec: timeout.Sec, Nsec: timeout.Usec * 1000%7D%0A%09%7D%0A%09return Pselect(nfd, r, w, e, ts, nil)%0A%7D%0A%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09return Fstatat(AT_FDCWD, path, stat, 0)%0A%7D%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09return Fchownat(AT_FDCWD, path, uid, gid, AT_SYMLINK_NOFOLLOW)%0A%7D%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09return Fstatat(AT_FDCWD, path, stat, AT_SYMLINK_NOFOLLOW)%0A%7D%0A%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc futimesat(dirfd int, path string, tv *%5B2%5DTimeval) (err error) %7B%0A%09if tv == nil %7B%0A%09%09return utimensat(dirfd, path, nil, 0)%0A%09%7D%0A%0A%09ts := %5B%5DTimespec%7B%0A%09%09NsecToTimespec(TimevalToNsec(tv%5B0%5D)),%0A%09%09NsecToTimespec(TimevalToNsec(tv%5B1%5D)),%0A%09%7D%0A%09return utimensat(dirfd, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%7D%0A%0Afunc Time(t *Time_t) (Time_t, error) %7B%0A%09var tv Timeval%0A%09err := Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0Afunc Utime(path string, buf *Utimbuf) error %7B%0A%09tv := %5B%5DTimeval%7B%0A%09%09%7BSec: buf.Actime%7D,%0A%09%09%7BSec: buf.Modtime%7D,%0A%09%7D%0A%09return Utimes(path, tv)%0A%7D%0A%0Afunc utimes(path string, tv *%5B2%5DTimeval) (err error) %7B%0A%09if tv == nil %7B%0A%09%09return utimensat(AT_FDCWD, path, nil, 0)%0A%09%7D%0A%0A%09ts := %5B%5DTimespec%7B%0A%09%09NsecToTimespec(TimevalToNsec(tv%5B0%5D)),%0A%09%09NsecToTimespec(TimevalToNsec(tv%5B1%5D)),%0A%09%7D%0A%09return utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%7D%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Pc %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Pc = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09return InotifyInit1(0)%0A%7D%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09return Dup3(oldfd, newfd, 0)%0A%7D%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PPOLL, 0, 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout %3E= 0 %7B%0A%09%09ts = new(Timespec)%0A%09%09*ts = NsecToTimespec(int64(timeout) * 1e6)%0A%09%7D%0A%09if len(fds) == 0 %7B%0A%09%09return ppoll(nil, 0, ts, nil)%0A%09%7D%0A%09return ppoll(&fds%5B0%5D, len(fds), ts, nil)%0A%7D%0A
- f dcd409c7e9f17b1f8f93b0e5c191e73f9dda84746ed3883af4bf3a35904e1003 vendor/golang.org/x/sys/unix/syscall_linux_gc.go
+ f 9b9137cc0e38dc5452969dc2ea5937d090827e008cbe192b6d74f383003a2b35 vendor/golang.org/x/sys/unix/syscall_linux_gc.go
dmppatch 3
@@ -190,8 +190,306 @@
 ge unix%0A
+%0A// SyscallNoError may be used instead of Syscall for syscalls that don't fail.%0Afunc SyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr)%0A%0A// RawSyscallNoError may be used instead of RawSyscall for syscalls that don't%0A// fail.%0Afunc RawSyscallNoError(trap, a1, a2, a3 uintptr) (r1, r2 uintptr)%0A
- f 84feb3b7960c8db2af1fc6dac01a74e9078bd9fad2e31f53585e3e8c304adfd6 vendor/golang.org/x/sys/unix/syscall_linux_gc_386.go
+ f 7250992b24d849c6317ea5960e8e4361e3ab93703645176c98cc42736aaf5784 vendor/golang.org/x/sys/unix/syscall_linux_gc_386.go
dmppatch 3
@@ -194,8 +194,389 @@
 ge unix%0A
+%0Aimport %22syscall%22%0A%0A// Underlying system call writes to newoffset via pointer.%0A// Implemented in assembly to avoid allocation.%0Afunc seek(fd int, offset int64, whence int) (newoffset int64, err syscall.Errno)%0A%0Afunc socketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (n int, err syscall.Errno)%0Afunc rawsocketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (n int, err syscall.Errno)%0A
- f a72f5ac504c5f5895badaecea44f4fe02f000a503fba5524b34aa7ca857dfa92 vendor/golang.org/x/sys/unix/syscall_linux_gccgo_386.go
+ f 2911ddba99bc64de127a935f11800346f1c2c985d6f32dee903fa31204efc614 vendor/golang.org/x/sys/unix/syscall_linux_gccgo_386.go
dmppatch 3
@@ -193,8 +193,787 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc seek(fd int, offset int64, whence int) (int64, syscall.Errno) %7B%0A%09var newoffset int64%0A%09offsetLow := uint32(offset & 0xffffffff)%0A%09offsetHigh := uint32((offset %3E%3E 32) & 0xffffffff)%0A%09_, _, err := Syscall6(SYS__LLSEEK, uintptr(fd), uintptr(offsetHigh), uintptr(offsetLow), uintptr(unsafe.Pointer(&newoffset)), uintptr(whence), 0)%0A%09return newoffset, err%0A%7D%0A%0Afunc socketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (int, syscall.Errno) %7B%0A%09fd, _, err := Syscall(SYS_SOCKETCALL, uintptr(call), uintptr(unsafe.Pointer(&a0)), 0)%0A%09return int(fd), err%0A%7D%0A%0Afunc rawsocketcall(call int, a0, a1, a2, a3, a4, a5 uintptr) (int, syscall.Errno) %7B%0A%09fd, _, err := RawSyscall(SYS_SOCKETCALL, uintptr(call), uintptr(unsafe.Pointer(&a0)), 0)%0A%09return int(fd), err%0A%7D%0A
- f 0f8708ce7e3fb3462d4e4cb282c0a75eb1a1d3ed835540da9804c41b853f2674 vendor/golang.org/x/sys/unix/syscall_linux_gccgo_arm.go
+ f 260633a1233cbfc7920b046ae90f8efda6a380c16e85703c199e4b3b4306c40f vendor/golang.org/x/sys/unix/syscall_linux_gccgo_arm.go
dmppatch 3
@@ -193,8 +193,397 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc seek(fd int, offset int64, whence int) (int64, syscall.Errno) %7B%0A%09var newoffset int64%0A%09offsetLow := uint32(offset & 0xffffffff)%0A%09offsetHigh := uint32((offset %3E%3E 32) & 0xffffffff)%0A%09_, _, err := Syscall6(SYS__LLSEEK, uintptr(fd), uintptr(offsetHigh), uintptr(offsetLow), uintptr(unsafe.Pointer(&newoffset)), uintptr(whence), 0)%0A%09return newoffset, err%0A%7D%0A
- f 7b3f0d4478ea66e52a9dbb6ac03968eaf3ac42caa0618f5a5b0f8c8b5261004e vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go
+ f 6544e6031a24b5694f5ea71394b4904d99a12b99a8f5cd8f681c599972e7e2f5 vendor/golang.org/x/sys/unix/syscall_linux_mips64x.go
dmppatch 3
@@ -209,8 +209,6366 @@
 ge unix%0A
+%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sysnb%09EpollCreate(size int) (fd int, err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_NEWFSTATAT%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout != nil %7B%0A%09%09ts = &Timespec%7BSec: timeout.Sec, Nsec: timeout.Usec * 1000%7D%0A%09%7D%0A%09return Pselect(nfd, r, w, e, ts, nil)%0A%7D%0A%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0A//sys%09futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09var tv Timeval%0A%09err = Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Afunc Iopl(level int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Atype stat_t struct %7B%0A%09Dev        uint32%0A%09Pad0       %5B3%5Dint32%0A%09Ino        uint64%0A%09Mode       uint32%0A%09Nlink      uint32%0A%09Uid        uint32%0A%09Gid        uint32%0A%09Rdev       uint32%0A%09Pad1       %5B3%5Duint32%0A%09Size       int64%0A%09Atime      uint32%0A%09Atime_nsec uint32%0A%09Mtime      uint32%0A%09Mtime_nsec uint32%0A%09Ctime      uint32%0A%09Ctime_nsec uint32%0A%09Blksize    uint32%0A%09Pad2       uint32%0A%09Blocks     int64%0A%7D%0A%0A//sys%09fstat(fd int, st *stat_t) (err error)%0A//sys%09lstat(path string, st *stat_t) (err error)%0A//sys%09stat(path string, st *stat_t) (err error)%0A%0Afunc Fstat(fd int, s *Stat_t) (err error) %7B%0A%09st := &stat_t%7B%7D%0A%09err = fstat(fd, st)%0A%09fillStat_t(s, st)%0A%09return%0A%7D%0A%0Afunc Lstat(path string, s *Stat_t) (err error) %7B%0A%09st := &stat_t%7B%7D%0A%09err = lstat(path, st)%0A%09fillStat_t(s, st)%0A%09return%0A%7D%0A%0Afunc Stat(path string, s *Stat_t) (err error) %7B%0A%09st := &stat_t%7B%7D%0A%09err = stat(path, st)%0A%09fillStat_t(s, st)%0A%09return%0A%7D%0A%0Afunc fillStat_t(s *Stat_t, st *stat_t) %7B%0A%09s.Dev = st.Dev%0A%09s.Ino = st.Ino%0A%09s.Mode = st.Mode%0A%09s.Nlink = st.Nlink%0A%09s.Uid = st.Uid%0A%09s.Gid = st.Gid%0A%09s.Rdev = st.Rdev%0A%09s.Size = st.Size%0A%09s.Atim = Timespec%7Bint64(st.Atime), int64(st.Atime_nsec)%7D%0A%09s.Mtim = Timespec%7Bint64(st.Mtime), int64(st.Mtime_nsec)%7D%0A%09s.Ctim = Timespec%7Bint64(st.Ctime), int64(st.Ctime_nsec)%7D%0A%09s.Blksize = st.Blksize%0A%09s.Blocks = st.Blocks%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Epc %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Epc = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f e553ff7b8e7b6d8628e8f6aa1578fde79fe4579b0f5dfc75a81882b5e5f50e41 vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go
+ f 81f514d7b90c5dd3c2e558b87810098d3c0339a074fcfb452f6f4b02c6e72fd6 vendor/golang.org/x/sys/unix/syscall_linux_mipsx.go
dmppatch 3
@@ -205,8 +205,7051 @@
 ge unix%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Afunc Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sysnb%09EpollCreate(size int) (fd int, err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error) = SYS_FTRUNCATE64%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = SYS_SENDFILE64%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error) = SYS_TRUNCATE64%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Ioperm(from int, num int, on int) (err error)%0A//sys%09Iopl(level int) (err error)%0A%0A//sys%09futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Time(t *Time_t) (tt Time_t, err error)%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0A//sys%09Lstat(path string, stat *Stat_t) (err error) = SYS_LSTAT64%0A//sys%09Fstat(fd int, stat *Stat_t) (err error) = SYS_FSTAT64%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sys%09Stat(path string, stat *Stat_t) (err error) = SYS_STAT64%0A%0A//sys%09Pause() (err error)%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e := Syscall(SYS_FSTATFS64, uintptr(fd), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = errnoErr(e)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09p, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09_, _, e := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(p)), unsafe.Sizeof(*buf), uintptr(unsafe.Pointer(buf)))%0A%09if e != 0 %7B%0A%09%09err = errnoErr(e)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09_, _, e := Syscall6(SYS__LLSEEK, uintptr(fd), uintptr(offset%3E%3E32), uintptr(offset), uintptr(unsafe.Pointer(&off)), uintptr(whence), 0)%0A%09if e != 0 %7B%0A%09%09err = errnoErr(e)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: int32(sec), Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: int32(sec), Usec: int32(usec)%7D%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe() (p1 int, p2 int, err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09p%5B0%5D, p%5B1%5D, err = pipe()%0A%09return%0A%7D%0A%0A//sys%09mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error)%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09page := uintptr(offset / 4096)%0A%09if offset != int64(page)*4096 %7B%0A%09%09return 0, EINVAL%0A%09%7D%0A%09return mmap2(addr, length, prot, flags, fd, page)%0A%7D%0A%0Aconst rlimInf32 = %5Euint32(0)%0Aconst rlimInf64 = %5Euint64(0)%0A%0Atype rlimit32 struct %7B%0A%09Cur uint32%0A%09Max uint32%0A%7D%0A%0A//sysnb getrlimit(resource int, rlim *rlimit32) (err error) = SYS_GETRLIMIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, nil, rlim)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09err = getrlimit(resource, &rl)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09if rl.Cur == rlimInf32 %7B%0A%09%09rlim.Cur = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Cur = uint64(rl.Cur)%0A%09%7D%0A%0A%09if rl.Max == rlimInf32 %7B%0A%09%09rlim.Max = rlimInf64%0A%09%7D else %7B%0A%09%09rlim.Max = uint64(rl.Max)%0A%09%7D%0A%09return%0A%7D%0A%0A//sysnb setrlimit(resource int, rlim *rlimit32) (err error) = SYS_SETRLIMIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09err = prlimit(0, resource, rlim, nil)%0A%09if err != ENOSYS %7B%0A%09%09return err%0A%09%7D%0A%0A%09rl := rlimit32%7B%7D%0A%09if rlim.Cur == rlimInf64 %7B%0A%09%09rl.Cur = rlimInf32%0A%09%7D else if rlim.Cur %3C uint64(rlimInf32) %7B%0A%09%09rl.Cur = uint32(rlim.Cur)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%09if rlim.Max == rlimInf64 %7B%0A%09%09rl.Max = rlimInf32%0A%09%7D else if rlim.Max %3C uint64(rlimInf32) %7B%0A%09%09rl.Max = uint32(rlim.Max)%0A%09%7D else %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09return setrlimit(resource, &rl)%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Epc %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Epc = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f 0127c79405fd6f3d87b9bc46a6c1f6518fe31d5e18fe92484f961827fa50d617 vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go
+ f c7670b0692c1e02ed709c93fad9b747b2c64e651b45e88deb17d79e86686bd65 vendor/golang.org/x/sys/unix/syscall_linux_ppc64x.go
dmppatch 3
@@ -207,8 +207,5250 @@
 ge unix%0A
+%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sysnb%09EpollCreate(size int) (fd int, err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_NEWFSTATAT%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error) = SYS_UGETRLIMIT%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Ioperm(from int, num int, on int) (err error)%0A//sys%09Iopl(level int) (err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) = SYS__NEWSELECT%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0A//sys%09futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Time(t *Time_t) (tt Time_t, err error)%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Nip %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Nip = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A//sysnb pipe(p *%5B2%5D_C_int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A%0A//sys%09syncFileRange2(fd int, flags int, off int64, n int64) (err error) = SYS_SYNC_FILE_RANGE2%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) error %7B%0A%09// The sync_file_range and sync_file_range2 syscalls differ only in the%0A%09// order of their arguments.%0A%09return syncFileRange2(fd, flags, off, n)%0A%7D%0A
+ f b066629db853b527e0a4318a3a63487f80e74ddc90e5c79ff85cb14482246757 vendor/golang.org/x/sys/unix/syscall_linux_riscv64.go
dmppatch 2
@@ -0,0 +1,6378 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build riscv64,linux%0A%0Apackage unix%0A%0Aimport %22unsafe%22%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09if size %3C= 0 %7B%0A%09%09return -1, EINVAL%0A%09%7D%0A%09return EpollCreate1(0)%0A%7D%0A%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) = SYS_EPOLL_PWAIT%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout != nil %7B%0A%09%09ts = &Timespec%7BSec: timeout.Sec, Nsec: timeout.Usec * 1000%7D%0A%09%7D%0A%09return Pselect(nfd, r, w, e, ts, nil)%0A%7D%0A%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09return Fstatat(AT_FDCWD, path, stat, 0)%0A%7D%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09return Fchownat(AT_FDCWD, path, uid, gid, AT_SYMLINK_NOFOLLOW)%0A%7D%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09return Fstatat(AT_FDCWD, path, stat, AT_SYMLINK_NOFOLLOW)%0A%7D%0A%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc futimesat(dirfd int, path string, tv *%5B2%5DTimeval) (err error) %7B%0A%09if tv == nil %7B%0A%09%09return utimensat(dirfd, path, nil, 0)%0A%09%7D%0A%0A%09ts := %5B%5DTimespec%7B%0A%09%09NsecToTimespec(TimevalToNsec(tv%5B0%5D)),%0A%09%09NsecToTimespec(TimevalToNsec(tv%5B1%5D)),%0A%09%7D%0A%09return utimensat(dirfd, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%7D%0A%0Afunc Time(t *Time_t) (Time_t, error) %7B%0A%09var tv Timeval%0A%09err := Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0Afunc Utime(path string, buf *Utimbuf) error %7B%0A%09tv := %5B%5DTimeval%7B%0A%09%09%7BSec: buf.Actime%7D,%0A%09%09%7BSec: buf.Modtime%7D,%0A%09%7D%0A%09return Utimes(path, tv)%0A%7D%0A%0Afunc utimes(path string, tv *%5B2%5DTimeval) (err error) %7B%0A%09if tv == nil %7B%0A%09%09return utimensat(AT_FDCWD, path, nil, 0)%0A%09%7D%0A%0A%09ts := %5B%5DTimespec%7B%0A%09%09NsecToTimespec(TimevalToNsec(tv%5B0%5D)),%0A%09%09NsecToTimespec(TimevalToNsec(tv%5B1%5D)),%0A%09%7D%0A%09return utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%7D%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Pc %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Pc = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09return InotifyInit1(0)%0A%7D%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09return Dup3(oldfd, newfd, 0)%0A%7D%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PPOLL, 0, 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09var ts *Timespec%0A%09if timeout %3E= 0 %7B%0A%09%09ts = new(Timespec)%0A%09%09*ts = NsecToTimespec(int64(timeout) * 1e6)%0A%09%7D%0A%09if len(fds) == 0 %7B%0A%09%09return ppoll(nil, 0, ts, nil)%0A%09%7D%0A%09return ppoll(&fds%5B0%5D, len(fds), ts, nil)%0A%7D%0A
- f 58702bfddf11ccfc5748c73bb3c9c4b0f49608c0d5055f79c0b24b37e2930fe8 vendor/golang.org/x/sys/unix/syscall_linux_s390x.go
+ f b32b2023ccaacf4cb166462e23064df9ed2c866fdff0a0964028fc3ec6020199 vendor/golang.org/x/sys/unix/syscall_linux_s390x.go
dmppatch 3
@@ -189,8 +189,9918 @@
 ge unix%0A
+%0Aimport (%0A%09%22unsafe%22%0A)%0A%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sysnb%09EpollCreate(size int) (fd int, err error)%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_NEWFSTATAT%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A%0A//sys%09futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09var tv Timeval%0A%09err = Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, 0) // pipe2 is the same as pipe when flags are set to 0.%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Afunc Iopl(level int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Psw.Addr %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Psw.Addr = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A// Linux on s390x uses the old mmap interface, which requires arguments to be passed in a struct.%0A// mmap2 also requires arguments to be passed in a struct; it is currently not exposed in %3Casm/unistd.h%3E.%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09mmap_args := %5B6%5Duintptr%7Baddr, length, uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset)%7D%0A%09r0, _, e1 := Syscall(SYS_MMAP, uintptr(unsafe.Pointer(&mmap_args%5B0%5D)), 0, 0)%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// On s390x Linux, all the socket calls go through an extra indirection.%0A// The arguments to the underlying system call (SYS_SOCKETCALL) are the%0A// number below and a pointer to an array of uintptr.%0Aconst (%0A%09// see linux/net.h%0A%09netSocket      = 1%0A%09netBind        = 2%0A%09netConnect     = 3%0A%09netListen      = 4%0A%09netAccept      = 5%0A%09netGetSockName = 6%0A%09netGetPeerName = 7%0A%09netSocketPair  = 8%0A%09netSend        = 9%0A%09netRecv        = 10%0A%09netSendTo      = 11%0A%09netRecvFrom    = 12%0A%09netShutdown    = 13%0A%09netSetSockOpt  = 14%0A%09netGetSockOpt  = 15%0A%09netSendMsg     = 16%0A%09netRecvMsg     = 17%0A%09netAccept4     = 18%0A%09netRecvMMsg    = 19%0A%09netSendMMsg    = 20%0A)%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (int, error) %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen))%7D%0A%09fd, _, err := Syscall(SYS_SOCKETCALL, netAccept, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(fd), nil%0A%7D%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (int, error) %7B%0A%09args := %5B4%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags)%7D%0A%09fd, _, err := Syscall(SYS_SOCKETCALL, netAccept4, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(fd), nil%0A%7D%0A%0Afunc getsockname(s int, rsa *RawSockaddrAny, addrlen *_Socklen) error %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen))%7D%0A%09_, _, err := RawSyscall(SYS_SOCKETCALL, netGetSockName, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc getpeername(s int, rsa *RawSockaddrAny, addrlen *_Socklen) error %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen))%7D%0A%09_, _, err := RawSyscall(SYS_SOCKETCALL, netGetPeerName, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc socketpair(domain int, typ int, flags int, fd *%5B2%5Dint32) error %7B%0A%09args := %5B4%5Duintptr%7Buintptr(domain), uintptr(typ), uintptr(flags), uintptr(unsafe.Pointer(fd))%7D%0A%09_, _, err := RawSyscall(SYS_SOCKETCALL, netSocketPair, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) error %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(addr), uintptr(addrlen)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netBind, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) error %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(addr), uintptr(addrlen)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netConnect, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc socket(domain int, typ int, proto int) (int, error) %7B%0A%09args := %5B3%5Duintptr%7Buintptr(domain), uintptr(typ), uintptr(proto)%7D%0A%09fd, _, err := RawSyscall(SYS_SOCKETCALL, netSocket, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(fd), nil%0A%7D%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) error %7B%0A%09args := %5B5%5Duintptr%7Buintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen))%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netGetSockOpt, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) error %7B%0A%09args := %5B4%5Duintptr%7Buintptr(s), uintptr(level), uintptr(name), uintptr(val)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netSetSockOpt, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc recvfrom(s int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (int, error) %7B%0A%09var base uintptr%0A%09if len(p) %3E 0 %7B%0A%09%09base = uintptr(unsafe.Pointer(&p%5B0%5D))%0A%09%7D%0A%09args := %5B6%5Duintptr%7Buintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen))%7D%0A%09n, _, err := Syscall(SYS_SOCKETCALL, netRecvFrom, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(n), nil%0A%7D%0A%0Afunc sendto(s int, p %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) error %7B%0A%09var base uintptr%0A%09if len(p) %3E 0 %7B%0A%09%09base = uintptr(unsafe.Pointer(&p%5B0%5D))%0A%09%7D%0A%09args := %5B6%5Duintptr%7Buintptr(s), base, uintptr(len(p)), uintptr(flags), uintptr(to), uintptr(addrlen)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netSendTo, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (int, error) %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags)%7D%0A%09n, _, err := Syscall(SYS_SOCKETCALL, netRecvMsg, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(n), nil%0A%7D%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (int, error) %7B%0A%09args := %5B3%5Duintptr%7Buintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags)%7D%0A%09n, _, err := Syscall(SYS_SOCKETCALL, netSendMsg, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return 0, err%0A%09%7D%0A%09return int(n), nil%0A%7D%0A%0Afunc Listen(s int, n int) error %7B%0A%09args := %5B2%5Duintptr%7Buintptr(s), uintptr(n)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netListen, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc Shutdown(s, how int) error %7B%0A%09args := %5B2%5Duintptr%7Buintptr(s), uintptr(how)%7D%0A%09_, _, err := Syscall(SYS_SOCKETCALL, netShutdown, uintptr(unsafe.Pointer(&args)), 0)%0A%09if err != 0 %7B%0A%09%09return err%0A%09%7D%0A%09return nil%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f b563153960d2b6724c6f79ed0a64f2531687e68c84af4929282d49157cb8ff1b vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go
+ f a9ce3f0cf18fb7a293d6fdcdebf7ac84f3b6192a50cb79f9f827f881aadce7b0 vendor/golang.org/x/sys/unix/syscall_linux_sparc64.go
dmppatch 3
@@ -191,8 +191,5071 @@
 ge unix%0A
+%0A//sys%09EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_FADVISE64%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) = SYS_FSTATAT64%0A//sys%09Fstatfs(fd int, buf *Statfs_t) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (euid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sysnb%09InotifyInit() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Listen(s int, n int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PREAD64%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) = SYS_PWRITE64%0A//sys%09Seek(fd int, offset int64, whence int) (off int64, err error) = SYS_LSEEK%0A//sys%09Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error)%0A//sys%09Setfsgid(gid int) (err error)%0A//sys%09Setfsuid(uid int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(resource int, rlim *Rlimit) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sys%09Shutdown(fd int, how int) (err error)%0A//sys%09Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, buf *Statfs_t) (err error)%0A//sys%09SyncFileRange(fd int, off int64, n int64, flags int) (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error)%0A//sys%09accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error)%0A//sysnb%09getgroups(n int, list *_Gid_t) (nn int, err error)%0A//sysnb%09setgroups(n int, list *_Gid_t) (err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error)%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error)%0A//sysnb%09socket(domain int, typ int, proto int) (fd int, err error)%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error)%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sysnb%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error)%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error)%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error)%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0Afunc Iopl(level int) (err error) %7B%0A%09return ENOSYS%0A%7D%0A%0A//sys%09futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09var tv Timeval%0A%09err = Gettimeofday(&tv)%0A%09if err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if t != nil %7B%0A%09%09*t = Time_t(tv.Sec)%0A%09%7D%0A%09return Time_t(tv.Sec), nil%0A%7D%0A%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc (r *PtraceRegs) PC() uint64 %7B return r.Tpc %7D%0A%0Afunc (r *PtraceRegs) SetPC(pc uint64) %7B r.Tpc = pc %7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint64(length)%0A%7D%0A%0A//sysnb pipe(p *%5B2%5D_C_int) (err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sysnb pipe2(p *%5B2%5D_C_int, flags int) (err error)%0A%0Afunc Pipe2(p %5B%5Dint, flags int) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe2(&pp, flags)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sys%09poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A
- f cd458b5e34dac9e84ef3784925462d237cdfb4920d33c687972beb2cb2605c8d vendor/golang.org/x/sys/unix/syscall_netbsd.go
+ f 7eba266c5437dcc3aaf0cb5c5dc6cc7399827940575fcc9ccc08e6c100f578ff vendor/golang.org/x/sys/unix/syscall_netbsd.go
dmppatch 15
@@ -512,16 +512,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -536,16 +536,3149 @@
 afe%22%0A)%0A%0A
+// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0Afunc Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0Afunc sysctlNodes(mib %5B%5D_C_int) (nodes %5B%5DSysctlnode, err error) %7B%0A%09var olen uintptr%0A%0A%09// Get a list of all sysctl nodes below the given MIB by performing%0A%09// a sysctl for the given MIB with CTL_QUERY appended.%0A%09mib = append(mib, CTL_QUERY)%0A%09qnode := Sysctlnode%7BFlags: SYSCTL_VERS_1%7D%0A%09qp := (*byte)(unsafe.Pointer(&qnode))%0A%09sz := unsafe.Sizeof(qnode)%0A%09if err = sysctl(mib, nil, &olen, qp, sz); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09// Now that we know the size, get the actual nodes.%0A%09nodes = make(%5B%5DSysctlnode, olen/sz)%0A%09np := (*byte)(unsafe.Pointer(&nodes%5B0%5D))%0A%09if err = sysctl(mib, np, &olen, qp, sz); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%0A%09return nodes, nil%0A%7D%0A%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09// Split name into components.%0A%09var parts %5B%5Dstring%0A%09last := 0%0A%09for i := 0; i %3C len(name); i++ %7B%0A%09%09if name%5Bi%5D == '.' %7B%0A%09%09%09parts = append(parts, name%5Blast:i%5D)%0A%09%09%09last = i + 1%0A%09%09%7D%0A%09%7D%0A%09parts = append(parts, name%5Blast:%5D)%0A%0A%09// Discover the nodes and construct the MIB OID.%0A%09for partno, part := range parts %7B%0A%09%09nodes, err := sysctlNodes(mib)%0A%09%09if err != nil %7B%0A%09%09%09return nil, err%0A%09%09%7D%0A%09%09for _, node := range nodes %7B%0A%09%09%09n := make(%5B%5Dbyte, 0)%0A%09%09%09for i := range node.Name %7B%0A%09%09%09%09if node.Name%5Bi%5D != 0 %7B%0A%09%09%09%09%09n = append(n, byte(node.Name%5Bi%5D))%0A%09%09%09%09%7D%0A%09%09%09%7D%0A%09%09%09if string(n) == part %7B%0A%09%09%09%09mib = append(mib, _C_int(node.Num))%0A%09%09%09%09break%0A%09%09%09%7D%0A%09%09%7D%0A%09%09if len(mib) != partno+1 %7B%0A%09%09%09return nil, EINVAL%0A%09%09%7D%0A%09%7D%0A%0A%09return mib, nil%0A%7D%0A%0A//sysnb pipe() (fd1 int, fd2 int, err error)%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09p%5B0%5D, p%5B1%5D, err = pipe()%0A%09return%0A%7D%0A%0A//sys getdents(fd int, buf %5B%5Dbyte) (n int, err error)%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09return getdents(fd, buf)%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error) = SYS___GETCWD%0A%0Afunc Getwd() (string, error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09_, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0A// TODO%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09return -1, ENOSYS%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09// used on Darwin for UtimesNano%0A%09return ENOSYS%0A%7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc ioctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A
 func ioc
@@ -3786,24 +3786,443 @@
 value)))%0A%7D%0A%0A
+// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func IoctlGe
@@ -4345,28 +4345,10807 @@
 ue)))%0A%09return &value, err%0A%7D%0A
+%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctl(mib, &uname.Sysname%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctl(mib, &uname.Nodename%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctl(mib, &uname.Release%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctl(mib, &uname.Version%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctl(mib, &uname.Machine%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exit(code int)%0A//sys%09ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error)%0A//sys%09ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error)%0A//sys%09ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error)%0A//sys%09ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error)%0A//sys%09ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error)%0A//sys%09Faccessat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fadvise(fd int, offset int64, length int64, advice int) (err error) = SYS_POSIX_FADVISE%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Issetugid() (tainted bool)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys%09munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0A/*%0A * Unimplemented%0A */%0A// ____semctl13%0A// __clone%0A// __fhopen40%0A// __fhstat40%0A// __fhstatvfs140%0A// __fstat30%0A// __getcwd%0A// __getfh30%0A// __getlogin%0A// __lstat30%0A// __mount50%0A// __msgctl13%0A// __msync13%0A// __ntp_gettime30%0A// __posix_chown%0A// __posix_fchown%0A// __posix_lchown%0A// __posix_rename%0A// __setlogin%0A// __shmctl13%0A// __sigaction_sigtramp%0A// __sigaltstack14%0A// __sigpending14%0A// __sigprocmask14%0A// __sigsuspend14%0A// __sigtimedwait%0A// __stat30%0A// __syscall%0A// __vfork14%0A// _ksem_close%0A// _ksem_destroy%0A// _ksem_getvalue%0A// _ksem_init%0A// _ksem_open%0A// _ksem_post%0A// _ksem_trywait%0A// _ksem_unlink%0A// _ksem_wait%0A// _lwp_continue%0A// _lwp_create%0A// _lwp_ctl%0A// _lwp_detach%0A// _lwp_exit%0A// _lwp_getname%0A// _lwp_getprivate%0A// _lwp_kill%0A// _lwp_park%0A// _lwp_self%0A// _lwp_setname%0A// _lwp_setprivate%0A// _lwp_suspend%0A// _lwp_unpark%0A// _lwp_unpark_all%0A// _lwp_wait%0A// _lwp_wakeup%0A// _pset_bind%0A// _sched_getaffinity%0A// _sched_getparam%0A// _sched_setaffinity%0A// _sched_setparam%0A// acct%0A// aio_cancel%0A// aio_error%0A// aio_fsync%0A// aio_read%0A// aio_return%0A// aio_suspend%0A// aio_write%0A// break%0A// clock_getres%0A// clock_gettime%0A// clock_settime%0A// compat_09_ogetdomainname%0A// compat_09_osetdomainname%0A// compat_09_ouname%0A// compat_10_omsgsys%0A// compat_10_osemsys%0A// compat_10_oshmsys%0A// compat_12_fstat12%0A// compat_12_getdirentries%0A// compat_12_lstat12%0A// compat_12_msync%0A// compat_12_oreboot%0A// compat_12_oswapon%0A// compat_12_stat12%0A// compat_13_sigaction13%0A// compat_13_sigaltstack13%0A// compat_13_sigpending13%0A// compat_13_sigprocmask13%0A// compat_13_sigreturn13%0A// compat_13_sigsuspend13%0A// compat_14___semctl%0A// compat_14_msgctl%0A// compat_14_shmctl%0A// compat_16___sigaction14%0A// compat_16___sigreturn14%0A// compat_20_fhstatfs%0A// compat_20_fstatfs%0A// compat_20_getfsstat%0A// compat_20_statfs%0A// compat_30___fhstat30%0A// compat_30___fstat13%0A// compat_30___lstat13%0A// compat_30___stat13%0A// compat_30_fhopen%0A// compat_30_fhstat%0A// compat_30_fhstatvfs1%0A// compat_30_getdents%0A// compat_30_getfh%0A// compat_30_ntp_gettime%0A// compat_30_socket%0A// compat_40_mount%0A// compat_43_fstat43%0A// compat_43_lstat43%0A// compat_43_oaccept%0A// compat_43_ocreat%0A// compat_43_oftruncate%0A// compat_43_ogetdirentries%0A// compat_43_ogetdtablesize%0A// compat_43_ogethostid%0A// compat_43_ogethostname%0A// compat_43_ogetkerninfo%0A// compat_43_ogetpagesize%0A// compat_43_ogetpeername%0A// compat_43_ogetrlimit%0A// compat_43_ogetsockname%0A// compat_43_okillpg%0A// compat_43_olseek%0A// compat_43_ommap%0A// compat_43_oquota%0A// compat_43_orecv%0A// compat_43_orecvfrom%0A// compat_43_orecvmsg%0A// compat_43_osend%0A// compat_43_osendmsg%0A// compat_43_osethostid%0A// compat_43_osethostname%0A// compat_43_osetrlimit%0A// compat_43_osigblock%0A// compat_43_osigsetmask%0A// compat_43_osigstack%0A// compat_43_osigvec%0A// compat_43_otruncate%0A// compat_43_owait%0A// compat_43_stat43%0A// execve%0A// extattr_delete_fd%0A// extattr_delete_file%0A// extattr_delete_link%0A// extattr_get_fd%0A// extattr_get_file%0A// extattr_get_link%0A// extattr_list_fd%0A// extattr_list_file%0A// extattr_list_link%0A// extattr_set_fd%0A// extattr_set_file%0A// extattr_set_link%0A// extattrctl%0A// fchroot%0A// fdatasync%0A// fgetxattr%0A// fktrace%0A// flistxattr%0A// fork%0A// fremovexattr%0A// fsetxattr%0A// fstatvfs1%0A// fsync_range%0A// getcontext%0A// getitimer%0A// getvfsstat%0A// getxattr%0A// ktrace%0A// lchflags%0A// lchmod%0A// lfs_bmapv%0A// lfs_markv%0A// lfs_segclean%0A// lfs_segwait%0A// lgetxattr%0A// lio_listio%0A// listxattr%0A// llistxattr%0A// lremovexattr%0A// lseek%0A// lsetxattr%0A// lutimes%0A// madvise%0A// mincore%0A// minherit%0A// modctl%0A// mq_close%0A// mq_getattr%0A// mq_notify%0A// mq_open%0A// mq_receive%0A// mq_send%0A// mq_setattr%0A// mq_timedreceive%0A// mq_timedsend%0A// mq_unlink%0A// mremap%0A// msgget%0A// msgrcv%0A// msgsnd%0A// nfssvc%0A// ntp_adjtime%0A// pmc_control%0A// pmc_get_info%0A// pollts%0A// preadv%0A// profil%0A// pselect%0A// pset_assign%0A// pset_create%0A// pset_destroy%0A// ptrace%0A// pwritev%0A// quotactl%0A// rasctl%0A// readv%0A// reboot%0A// removexattr%0A// sa_enable%0A// sa_preempt%0A// sa_register%0A// sa_setconcurrency%0A// sa_stacks%0A// sa_yield%0A// sbrk%0A// sched_yield%0A// semconfig%0A// semget%0A// semop%0A// setcontext%0A// setitimer%0A// setxattr%0A// shmat%0A// shmdt%0A// shmget%0A// sstk%0A// statvfs1%0A// swapctl%0A// sysarch%0A// syscall%0A// timer_create%0A// timer_delete%0A// timer_getoverrun%0A// timer_gettime%0A// timer_settime%0A// undelete%0A// utrace%0A// uuidgen%0A// vadvise%0A// vfork%0A// writev%0A
- f 6d7a27c6b56b9df7cc9783eb089e02af0c66f5d111977a04c0dadb31cb810a74 vendor/golang.org/x/sys/unix/syscall_netbsd_386.go
+ f e9755f98347998d8d9dec7b722469d01144ceb05f9b6c45a14326be89d828de4 vendor/golang.org/x/sys/unix/syscall_netbsd_386.go
dmppatch 3
@@ -188,8 +188,548 @@
 ge unix%0A
+%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = uint32(mode)%0A%09k.Flags = uint32(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f 647aa4d6b6066b8594f6db33d2d1f62a5e2c091f4d72131f867dc6b7ba4eaee3 vendor/golang.org/x/sys/unix/syscall_netbsd_amd64.go
+ f 754d0e9b12aa147a7bc0624bc773dce1b4a673ed215dcf2a76424f14b44b5f2e vendor/golang.org/x/sys/unix/syscall_netbsd_amd64.go
dmppatch 3
@@ -190,8 +190,541 @@
 ge unix%0A
+%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = uint32(mode)%0A%09k.Flags = uint32(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f 09bcd53a23d49dfe6dbc9e820b1e91b851e5f2ef759a4678bad8248295d259aa vendor/golang.org/x/sys/unix/syscall_netbsd_arm.go
+ f 39aeec8bf0d4d432931663abac5cf96ec2be31e1bd214aef26dd301f9cbb2d48 vendor/golang.org/x/sys/unix/syscall_netbsd_arm.go
dmppatch 3
@@ -188,8 +188,548 @@
 ge unix%0A
+%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = uint32(mode)%0A%09k.Flags = uint32(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f 902e1192fe78ec696be3f435af410b536745eb4cc4746a0c5d1c3d6aefe9c4aa vendor/golang.org/x/sys/unix/syscall_openbsd.go
+ f 15219802cbb7ac0750182c6877bf19afeb5b85e8e4a0d0d6ebef18faa985fdf0 vendor/golang.org/x/sys/unix/syscall_openbsd.go
dmppatch 15
@@ -513,16 +513,35 @@
 mport (%0A
+%09%22sort%22%0A%09%22syscall%22%0A
 %09%22unsafe
@@ -545,16 +545,2390 @@
 afe%22%0A)%0A%0A
+// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B24%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0Afunc Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0Afunc nametomib(name string) (mib %5B%5D_C_int, err error) %7B%0A%09i := sort.Search(len(sysctlMib), func(i int) bool %7B%0A%09%09return sysctlMib%5Bi%5D.ctlname %3E= name%0A%09%7D)%0A%09if i %3C len(sysctlMib) && sysctlMib%5Bi%5D.ctlname == name %7B%0A%09%09return sysctlMib%5Bi%5D.ctloid, nil%0A%09%7D%0A%09return nil, EINVAL%0A%7D%0A%0A//sysnb pipe(p *%5B2%5D_C_int) (err error)%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09err = pipe(&pp)%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return%0A%7D%0A%0A//sys getdents(fd int, buf %5B%5Dbyte) (n int, err error)%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09return getdents(fd, buf)%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error) = SYS___GETCWD%0A%0Afunc Getwd() (string, error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09_, err := Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0A// TODO%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09return -1, ENOSYS%0A%7D%0A%0Afunc Getfsstat(buf %5B%5DStatfs_t, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09var bufsize uintptr%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%09bufsize = unsafe.Sizeof(Statfs_t%7B%7D) * uintptr(len(buf))%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETFSSTAT, uintptr(_p0), bufsize, uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setattrlistTimes(path string, times %5B%5DTimespec, flags int) error %7B%0A%09// used on Darwin for UtimesNano%0A%09return ENOSYS%0A%7D%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0A// ioctl itself should not be exposed directly, but additional get/set%0A// functions for specific types are permissible.%0A%0A// IoctlSetInt performs an ioctl operation which sets an integer value%0A// on fd, using the specified request number.%0Afunc IoctlSetInt(fd int, req uint, value int) error %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc ioctlSetWinsize(fd int, req uint, value *Winsize) error %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A
 func ioc
@@ -3036,24 +3036,443 @@
 value)))%0A%7D%0A%0A
+// IoctlGetInt performs an ioctl operation which gets an integer value%0A// from fd, using the specified request number.%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func IoctlGe
@@ -3595,28 +3595,6543 @@
 ue)))%0A%09return &value, err%0A%7D%0A
+%0Afunc Uname(uname *Utsname) error %7B%0A%09mib := %5B%5D_C_int%7BCTL_KERN, KERN_OSTYPE%7D%0A%09n := unsafe.Sizeof(uname.Sysname)%0A%09if err := sysctl(mib, &uname.Sysname%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_HOSTNAME%7D%0A%09n = unsafe.Sizeof(uname.Nodename)%0A%09if err := sysctl(mib, &uname.Nodename%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_OSRELEASE%7D%0A%09n = unsafe.Sizeof(uname.Release)%0A%09if err := sysctl(mib, &uname.Release%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_KERN, KERN_VERSION%7D%0A%09n = unsafe.Sizeof(uname.Version)%0A%09if err := sysctl(mib, &uname.Version%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// The version might have newlines or tabs in it, convert them to%0A%09// spaces.%0A%09for i, b := range uname.Version %7B%0A%09%09if b == '%5Cn' %7C%7C b == '%5Ct' %7B%0A%09%09%09if i == len(uname.Version)-1 %7B%0A%09%09%09%09uname.Version%5Bi%5D = 0%0A%09%09%09%7D else %7B%0A%09%09%09%09uname.Version%5Bi%5D = ' '%0A%09%09%09%7D%0A%09%09%7D%0A%09%7D%0A%0A%09mib = %5B%5D_C_int%7BCTL_HW, HW_MACHINE%7D%0A%09n = unsafe.Sizeof(uname.Machine)%0A%09if err := sysctl(mib, &uname.Machine%5B0%5D, &n, nil, 0); err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09return nil%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chflags(path string, flags int) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(from int, to int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Faccessat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchflags(fd int, flags int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatfs(fd int, stat *Statfs_t) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sysnb%09Getegid() (egid int)%0A//sysnb%09Geteuid() (uid int)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgrp int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (prio int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrtable() (rtable int, err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Getsid(pid int) (sid int, err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Issetugid() (tainted bool)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Kqueue() (fd int, err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Listen(s int, backlog int) (err error)%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Revoke(path string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = SYS_LSEEK%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Setlogin(name string) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setresgid(rgid int, egid int, sgid int) (err error)%0A//sysnb%09Setresuid(ruid int, euid int, suid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setrtable(rtable int) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Settimeofday(tp *Timeval) (err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statfs(path string, stat *Statfs_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Sync() (err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Umask(newmask int) (oldmask int)%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unmount(path string, flags int) (err error)%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys%09munmap(addr uintptr, length uintptr) (err error)%0A//sys%09readlen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_READ%0A//sys%09writelen(fd int, buf *byte, nbuf int) (n int, err error) = SYS_WRITE%0A//sys%09utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error)%0A%0A/*%0A * Unimplemented%0A */%0A// __getcwd%0A// __semctl%0A// __syscall%0A// __sysctl%0A// adjfreq%0A// break%0A// clock_getres%0A// clock_gettime%0A// clock_settime%0A// closefrom%0A// execve%0A// faccessat%0A// fchmodat%0A// fchownat%0A// fcntl%0A// fhopen%0A// fhstat%0A// fhstatfs%0A// fork%0A// fstatat%0A// futimens%0A// getfh%0A// getgid%0A// getitimer%0A// getlogin%0A// getresgid%0A// getresuid%0A// getthrid%0A// ktrace%0A// lfs_bmapv%0A// lfs_markv%0A// lfs_segclean%0A// lfs_segwait%0A// linkat%0A// mincore%0A// minherit%0A// mkdirat%0A// mkfifoat%0A// mknodat%0A// mount%0A// mquery%0A// msgctl%0A// msgget%0A// msgrcv%0A// msgsnd%0A// nfssvc%0A// nnpfspioctl%0A// openat%0A// preadv%0A// profil%0A// pwritev%0A// quotactl%0A// readlinkat%0A// readv%0A// reboot%0A// renameat%0A// rfork%0A// sched_yield%0A// semget%0A// semop%0A// setgroups%0A// setitimer%0A// setsockopt%0A// shmat%0A// shmctl%0A// shmdt%0A// shmget%0A// sigaction%0A// sigaltstack%0A// sigpending%0A// sigprocmask%0A// sigreturn%0A// sigsuspend%0A// symlinkat%0A// sysarch%0A// syscall%0A// threxit%0A// thrsigdivert%0A// thrsleep%0A// thrwakeup%0A// unlinkat%0A// vfork%0A// writev%0A
- f f24d3e4e70cf48af0718b8a5e705a5f81a609683bcfaab93355137920e584909 vendor/golang.org/x/sys/unix/syscall_openbsd_386.go
+ f a241460c7c9f9d6fd94840552f5e90ae4d25cec35ed6292f05a088435a30c352 vendor/golang.org/x/sys/unix/syscall_openbsd_386.go
dmppatch 3
@@ -189,8 +189,547 @@
 ge unix%0A
+%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f b6366ba1c188dd355f85825a335ff7217f0b5d41cdaf590ea6dfb4d3d09a7725 vendor/golang.org/x/sys/unix/syscall_openbsd_amd64.go
+ f a9e35f015b27daed8df9fa4462e0f8d7c8a40f92752f33294d55686678cd1c27 vendor/golang.org/x/sys/unix/syscall_openbsd_amd64.go
dmppatch 3
@@ -191,8 +191,715 @@
 ge unix%0A
+%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint64(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A%0A// SYS___SYSCTL is used by syscall_bsd.go for all BSDs, but in modern versions%0A// of openbsd/amd64 the syscall is called sysctl instead of __sysctl.%0Aconst SYS___SYSCTL = SYS_SYSCTL%0A
- f 4257b297f03876e43901c38b6b37de45563bf883b398a5452eb4bc0d31452ef5 vendor/golang.org/x/sys/unix/syscall_openbsd_arm.go
+ f 2d4efc2a522160f6d70eeb886dfcd1d9199394a93f2c6b570b4a50ca152d046b vendor/golang.org/x/sys/unix/syscall_openbsd_arm.go
dmppatch 3
@@ -189,8 +189,547 @@
 ge unix%0A
+%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: int32(nsec)%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: int32(usec)%7D%0A%7D%0A%0Afunc SetKevent(k *Kevent_t, fd, mode, flags int) %7B%0A%09k.Ident = uint32(fd)%0A%09k.Filter = int16(mode)%0A%09k.Flags = uint16(flags)%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint32(length)%0A%7D%0A%0Afunc (msghdr *Msghdr) SetControllen(length int) %7B%0A%09msghdr.Controllen = uint32(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f 7b76a190e35094e62f5a27dac83ecd13f5b1144bbf85681ebb91f4dc6a65400a vendor/golang.org/x/sys/unix/syscall_solaris.go
+ f 609c07c930dd98b05e5b59d836ba133db9a61a63a4fe7f9f3b51ff965a67ef99 vendor/golang.org/x/sys/unix/syscall_solaris.go
dmppatch 15
@@ -512,16 +512,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -536,16 +536,12740 @@
 afe%22%0A)%0A%0A
+// Implemented in runtime/syscall_solaris.go.%0Atype syscallFunc uintptr%0A%0Afunc rawSysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)%0Afunc sysvicall6(trap, nargs, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A%0A// SockaddrDatalink implements the Sockaddr interface for AF_LINK type sockets.%0Atype SockaddrDatalink struct %7B%0A%09Family uint16%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B244%5Dint8%0A%09raw    RawSockaddrDatalink%0A%7D%0A%0A//sysnb%09pipe(p *%5B2%5D_C_int) (n int, err error)%0A%0Afunc Pipe(p %5B%5Dint) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09var pp %5B2%5D_C_int%0A%09n, err := pipe(&pp)%0A%09if n != 0 %7B%0A%09%09return err%0A%09%7D%0A%09p%5B0%5D = int(pp%5B0%5D)%0A%09p%5B1%5D = int(pp%5B1%5D)%0A%09return nil%0A%7D%0A%0Afunc (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet4, nil%0A%7D%0A%0Afunc (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET6%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09sa.raw.Scope_id = sa.ZoneId%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), SizeofSockaddrInet6, nil%0A%7D%0A%0Afunc (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, _Socklen, error) %7B%0A%09name := sa.Name%0A%09n := len(name)%0A%09if n %3E= len(sa.raw.Path) %7B%0A%09%09return nil, 0, EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_UNIX%0A%09for i := 0; i %3C n; i++ %7B%0A%09%09sa.raw.Path%5Bi%5D = int8(name%5Bi%5D)%0A%09%7D%0A%09// length is family (uint16), name, NUL.%0A%09sl := _Socklen(2)%0A%09if n %3E 0 %7B%0A%09%09sl += _Socklen(n) + 1%0A%09%7D%0A%09if sa.raw.Path%5B0%5D == '@' %7B%0A%09%09sa.raw.Path%5B0%5D = 0%0A%09%09// Don't count trailing NUL for abstract address.%0A%09%09sl--%0A%09%7D%0A%0A%09return unsafe.Pointer(&sa.raw), sl, nil%0A%7D%0A%0A//sys%09getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) = libsocket.getsockname%0A%0Afunc Getsockname(fd int) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if err = getsockname(fd, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return anyToSockaddr(fd, &rsa)%0A%7D%0A%0A// GetsockoptString returns the string value of the socket option opt for the%0A// socket associated with fd at the given socket level.%0Afunc GetsockoptString(fd, level, opt int) (string, error) %7B%0A%09buf := make(%5B%5Dbyte, 256)%0A%09vallen := _Socklen(len(buf))%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&buf%5B0%5D), &vallen)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09return string(buf%5B:vallen-1%5D), nil%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0A//sys%09Getcwd(buf %5B%5Dbyte) (n int, err error)%0A%0Afunc Getwd() (wd string, err error) %7B%0A%09var buf %5BPathMax%5Dbyte%0A%09// Getcwd will return an error if it failed for any reason.%0A%09_, err = Getcwd(buf%5B0:%5D)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EINVAL%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0A/*%0A * Wrapped%0A */%0A%0A//sysnb%09getgroups(ngid int, gid *_Gid_t) (n int, err error)%0A//sysnb%09setgroups(ngid int, gid *_Gid_t) (err error)%0A%0Afunc Getgroups() (gids %5B%5Dint, err error) %7B%0A%09n, err := getgroups(0, nil)%0A%09// Check for error and sanity check group count. Newer versions of%0A%09// Solaris allow up to 1024 (NGROUPS_MAX).%0A%09if n %3C 0 %7C%7C n %3E 1024 %7B%0A%09%09if err != nil %7B%0A%09%09%09return nil, err%0A%09%09%7D%0A%09%09return nil, EINVAL%0A%09%7D else if n == 0 %7B%0A%09%09return nil, nil%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, n)%0A%09n, err = getgroups(n, &a%5B0%5D)%0A%09if n == -1 %7B%0A%09%09return nil, err%0A%09%7D%0A%09gids = make(%5B%5Dint, n)%0A%09for i, v := range a%5B0:n%5D %7B%0A%09%09gids%5Bi%5D = int(v)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setgroups(gids %5B%5Dint) (err error) %7B%0A%09if len(gids) == 0 %7B%0A%09%09return setgroups(0, nil)%0A%09%7D%0A%0A%09a := make(%5B%5D_Gid_t, len(gids))%0A%09for i, v := range gids %7B%0A%09%09a%5Bi%5D = _Gid_t(v)%0A%09%7D%0A%09return setgroups(len(a), &a%5B0%5D)%0A%7D%0A%0Afunc ReadDirent(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09// Final argument is (basep *uintptr) and the syscall doesn't take nil.%0A%09// TODO(rsc): Can we use a single global basep for all calls?%0A%09return Getdents(fd, buf, new(uintptr))%0A%7D%0A%0A// Wait status is 7 bits at bottom, either 0 (exited),%0A// 0x7F (stopped), or a signal number that caused an exit.%0A// The 0x80 bit is whether there was a core dump.%0A// An extra number (exit code, signal causing a stop)%0A// is in the high bits.%0A%0Atype WaitStatus uint32%0A%0Aconst (%0A%09mask  = 0x7F%0A%09core  = 0x80%0A%09shift = 8%0A%0A%09exited  = 0%0A%09stopped = 0x7F%0A)%0A%0Afunc (w WaitStatus) Exited() bool %7B return w&mask == exited %7D%0A%0Afunc (w WaitStatus) ExitStatus() int %7B%0A%09if w&mask != exited %7B%0A%09%09return -1%0A%09%7D%0A%09return int(w %3E%3E shift)%0A%7D%0A%0Afunc (w WaitStatus) Signaled() bool %7B return w&mask != stopped && w&mask != 0 %7D%0A%0Afunc (w WaitStatus) Signal() syscall.Signal %7B%0A%09sig := syscall.Signal(w & mask)%0A%09if sig == stopped %7C%7C sig == 0 %7B%0A%09%09return -1%0A%09%7D%0A%09return sig%0A%7D%0A%0Afunc (w WaitStatus) CoreDump() bool %7B return w.Signaled() && w&core != 0 %7D%0A%0Afunc (w WaitStatus) Stopped() bool %7B return w&mask == stopped && syscall.Signal(w%3E%3Eshift) != SIGSTOP %7D%0A%0Afunc (w WaitStatus) Continued() bool %7B return w&mask == stopped && syscall.Signal(w%3E%3Eshift) == SIGSTOP %7D%0A%0Afunc (w WaitStatus) StopSignal() syscall.Signal %7B%0A%09if !w.Stopped() %7B%0A%09%09return -1%0A%09%7D%0A%09return syscall.Signal(w%3E%3Eshift) & 0xFF%0A%7D%0A%0Afunc (w WaitStatus) TrapCause() int %7B return -1 %7D%0A%0A//sys%09wait4(pid int32, statusp *_C_int, options int, rusage *Rusage) (wpid int32, err error)%0A%0Afunc Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (int, error) %7B%0A%09var status _C_int%0A%09rpid, err := wait4(int32(pid), &status, options, rusage)%0A%09wpid := int(rpid)%0A%09if wpid == -1 %7B%0A%09%09return wpid, err%0A%09%7D%0A%09if wstatus != nil %7B%0A%09%09*wstatus = WaitStatus(status)%0A%09%7D%0A%09return wpid, nil%0A%7D%0A%0A//sys%09gethostname(buf %5B%5Dbyte) (n int, err error)%0A%0Afunc Gethostname() (name string, err error) %7B%0A%09var buf %5BMaxHostNameLen%5Dbyte%0A%09n, err := gethostname(buf%5B:%5D)%0A%09if n != 0 %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n = clen(buf%5B:%5D)%0A%09if n %3C 1 %7B%0A%09%09return %22%22, EFAULT%0A%09%7D%0A%09return string(buf%5B:n%5D), nil%0A%7D%0A%0A//sys%09utimes(path string, times *%5B2%5DTimeval) (err error)%0A%0Afunc Utimes(path string, tv %5B%5DTimeval) (err error) %7B%0A%09if tv == nil %7B%0A%09%09return utimes(path, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimes(path, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0A//sys%09utimensat(fd int, path string, times *%5B2%5DTimespec, flag int) (err error)%0A%0Afunc UtimesNano(path string, ts %5B%5DTimespec) error %7B%0A%09if ts == nil %7B%0A%09%09return utimensat(AT_FDCWD, path, nil, 0)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimensat(AT_FDCWD, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), 0)%0A%7D%0A%0Afunc UtimesNanoAt(dirfd int, path string, ts %5B%5DTimespec, flags int) error %7B%0A%09if ts == nil %7B%0A%09%09return utimensat(dirfd, path, nil, flags)%0A%09%7D%0A%09if len(ts) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return utimensat(dirfd, path, (*%5B2%5DTimespec)(unsafe.Pointer(&ts%5B0%5D)), flags)%0A%7D%0A%0A//sys%09fcntl(fd int, cmd int, arg int) (val int, err error)%0A%0A// FcntlInt performs a fcntl syscall on fd with the provided command and argument.%0Afunc FcntlInt(fd uintptr, cmd, arg int) (int, error) %7B%0A%09valptr, _, errno := sysvicall6(uintptr(unsafe.Pointer(&procfcntl)), 3, uintptr(fd), uintptr(cmd), uintptr(arg), 0, 0, 0)%0A%09var err error%0A%09if errno != 0 %7B%0A%09%09err = errno%0A%09%7D%0A%09return int(valptr), err%0A%7D%0A%0A// FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.%0Afunc FcntlFlock(fd uintptr, cmd int, lk *Flock_t) error %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procfcntl)), 3, uintptr(fd), uintptr(cmd), uintptr(unsafe.Pointer(lk)), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09return e1%0A%09%7D%0A%09return nil%0A%7D%0A%0A//sys%09futimesat(fildes int, path *byte, times *%5B2%5DTimeval) (err error)%0A%0Afunc Futimesat(dirfd int, path string, tv %5B%5DTimeval) error %7B%0A%09pathp, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if tv == nil %7B%0A%09%09return futimesat(dirfd, pathp, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return futimesat(dirfd, pathp, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0A// Solaris doesn't have an futimes function because it allows NULL to be%0A// specified as the path for futimesat. However, Go doesn't like%0A// NULL-style string interfaces, so this simple wrapper is provided.%0Afunc Futimes(fd int, tv %5B%5DTimeval) error %7B%0A%09if tv == nil %7B%0A%09%09return futimesat(fd, nil, nil)%0A%09%7D%0A%09if len(tv) != 2 %7B%0A%09%09return EINVAL%0A%09%7D%0A%09return futimesat(fd, nil, (*%5B2%5DTimeval)(unsafe.Pointer(&tv%5B0%5D)))%0A%7D%0A%0Afunc anyToSockaddr(fd int, rsa *RawSockaddrAny) (Sockaddr, error) %7B%0A%09switch rsa.Addr.Family %7B%0A%09case AF_UNIX:%0A%09%09pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrUnix)%0A%09%09// Assume path ends at NUL.%0A%09%09// This is not technically the Solaris semantics for%0A%09%09// abstract Unix domain sockets -- they are supposed%0A%09%09// to be uninterpreted fixed-size binary blobs -- but%0A%09%09// everyone uses this convention.%0A%09%09n := 0%0A%09%09for n %3C len(pp.Path) && pp.Path%5Bn%5D != 0 %7B%0A%09%09%09n++%0A%09%09%7D%0A%09%09bytes := (*%5B10000%5Dbyte)(unsafe.Pointer(&pp.Path%5B0%5D))%5B0:n%5D%0A%09%09sa.Name = string(bytes)%0A%09%09return sa, nil%0A%0A%09case AF_INET:%0A%09%09pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet4)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_INET6:%0A%09%09pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet6)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09sa.ZoneId = pp.Scope_id%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%09%7D%0A%09return nil, EAFNOSUPPORT%0A%7D%0A%0A//sys%09accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) = libsocket.accept%0A%0Afunc Accept(fd int) (nfd int, sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09nfd, err = accept(fd, &rsa, &len)%0A%09if nfd == -1 %7B%0A%09%09return%0A%09%7D%0A%09sa, err = anyToSockaddr(fd, &rsa)%0A%09if err != nil %7B%0A%09%09Close(nfd)%0A%09%09nfd = 0%0A%09%7D%0A%09return%0A%7D%0A%0A//sys%09recvmsg(s int, msg *Msghdr, flags int) (n int, err error) = libsocket.__xnet_recvmsg%0A%0Afunc Recvmsg(fd int, p, oob %5B%5Dbyte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) %7B%0A%09var msg Msghdr%0A%09var rsa RawSockaddrAny%0A%09msg.Name = (*byte)(unsafe.Pointer(&rsa))%0A%09msg.Namelen = uint32(SizeofSockaddrAny)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = (*int8)(unsafe.Pointer(&p%5B0%5D))%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy int8%0A%09if len(oob) %3E 0 %7B%0A%09%09// receive at least one normal byte%0A%09%09if len(p) == 0 %7B%0A%09%09%09iov.Base = &dummy%0A%09%09%09iov.SetLen(1)%0A%09%09%7D%0A%09%09msg.Accrightslen = int32(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = recvmsg(fd, &msg, flags); n == -1 %7B%0A%09%09return%0A%09%7D%0A%09oobn = int(msg.Accrightslen)%0A%09// source address is only specified if the socket is unconnected%0A%09if rsa.Addr.Family != AF_UNSPEC %7B%0A%09%09from, err = anyToSockaddr(fd, &rsa)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sendmsg(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (err error) %7B%0A%09_, err = SendmsgN(fd, p, oob, to, flags)%0A%09return%0A%7D%0A%0A//sys%09sendmsg(s int, msg *Msghdr, flags int) (n int, err error) = libsocket.__xnet_sendmsg%0A%0Afunc SendmsgN(fd int, p, oob %5B%5Dbyte, to Sockaddr, flags int) (n int, err error) %7B%0A%09var ptr unsafe.Pointer%0A%09var salen _Socklen%0A%09if to != nil %7B%0A%09%09ptr, salen, err = to.sockaddr()%0A%09%09if err != nil %7B%0A%09%09%09return 0, err%0A%09%09%7D%0A%09%7D%0A%09var msg Msghdr%0A%09msg.Name = (*byte)(unsafe.Pointer(ptr))%0A%09msg.Namelen = uint32(salen)%0A%09var iov Iovec%0A%09if len(p) %3E 0 %7B%0A%09%09iov.Base = (*int8)(unsafe.Pointer(&p%5B0%5D))%0A%09%09iov.SetLen(len(p))%0A%09%7D%0A%09var dummy int8%0A%09if len(oob) %3E 0 %7B%0A%09%09// send at least one normal byte%0A%09%09if len(p) == 0 %7B%0A%09%09%09iov.Base = &dummy%0A%09%09%09iov.SetLen(1)%0A%09%09%7D%0A%09%09msg.Accrightslen = int32(len(oob))%0A%09%7D%0A%09msg.Iov = &iov%0A%09msg.Iovlen = 1%0A%09if n, err = sendmsg(fd, &msg, flags); err != nil %7B%0A%09%09return 0, err%0A%09%7D%0A%09if len(oob) %3E 0 && len(p) == 0 %7B%0A%09%09n = 0%0A%09%7D%0A%09return n, nil%0A%7D%0A%0A//sys%09acct(path *byte) (err error)%0A%0Afunc Acct(path string) (err error) %7B%0A%09if len(path) == 0 %7B%0A%09%09// Assume caller wants to disable accounting.%0A%09%09return acct(nil)%0A%09%7D%0A%0A%09pathp, err := BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return acct(pathp)%0A%7D%0A%0A//sys%09__makedev(version int, major uint, minor uint) (val uint64)%0A%0Afunc Mkdev(major, minor uint32) uint64 %7B%0A%09return __makedev(NEWDEV, uint(major), uint(minor))%0A%7D%0A%0A//sys%09__major(version int, dev uint64) (val uint)%0A%0Afunc Major(dev uint64) uint32 %7B%0A%09return uint32(__major(NEWDEV, dev))%0A%7D%0A%0A//sys%09__minor(version int, dev uint64) (val uint)%0A%0Afunc Minor(dev uint64) uint32 %7B%0A%09return uint32(__minor(NEWDEV, dev))%0A%7D%0A%0A/*%0A * Expose the ioctl function%0A */%0A%0A//sys%09ioctl(fd int, req uint, arg uintptr) (err error)%0A%0Afunc IoctlSetInt(fd int, req uint, value int) (err error) %7B%0A%09return ioctl(fd, req, uintptr(value))%0A%7D%0A%0Afunc ioctlSetWinsize(fd int, req uint, value *Winsize) (err error) %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0A
 func ioc
@@ -13383,24 +13383,449 @@
 value)))%0A%7D%0A%0A
+func IoctlSetTermio(fd int, req uint, value *Termio) (err error) %7B%0A%09return ioctl(fd, req, uintptr(unsafe.Pointer(value)))%0A%7D%0A%0Afunc IoctlGetInt(fd int, req uint) (int, error) %7B%0A%09var value int%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return value, err%0A%7D%0A%0Afunc IoctlGetWinsize(fd int, req uint) (*Winsize, error) %7B%0A%09var value Winsize%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A
 func IoctlGe
@@ -13948,28 +13948,7263 @@
 ue)))%0A%09return &value, err%0A%7D%0A
+%0Afunc IoctlGetTermio(fd int, req uint) (*Termio, error) %7B%0A%09var value Termio%0A%09err := ioctl(fd, req, uintptr(unsafe.Pointer(&value)))%0A%09return &value, err%0A%7D%0A%0A//sys   poll(fds *PollFd, nfds int, timeout int) (n int, err error)%0A%0Afunc Poll(fds %5B%5DPollFd, timeout int) (n int, err error) %7B%0A%09if len(fds) == 0 %7B%0A%09%09return poll(nil, 0, timeout)%0A%09%7D%0A%09return poll(&fds%5B0%5D, len(fds), timeout)%0A%7D%0A%0A/*%0A * Exposed directly%0A */%0A//sys%09Access(path string, mode uint32) (err error)%0A//sys%09Adjtime(delta *Timeval, olddelta *Timeval) (err error)%0A//sys%09Chdir(path string) (err error)%0A//sys%09Chmod(path string, mode uint32) (err error)%0A//sys%09Chown(path string, uid int, gid int) (err error)%0A//sys%09Chroot(path string) (err error)%0A//sys%09Close(fd int) (err error)%0A//sys%09Creat(path string, mode uint32) (fd int, err error)%0A//sys%09Dup(fd int) (nfd int, err error)%0A//sys%09Dup2(oldfd int, newfd int) (err error)%0A//sys%09Exit(code int)%0A//sys%09Faccessat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchdir(fd int) (err error)%0A//sys%09Fchmod(fd int, mode uint32) (err error)%0A//sys%09Fchmodat(dirfd int, path string, mode uint32, flags int) (err error)%0A//sys%09Fchown(fd int, uid int, gid int) (err error)%0A//sys%09Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error)%0A//sys%09Fdatasync(fd int) (err error)%0A//sys%09Flock(fd int, how int) (err error)%0A//sys%09Fpathconf(fd int, name int) (val int, err error)%0A//sys%09Fstat(fd int, stat *Stat_t) (err error)%0A//sys%09Fstatat(fd int, path string, stat *Stat_t, flags int) (err error)%0A//sys%09Fstatvfs(fd int, vfsstat *Statvfs_t) (err error)%0A//sys%09Getdents(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error)%0A//sysnb%09Getgid() (gid int)%0A//sysnb%09Getpid() (pid int)%0A//sysnb%09Getpgid(pid int) (pgid int, err error)%0A//sysnb%09Getpgrp() (pgid int, err error)%0A//sys%09Geteuid() (euid int)%0A//sys%09Getegid() (egid int)%0A//sys%09Getppid() (ppid int)%0A//sys%09Getpriority(which int, who int) (n int, err error)%0A//sysnb%09Getrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Getrusage(who int, rusage *Rusage) (err error)%0A//sysnb%09Gettimeofday(tv *Timeval) (err error)%0A//sysnb%09Getuid() (uid int)%0A//sys%09Kill(pid int, signum syscall.Signal) (err error)%0A//sys%09Lchown(path string, uid int, gid int) (err error)%0A//sys%09Link(path string, link string) (err error)%0A//sys%09Listen(s int, backlog int) (err error) = libsocket.__xnet_llisten%0A//sys%09Lstat(path string, stat *Stat_t) (err error)%0A//sys%09Madvise(b %5B%5Dbyte, advice int) (err error)%0A//sys%09Mkdir(path string, mode uint32) (err error)%0A//sys%09Mkdirat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mkfifo(path string, mode uint32) (err error)%0A//sys%09Mkfifoat(dirfd int, path string, mode uint32) (err error)%0A//sys%09Mknod(path string, mode uint32, dev int) (err error)%0A//sys%09Mknodat(dirfd int, path string, mode uint32, dev int) (err error)%0A//sys%09Mlock(b %5B%5Dbyte) (err error)%0A//sys%09Mlockall(flags int) (err error)%0A//sys%09Mprotect(b %5B%5Dbyte, prot int) (err error)%0A//sys%09Msync(b %5B%5Dbyte, flags int) (err error)%0A//sys%09Munlock(b %5B%5Dbyte) (err error)%0A//sys%09Munlockall() (err error)%0A//sys%09Nanosleep(time *Timespec, leftover *Timespec) (err error)%0A//sys%09Open(path string, mode int, perm uint32) (fd int, err error)%0A//sys%09Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error)%0A//sys%09Pathconf(path string, name int) (val int, err error)%0A//sys%09Pause() (err error)%0A//sys%09Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error)%0A//sys%09read(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09Readlink(path string, buf %5B%5Dbyte) (n int, err error)%0A//sys%09Rename(from string, to string) (err error)%0A//sys%09Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)%0A//sys%09Rmdir(path string) (err error)%0A//sys%09Seek(fd int, offset int64, whence int) (newoffset int64, err error) = lseek%0A//sys%09Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error)%0A//sysnb%09Setegid(egid int) (err error)%0A//sysnb%09Seteuid(euid int) (err error)%0A//sysnb%09Setgid(gid int) (err error)%0A//sys%09Sethostname(p %5B%5Dbyte) (err error)%0A//sysnb%09Setpgid(pid int, pgid int) (err error)%0A//sys%09Setpriority(which int, who int, prio int) (err error)%0A//sysnb%09Setregid(rgid int, egid int) (err error)%0A//sysnb%09Setreuid(ruid int, euid int) (err error)%0A//sysnb%09Setrlimit(which int, lim *Rlimit) (err error)%0A//sysnb%09Setsid() (pid int, err error)%0A//sysnb%09Setuid(uid int) (err error)%0A//sys%09Shutdown(s int, how int) (err error) = libsocket.shutdown%0A//sys%09Stat(path string, stat *Stat_t) (err error)%0A//sys%09Statvfs(path string, vfsstat *Statvfs_t) (err error)%0A//sys%09Symlink(path string, link string) (err error)%0A//sys%09Sync() (err error)%0A//sysnb%09Times(tms *Tms) (ticks uintptr, err error)%0A//sys%09Truncate(path string, length int64) (err error)%0A//sys%09Fsync(fd int) (err error)%0A//sys%09Ftruncate(fd int, length int64) (err error)%0A//sys%09Umask(mask int) (oldmask int)%0A//sysnb%09Uname(buf *Utsname) (err error)%0A//sys%09Unmount(target string, flags int) (err error) = libc.umount%0A//sys%09Unlink(path string) (err error)%0A//sys%09Unlinkat(dirfd int, path string, flags int) (err error)%0A//sys%09Ustat(dev int, ubuf *Ustat_t) (err error)%0A//sys%09Utime(path string, buf *Utimbuf) (err error)%0A//sys%09bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_bind%0A//sys%09connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_connect%0A//sys%09mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error)%0A//sys%09munmap(addr uintptr, length uintptr) (err error)%0A//sys%09sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) = libsendfile.sendfile%0A//sys%09sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) = libsocket.__xnet_sendto%0A//sys%09socket(domain int, typ int, proto int) (fd int, err error) = libsocket.__xnet_socket%0A//sysnb%09socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) = libsocket.__xnet_socketpair%0A//sys%09write(fd int, p %5B%5Dbyte) (n int, err error)%0A//sys%09getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) = libsocket.__xnet_getsockopt%0A//sysnb%09getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) = libsocket.getpeername%0A//sys%09setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) = libsocket.setsockopt%0A//sys%09recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) = libsocket.recvfrom%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procread)), 3, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procwrite)), 3, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Avar mapper = &mmapper%7B%0A%09active: make(map%5B*byte%5D%5B%5Dbyte),%0A%09mmap:   mmap,%0A%09munmap: munmap,%0A%7D%0A%0Afunc Mmap(fd int, offset int64, length int, prot int, flags int) (data %5B%5Dbyte, err error) %7B%0A%09return mapper.Mmap(fd, offset, length, prot, flags)%0A%7D%0A%0Afunc Munmap(b %5B%5Dbyte) (err error) %7B%0A%09return mapper.Munmap(b)%0A%7D%0A
- f 559dae0d71511636b654a9a0a32456ab90f2bab65aa2e328c05afdbe8cbcbaeb vendor/golang.org/x/sys/unix/syscall_solaris_amd64.go
+ f e8ef5fdecd6c09589bd1f6607b4ef43b64a0e79e39214f555a676c1ec7ca6a15 vendor/golang.org/x/sys/unix/syscall_solaris_amd64.go
dmppatch 3
@@ -191,8 +191,319 @@
 ge unix%0A
+%0Afunc setTimespec(sec, nsec int64) Timespec %7B%0A%09return Timespec%7BSec: sec, Nsec: nsec%7D%0A%7D%0A%0Afunc setTimeval(sec, usec int64) Timeval %7B%0A%09return Timeval%7BSec: sec, Usec: usec%7D%0A%7D%0A%0Afunc (iov *Iovec) SetLen(length int) %7B%0A%09iov.Len = uint64(length)%0A%7D%0A%0Afunc (cmsg *Cmsghdr) SetLen(length int) %7B%0A%09cmsg.Len = uint32(length)%0A%7D%0A
- f 1cd028aaf5839194c919ff9b6e68e2d76c451f9989424af83e1d383a934dac73 vendor/golang.org/x/sys/unix/syscall_unix.go
+ f 2fccf73dfa6ceaf67d412d0cd388ebce43a434bb4a59168fca2613c98d6be934 vendor/golang.org/x/sys/unix/syscall_unix.go
dmppatch 24
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 %0Apac
@@ -245,16 +245,52 @@
 mport (%0A
+%09%22bytes%22%0A%09%22runtime%22%0A%09%22sort%22%0A%09%22sync%22%0A
 %09%22syscal
@@ -305,16 +305,320 @@
 afe%22%0A)%0A%0A
+var (%0A%09Stdin  = 0%0A%09Stdout = 1%0A%09Stderr = 2%0A)%0A%0Aconst (%0A%09darwin64Bit    = runtime.GOOS == %22darwin%22 && sizeofPtr == 8%0A%09dragonfly64Bit = runtime.GOOS == %22dragonfly%22 && sizeofPtr == 8%0A%09netbsd32Bit    = runtime.GOOS == %22netbsd%22 && sizeofPtr == 4%0A%09solaris64Bit   = runtime.GOOS == %22solaris%22 && sizeofPtr == 8%0A)%0A%0A
 // Do th
@@ -1063,16 +1063,2145 @@
 rn e%0A%7D%0A%0A
+// ErrnoName returns the error name for error number e.%0Afunc ErrnoName(e syscall.Errno) string %7B%0A%09i := sort.Search(len(errorList), func(i int) bool %7B%0A%09%09return errorList%5Bi%5D.num %3E= e%0A%09%7D)%0A%09if i %3C len(errorList) && errorList%5Bi%5D.num == e %7B%0A%09%09return errorList%5Bi%5D.name%0A%09%7D%0A%09return %22%22%0A%7D%0A%0A// SignalName returns the signal name for signal number s.%0Afunc SignalName(s syscall.Signal) string %7B%0A%09i := sort.Search(len(signalList), func(i int) bool %7B%0A%09%09return signalList%5Bi%5D.num %3E= s%0A%09%7D)%0A%09if i %3C len(signalList) && signalList%5Bi%5D.num == s %7B%0A%09%09return signalList%5Bi%5D.name%0A%09%7D%0A%09return %22%22%0A%7D%0A%0A// clen returns the index of the first NULL byte in n or len(n) if n contains no NULL byte.%0Afunc clen(n %5B%5Dbyte) int %7B%0A%09i := bytes.IndexByte(n, 0)%0A%09if i == -1 %7B%0A%09%09i = len(n)%0A%09%7D%0A%09return i%0A%7D%0A%0A// Mmap manager, for use by operating system-specific implementations.%0A%0Atype mmapper struct %7B%0A%09sync.Mutex%0A%09active map%5B*byte%5D%5B%5Dbyte // active mappings; key is last byte in mapping%0A%09mmap   func(addr, length uintptr, prot, flags, fd int, offset int64) (uintptr, error)%0A%09munmap func(addr uintptr, length uintptr) error%0A%7D%0A%0Afunc (m *mmapper) Mmap(fd int, offset int64, length int, prot int, flags int) (data %5B%5Dbyte, err error) %7B%0A%09if length %3C= 0 %7B%0A%09%09return nil, EINVAL%0A%09%7D%0A%0A%09// Map the requested memory.%0A%09addr, errno := m.mmap(0, uintptr(length), prot, flags, fd, offset)%0A%09if errno != nil %7B%0A%09%09return nil, errno%0A%09%7D%0A%0A%09// Slice memory layout%0A%09var sl = struct %7B%0A%09%09addr uintptr%0A%09%09len  int%0A%09%09cap  int%0A%09%7D%7Baddr, length, length%7D%0A%0A%09// Use unsafe to turn sl into a %5B%5Dbyte.%0A%09b := *(*%5B%5Dbyte)(unsafe.Pointer(&sl))%0A%0A%09// Register mapping in m and return it.%0A%09p := &b%5Bcap(b)-1%5D%0A%09m.Lock()%0A%09defer m.Unlock()%0A%09m.active%5Bp%5D = b%0A%09return b, nil%0A%7D%0A%0Afunc (m *mmapper) Munmap(data %5B%5Dbyte) (err error) %7B%0A%09if len(data) == 0 %7C%7C len(data) != cap(data) %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09// Find the base of the mapping.%0A%09p := &data%5Bcap(data)-1%5D%0A%09m.Lock()%0A%09defer m.Unlock()%0A%09b := m.active%5Bp%5D%0A%09if b == nil %7C%7C &b%5B0%5D != &data%5B0%5D %7B%0A%09%09return EINVAL%0A%09%7D%0A%0A%09// Unmap the memory and update m.%0A%09if errno := m.munmap(uintptr(unsafe.Pointer(&b%5B0%5D)), uintptr(len(b))); errno != nil %7B%0A%09%09return errno%0A%09%7D%0A%09delete(m.active, p)%0A%09return nil%0A%7D%0A%0A
 func Rea
@@ -3418,16 +3418,5709 @@
 turn%0A%7D%0A%0A
+func Write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09if raceenabled %7B%0A%09%09raceReleaseMerge(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09n, err = write(fd, p)%0A%09if raceenabled && n %3E 0 %7B%0A%09%09raceReadRange(unsafe.Pointer(&p%5B0%5D), n)%0A%09%7D%0A%09return%0A%7D%0A%0A// For testing: clients can set this flag to force%0A// creation of IPv6 sockets to return EAFNOSUPPORT.%0Avar SocketDisableIPv6 bool%0A%0A// Sockaddr represents a socket address.%0Atype Sockaddr interface %7B%0A%09sockaddr() (ptr unsafe.Pointer, len _Socklen, err error) // lowercase; only we can define Sockaddrs%0A%7D%0A%0A// SockaddrInet4 implements the Sockaddr interface for AF_INET type sockets.%0Atype SockaddrInet4 struct %7B%0A%09Port int%0A%09Addr %5B4%5Dbyte%0A%09raw  RawSockaddrInet4%0A%7D%0A%0A// SockaddrInet6 implements the Sockaddr interface for AF_INET6 type sockets.%0Atype SockaddrInet6 struct %7B%0A%09Port   int%0A%09ZoneId uint32%0A%09Addr   %5B16%5Dbyte%0A%09raw    RawSockaddrInet6%0A%7D%0A%0A// SockaddrUnix implements the Sockaddr interface for AF_UNIX type sockets.%0Atype SockaddrUnix struct %7B%0A%09Name string%0A%09raw  RawSockaddrUnix%0A%7D%0A%0Afunc Bind(fd int, sa Sockaddr) (err error) %7B%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return bind(fd, ptr, n)%0A%7D%0A%0Afunc Connect(fd int, sa Sockaddr) (err error) %7B%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return connect(fd, ptr, n)%0A%7D%0A%0Afunc Getpeername(fd int) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if err = getpeername(fd, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return anyToSockaddr(fd, &rsa)%0A%7D%0A%0Afunc GetsockoptByte(fd, level, opt int) (value byte, err error) %7B%0A%09var n byte%0A%09vallen := _Socklen(1)%0A%09err = getsockopt(fd, level, opt, unsafe.Pointer(&n), &vallen)%0A%09return n, err%0A%7D%0A%0Afunc GetsockoptInt(fd, level, opt int) (value int, err error) %7B%0A%09var n int32%0A%09vallen := _Socklen(4)%0A%09err = getsockopt(fd, level, opt, unsafe.Pointer(&n), &vallen)%0A%09return int(n), err%0A%7D%0A%0Afunc GetsockoptInet4Addr(fd, level, opt int) (value %5B4%5Dbyte, err error) %7B%0A%09vallen := _Socklen(4)%0A%09err = getsockopt(fd, level, opt, unsafe.Pointer(&value%5B0%5D), &vallen)%0A%09return value, err%0A%7D%0A%0Afunc GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error) %7B%0A%09var value IPMreq%0A%09vallen := _Socklen(SizeofIPMreq)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error) %7B%0A%09var value IPv6Mreq%0A%09vallen := _Socklen(SizeofIPv6Mreq)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptIPv6MTUInfo(fd, level, opt int) (*IPv6MTUInfo, error) %7B%0A%09var value IPv6MTUInfo%0A%09vallen := _Socklen(SizeofIPv6MTUInfo)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptICMPv6Filter(fd, level, opt int) (*ICMPv6Filter, error) %7B%0A%09var value ICMPv6Filter%0A%09vallen := _Socklen(SizeofICMPv6Filter)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&value), &vallen)%0A%09return &value, err%0A%7D%0A%0Afunc GetsockoptLinger(fd, level, opt int) (*Linger, error) %7B%0A%09var linger Linger%0A%09vallen := _Socklen(SizeofLinger)%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&linger), &vallen)%0A%09return &linger, err%0A%7D%0A%0Afunc GetsockoptTimeval(fd, level, opt int) (*Timeval, error) %7B%0A%09var tv Timeval%0A%09vallen := _Socklen(unsafe.Sizeof(tv))%0A%09err := getsockopt(fd, level, opt, unsafe.Pointer(&tv), &vallen)%0A%09return &tv, err%0A%7D%0A%0Afunc Recvfrom(fd int, p %5B%5Dbyte, flags int) (n int, from Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09var len _Socklen = SizeofSockaddrAny%0A%09if n, err = recvfrom(fd, p, flags, &rsa, &len); err != nil %7B%0A%09%09return%0A%09%7D%0A%09if rsa.Addr.Family != AF_UNSPEC %7B%0A%09%09from, err = anyToSockaddr(fd, &rsa)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sendto(fd int, p %5B%5Dbyte, flags int, to Sockaddr) (err error) %7B%0A%09ptr, n, err := to.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return sendto(fd, p, flags, ptr, n)%0A%7D%0A%0Afunc SetsockoptByte(fd, level, opt int, value byte) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(&value), 1)%0A%7D%0A%0Afunc SetsockoptInt(fd, level, opt int, value int) (err error) %7B%0A%09var n = int32(value)%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(&n), 4)%0A%7D%0A%0Afunc SetsockoptInet4Addr(fd, level, opt int, value %5B4%5Dbyte) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(&value%5B0%5D), 4)%0A%7D%0A%0Afunc SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(mreq), SizeofIPMreq)%0A%7D%0A%0Afunc SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(mreq), SizeofIPv6Mreq)%0A%7D%0A%0Afunc SetsockoptICMPv6Filter(fd, level, opt int, filter *ICMPv6Filter) error %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(filter), SizeofICMPv6Filter)%0A%7D%0A%0Afunc SetsockoptLinger(fd, level, opt int, l *Linger) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(l), SizeofLinger)%0A%7D%0A%0Afunc SetsockoptString(fd, level, opt int, s string) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(&%5B%5Dbyte(s)%5B0%5D), uintptr(len(s)))%0A%7D%0A%0Afunc SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error) %7B%0A%09return setsockopt(fd, level, opt, unsafe.Pointer(tv), unsafe.Sizeof(*tv))%0A%7D%0A%0Afunc Socket(domain, typ, proto int) (fd int, err error) %7B%0A%09if domain == AF_INET6 && SocketDisableIPv6 %7B%0A%09%09return -1, EAFNOSUPPORT%0A%09%7D%0A%09fd, err = socket(domain, typ, proto)%0A%09return%0A%7D%0A%0Afunc Socketpair(domain, typ, proto int) (fd %5B2%5Dint, err error) %7B%0A%09var fdx %5B2%5Dint32%0A%09err = socketpair(domain, typ, proto, &fdx)%0A%09if err == nil %7B%0A%09%09fd%5B0%5D = int(fdx%5B0%5D)%0A%09%09fd%5B1%5D = int(fdx%5B1%5D)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09if raceenabled %7B%0A%09%09raceReleaseMerge(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09return sendfile(outfd, infd, offset, count)%0A%7D%0A%0A
 var ioSy
@@ -9128,8 +9128,764 @@
 c int64%0A
+%0Afunc CloseOnExec(fd int) %7B fcntl(fd, F_SETFD, FD_CLOEXEC) %7D%0A%0Afunc SetNonblock(fd int, nonblocking bool) (err error) %7B%0A%09flag, err := fcntl(fd, F_GETFL, 0)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09if nonblocking %7B%0A%09%09flag %7C= O_NONBLOCK%0A%09%7D else %7B%0A%09%09flag &= %5EO_NONBLOCK%0A%09%7D%0A%09_, err = fcntl(fd, F_SETFL, flag)%0A%09return err%0A%7D%0A%0A// Exec calls execve(2), which replaces the calling executable in the process%0A// tree. argv0 should be the full path to an executable (%22/bin/ls%22) and the%0A// executable name should also be the first argument in argv (%5B%22ls%22, %22-l%22%5D).%0A// envv are the environment variables that should be passed to the new%0A// process (%5B%22USER=go%22, %22PWD=/tmp%22%5D).%0Afunc Exec(argv0 string, argv %5B%5Dstring, envv %5B%5Dstring) error %7B%0A%09return syscall.Exec(argv0, argv, envv)%0A%7D%0A
- f 95aa35addff8e88240a81f5fa167f232eee04d64cc537e98677595b9f6e5abde vendor/golang.org/x/sys/unix/syscall_unix_gc.go
+ f a6ad734e545b34d2e436990b0a62d1aa0e5f1f07fcd188431e55ccd434a087a3 vendor/golang.org/x/sys/unix/syscall_unix_gc.go
dmppatch 3
@@ -342,8 +342,265 @@
 .Errno)%0A
+func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)%0Afunc RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)%0Afunc RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)%0A
- f c0e181380978e721960f20eded408c817d07fdcca189cc95e92fd5377571bbae vendor/golang.org/x/sys/unix/timestruct.go
+ f c66825e94bff118443361c76775cd3427c707d435ad70cc75269d29cbe409d9c vendor/golang.org/x/sys/unix/timestruct.go
dmppatch 8
@@ -157,72 +157,76 @@
 e.%0A%0A
-// +build darwin dragonfly freebsd linux netbsd openbsd solaris%0A
+// +build aix darwin dragonfly freebsd linux netbsd openbsd solaris%0A
 %0Apac
@@ -235,8 +235,2312 @@
 ge unix%0A
+%0Aimport %22time%22%0A%0A// TimespecToNsec converts a Timespec value into a number of%0A// nanoseconds since the Unix epoch.%0Afunc TimespecToNsec(ts Timespec) int64 %7B return int64(ts.Sec)*1e9 + int64(ts.Nsec) %7D%0A%0A// NsecToTimespec takes a number of nanoseconds since the Unix epoch%0A// and returns the corresponding Timespec value.%0Afunc NsecToTimespec(nsec int64) Timespec %7B%0A%09sec := nsec / 1e9%0A%09nsec = nsec %25 1e9%0A%09if nsec %3C 0 %7B%0A%09%09nsec += 1e9%0A%09%09sec--%0A%09%7D%0A%09return setTimespec(sec, nsec)%0A%7D%0A%0A// TimeToTimespec converts t into a Timespec.%0A// On some 32-bit systems the range of valid Timespec values are smaller%0A// than that of time.Time values.  So if t is out of the valid range of%0A// Timespec, it returns a zero Timespec and ERANGE.%0Afunc TimeToTimespec(t time.Time) (Timespec, error) %7B%0A%09sec := t.Unix()%0A%09nsec := int64(t.Nanosecond())%0A%09ts := setTimespec(sec, nsec)%0A%0A%09// Currently all targets have either int32 or int64 for Timespec.Sec.%0A%09// If there were a new target with floating point type for it, we have%0A%09// to consider the rounding error.%0A%09if int64(ts.Sec) != sec %7B%0A%09%09return Timespec%7B%7D, ERANGE%0A%09%7D%0A%09return ts, nil%0A%7D%0A%0A// TimevalToNsec converts a Timeval value into a number of nanoseconds%0A// since the Unix epoch.%0Afunc TimevalToNsec(tv Timeval) int64 %7B return int64(tv.Sec)*1e9 + int64(tv.Usec)*1e3 %7D%0A%0A// NsecToTimeval takes a number of nanoseconds since the Unix epoch%0A// and returns the corresponding Timeval value.%0Afunc NsecToTimeval(nsec int64) Timeval %7B%0A%09nsec += 999 // round up to microsecond%0A%09usec := nsec %25 1e9 / 1e3%0A%09sec := nsec / 1e9%0A%09if usec %3C 0 %7B%0A%09%09usec += 1e6%0A%09%09sec--%0A%09%7D%0A%09return setTimeval(sec, usec)%0A%7D%0A%0A// Unix returns ts as the number of seconds and nanoseconds elapsed since the%0A// Unix epoch.%0Afunc (ts *Timespec) Unix() (sec int64, nsec int64) %7B%0A%09return int64(ts.Sec), int64(ts.Nsec)%0A%7D%0A%0A// Unix returns tv as the number of seconds and nanoseconds elapsed since the%0A// Unix epoch.%0Afunc (tv *Timeval) Unix() (sec int64, nsec int64) %7B%0A%09return int64(tv.Sec), int64(tv.Usec) * 1000%0A%7D%0A%0A// Nano returns ts as the number of nanoseconds elapsed since the Unix epoch.%0Afunc (ts *Timespec) Nano() int64 %7B%0A%09return int64(ts.Sec)*1e9 + int64(ts.Nsec)%0A%7D%0A%0A// Nano returns tv as the number of nanoseconds elapsed since the Unix epoch.%0Afunc (tv *Timeval) Nano() int64 %7B%0A%09return int64(tv.Sec)*1e9 + int64(tv.Usec)*1000%0A%7D%0A
+ f e2e8c3c982e4bcf38fd33e4f94aaab2bd5a1f84583d99675c68c5deeb9d8db47 vendor/golang.org/x/sys/unix/types_aix.go
dmppatch 2
@@ -0,0 +1,4229 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A// +build ignore%0A// +build aix%0A%0A/*%0AInput to cgo -godefs.  See also mkerrors.sh and mkall.sh%0A*/%0A%0A// +godefs map struct_in_addr %5B4%5Dbyte /* in_addr */%0A// +godefs map struct_in6_addr %5B16%5Dbyte /* in6_addr */%0A%0Apackage unix%0A%0A/*%0A#include %3Csys/types.h%3E%0A#include %3Csys/time.h%3E%0A#include %3Csys/limits.h%3E%0A#include %3Csys/un.h%3E%0A#include %3Cutime.h%3E%0A#include %3Csys/utsname.h%3E%0A#include %3Csys/poll.h%3E%0A#include %3Csys/resource.h%3E%0A#include %3Csys/stat.h%3E%0A#include %3Csys/statfs.h%3E%0A#include %3Csys/termio.h%3E%0A#include %3Csys/ioctl.h%3E%0A%0A#include %3Ctermios.h%3E%0A%0A#include %3Cnet/if.h%3E%0A#include %3Cnet/if_dl.h%3E%0A#include %3Cnetinet/in.h%3E%0A#include %3Cnetinet/icmp6.h%3E%0A%0A%0A#include %3Cdirent.h%3E%0A#include %3Cfcntl.h%3E%0A%0Aenum %7B%0A%09sizeofPtr = sizeof(void*),%0A%7D;%0A%0Aunion sockaddr_all %7B%0A%09struct sockaddr s1;     // this one gets used for fields%0A%09struct sockaddr_in s2;  // these pad it out%0A%09struct sockaddr_in6 s3;%0A%09struct sockaddr_un s4;%0A%09struct sockaddr_dl s5;%0A%7D;%0A%0Astruct sockaddr_any %7B%0A%09struct sockaddr addr;%0A%09char pad%5Bsizeof(union sockaddr_all) - sizeof(struct sockaddr)%5D;%0A%7D;%0A%0A*/%0Aimport %22C%22%0A%0A// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A%09PathMax        = C.PATH_MAX%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0Atype off64 C.off64_t%0Atype off C.off_t%0Atype Mode_t C.mode_t%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype StTimespec C.struct_st_timespec%0A%0Atype Timeval C.struct_timeval%0A%0Atype Timeval32 C.struct_timeval32%0A%0Atype Timex C.struct_timex%0A%0Atype Time_t C.time_t%0A%0Atype Tms C.struct_tms%0A%0Atype Utimbuf C.struct_utimbuf%0A%0Atype Timezone C.struct_timezone%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit64%0A%0Atype Pid_t C.pid_t%0A%0Atype _Gid_t C.gid_t%0A%0Atype dev_t C.dev_t%0A%0A// Files%0A%0Atype Stat_t C.struct_stat%0A%0Atype StatxTimestamp C.struct_statx_timestamp%0A%0Atype Statx_t C.struct_statx%0A%0Atype Dirent C.struct_dirent%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype Linger C.struct_linger%0A%0Atype Msghdr C.struct_msghdr%0A%0Aconst (%0A%09SizeofSockaddrInet4 = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6 = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny   = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix  = C.sizeof_struct_sockaddr_un%0A%09SizeofLinger        = C.sizeof_struct_linger%0A%09SizeofIPMreq        = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq      = C.sizeof_struct_ipv6_mreq%0A%09SizeofIPv6MTUInfo   = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofMsghdr        = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr       = C.sizeof_struct_cmsghdr%0A%09SizeofICMPv6Filter  = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr = C.sizeof_struct_if_msghdr%0A)%0A%0Atype IfMsgHdr C.struct_if_msghdr%0A%0A// Misc%0A%0Atype FdSet C.fd_set%0A%0Atype Utsname C.struct_utsname%0A%0Atype Ustat_t C.struct_ustat%0A%0Atype Sigset_t C.sigset_t%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_REMOVEDIR        = C.AT_REMOVEDIR%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// Terminal handling%0A%0Atype Termios C.struct_termios%0A%0Atype Termio C.struct_termio%0A%0Atype Winsize C.struct_winsize%0A%0A//poll%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  uint16%0A%09Revents uint16%0A%7D%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A%0A//flock_t%0A%0Atype Flock_t C.struct_flock64%0A%0A// Statfs%0A%0Atype Fsid_t C.struct_fsid_t%0Atype Fsid64_t C.struct_fsid64_t%0A%0Atype Statfs_t C.struct_statfs%0A%0Aconst RNDGETENTCNT = 0x80045200%0A
- f 05c883508833c12e3d3cdc366f588f61373e8513de446ddc46de0668fb9bc52c vendor/golang.org/x/sys/unix/types_darwin.go
+ f c3a3783a479a812986ef017699be1aa0f2657f4dbb43d07142b62b0c7853f259 vendor/golang.org/x/sys/unix/types_darwin.go
dmppatch 7
@@ -1501,16 +1501,3529 @@
 rt %22C%22%0A%0A
+// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0Atype Timeval32 C.struct_timeval32%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Atype Stat_t C.struct_stat64%0A%0Atype Statfs_t C.struct_statfs64%0A%0Atype Flock_t C.struct_flock%0A%0Atype Fstore_t C.struct_fstore%0A%0Atype Radvisory_t C.struct_radvisory%0A%0Atype Fbootstraptransfer_t C.struct_fbootstraptransfer%0A%0Atype Log2phys_t C.struct_log2phys%0A%0Atype Fsid C.struct_fsid%0A%0Atype Dirent C.struct_dirent%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet4Pktinfo C.struct_in_pktinfo%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet4Pktinfo     = C.sizeof_struct_in_pktinfo%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr    = C.sizeof_struct_if_msghdr%0A%09SizeofIfData      = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr   = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfmaMsghdr  = C.sizeof_struct_ifma_msghdr%0A%09SizeofIfmaMsghdr2 = C.sizeof_struct_ifma_msghdr2%0A%09SizeofRtMsghdr    = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics   = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfmaMsghdr C.struct_ifma_msghdr%0A%0Atype IfmaMsghdr2 C.struct_ifma_msghdr2%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0A
 // Termi
@@ -5066,8 +5066,580 @@
 termios%0A
+%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_REMOVEDIR        = C.AT_REMOVEDIR%0A%09AT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A%0A// uname%0A%0Atype Utsname C.struct_utsname%0A
- f c9c2cae01c5185e4276ba92860764637c169ea4d7b5620a0c6daaa9c0e25215e vendor/golang.org/x/sys/unix/types_dragonfly.go
+ f 391f3b857341ebf6122005c6e50b37f7fd54234d3569f41c5c90746bf0f32c96 vendor/golang.org/x/sys/unix/types_dragonfly.go
dmppatch 7
@@ -1367,16 +1367,3346 @@
 rt %22C%22%0A%0A
+// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Atype Stat_t C.struct_stat%0A%0Atype Statfs_t C.struct_statfs%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0Atype Fsid C.struct_fsid%0A%0A// File system limits%0A%0Aconst (%0A%09PathMax = C.PATH_MAX%0A)%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr         = C.sizeof_struct_if_msghdr%0A%09SizeofIfData           = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfmaMsghdr       = C.sizeof_struct_ifma_msghdr%0A%09SizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr%0A%09SizeofRtMsghdr         = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics        = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfmaMsghdr C.struct_ifma_msghdr%0A%0Atype IfAnnounceMsghdr C.struct_if_announcemsghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0A
 // Termi
@@ -4749,8 +4749,499 @@
 termios%0A
+%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A%0A// Uname%0A%0Atype Utsname C.struct_utsname%0A
- f c7019bfadf08cbf162e4b274a5a9a19e04c3451d1e8955c6a953766012ef0d01 vendor/golang.org/x/sys/unix/types_freebsd.go
+ f 290bc5a128ba625106c87825c1a3d092c43c020dd8d6bd20618f2f780ee64348 vendor/golang.org/x/sys/unix/types_freebsd.go
dmppatch 7
@@ -3597,16 +3597,4071 @@
 rt %22C%22%0A%0A
+// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Atype Stat_t C.struct_stat8%0A%0Atype Statfs_t C.struct_statfs%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0Atype Fsid C.struct_fsid%0A%0A// File system limits%0A%0Aconst (%0A%09PathMax = C.PATH_MAX%0A)%0A%0A// Advice to Fadvise%0A%0Aconst (%0A%09FADV_NORMAL     = C.POSIX_FADV_NORMAL%0A%09FADV_RANDOM     = C.POSIX_FADV_RANDOM%0A%09FADV_SEQUENTIAL = C.POSIX_FADV_SEQUENTIAL%0A%09FADV_WILLNEED   = C.POSIX_FADV_WILLNEED%0A%09FADV_DONTNEED   = C.POSIX_FADV_DONTNEED%0A%09FADV_NOREUSE    = C.POSIX_FADV_NOREUSE%0A)%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPMreqn C.struct_ip_mreqn%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPMreqn          = C.sizeof_struct_ip_mreqn%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09sizeofIfMsghdr         = C.sizeof_struct_if_msghdr%0A%09SizeofIfMsghdr         = C.sizeof_struct_if_msghdr8%0A%09sizeofIfData           = C.sizeof_struct_if_data%0A%09SizeofIfData           = C.sizeof_struct_if_data8%0A%09SizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfmaMsghdr       = C.sizeof_struct_ifma_msghdr%0A%09SizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr%0A%09SizeofRtMsghdr         = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics        = C.sizeof_struct_rt_metrics%0A)%0A%0Atype ifMsghdr C.struct_if_msghdr%0A%0Atype IfMsghdr C.struct_if_msghdr8%0A%0Atype ifData C.struct_if_data%0A%0Atype IfData C.struct_if_data8%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfmaMsghdr C.struct_ifma_msghdr%0A%0Atype IfAnnounceMsghdr C.struct_if_announcemsghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion    = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat       = C.sizeof_struct_bpf_stat%0A%09SizeofBpfZbuf       = C.sizeof_struct_bpf_zbuf%0A%09SizeofBpfProgram    = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn       = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr        = C.sizeof_struct_bpf_hdr%0A%09SizeofBpfZbufHeader = C.sizeof_struct_bpf_zbuf_header%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfZbuf C.struct_bpf_zbuf%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0Atype BpfZbufHeader C.struct_bpf_zbuf_header%0A%0A
 // Termi
@@ -7704,8 +7704,684 @@
 termios%0A
+%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_REMOVEDIR        = C.AT_REMOVEDIR%0A%09AT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR      = C.POLLERR%0A%09POLLHUP      = C.POLLHUP%0A%09POLLIN       = C.POLLIN%0A%09POLLINIGNEOF = C.POLLINIGNEOF%0A%09POLLNVAL     = C.POLLNVAL%0A%09POLLOUT      = C.POLLOUT%0A%09POLLPRI      = C.POLLPRI%0A%09POLLRDBAND   = C.POLLRDBAND%0A%09POLLRDNORM   = C.POLLRDNORM%0A%09POLLWRBAND   = C.POLLWRBAND%0A%09POLLWRNORM   = C.POLLWRNORM%0A)%0A%0A// Capabilities%0A%0Atype CapRights C.struct_cap_rights%0A%0A// Uname%0A%0Atype Utsname C.struct_utsname%0A
- f 31b8cc4de13d0d49f8f0b703d8c2918d3243129bdb856f0914b6a97ec9f4d43c vendor/golang.org/x/sys/unix/types_netbsd.go
+ f 93135ad2f2b96226dae6b0a3f705faa2a4af99773bbb0d86c74db3420c60248c vendor/golang.org/x/sys/unix/types_netbsd.go
dmppatch 7
@@ -1412,16 +1412,3594 @@
 rt %22C%22%0A%0A
+// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Atype Stat_t C.struct_stat%0A%0Atype Statfs_t C.struct_statfs%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0Atype Fsid C.fsid_t%0A%0A// File system limits%0A%0Aconst (%0A%09PathMax = C.PATH_MAX%0A)%0A%0A// Advice to Fadvise%0A%0Aconst (%0A%09FADV_NORMAL     = C.POSIX_FADV_NORMAL%0A%09FADV_RANDOM     = C.POSIX_FADV_RANDOM%0A%09FADV_SEQUENTIAL = C.POSIX_FADV_SEQUENTIAL%0A%09FADV_WILLNEED   = C.POSIX_FADV_WILLNEED%0A%09FADV_DONTNEED   = C.POSIX_FADV_DONTNEED%0A%09FADV_NOREUSE    = C.POSIX_FADV_NOREUSE%0A)%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr         = C.sizeof_struct_if_msghdr%0A%09SizeofIfData           = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr%0A%09SizeofRtMsghdr         = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics        = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfAnnounceMsghdr C.struct_if_announcemsghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0Atype Mclpool C.struct_mclpool%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0Atype BpfTimeval C.struct_bpf_timeval%0A%0A
 // Termi
@@ -5042,8 +5042,547 @@
 termios%0A
+%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A%0A// Sysctl%0A%0Atype Sysctlnode C.struct_sysctlnode%0A%0A// Uname%0A%0Atype Utsname C.struct_utsname%0A
- f dfdae33cf42644b3d5d6a42aaceac6f0b8acf0516309a522168a4fd364fa6dd9 vendor/golang.org/x/sys/unix/types_openbsd.go
+ f 96d175462ea21e3314a178ab6e8243444fecf762cb6c3296ee20a9be996e34df vendor/golang.org/x/sys/unix/types_openbsd.go
dmppatch 7
@@ -1388,16 +1388,3318 @@
 rt %22C%22%0A%0A
+// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Atype Stat_t C.struct_stat%0A%0Atype Statfs_t C.struct_statfs%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0Atype Fsid C.fsid_t%0A%0A// File system limits%0A%0Aconst (%0A%09PathMax = C.PATH_MAX%0A)%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Ptrace requests%0A%0Aconst (%0A%09PTRACE_TRACEME = C.PT_TRACE_ME%0A%09PTRACE_CONT    = C.PT_CONTINUE%0A%09PTRACE_KILL    = C.PT_KILL%0A)%0A%0A// Events (kqueue, kevent)%0A%0Atype Kevent_t C.struct_kevent%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr         = C.sizeof_struct_if_msghdr%0A%09SizeofIfData           = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr        = C.sizeof_struct_ifa_msghdr%0A%09SizeofIfAnnounceMsghdr = C.sizeof_struct_if_announcemsghdr%0A%09SizeofRtMsghdr         = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics        = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype IfAnnounceMsghdr C.struct_if_announcemsghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0Atype Mclpool C.struct_mclpool%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0Atype BpfTimeval C.struct_bpf_timeval%0A%0A
 // Termi
@@ -4742,8 +4742,499 @@
 termios%0A
+%0Atype Winsize C.struct_winsize%0A%0A// fchmodat-like syscalls.%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A)%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A%0A// Uname%0A%0Atype Utsname C.struct_utsname%0A
- f e32264cfe98b422fd605165745be0c102744893db4c629fde4744ac20173d5af vendor/golang.org/x/sys/unix/types_solaris.go
+ f 78e1e353fb067021d36297850ead467b5e04899f80790f5c0384b6e883e65806 vendor/golang.org/x/sys/unix/types_solaris.go
dmppatch 7
@@ -1729,16 +1729,3362 @@
 rt %22C%22%0A%0A
+// Machine characteristics; for internal use.%0A%0Aconst (%0A%09sizeofPtr      = C.sizeofPtr%0A%09sizeofShort    = C.sizeof_short%0A%09sizeofInt      = C.sizeof_int%0A%09sizeofLong     = C.sizeof_long%0A%09sizeofLongLong = C.sizeof_longlong%0A%09PathMax        = C.PATH_MAX%0A%09MaxHostNameLen = C.MAXHOSTNAMELEN%0A)%0A%0A// Basic types%0A%0Atype (%0A%09_C_short     C.short%0A%09_C_int       C.int%0A%09_C_long      C.long%0A%09_C_long_long C.longlong%0A)%0A%0A// Time%0A%0Atype Timespec C.struct_timespec%0A%0Atype Timeval C.struct_timeval%0A%0Atype Timeval32 C.struct_timeval32%0A%0Atype Tms C.struct_tms%0A%0Atype Utimbuf C.struct_utimbuf%0A%0A// Processes%0A%0Atype Rusage C.struct_rusage%0A%0Atype Rlimit C.struct_rlimit%0A%0Atype _Gid_t C.gid_t%0A%0A// Files%0A%0Atype Stat_t C.struct_stat%0A%0Atype Flock_t C.struct_flock%0A%0Atype Dirent C.struct_dirent%0A%0A// Filesystems%0A%0Atype _Fsblkcnt_t C.fsblkcnt_t%0A%0Atype Statvfs_t C.struct_statvfs%0A%0A// Sockets%0A%0Atype RawSockaddrInet4 C.struct_sockaddr_in%0A%0Atype RawSockaddrInet6 C.struct_sockaddr_in6%0A%0Atype RawSockaddrUnix C.struct_sockaddr_un%0A%0Atype RawSockaddrDatalink C.struct_sockaddr_dl%0A%0Atype RawSockaddr C.struct_sockaddr%0A%0Atype RawSockaddrAny C.struct_sockaddr_any%0A%0Atype _Socklen C.socklen_t%0A%0Atype Linger C.struct_linger%0A%0Atype Iovec C.struct_iovec%0A%0Atype IPMreq C.struct_ip_mreq%0A%0Atype IPv6Mreq C.struct_ipv6_mreq%0A%0Atype Msghdr C.struct_msghdr%0A%0Atype Cmsghdr C.struct_cmsghdr%0A%0Atype Inet6Pktinfo C.struct_in6_pktinfo%0A%0Atype IPv6MTUInfo C.struct_ip6_mtuinfo%0A%0Atype ICMPv6Filter C.struct_icmp6_filter%0A%0Aconst (%0A%09SizeofSockaddrInet4    = C.sizeof_struct_sockaddr_in%0A%09SizeofSockaddrInet6    = C.sizeof_struct_sockaddr_in6%0A%09SizeofSockaddrAny      = C.sizeof_struct_sockaddr_any%0A%09SizeofSockaddrUnix     = C.sizeof_struct_sockaddr_un%0A%09SizeofSockaddrDatalink = C.sizeof_struct_sockaddr_dl%0A%09SizeofLinger           = C.sizeof_struct_linger%0A%09SizeofIPMreq           = C.sizeof_struct_ip_mreq%0A%09SizeofIPv6Mreq         = C.sizeof_struct_ipv6_mreq%0A%09SizeofMsghdr           = C.sizeof_struct_msghdr%0A%09SizeofCmsghdr          = C.sizeof_struct_cmsghdr%0A%09SizeofInet6Pktinfo     = C.sizeof_struct_in6_pktinfo%0A%09SizeofIPv6MTUInfo      = C.sizeof_struct_ip6_mtuinfo%0A%09SizeofICMPv6Filter     = C.sizeof_struct_icmp6_filter%0A)%0A%0A// Select%0A%0Atype FdSet C.fd_set%0A%0A// Misc%0A%0Atype Utsname C.struct_utsname%0A%0Atype Ustat_t C.struct_ustat%0A%0Aconst (%0A%09AT_FDCWD            = C.AT_FDCWD%0A%09AT_SYMLINK_NOFOLLOW = C.AT_SYMLINK_NOFOLLOW%0A%09AT_SYMLINK_FOLLOW   = C.AT_SYMLINK_FOLLOW%0A%09AT_REMOVEDIR        = C.AT_REMOVEDIR%0A%09AT_EACCESS          = C.AT_EACCESS%0A)%0A%0A// Routing and interface messages%0A%0Aconst (%0A%09SizeofIfMsghdr  = C.sizeof_struct_if_msghdr%0A%09SizeofIfData    = C.sizeof_struct_if_data%0A%09SizeofIfaMsghdr = C.sizeof_struct_ifa_msghdr%0A%09SizeofRtMsghdr  = C.sizeof_struct_rt_msghdr%0A%09SizeofRtMetrics = C.sizeof_struct_rt_metrics%0A)%0A%0Atype IfMsghdr C.struct_if_msghdr%0A%0Atype IfData C.struct_if_data%0A%0Atype IfaMsghdr C.struct_ifa_msghdr%0A%0Atype RtMsghdr C.struct_rt_msghdr%0A%0Atype RtMetrics C.struct_rt_metrics%0A%0A// Berkeley packet filter%0A%0Aconst (%0A%09SizeofBpfVersion = C.sizeof_struct_bpf_version%0A%09SizeofBpfStat    = C.sizeof_struct_bpf_stat%0A%09SizeofBpfProgram = C.sizeof_struct_bpf_program%0A%09SizeofBpfInsn    = C.sizeof_struct_bpf_insn%0A%09SizeofBpfHdr     = C.sizeof_struct_bpf_hdr%0A)%0A%0Atype BpfVersion C.struct_bpf_version%0A%0Atype BpfStat C.struct_bpf_stat%0A%0Atype BpfProgram C.struct_bpf_program%0A%0Atype BpfInsn C.struct_bpf_insn%0A%0Atype BpfTimeval C.struct_bpf_timeval%0A%0Atype BpfHdr C.struct_bpf_hdr%0A%0A
 // Termi
@@ -5127,8 +5127,369 @@
 termios%0A
+%0Atype Termio C.struct_termio%0A%0Atype Winsize C.struct_winsize%0A%0A// poll%0A%0Atype PollFd C.struct_pollfd%0A%0Aconst (%0A%09POLLERR    = C.POLLERR%0A%09POLLHUP    = C.POLLHUP%0A%09POLLIN     = C.POLLIN%0A%09POLLNVAL   = C.POLLNVAL%0A%09POLLOUT    = C.POLLOUT%0A%09POLLPRI    = C.POLLPRI%0A%09POLLRDBAND = C.POLLRDBAND%0A%09POLLRDNORM = C.POLLRDNORM%0A%09POLLWRBAND = C.POLLWRBAND%0A%09POLLWRNORM = C.POLLWRNORM%0A)%0A
- f 53ee50011ce593173f9a34308134c0aa49c8535323b46645c5d1266e9661d430 vendor/golang.org/x/sys/unix/xattr_bsd.go
+ f 0e5c9e20b078120316c30943d8f04e5a92376af849587de57ce9b91280f4ab35 vendor/golang.org/x/sys/unix/xattr_bsd.go
dmppatch 3
@@ -192,8 +192,4767 @@
 ge unix%0A
+%0Aimport (%0A%09%22strings%22%0A%09%22unsafe%22%0A)%0A%0A// Derive extattr namespace and attribute name%0A%0Afunc xattrnamespace(fullattr string) (ns int, attr string, err error) %7B%0A%09s := strings.IndexByte(fullattr, '.')%0A%09if s == -1 %7B%0A%09%09return -1, %22%22, ENOATTR%0A%09%7D%0A%0A%09namespace := fullattr%5B0:s%5D%0A%09attr = fullattr%5Bs+1:%5D%0A%0A%09switch namespace %7B%0A%09case %22user%22:%0A%09%09return EXTATTR_NAMESPACE_USER, attr, nil%0A%09case %22system%22:%0A%09%09return EXTATTR_NAMESPACE_SYSTEM, attr, nil%0A%09default:%0A%09%09return -1, %22%22, ENOATTR%0A%09%7D%0A%7D%0A%0Afunc initxattrdest(dest %5B%5Dbyte, idx int) (d unsafe.Pointer) %7B%0A%09if len(dest) %3E idx %7B%0A%09%09return unsafe.Pointer(&dest%5Bidx%5D)%0A%09%7D else %7B%0A%09%09return unsafe.Pointer(_zero)%0A%09%7D%0A%7D%0A%0A// FreeBSD and NetBSD implement their own syscalls to handle extended attributes%0A%0Afunc Getxattr(file string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsize := len(dest)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%0A%09return ExtattrGetFile(file, nsid, a, uintptr(d), destsize)%0A%7D%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsize := len(dest)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%0A%09return ExtattrGetFd(fd, nsid, a, uintptr(d), destsize)%0A%7D%0A%0Afunc Lgetxattr(link string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsize := len(dest)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%0A%09return ExtattrGetLink(link, nsid, a, uintptr(d), destsize)%0A%7D%0A%0A// flags are unused on FreeBSD%0A%0Afunc Fsetxattr(fd int, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09d := unsafe.Pointer(&data%5B0%5D)%0A%09datasiz := len(data)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09_, err = ExtattrSetFd(fd, nsid, a, uintptr(d), datasiz)%0A%09return%0A%7D%0A%0Afunc Setxattr(file string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09d := unsafe.Pointer(&data%5B0%5D)%0A%09datasiz := len(data)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09_, err = ExtattrSetFile(file, nsid, a, uintptr(d), datasiz)%0A%09return%0A%7D%0A%0Afunc Lsetxattr(link string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09d := unsafe.Pointer(&data%5B0%5D)%0A%09datasiz := len(data)%0A%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09_, err = ExtattrSetLink(link, nsid, a, uintptr(d), datasiz)%0A%09return%0A%7D%0A%0Afunc Removexattr(file string, attr string) (err error) %7B%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09err = ExtattrDeleteFile(file, nsid, a)%0A%09return%0A%7D%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09err = ExtattrDeleteFd(fd, nsid, a)%0A%09return%0A%7D%0A%0Afunc Lremovexattr(link string, attr string) (err error) %7B%0A%09nsid, a, err := xattrnamespace(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%0A%09err = ExtattrDeleteLink(link, nsid, a)%0A%09return%0A%7D%0A%0Afunc Listxattr(file string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsiz := len(dest)%0A%0A%09// FreeBSD won't allow you to list xattrs from multiple namespaces%0A%09s := 0%0A%09for _, nsid := range %5B...%5Dint%7BEXTATTR_NAMESPACE_USER, EXTATTR_NAMESPACE_SYSTEM%7D %7B%0A%09%09stmp, e := ExtattrListFile(file, nsid, uintptr(d), destsiz)%0A%0A%09%09/* Errors accessing system attrs are ignored so that%0A%09%09 * we can implement the Linux-like behavior of omitting errors that%0A%09%09 * we don't have read permissions on%0A%09%09 *%0A%09%09 * Linux will still error if we ask for user attributes on a file that%0A%09%09 * we don't have read permissions on, so don't ignore those errors%0A%09%09 */%0A%09%09if e != nil && e == EPERM && nsid != EXTATTR_NAMESPACE_USER %7B%0A%09%09%09continue%0A%09%09%7D else if e != nil %7B%0A%09%09%09return s, e%0A%09%09%7D%0A%0A%09%09s += stmp%0A%09%09destsiz -= s%0A%09%09if destsiz %3C 0 %7B%0A%09%09%09destsiz = 0%0A%09%09%7D%0A%09%09d = initxattrdest(dest, s)%0A%09%7D%0A%0A%09return s, nil%0A%7D%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsiz := len(dest)%0A%0A%09s := 0%0A%09for _, nsid := range %5B...%5Dint%7BEXTATTR_NAMESPACE_USER, EXTATTR_NAMESPACE_SYSTEM%7D %7B%0A%09%09stmp, e := ExtattrListFd(fd, nsid, uintptr(d), destsiz)%0A%09%09if e != nil && e == EPERM && nsid != EXTATTR_NAMESPACE_USER %7B%0A%09%09%09continue%0A%09%09%7D else if e != nil %7B%0A%09%09%09return s, e%0A%09%09%7D%0A%0A%09%09s += stmp%0A%09%09destsiz -= s%0A%09%09if destsiz %3C 0 %7B%0A%09%09%09destsiz = 0%0A%09%09%7D%0A%09%09d = initxattrdest(dest, s)%0A%09%7D%0A%0A%09return s, nil%0A%7D%0A%0Afunc Llistxattr(link string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09d := initxattrdest(dest, 0)%0A%09destsiz := len(dest)%0A%0A%09s := 0%0A%09for _, nsid := range %5B...%5Dint%7BEXTATTR_NAMESPACE_USER, EXTATTR_NAMESPACE_SYSTEM%7D %7B%0A%09%09stmp, e := ExtattrListLink(link, nsid, uintptr(d), destsiz)%0A%09%09if e != nil && e == EPERM && nsid != EXTATTR_NAMESPACE_USER %7B%0A%09%09%09continue%0A%09%09%7D else if e != nil %7B%0A%09%09%09return s, e%0A%09%09%7D%0A%0A%09%09s += stmp%0A%09%09destsiz -= s%0A%09%09if destsiz %3C 0 %7B%0A%09%09%09destsiz = 0%0A%09%09%7D%0A%09%09d = initxattrdest(dest, s)%0A%09%7D%0A%0A%09return s, nil%0A%7D%0A
+ f 2817dbef801553e0bfd763d1d3874fc581bc8c240b170763c2c95d7e66033787 vendor/golang.org/x/sys/unix/zerrors_aix_ppc.go
dmppatch 2
@@ -0,0 +1,53216 @@
+// mkerrors.sh -maix32%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build ppc,aix%0A%0A// Created by cgo -godefs - DO NOT EDIT%0A// cgo -godefs -- -maix32 _const.go%0A%0Apackage unix%0A%0Aimport %22syscall%22%0A%0Aconst (%0A%09AF_APPLETALK                  = 0x10%0A%09AF_BYPASS                     = 0x19%0A%09AF_CCITT                      = 0xa%0A%09AF_CHAOS                      = 0x5%0A%09AF_DATAKIT                    = 0x9%0A%09AF_DECnet                     = 0xc%0A%09AF_DLI                        = 0xd%0A%09AF_ECMA                       = 0x8%0A%09AF_HYLINK                     = 0xf%0A%09AF_IMPLINK                    = 0x3%0A%09AF_INET                       = 0x2%0A%09AF_INET6                      = 0x18%0A%09AF_INTF                       = 0x14%0A%09AF_ISO                        = 0x7%0A%09AF_LAT                        = 0xe%0A%09AF_LINK                       = 0x12%0A%09AF_LOCAL                      = 0x1%0A%09AF_MAX                        = 0x1e%0A%09AF_NDD                        = 0x17%0A%09AF_NETWARE                    = 0x16%0A%09AF_NS                         = 0x6%0A%09AF_OSI                        = 0x7%0A%09AF_PUP                        = 0x4%0A%09AF_RIF                        = 0x15%0A%09AF_ROUTE                      = 0x11%0A%09AF_SNA                        = 0xb%0A%09AF_UNIX                       = 0x1%0A%09AF_UNSPEC                     = 0x0%0A%09ALTWERASE                     = 0x400000%0A%09ARPHRD_802_3                  = 0x6%0A%09ARPHRD_802_5                  = 0x6%0A%09ARPHRD_ETHER                  = 0x1%0A%09ARPHRD_FDDI                   = 0x1%0A%09B0                            = 0x0%0A%09B110                          = 0x3%0A%09B1200                         = 0x9%0A%09B134                          = 0x4%0A%09B150                          = 0x5%0A%09B1800                         = 0xa%0A%09B19200                        = 0xe%0A%09B200                          = 0x6%0A%09B2400                         = 0xb%0A%09B300                          = 0x7%0A%09B38400                        = 0xf%0A%09B4800                         = 0xc%0A%09B50                           = 0x1%0A%09B600                          = 0x8%0A%09B75                           = 0x2%0A%09B9600                         = 0xd%0A%09BRKINT                        = 0x2%0A%09BS0                           = 0x0%0A%09BS1                           = 0x1000%0A%09BSDLY                         = 0x1000%0A%09CAP_AACCT                     = 0x6%0A%09CAP_ARM_APPLICATION           = 0x5%0A%09CAP_BYPASS_RAC_VMM            = 0x3%0A%09CAP_CLEAR                     = 0x0%0A%09CAP_CREDENTIALS               = 0x7%0A%09CAP_EFFECTIVE                 = 0x1%0A%09CAP_EWLM_AGENT                = 0x4%0A%09CAP_INHERITABLE               = 0x2%0A%09CAP_MAXIMUM                   = 0x7%0A%09CAP_NUMA_ATTACH               = 0x2%0A%09CAP_PERMITTED                 = 0x3%0A%09CAP_PROPAGATE                 = 0x1%0A%09CAP_PROPOGATE                 = 0x1%0A%09CAP_SET                       = 0x1%0A%09CBAUD                         = 0xf%0A%09CFLUSH                        = 0xf%0A%09CIBAUD                        = 0xf0000%0A%09CLOCAL                        = 0x800%0A%09CLOCK_MONOTONIC               = 0xa%0A%09CLOCK_PROCESS_CPUTIME_ID      = 0xb%0A%09CLOCK_REALTIME                = 0x9%0A%09CLOCK_THREAD_CPUTIME_ID       = 0xc%0A%09CR0                           = 0x0%0A%09CR1                           = 0x100%0A%09CR2                           = 0x200%0A%09CR3                           = 0x300%0A%09CRDLY                         = 0x300%0A%09CREAD                         = 0x80%0A%09CS5                           = 0x0%0A%09CS6                           = 0x10%0A%09CS7                           = 0x20%0A%09CS8                           = 0x30%0A%09CSIOCGIFCONF                  = -0x3ff796dc%0A%09CSIZE                         = 0x30%0A%09CSMAP_DIR                     = %22/usr/lib/nls/csmap/%22%0A%09CSTART                        = '%5C021'%0A%09CSTOP                         = '%5C023'%0A%09CSTOPB                        = 0x40%0A%09CSUSP                         = 0x1a%0A%09ECHO                          = 0x8%0A%09ECHOCTL                       = 0x20000%0A%09ECHOE                         = 0x10%0A%09ECHOK                         = 0x20%0A%09ECHOKE                        = 0x80000%0A%09ECHONL                        = 0x40%0A%09ECHOPRT                       = 0x40000%0A%09ECH_ICMPID                    = 0x2%0A%09ETHERNET_CSMACD               = 0x6%0A%09EVENP                         = 0x80%0A%09EXCONTINUE                    = 0x0%0A%09EXDLOK                        = 0x3%0A%09EXIO                          = 0x2%0A%09EXPGIO                        = 0x0%0A%09EXRESUME                      = 0x2%0A%09EXRETURN                      = 0x1%0A%09EXSIG                         = 0x4%0A%09EXTA                          = 0xe%0A%09EXTB                          = 0xf%0A%09EXTRAP                        = 0x1%0A%09EYEC_RTENTRYA                 = 0x257274656e747241%0A%09EYEC_RTENTRYF                 = 0x257274656e747246%0A%09E_ACC                         = 0x0%0A%09FD_CLOEXEC                    = 0x1%0A%09FD_SETSIZE                    = 0xfffe%0A%09FF0                           = 0x0%0A%09FF1                           = 0x2000%0A%09FFDLY                         = 0x2000%0A%09FLUSHBAND                     = 0x40%0A%09FLUSHLOW                      = 0x8%0A%09FLUSHO                        = 0x100000%0A%09FLUSHR                        = 0x1%0A%09FLUSHRW                       = 0x3%0A%09FLUSHW                        = 0x2%0A%09F_CLOSEM                      = 0xa%0A%09F_DUP2FD                      = 0xe%0A%09F_DUPFD                       = 0x0%0A%09F_GETFD                       = 0x1%0A%09F_GETFL                       = 0x3%0A%09F_GETLK                       = 0x5%0A%09F_GETLK64                     = 0xb%0A%09F_GETOWN                      = 0x8%0A%09F_LOCK                        = 0x1%0A%09F_OK                          = 0x0%0A%09F_RDLCK                       = 0x1%0A%09F_SETFD                       = 0x2%0A%09F_SETFL                       = 0x4%0A%09F_SETLK                       = 0x6%0A%09F_SETLK64                     = 0xc%0A%09F_SETLKW                      = 0x7%0A%09F_SETLKW64                    = 0xd%0A%09F_SETOWN                      = 0x9%0A%09F_TEST                        = 0x3%0A%09F_TLOCK                       = 0x2%0A%09F_TSTLK                       = 0xf%0A%09F_ULOCK                       = 0x0%0A%09F_UNLCK                       = 0x3%0A%09F_WRLCK                       = 0x2%0A%09HUPCL                         = 0x400%0A%09IBSHIFT                       = 0x10%0A%09ICANON                        = 0x2%0A%09ICMP6_FILTER                  = 0x26%0A%09ICMP6_SEC_SEND_DEL            = 0x46%0A%09ICMP6_SEC_SEND_GET            = 0x47%0A%09ICMP6_SEC_SEND_SET            = 0x44%0A%09ICMP6_SEC_SEND_SET_CGA_ADDR   = 0x45%0A%09ICRNL                         = 0x100%0A%09IEXTEN                        = 0x200000%0A%09IFA_FIRSTALIAS                = 0x2000%0A%09IFA_ROUTE                     = 0x1%0A%09IFF_64BIT                     = 0x4000000%0A%09IFF_ALLCAST                   = 0x20000%0A%09IFF_ALLMULTI                  = 0x200%0A%09IFF_BPF                       = 0x8000000%0A%09IFF_BRIDGE                    = 0x40000%0A%09IFF_BROADCAST                 = 0x2%0A%09IFF_CANTCHANGE                = 0x80c52%0A%09IFF_CHECKSUM_OFFLOAD          = 0x10000000%0A%09IFF_D1                        = 0x8000%0A%09IFF_D2                        = 0x4000%0A%09IFF_D3                        = 0x2000%0A%09IFF_D4                        = 0x1000%0A%09IFF_DEBUG                     = 0x4%0A%09IFF_DEVHEALTH                 = 0x4000%0A%09IFF_DO_HW_LOOPBACK            = 0x10000%0A%09IFF_GROUP_ROUTING             = 0x2000000%0A%09IFF_IFBUFMGT                  = 0x800000%0A%09IFF_LINK0                     = 0x100000%0A%09IFF_LINK1                     = 0x200000%0A%09IFF_LINK2                     = 0x400000%0A%09IFF_LOOPBACK                  = 0x8%0A%09IFF_MULTICAST                 = 0x80000%0A%09IFF_NOARP                     = 0x80%0A%09IFF_NOECHO                    = 0x800%0A%09IFF_NOTRAILERS                = 0x20%0A%09IFF_OACTIVE                   = 0x400%0A%09IFF_POINTOPOINT               = 0x10%0A%09IFF_PROMISC                   = 0x100%0A%09IFF_PSEG                      = 0x40000000%0A%09IFF_RUNNING                   = 0x40%0A%09IFF_SIMPLEX                   = 0x800%0A%09IFF_SNAP                      = 0x8000%0A%09IFF_TCP_DISABLE_CKSUM         = 0x20000000%0A%09IFF_TCP_NOCKSUM               = 0x1000000%0A%09IFF_UP                        = 0x1%0A%09IFF_VIPA                      = 0x80000000%0A%09IFNAMSIZ                      = 0x10%0A%09IFO_FLUSH                     = 0x1%0A%09IFT_1822                      = 0x2%0A%09IFT_AAL5                      = 0x31%0A%09IFT_ARCNET                    = 0x23%0A%09IFT_ARCNETPLUS                = 0x24%0A%09IFT_ATM                       = 0x25%0A%09IFT_CEPT                      = 0x13%0A%09IFT_CLUSTER                   = 0x3e%0A%09IFT_DS3                       = 0x1e%0A%09IFT_EON                       = 0x19%0A%09IFT_ETHER                     = 0x6%0A%09IFT_FCS                       = 0x3a%0A%09IFT_FDDI                      = 0xf%0A%09IFT_FRELAY                    = 0x20%0A%09IFT_FRELAYDCE                 = 0x2c%0A%09IFT_GIFTUNNEL                 = 0x3c%0A%09IFT_HDH1822                   = 0x3%0A%09IFT_HF                        = 0x3d%0A%09IFT_HIPPI                     = 0x2f%0A%09IFT_HSSI                      = 0x2e%0A%09IFT_HY                        = 0xe%0A%09IFT_IB                        = 0xc7%0A%09IFT_ISDNBASIC                 = 0x14%0A%09IFT_ISDNPRIMARY               = 0x15%0A%09IFT_ISO88022LLC               = 0x29%0A%09IFT_ISO88023                  = 0x7%0A%09IFT_ISO88024                  = 0x8%0A%09IFT_ISO88025                  = 0x9%0A%09IFT_ISO88026                  = 0xa%0A%09IFT_LAPB                      = 0x10%0A%09IFT_LOCALTALK                 = 0x2a%0A%09IFT_LOOP                      = 0x18%0A%09IFT_MIOX25                    = 0x26%0A%09IFT_MODEM                     = 0x30%0A%09IFT_NSIP                      = 0x1b%0A%09IFT_OTHER                     = 0x1%0A%09IFT_P10                       = 0xc%0A%09IFT_P80                       = 0xd%0A%09IFT_PARA                      = 0x22%0A%09IFT_PPP                       = 0x17%0A%09IFT_PROPMUX                   = 0x36%0A%09IFT_PROPVIRTUAL               = 0x35%0A%09IFT_PTPSERIAL                 = 0x16%0A%09IFT_RS232                     = 0x21%0A%09IFT_SDLC                      = 0x11%0A%09IFT_SIP                       = 0x1f%0A%09IFT_SLIP                      = 0x1c%0A%09IFT_SMDSDXI                   = 0x2b%0A%09IFT_SMDSICIP                  = 0x34%0A%09IFT_SN                        = 0x38%0A%09IFT_SONET                     = 0x27%0A%09IFT_SONETPATH                 = 0x32%0A%09IFT_SONETVT                   = 0x33%0A%09IFT_SP                        = 0x39%0A%09IFT_STARLAN                   = 0xb%0A%09IFT_T1                        = 0x12%0A%09IFT_TUNNEL                    = 0x3b%0A%09IFT_ULTRA                     = 0x1d%0A%09IFT_V35                       = 0x2d%0A%09IFT_VIPA                      = 0x37%0A%09IFT_X25                       = 0x5%0A%09IFT_X25DDN                    = 0x4%0A%09IFT_X25PLE                    = 0x28%0A%09IFT_XETHER                    = 0x1a%0A%09IGNBRK                        = 0x1%0A%09IGNCR                         = 0x80%0A%09IGNPAR                        = 0x4%0A%09IMAXBEL                       = 0x10000%0A%09INLCR                         = 0x40%0A%09INPCK                         = 0x10%0A%09IN_CLASSA_HOST                = 0xffffff%0A%09IN_CLASSA_MAX                 = 0x80%0A%09IN_CLASSA_NET                 = 0xff000000%0A%09IN_CLASSA_NSHIFT              = 0x18%0A%09IN_CLASSB_HOST                = 0xffff%0A%09IN_CLASSB_MAX                 = 0x10000%0A%09IN_CLASSB_NET                 = 0xffff0000%0A%09IN_CLASSB_NSHIFT              = 0x10%0A%09IN_CLASSC_HOST                = 0xff%0A%09IN_CLASSC_NET                 = 0xffffff00%0A%09IN_CLASSC_NSHIFT              = 0x8%0A%09IN_CLASSD_HOST                = 0xfffffff%0A%09IN_CLASSD_NET                 = 0xf0000000%0A%09IN_CLASSD_NSHIFT              = 0x1c%0A%09IN_LOOPBACKNET                = 0x7f%0A%09IN_USE                        = 0x1%0A%09IPPROTO_AH                    = 0x33%0A%09IPPROTO_BIP                   = 0x53%0A%09IPPROTO_DSTOPTS               = 0x3c%0A%09IPPROTO_EGP                   = 0x8%0A%09IPPROTO_EON                   = 0x50%0A%09IPPROTO_ESP                   = 0x32%0A%09IPPROTO_FRAGMENT              = 0x2c%0A%09IPPROTO_GGP                   = 0x3%0A%09IPPROTO_GIF                   = 0x8c%0A%09IPPROTO_GRE                   = 0x2f%0A%09IPPROTO_HOPOPTS               = 0x0%0A%09IPPROTO_ICMP                  = 0x1%0A%09IPPROTO_ICMPV6                = 0x3a%0A%09IPPROTO_IDP                   = 0x16%0A%09IPPROTO_IGMP                  = 0x2%0A%09IPPROTO_IP                    = 0x0%0A%09IPPROTO_IPIP                  = 0x4%0A%09IPPROTO_IPV6                  = 0x29%0A%09IPPROTO_LOCAL                 = 0x3f%0A%09IPPROTO_MAX                   = 0x100%0A%09IPPROTO_MH                    = 0x87%0A%09IPPROTO_NONE                  = 0x3b%0A%09IPPROTO_PUP                   = 0xc%0A%09IPPROTO_QOS                   = 0x2d%0A%09IPPROTO_RAW                   = 0xff%0A%09IPPROTO_ROUTING               = 0x2b%0A%09IPPROTO_RSVP                  = 0x2e%0A%09IPPROTO_SCTP                  = 0x84%0A%09IPPROTO_TCP                   = 0x6%0A%09IPPROTO_TP                    = 0x1d%0A%09IPPROTO_UDP                   = 0x11%0A%09IPV6_ADDRFORM                 = 0x16%0A%09IPV6_ADDR_PREFERENCES         = 0x4a%0A%09IPV6_ADD_MEMBERSHIP           = 0xc%0A%09IPV6_AIXRAWSOCKET             = 0x39%0A%09IPV6_CHECKSUM                 = 0x27%0A%09IPV6_DONTFRAG                 = 0x2d%0A%09IPV6_DROP_MEMBERSHIP          = 0xd%0A%09IPV6_DSTOPTS                  = 0x36%0A%09IPV6_FLOWINFO_FLOWLABEL       = 0xffffff%0A%09IPV6_FLOWINFO_PRIFLOW         = 0xfffffff%0A%09IPV6_FLOWINFO_PRIORITY        = 0xf000000%0A%09IPV6_FLOWINFO_SRFLAG          = 0x10000000%0A%09IPV6_FLOWINFO_VERSION         = 0xf0000000%0A%09IPV6_HOPLIMIT                 = 0x28%0A%09IPV6_HOPOPTS                  = 0x34%0A%09IPV6_JOIN_GROUP               = 0xc%0A%09IPV6_LEAVE_GROUP              = 0xd%0A%09IPV6_MIPDSTOPTS               = 0x36%0A%09IPV6_MULTICAST_HOPS           = 0xa%0A%09IPV6_MULTICAST_IF             = 0x9%0A%09IPV6_MULTICAST_LOOP           = 0xb%0A%09IPV6_NEXTHOP                  = 0x30%0A%09IPV6_NOPROBE                  = 0x1c%0A%09IPV6_PATHMTU                  = 0x2e%0A%09IPV6_PKTINFO                  = 0x21%0A%09IPV6_PKTOPTIONS               = 0x24%0A%09IPV6_PRIORITY_10              = 0xa000000%0A%09IPV6_PRIORITY_11              = 0xb000000%0A%09IPV6_PRIORITY_12              = 0xc000000%0A%09IPV6_PRIORITY_13              = 0xd000000%0A%09IPV6_PRIORITY_14              = 0xe000000%0A%09IPV6_PRIORITY_15              = 0xf000000%0A%09IPV6_PRIORITY_8               = 0x8000000%0A%09IPV6_PRIORITY_9               = 0x9000000%0A%09IPV6_PRIORITY_BULK            = 0x4000000%0A%09IPV6_PRIORITY_CONTROL         = 0x7000000%0A%09IPV6_PRIORITY_FILLER          = 0x1000000%0A%09IPV6_PRIORITY_INTERACTIVE     = 0x6000000%0A%09IPV6_PRIORITY_RESERVED1       = 0x3000000%0A%09IPV6_PRIORITY_RESERVED2       = 0x5000000%0A%09IPV6_PRIORITY_UNATTENDED      = 0x2000000%0A%09IPV6_PRIORITY_UNCHARACTERIZED = 0x0%0A%09IPV6_RECVDSTOPTS              = 0x38%0A%09IPV6_RECVHOPLIMIT             = 0x29%0A%09IPV6_RECVHOPOPTS              = 0x35%0A%09IPV6_RECVHOPS                 = 0x22%0A%09IPV6_RECVIF                   = 0x1e%0A%09IPV6_RECVPATHMTU              = 0x2f%0A%09IPV6_RECVPKTINFO              = 0x23%0A%09IPV6_RECVRTHDR                = 0x33%0A%09IPV6_RECVSRCRT                = 0x1d%0A%09IPV6_RECVTCLASS               = 0x2a%0A%09IPV6_RTHDR                    = 0x32%0A%09IPV6_RTHDRDSTOPTS             = 0x37%0A%09IPV6_RTHDR_TYPE_0             = 0x0%0A%09IPV6_RTHDR_TYPE_2             = 0x2%0A%09IPV6_SENDIF                   = 0x1f%0A%09IPV6_SRFLAG_LOOSE             = 0x0%0A%09IPV6_SRFLAG_STRICT            = 0x10000000%0A%09IPV6_TCLASS                   = 0x2b%0A%09IPV6_TOKEN_LENGTH             = 0x40%0A%09IPV6_UNICAST_HOPS             = 0x4%0A%09IPV6_USE_MIN_MTU              = 0x2c%0A%09IPV6_V6ONLY                   = 0x25%0A%09IPV6_VERSION                  = 0x60000000%0A%09IP_ADDRFORM                   = 0x16%0A%09IP_ADD_MEMBERSHIP             = 0xc%0A%09IP_ADD_SOURCE_MEMBERSHIP      = 0x3c%0A%09IP_BLOCK_SOURCE               = 0x3a%0A%09IP_BROADCAST_IF               = 0x10%0A%09IP_CACHE_LINE_SIZE            = 0x80%0A%09IP_DEFAULT_MULTICAST_LOOP     = 0x1%0A%09IP_DEFAULT_MULTICAST_TTL      = 0x1%0A%09IP_DF                         = 0x4000%0A%09IP_DHCPMODE                   = 0x11%0A%09IP_DONTFRAG                   = 0x19%0A%09IP_DROP_MEMBERSHIP            = 0xd%0A%09IP_DROP_SOURCE_MEMBERSHIP     = 0x3d%0A%09IP_FINDPMTU                   = 0x1a%0A%09IP_HDRINCL                    = 0x2%0A%09IP_INC_MEMBERSHIPS            = 0x14%0A%09IP_INIT_MEMBERSHIP            = 0x14%0A%09IP_MAXPACKET                  = 0xffff%0A%09IP_MF                         = 0x2000%0A%09IP_MSS                        = 0x240%0A%09IP_MULTICAST_HOPS             = 0xa%0A%09IP_MULTICAST_IF               = 0x9%0A%09IP_MULTICAST_LOOP             = 0xb%0A%09IP_MULTICAST_TTL              = 0xa%0A%09IP_OPT                        = 0x1b%0A%09IP_OPTIONS                    = 0x1%0A%09IP_PMTUAGE                    = 0x1b%0A%09IP_RECVDSTADDR                = 0x7%0A%09IP_RECVIF                     = 0x14%0A%09IP_RECVIFINFO                 = 0xf%0A%09IP_RECVINTERFACE              = 0x20%0A%09IP_RECVMACHDR                 = 0xe%0A%09IP_RECVOPTS                   = 0x5%0A%09IP_RECVRETOPTS                = 0x6%0A%09IP_RECVTTL                    = 0x22%0A%09IP_RETOPTS                    = 0x8%0A%09IP_SOURCE_FILTER              = 0x48%0A%09IP_TOS                        = 0x3%0A%09IP_TTL                        = 0x4%0A%09IP_UNBLOCK_SOURCE             = 0x3b%0A%09IP_UNICAST_HOPS               = 0x4%0A%09ISIG                          = 0x1%0A%09ISTRIP                        = 0x20%0A%09IUCLC                         = 0x800%0A%09IXANY                         = 0x1000%0A%09IXOFF                         = 0x400%0A%09IXON                          = 0x200%0A%09I_FLUSH                       = 0x20005305%0A%09LNOFLSH                       = 0x8000%0A%09LOCK_EX                       = 0x2%0A%09LOCK_NB                       = 0x4%0A%09LOCK_SH                       = 0x1%0A%09LOCK_UN                       = 0x8%0A%09MADV_DONTNEED                 = 0x4%0A%09MADV_NORMAL                   = 0x0%0A%09MADV_RANDOM                   = 0x1%0A%09MADV_SEQUENTIAL               = 0x2%0A%09MADV_SPACEAVAIL               = 0x5%0A%09MADV_WILLNEED                 = 0x3%0A%09MAP_ANON                      = 0x10%0A%09MAP_ANONYMOUS                 = 0x10%0A%09MAP_FILE                      = 0x0%0A%09MAP_FIXED                     = 0x100%0A%09MAP_PRIVATE                   = 0x2%0A%09MAP_SHARED                    = 0x1%0A%09MAP_TYPE                      = 0xf0%0A%09MAP_VARIABLE                  = 0x0%0A%09MCL_CURRENT                   = 0x100%0A%09MCL_FUTURE                    = 0x200%0A%09MSG_ANY                       = 0x4%0A%09MSG_ARGEXT                    = 0x400%0A%09MSG_BAND                      = 0x2%0A%09MSG_COMPAT                    = 0x8000%0A%09MSG_CTRUNC                    = 0x20%0A%09MSG_DONTROUTE                 = 0x4%0A%09MSG_EOR                       = 0x8%0A%09MSG_HIPRI                     = 0x1%0A%09MSG_MAXIOVLEN                 = 0x10%0A%09MSG_MPEG2                     = 0x80%0A%09MSG_NONBLOCK                  = 0x4000%0A%09MSG_NOSIGNAL                  = 0x100%0A%09MSG_OOB                       = 0x1%0A%09MSG_PEEK                      = 0x2%0A%09MSG_TRUNC                     = 0x10%0A%09MSG_WAITALL                   = 0x40%0A%09MSG_WAITFORONE                = 0x200%0A%09MS_ASYNC                      = 0x10%0A%09MS_EINTR                      = 0x80%0A%09MS_INVALIDATE                 = 0x40%0A%09MS_PER_SEC                    = 0x3e8%0A%09MS_SYNC                       = 0x20%0A%09NL0                           = 0x0%0A%09NL1                           = 0x4000%0A%09NL2                           = 0x8000%0A%09NL3                           = 0xc000%0A%09NLDLY                         = 0x4000%0A%09NOFLSH                        = 0x80%0A%09NOFLUSH                       = 0x80000000%0A%09OCRNL                         = 0x8%0A%09OFDEL                         = 0x80%0A%09OFILL                         = 0x40%0A%09OLCUC                         = 0x2%0A%09ONLCR                         = 0x4%0A%09ONLRET                        = 0x20%0A%09ONOCR                         = 0x10%0A%09ONOEOT                        = 0x80000%0A%09OPOST                         = 0x1%0A%09OXTABS                        = 0x40000%0A%09O_ACCMODE                     = 0x23%0A%09O_APPEND                      = 0x8%0A%09O_CIO                         = 0x80%0A%09O_CIOR                        = 0x800000000%0A%09O_CLOEXEC                     = 0x800000%0A%09O_CREAT                       = 0x100%0A%09O_DEFER                       = 0x2000%0A%09O_DELAY                       = 0x4000%0A%09O_DIRECT                      = 0x8000000%0A%09O_DIRECTORY                   = 0x80000%0A%09O_DSYNC                       = 0x400000%0A%09O_EFSOFF                      = 0x400000000%0A%09O_EFSON                       = 0x200000000%0A%09O_EXCL                        = 0x400%0A%09O_EXEC                        = 0x20%0A%09O_LARGEFILE                   = 0x4000000%0A%09O_NDELAY                      = 0x8000%0A%09O_NOCACHE                     = 0x100000%0A%09O_NOCTTY                      = 0x800%0A%09O_NOFOLLOW                    = 0x1000000%0A%09O_NONBLOCK                    = 0x4%0A%09O_NONE                        = 0x3%0A%09O_NSHARE                      = 0x10000%0A%09O_RAW                         = 0x100000000%0A%09O_RDONLY                      = 0x0%0A%09O_RDWR                        = 0x2%0A%09O_RSHARE                      = 0x1000%0A%09O_RSYNC                       = 0x200000%0A%09O_SEARCH                      = 0x20%0A%09O_SNAPSHOT                    = 0x40%0A%09O_SYNC                        = 0x10%0A%09O_TRUNC                       = 0x200%0A%09O_TTY_INIT                    = 0x0%0A%09O_WRONLY                      = 0x1%0A%09PARENB                        = 0x100%0A%09PAREXT                        = 0x100000%0A%09PARMRK                        = 0x8%0A%09PARODD                        = 0x200%0A%09PENDIN                        = 0x20000000%0A%09PRIO_PGRP                     = 0x1%0A%09PRIO_PROCESS                  = 0x0%0A%09PRIO_USER                     = 0x2%0A%09PROT_EXEC                     = 0x4%0A%09PROT_NONE                     = 0x0%0A%09PROT_READ                     = 0x1%0A%09PROT_WRITE                    = 0x2%0A%09PR_64BIT                      = 0x20%0A%09PR_ADDR                       = 0x2%0A%09PR_ARGEXT                     = 0x400%0A%09PR_ATOMIC                     = 0x1%0A%09PR_CONNREQUIRED               = 0x4%0A%09PR_FASTHZ                     = 0x5%0A%09PR_INP                        = 0x40%0A%09PR_INTRLEVEL                  = 0x8000%0A%09PR_MLS                        = 0x100%0A%09PR_MLS_1_LABEL                = 0x200%0A%09PR_NOEOR                      = 0x4000%0A%09PR_RIGHTS                     = 0x10%0A%09PR_SLOWHZ                     = 0x2%0A%09PR_WANTRCVD                   = 0x8%0A%09RLIMIT_AS                     = 0x6%0A%09RLIMIT_CORE                   = 0x4%0A%09RLIMIT_CPU                    = 0x0%0A%09RLIMIT_DATA                   = 0x2%0A%09RLIMIT_FSIZE                  = 0x1%0A%09RLIMIT_NOFILE                 = 0x7%0A%09RLIMIT_NPROC                  = 0x9%0A%09RLIMIT_RSS                    = 0x5%0A%09RLIMIT_STACK                  = 0x3%0A%09RLIM_INFINITY                 = 0x7fffffff%0A%09RTAX_AUTHOR                   = 0x6%0A%09RTAX_BRD                      = 0x7%0A%09RTAX_DST                      = 0x0%0A%09RTAX_GATEWAY                  = 0x1%0A%09RTAX_GENMASK                  = 0x3%0A%09RTAX_IFA                      = 0x5%0A%09RTAX_IFP                      = 0x4%0A%09RTAX_MAX                      = 0x8%0A%09RTAX_NETMASK                  = 0x2%0A%09RTA_AUTHOR                    = 0x40%0A%09RTA_BRD                       = 0x80%0A%09RTA_DOWNSTREAM                = 0x100%0A%09RTA_DST                       = 0x1%0A%09RTA_GATEWAY                   = 0x2%0A%09RTA_GENMASK                   = 0x8%0A%09RTA_IFA                       = 0x20%0A%09RTA_IFP                       = 0x10%0A%09RTA_NETMASK                   = 0x4%0A%09RTC_IA64                      = 0x3%0A%09RTC_POWER                     = 0x1%0A%09RTC_POWER_PC                  = 0x2%0A%09RTF_ACTIVE_DGD                = 0x1000000%0A%09RTF_BCE                       = 0x80000%0A%09RTF_BLACKHOLE                 = 0x1000%0A%09RTF_BROADCAST                 = 0x400000%0A%09RTF_BUL                       = 0x2000%0A%09RTF_CLONE                     = 0x10000%0A%09RTF_CLONED                    = 0x20000%0A%09RTF_CLONING                   = 0x100%0A%09RTF_DONE                      = 0x40%0A%09RTF_DYNAMIC                   = 0x10%0A%09RTF_FREE_IN_PROG              = 0x4000000%0A%09RTF_GATEWAY                   = 0x2%0A%09RTF_HOST                      = 0x4%0A%09RTF_LLINFO                    = 0x400%0A%09RTF_LOCAL                     = 0x200000%0A%09RTF_MASK                      = 0x80%0A%09RTF_MODIFIED                  = 0x20%0A%09RTF_MULTICAST                 = 0x800000%0A%09RTF_PERMANENT6                = 0x8000000%0A%09RTF_PINNED                    = 0x100000%0A%09RTF_PROTO1                    = 0x8000%0A%09RTF_PROTO2                    = 0x4000%0A%09RTF_PROTO3                    = 0x40000%0A%09RTF_REJECT                    = 0x8%0A%09RTF_SMALLMTU                  = 0x40000%0A%09RTF_STATIC                    = 0x800%0A%09RTF_STOPSRCH                  = 0x2000000%0A%09RTF_UNREACHABLE               = 0x10000000%0A%09RTF_UP                        = 0x1%0A%09RTF_XRESOLVE                  = 0x200%0A%09RTM_ADD                       = 0x1%0A%09RTM_CHANGE                    = 0x3%0A%09RTM_DELADDR                   = 0xd%0A%09RTM_DELETE                    = 0x2%0A%09RTM_EXPIRE                    = 0xf%0A%09RTM_GET                       = 0x4%0A%09RTM_GETNEXT                   = 0x11%0A%09RTM_IFINFO                    = 0xe%0A%09RTM_LOCK                      = 0x8%0A%09RTM_LOSING                    = 0x5%0A%09RTM_MISS                      = 0x7%0A%09RTM_NEWADDR                   = 0xc%0A%09RTM_OLDADD                    = 0x9%0A%09RTM_OLDDEL                    = 0xa%0A%09RTM_REDIRECT                  = 0x6%0A%09RTM_RESOLVE                   = 0xb%0A%09RTM_RTLOST                    = 0x10%0A%09RTM_RTTUNIT                   = 0xf4240%0A%09RTM_SAMEADDR                  = 0x12%0A%09RTM_SET                       = 0x13%0A%09RTM_VERSION                   = 0x2%0A%09RTM_VERSION_GR                = 0x4%0A%09RTM_VERSION_GR_COMPAT         = 0x3%0A%09RTM_VERSION_POLICY            = 0x5%0A%09RTM_VERSION_POLICY_EXT        = 0x6%0A%09RTM_VERSION_POLICY_PRFN       = 0x7%0A%09RTV_EXPIRE                    = 0x4%0A%09RTV_HOPCOUNT                  = 0x2%0A%09RTV_MTU                       = 0x1%0A%09RTV_RPIPE                     = 0x8%0A%09RTV_RTT                       = 0x40%0A%09RTV_RTTVAR                    = 0x80%0A%09RTV_SPIPE                     = 0x10%0A%09RTV_SSTHRESH                  = 0x20%0A%09RUSAGE_CHILDREN               = -0x1%0A%09RUSAGE_SELF                   = 0x0%0A%09RUSAGE_THREAD                 = 0x1%0A%09SCM_RIGHTS                    = 0x1%0A%09SHUT_RD                       = 0x0%0A%09SHUT_RDWR                     = 0x2%0A%09SHUT_WR                       = 0x1%0A%09SIGMAX64                      = 0xff%0A%09SIGQUEUE_MAX                  = 0x20%0A%09SIOCADDIFVIPA                 = 0x20006942%0A%09SIOCADDMTU                    = -0x7ffb9690%0A%09SIOCADDMULTI                  = -0x7fdf96cf%0A%09SIOCADDNETID                  = -0x7fd796a9%0A%09SIOCADDRT                     = -0x7fcf8df6%0A%09SIOCAIFADDR                   = -0x7fbf96e6%0A%09SIOCATMARK                    = 0x40047307%0A%09SIOCDARP                      = -0x7fb396e0%0A%09SIOCDELIFVIPA                 = 0x20006943%0A%09SIOCDELMTU                    = -0x7ffb968f%0A%09SIOCDELMULTI                  = -0x7fdf96ce%0A%09SIOCDELPMTU                   = -0x7fd78ff6%0A%09SIOCDELRT                     = -0x7fcf8df5%0A%09SIOCDIFADDR                   = -0x7fd796e7%0A%09SIOCDNETOPT                   = -0x3ffe9680%0A%09SIOCDX25XLATE                 = -0x7fd7969b%0A%09SIOCFIFADDR                   = -0x7fdf966d%0A%09SIOCGARP                      = -0x3fb396da%0A%09SIOCGETMTUS                   = 0x2000696f%0A%09SIOCGETSGCNT                  = -0x3feb8acc%0A%09SIOCGETVIFCNT                 = -0x3feb8acd%0A%09SIOCGHIWAT                    = 0x40047301%0A%09SIOCGIFADDR                   = -0x3fd796df%0A%09SIOCGIFADDRS                  = 0x2000698c%0A%09SIOCGIFBAUDRATE               = -0x3fd79693%0A%09SIOCGIFBRDADDR                = -0x3fd796dd%0A%09SIOCGIFCONF                   = -0x3ff796bb%0A%09SIOCGIFCONFGLOB               = -0x3ff79670%0A%09SIOCGIFDSTADDR                = -0x3fd796de%0A%09SIOCGIFFLAGS                  = -0x3fd796ef%0A%09SIOCGIFGIDLIST                = 0x20006968%0A%09SIOCGIFHWADDR                 = -0x3fab966b%0A%09SIOCGIFMETRIC                 = -0x3fd796e9%0A%09SIOCGIFMTU                    = -0x3fd796aa%0A%09SIOCGIFNETMASK                = -0x3fd796db%0A%09SIOCGIFOPTIONS                = -0x3fd796d6%0A%09SIOCGISNO                     = -0x3fd79695%0A%09SIOCGLOADF                    = -0x3ffb967e%0A%09SIOCGLOWAT                    = 0x40047303%0A%09SIOCGNETOPT                   = -0x3ffe96a5%0A%09SIOCGNETOPT1                  = -0x3fdf967f%0A%09SIOCGNMTUS                    = 0x2000696e%0A%09SIOCGPGRP                     = 0x40047309%0A%09SIOCGSIZIFCONF                = 0x4004696a%0A%09SIOCGSRCFILTER                = -0x3fe796cb%0A%09SIOCGTUNEPHASE                = -0x3ffb9676%0A%09SIOCGX25XLATE                 = -0x3fd7969c%0A%09SIOCIFATTACH                  = -0x7fdf9699%0A%09SIOCIFDETACH                  = -0x7fdf969a%0A%09SIOCIFGETPKEY                 = -0x7fdf969b%0A%09SIOCIF_ATM_DARP               = -0x7fdf9683%0A%09SIOCIF_ATM_DUMPARP            = -0x7fdf9685%0A%09SIOCIF_ATM_GARP               = -0x7fdf9682%0A%09SIOCIF_ATM_IDLE               = -0x7fdf9686%0A%09SIOCIF_ATM_SARP               = -0x7fdf9681%0A%09SIOCIF_ATM_SNMPARP            = -0x7fdf9687%0A%09SIOCIF_ATM_SVC                = -0x7fdf9684%0A%09SIOCIF_ATM_UBR                = -0x7fdf9688%0A%09SIOCIF_DEVHEALTH              = -0x7ffb966c%0A%09SIOCIF_IB_ARP_INCOMP          = -0x7fdf9677%0A%09SIOCIF_IB_ARP_TIMER           = -0x7fdf9678%0A%09SIOCIF_IB_CLEAR_PINFO         = -0x3fdf966f%0A%09SIOCIF_IB_DEL_ARP             = -0x7fdf967f%0A%09SIOCIF_IB_DEL_PINFO           = -0x3fdf9670%0A%09SIOCIF_IB_DUMP_ARP            = -0x7fdf9680%0A%09SIOCIF_IB_GET_ARP             = -0x7fdf967e%0A%09SIOCIF_IB_GET_INFO            = -0x3f879675%0A%09SIOCIF_IB_GET_STATS           = -0x3f879672%0A%09SIOCIF_IB_NOTIFY_ADDR_REM     = -0x3f87966a%0A%09SIOCIF_IB_RESET_STATS         = -0x3f879671%0A%09SIOCIF_IB_RESIZE_CQ           = -0x7fdf9679%0A%09SIOCIF_IB_SET_ARP             = -0x7fdf967d%0A%09SIOCIF_IB_SET_PKEY            = -0x7fdf967c%0A%09SIOCIF_IB_SET_PORT            = -0x7fdf967b%0A%09SIOCIF_IB_SET_QKEY            = -0x7fdf9676%0A%09SIOCIF_IB_SET_QSIZE           = -0x7fdf967a%0A%09SIOCLISTIFVIPA                = 0x20006944%0A%09SIOCSARP                      = -0x7fb396e2%0A%09SIOCSHIWAT                    = 0x80047300%0A%09SIOCSIFADDR                   = -0x7fd796f4%0A%09SIOCSIFADDRORI                = -0x7fdb9673%0A%09SIOCSIFBRDADDR                = -0x7fd796ed%0A%09SIOCSIFDSTADDR                = -0x7fd796f2%0A%09SIOCSIFFLAGS                  = -0x7fd796f0%0A%09SIOCSIFGIDLIST                = 0x20006969%0A%09SIOCSIFMETRIC                 = -0x7fd796e8%0A%09SIOCSIFMTU                    = -0x7fd796a8%0A%09SIOCSIFNETDUMP                = -0x7fd796e4%0A%09SIOCSIFNETMASK                = -0x7fd796ea%0A%09SIOCSIFOPTIONS                = -0x7fd796d7%0A%09SIOCSIFSUBCHAN                = -0x7fd796e5%0A%09SIOCSISNO                     = -0x7fd79694%0A%09SIOCSLOADF                    = -0x3ffb967d%0A%09SIOCSLOWAT                    = 0x80047302%0A%09SIOCSNETOPT                   = -0x7ffe96a6%0A%09SIOCSPGRP                     = 0x80047308%0A%09SIOCSX25XLATE                 = -0x7fd7969d%0A%09SOCK_CONN_DGRAM               = 0x6%0A%09SOCK_DGRAM                    = 0x2%0A%09SOCK_RAW                      = 0x3%0A%09SOCK_RDM                      = 0x4%0A%09SOCK_SEQPACKET                = 0x5%0A%09SOCK_STREAM                   = 0x1%0A%09SOL_SOCKET                    = 0xffff%0A%09SOMAXCONN                     = 0x400%0A%09SO_ACCEPTCONN                 = 0x2%0A%09SO_AUDIT                      = 0x8000%0A%09SO_BROADCAST                  = 0x20%0A%09SO_CKSUMRECV                  = 0x800%0A%09SO_DEBUG                      = 0x1%0A%09SO_DONTROUTE                  = 0x10%0A%09SO_ERROR                      = 0x1007%0A%09SO_KEEPALIVE                  = 0x8%0A%09SO_KERNACCEPT                 = 0x2000%0A%09SO_LINGER                     = 0x80%0A%09SO_NOMULTIPATH                = 0x4000%0A%09SO_NOREUSEADDR                = 0x1000%0A%09SO_OOBINLINE                  = 0x100%0A%09SO_PEERID                     = 0x1009%0A%09SO_RCVBUF                     = 0x1002%0A%09SO_RCVLOWAT                   = 0x1004%0A%09SO_RCVTIMEO                   = 0x1006%0A%09SO_REUSEADDR                  = 0x4%0A%09SO_REUSEPORT                  = 0x200%0A%09SO_SNDBUF                     = 0x1001%0A%09SO_SNDLOWAT                   = 0x1003%0A%09SO_SNDTIMEO                   = 0x1005%0A%09SO_TIMESTAMPNS                = 0x100a%0A%09SO_TYPE                       = 0x1008%0A%09SO_USELOOPBACK                = 0x40%0A%09SO_USE_IFBUFS                 = 0x400%0A%09S_BANDURG                     = 0x400%0A%09S_EMODFMT                     = 0x3c000000%0A%09S_ENFMT                       = 0x400%0A%09S_ERROR                       = 0x100%0A%09S_HANGUP                      = 0x200%0A%09S_HIPRI                       = 0x2%0A%09S_ICRYPTO                     = 0x80000%0A%09S_IEXEC                       = 0x40%0A%09S_IFBLK                       = 0x6000%0A%09S_IFCHR                       = 0x2000%0A%09S_IFDIR                       = 0x4000%0A%09S_IFIFO                       = 0x1000%0A%09S_IFJOURNAL                   = 0x10000%0A%09S_IFLNK                       = 0xa000%0A%09S_IFMPX                       = 0x2200%0A%09S_IFMT                        = 0xf000%0A%09S_IFPDIR                      = 0x4000000%0A%09S_IFPSDIR                     = 0x8000000%0A%09S_IFPSSDIR                    = 0xc000000%0A%09S_IFREG                       = 0x8000%0A%09S_IFSOCK                      = 0xc000%0A%09S_IFSYSEA                     = 0x30000000%0A%09S_INPUT                       = 0x1%0A%09S_IREAD                       = 0x100%0A%09S_IRGRP                       = 0x20%0A%09S_IROTH                       = 0x4%0A%09S_IRUSR                       = 0x100%0A%09S_IRWXG                       = 0x38%0A%09S_IRWXO                       = 0x7%0A%09S_IRWXU                       = 0x1c0%0A%09S_ISGID                       = 0x400%0A%09S_ISUID                       = 0x800%0A%09S_ISVTX                       = 0x200%0A%09S_ITCB                        = 0x1000000%0A%09S_ITP                         = 0x800000%0A%09S_IWGRP                       = 0x10%0A%09S_IWOTH                       = 0x2%0A%09S_IWRITE                      = 0x80%0A%09S_IWUSR                       = 0x80%0A%09S_IXACL                       = 0x2000000%0A%09S_IXATTR                      = 0x40000%0A%09S_IXGRP                       = 0x8%0A%09S_IXINTERFACE                 = 0x100000%0A%09S_IXMOD                       = 0x40000000%0A%09S_IXOTH                       = 0x1%0A%09S_IXUSR                       = 0x40%0A%09S_MSG                         = 0x8%0A%09S_OUTPUT                      = 0x4%0A%09S_RDBAND                      = 0x20%0A%09S_RDNORM                      = 0x10%0A%09S_RESERVED1                   = 0x20000%0A%09S_RESERVED2                   = 0x200000%0A%09S_RESERVED3                   = 0x400000%0A%09S_RESERVED4                   = 0x80000000%0A%09S_RESFMT1                     = 0x10000000%0A%09S_RESFMT10                    = 0x34000000%0A%09S_RESFMT11                    = 0x38000000%0A%09S_RESFMT12                    = 0x3c000000%0A%09S_RESFMT2                     = 0x14000000%0A%09S_RESFMT3                     = 0x18000000%0A%09S_RESFMT4                     = 0x1c000000%0A%09S_RESFMT5                     = 0x20000000%0A%09S_RESFMT6                     = 0x24000000%0A%09S_RESFMT7                     = 0x28000000%0A%09S_RESFMT8                     = 0x2c000000%0A%09S_WRBAND                      = 0x80%0A%09S_WRNORM                      = 0x40%0A%09TAB0                          = 0x0%0A%09TAB1                          = 0x400%0A%09TAB2                          = 0x800%0A%09TAB3                          = 0xc00%0A%09TABDLY                        = 0xc00%0A%09TCFLSH                        = 0x540c%0A%09TCGETA                        = 0x5405%0A%09TCGETS                        = 0x5401%0A%09TCIFLUSH                      = 0x0%0A%09TCIOFF                        = 0x2%0A%09TCIOFLUSH                     = 0x2%0A%09TCION                         = 0x3%0A%09TCOFLUSH                      = 0x1%0A%09TCOOFF                        = 0x0%0A%09TCOON                         = 0x1%0A%09TCP_24DAYS_WORTH_OF_SLOWTICKS = 0x3f4800%0A%09TCP_ACLADD                    = 0x23%0A%09TCP_ACLBIND                   = 0x26%0A%09TCP_ACLCLEAR                  = 0x22%0A%09TCP_ACLDEL                    = 0x24%0A%09TCP_ACLDENY                   = 0x8%0A%09TCP_ACLFLUSH                  = 0x21%0A%09TCP_ACLGID                    = 0x1%0A%09TCP_ACLLS                     = 0x25%0A%09TCP_ACLSUBNET                 = 0x4%0A%09TCP_ACLUID                    = 0x2%0A%09TCP_CWND_DF                   = 0x16%0A%09TCP_CWND_IF                   = 0x15%0A%09TCP_DELAY_ACK_FIN             = 0x2%0A%09TCP_DELAY_ACK_SYN             = 0x1%0A%09TCP_FASTNAME                  = 0x101080a%0A%09TCP_KEEPCNT                   = 0x13%0A%09TCP_KEEPIDLE                  = 0x11%0A%09TCP_KEEPINTVL                 = 0x12%0A%09TCP_LSPRIV                    = 0x29%0A%09TCP_LUID                      = 0x20%0A%09TCP_MAXBURST                  = 0x8%0A%09TCP_MAXDF                     = 0x64%0A%09TCP_MAXIF                     = 0x64%0A%09TCP_MAXSEG                    = 0x2%0A%09TCP_MAXWIN                    = 0xffff%0A%09TCP_MAXWINDOWSCALE            = 0xe%0A%09TCP_MAX_SACK                  = 0x4%0A%09TCP_MSS                       = 0x5b4%0A%09TCP_NODELAY                   = 0x1%0A%09TCP_NODELAYACK                = 0x14%0A%09TCP_NOREDUCE_CWND_EXIT_FRXMT  = 0x19%0A%09TCP_NOREDUCE_CWND_IN_FRXMT    = 0x18%0A%09TCP_NOTENTER_SSTART           = 0x17%0A%09TCP_OPT                       = 0x19%0A%09TCP_RFC1323                   = 0x4%0A%09TCP_SETPRIV                   = 0x27%0A%09TCP_STDURG                    = 0x10%0A%09TCP_TIMESTAMP_OPTLEN          = 0xc%0A%09TCP_UNSETPRIV                 = 0x28%0A%09TCSAFLUSH                     = 0x2%0A%09TCSBRK                        = 0x5409%0A%09TCSETA                        = 0x5406%0A%09TCSETAF                       = 0x5408%0A%09TCSETAW                       = 0x5407%0A%09TCSETS                        = 0x5402%0A%09TCSETSF                       = 0x5404%0A%09TCSETSW                       = 0x5403%0A%09TCXONC                        = 0x540b%0A%09TIOC                          = 0x5400%0A%09TIOCCBRK                      = 0x2000747a%0A%09TIOCCDTR                      = 0x20007478%0A%09TIOCCONS                      = 0x80047462%0A%09TIOCEXCL                      = 0x2000740d%0A%09TIOCFLUSH                     = 0x80047410%0A%09TIOCGETC                      = 0x40067412%0A%09TIOCGETD                      = 0x40047400%0A%09TIOCGETP                      = 0x40067408%0A%09TIOCGLTC                      = 0x40067474%0A%09TIOCGPGRP                     = 0x40047477%0A%09TIOCGSID                      = 0x40047448%0A%09TIOCGSIZE                     = 0x40087468%0A%09TIOCGWINSZ                    = 0x40087468%0A%09TIOCHPCL                      = 0x20007402%0A%09TIOCLBIC                      = 0x8004747e%0A%09TIOCLBIS                      = 0x8004747f%0A%09TIOCLGET                      = 0x4004747c%0A%09TIOCLSET                      = 0x8004747d%0A%09TIOCMBIC                      = 0x8004746b%0A%09TIOCMBIS                      = 0x8004746c%0A%09TIOCMGET                      = 0x4004746a%0A%09TIOCMIWAIT                    = 0x80047464%0A%09TIOCMODG                      = 0x40047403%0A%09TIOCMODS                      = 0x80047404%0A%09TIOCMSET                      = 0x8004746d%0A%09TIOCM_CAR                     = 0x40%0A%09TIOCM_CD                      = 0x40%0A%09TIOCM_CTS                     = 0x20%0A%09TIOCM_DSR                     = 0x100%0A%09TIOCM_DTR                     = 0x2%0A%09TIOCM_LE                      = 0x1%0A%09TIOCM_RI                      = 0x80%0A%09TIOCM_RNG                     = 0x80%0A%09TIOCM_RTS                     = 0x4%0A%09TIOCM_SR                      = 0x10%0A%09TIOCM_ST                      = 0x8%0A%09TIOCNOTTY                     = 0x20007471%0A%09TIOCNXCL                      = 0x2000740e%0A%09TIOCOUTQ                      = 0x40047473%0A%09TIOCPKT                       = 0x80047470%0A%09TIOCPKT_DATA                  = 0x0%0A%09TIOCPKT_DOSTOP                = 0x20%0A%09TIOCPKT_FLUSHREAD             = 0x1%0A%09TIOCPKT_FLUSHWRITE            = 0x2%0A%09TIOCPKT_NOSTOP                = 0x10%0A%09TIOCPKT_START                 = 0x8%0A%09TIOCPKT_STOP                  = 0x4%0A%09TIOCREMOTE                    = 0x80047469%0A%09TIOCSBRK                      = 0x2000747b%0A%09TIOCSDTR                      = 0x20007479%0A%09TIOCSETC                      = 0x80067411%0A%09TIOCSETD                      = 0x80047401%0A%09TIOCSETN                      = 0x8006740a%0A%09TIOCSETP                      = 0x80067409%0A%09TIOCSLTC                      = 0x80067475%0A%09TIOCSPGRP                     = 0x80047476%0A%09TIOCSSIZE                     = 0x80087467%0A%09TIOCSTART                     = 0x2000746e%0A%09TIOCSTI                       = 0x80017472%0A%09TIOCSTOP                      = 0x2000746f%0A%09TIOCSWINSZ                    = 0x80087467%0A%09TIOCUCNTL                     = 0x80047466%0A%09TOSTOP                        = 0x10000%0A%09UTIME_NOW                     = -0x2%0A%09UTIME_OMIT                    = -0x3%0A%09VDISCRD                       = 0xc%0A%09VDSUSP                        = 0xa%0A%09VEOF                          = 0x4%0A%09VEOL                          = 0x5%0A%09VEOL2                         = 0x6%0A%09VERASE                        = 0x2%0A%09VINTR                         = 0x0%0A%09VKILL                         = 0x3%0A%09VLNEXT                        = 0xe%0A%09VMIN                          = 0x4%0A%09VQUIT                         = 0x1%0A%09VREPRINT                      = 0xb%0A%09VSTART                        = 0x7%0A%09VSTOP                         = 0x8%0A%09VSTRT                         = 0x7%0A%09VSUSP                         = 0x9%0A%09VT0                           = 0x0%0A%09VT1                           = 0x8000%0A%09VTDELAY                       = 0x2000%0A%09VTDLY                         = 0x8000%0A%09VTIME                         = 0x5%0A%09VWERSE                        = 0xd%0A%09WPARSTART                     = 0x1%0A%09WPARSTOP                      = 0x2%0A%09WPARTTYNAME                   = %22Global%22%0A%09XCASE                         = 0x4%0A%09XTABS                         = 0xc00%0A%09_FDATAFLUSH                   = 0x2000000000%0A)%0A%0A// Errors%0Aconst (%0A%09E2BIG           = syscall.Errno(0x7)%0A%09EACCES          = syscall.Errno(0xd)%0A%09EADDRINUSE      = syscall.Errno(0x43)%0A%09EADDRNOTAVAIL   = syscall.Errno(0x44)%0A%09EAFNOSUPPORT    = syscall.Errno(0x42)%0A%09EAGAIN          = syscall.Errno(0xb)%0A%09EALREADY        = syscall.Errno(0x38)%0A%09EBADF           = syscall.Errno(0x9)%0A%09EBADMSG         = syscall.Errno(0x78)%0A%09EBUSY           = syscall.Errno(0x10)%0A%09ECANCELED       = syscall.Errno(0x75)%0A%09ECHILD          = syscall.Errno(0xa)%0A%09ECHRNG          = syscall.Errno(0x25)%0A%09ECLONEME        = syscall.Errno(0x52)%0A%09ECONNABORTED    = syscall.Errno(0x48)%0A%09ECONNREFUSED    = syscall.Errno(0x4f)%0A%09ECONNRESET      = syscall.Errno(0x49)%0A%09ECORRUPT        = syscall.Errno(0x59)%0A%09EDEADLK         = syscall.Errno(0x2d)%0A%09EDESTADDREQ     = syscall.Errno(0x3a)%0A%09EDESTADDRREQ    = syscall.Errno(0x3a)%0A%09EDIST           = syscall.Errno(0x35)%0A%09EDOM            = syscall.Errno(0x21)%0A%09EDQUOT          = syscall.Errno(0x58)%0A%09EEXIST          = syscall.Errno(0x11)%0A%09EFAULT          = syscall.Errno(0xe)%0A%09EFBIG           = syscall.Errno(0x1b)%0A%09EFORMAT         = syscall.Errno(0x30)%0A%09EHOSTDOWN       = syscall.Errno(0x50)%0A%09EHOSTUNREACH    = syscall.Errno(0x51)%0A%09EIDRM           = syscall.Errno(0x24)%0A%09EILSEQ          = syscall.Errno(0x74)%0A%09EINPROGRESS     = syscall.Errno(0x37)%0A%09EINTR           = syscall.Errno(0x4)%0A%09EINVAL          = syscall.Errno(0x16)%0A%09EIO             = syscall.Errno(0x5)%0A%09EISCONN         = syscall.Errno(0x4b)%0A%09EISDIR          = syscall.Errno(0x15)%0A%09EL2HLT          = syscall.Errno(0x2c)%0A%09EL2NSYNC        = syscall.Errno(0x26)%0A%09EL3HLT          = syscall.Errno(0x27)%0A%09EL3RST          = syscall.Errno(0x28)%0A%09ELNRNG          = syscall.Errno(0x29)%0A%09ELOOP           = syscall.Errno(0x55)%0A%09EMEDIA          = syscall.Errno(0x6e)%0A%09EMFILE          = syscall.Errno(0x18)%0A%09EMLINK          = syscall.Errno(0x1f)%0A%09EMSGSIZE        = syscall.Errno(0x3b)%0A%09EMULTIHOP       = syscall.Errno(0x7d)%0A%09ENAMETOOLONG    = syscall.Errno(0x56)%0A%09ENETDOWN        = syscall.Errno(0x45)%0A%09ENETRESET       = syscall.Errno(0x47)%0A%09ENETUNREACH     = syscall.Errno(0x46)%0A%09ENFILE          = syscall.Errno(0x17)%0A%09ENOATTR         = syscall.Errno(0x70)%0A%09ENOBUFS         = syscall.Errno(0x4a)%0A%09ENOCONNECT      = syscall.Errno(0x32)%0A%09ENOCSI          = syscall.Errno(0x2b)%0A%09ENODATA         = syscall.Errno(0x7a)%0A%09ENODEV          = syscall.Errno(0x13)%0A%09ENOENT          = syscall.Errno(0x2)%0A%09ENOEXEC         = syscall.Errno(0x8)%0A%09ENOLCK          = syscall.Errno(0x31)%0A%09ENOLINK         = syscall.Errno(0x7e)%0A%09ENOMEM          = syscall.Errno(0xc)%0A%09ENOMSG          = syscall.Errno(0x23)%0A%09ENOPROTOOPT     = syscall.Errno(0x3d)%0A%09ENOSPC          = syscall.Errno(0x1c)%0A%09ENOSR           = syscall.Errno(0x76)%0A%09ENOSTR          = syscall.Errno(0x7b)%0A%09ENOSYS          = syscall.Errno(0x6d)%0A%09ENOTBLK         = syscall.Errno(0xf)%0A%09ENOTCONN        = syscall.Errno(0x4c)%0A%09ENOTDIR         = syscall.Errno(0x14)%0A%09ENOTEMPTY       = syscall.Errno(0x11)%0A%09ENOTREADY       = syscall.Errno(0x2e)%0A%09ENOTRECOVERABLE = syscall.Errno(0x5e)%0A%09ENOTRUST        = syscall.Errno(0x72)%0A%09ENOTSOCK        = syscall.Errno(0x39)%0A%09ENOTSUP         = syscall.Errno(0x7c)%0A%09ENOTTY          = syscall.Errno(0x19)%0A%09ENXIO           = syscall.Errno(0x6)%0A%09EOPNOTSUPP      = syscall.Errno(0x40)%0A%09EOVERFLOW       = syscall.Errno(0x7f)%0A%09EOWNERDEAD      = syscall.Errno(0x5f)%0A%09EPERM           = syscall.Errno(0x1)%0A%09EPFNOSUPPORT    = syscall.Errno(0x41)%0A%09EPIPE           = syscall.Errno(0x20)%0A%09EPROCLIM        = syscall.Errno(0x53)%0A%09EPROTO          = syscall.Errno(0x79)%0A%09EPROTONOSUPPORT = syscall.Errno(0x3e)%0A%09EPROTOTYPE      = syscall.Errno(0x3c)%0A%09ERANGE          = syscall.Errno(0x22)%0A%09EREMOTE         = syscall.Errno(0x5d)%0A%09ERESTART        = syscall.Errno(0x52)%0A%09EROFS           = syscall.Errno(0x1e)%0A%09ESAD            = syscall.Errno(0x71)%0A%09ESHUTDOWN       = syscall.Errno(0x4d)%0A%09ESOCKTNOSUPPORT = syscall.Errno(0x3f)%0A%09ESOFT           = syscall.Errno(0x6f)%0A%09ESPIPE          = syscall.Errno(0x1d)%0A%09ESRCH           = syscall.Errno(0x3)%0A%09ESTALE          = syscall.Errno(0x34)%0A%09ESYSERROR       = syscall.Errno(0x5a)%0A%09ETIME           = syscall.Errno(0x77)%0A%09ETIMEDOUT       = syscall.Errno(0x4e)%0A%09ETOOMANYREFS    = syscall.Errno(0x73)%0A%09ETXTBSY         = syscall.Errno(0x1a)%0A%09EUNATCH         = syscall.Errno(0x2a)%0A%09EUSERS          = syscall.Errno(0x54)%0A%09EWOULDBLOCK     = syscall.Errno(0xb)%0A%09EWRPROTECT      = syscall.Errno(0x2f)%0A%09EXDEV           = syscall.Errno(0x12)%0A)%0A%0A// Signals%0Aconst (%0A%09SIGABRT     = syscall.Signal(0x6)%0A%09SIGAIO      = syscall.Signal(0x17)%0A%09SIGALRM     = syscall.Signal(0xe)%0A%09SIGALRM1    = syscall.Signal(0x26)%0A%09SIGBUS      = syscall.Signal(0xa)%0A%09SIGCAPI     = syscall.Signal(0x31)%0A%09SIGCHLD     = syscall.Signal(0x14)%0A%09SIGCLD      = syscall.Signal(0x14)%0A%09SIGCONT     = syscall.Signal(0x13)%0A%09SIGCPUFAIL  = syscall.Signal(0x3b)%0A%09SIGDANGER   = syscall.Signal(0x21)%0A%09SIGEMT      = syscall.Signal(0x7)%0A%09SIGFPE      = syscall.Signal(0x8)%0A%09SIGGRANT    = syscall.Signal(0x3c)%0A%09SIGHUP      = syscall.Signal(0x1)%0A%09SIGILL      = syscall.Signal(0x4)%0A%09SIGINT      = syscall.Signal(0x2)%0A%09SIGIO       = syscall.Signal(0x17)%0A%09SIGIOINT    = syscall.Signal(0x10)%0A%09SIGIOT      = syscall.Signal(0x6)%0A%09SIGKAP      = syscall.Signal(0x3c)%0A%09SIGKILL     = syscall.Signal(0x9)%0A%09SIGLOST     = syscall.Signal(0x6)%0A%09SIGMAX      = syscall.Signal(0x3f)%0A%09SIGMAX32    = syscall.Signal(0x3f)%0A%09SIGMIGRATE  = syscall.Signal(0x23)%0A%09SIGMSG      = syscall.Signal(0x1b)%0A%09SIGPIPE     = syscall.Signal(0xd)%0A%09SIGPOLL     = syscall.Signal(0x17)%0A%09SIGPRE      = syscall.Signal(0x24)%0A%09SIGPROF     = syscall.Signal(0x20)%0A%09SIGPTY      = syscall.Signal(0x17)%0A%09SIGPWR      = syscall.Signal(0x1d)%0A%09SIGQUIT     = syscall.Signal(0x3)%0A%09SIGRECONFIG = syscall.Signal(0x3a)%0A%09SIGRETRACT  = syscall.Signal(0x3d)%0A%09SIGSAK      = syscall.Signal(0x3f)%0A%09SIGSEGV     = syscall.Signal(0xb)%0A%09SIGSOUND    = syscall.Signal(0x3e)%0A%09SIGSTOP     = syscall.Signal(0x11)%0A%09SIGSYS      = syscall.Signal(0xc)%0A%09SIGSYSERROR = syscall.Signal(0x30)%0A%09SIGTALRM    = syscall.Signal(0x26)%0A%09SIGTERM     = syscall.Signal(0xf)%0A%09SIGTRAP     = syscall.Signal(0x5)%0A%09SIGTSTP     = syscall.Signal(0x12)%0A%09SIGTTIN     = syscall.Signal(0x15)%0A%09SIGTTOU     = syscall.Signal(0x16)%0A%09SIGURG      = syscall.Signal(0x10)%0A%09SIGUSR1     = syscall.Signal(0x1e)%0A%09SIGUSR2     = syscall.Signal(0x1f)%0A%09SIGVIRT     = syscall.Signal(0x25)%0A%09SIGVTALRM   = syscall.Signal(0x22)%0A%09SIGWAITING  = syscall.Signal(0x27)%0A%09SIGWINCH    = syscall.Signal(0x1c)%0A%09SIGXCPU     = syscall.Signal(0x18)%0A%09SIGXFSZ     = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22not owner%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22I/O error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22arg list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file number%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EWOULDBLOCK%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22not enough space%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22ENOTEMPTY%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22file table overflow%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22not a typewriter%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22deadlock condition if locked%22%7D,%0A%09%7B46, %22ENOTREADY%22, %22device not ready%22%7D,%0A%09%7B47, %22EWRPROTECT%22, %22write-protected media%22%7D,%0A%09%7B48, %22EFORMAT%22, %22unformatted or incompatible media%22%7D,%0A%09%7B49, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22ENOCONNECT%22, %22cannot Establish Connection%22%7D,%0A%09%7B52, %22ESTALE%22, %22missing file or filesystem%22%7D,%0A%09%7B53, %22EDIST%22, %22requests blocked by Administrator%22%7D,%0A%09%7B55, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B56, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B57, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B58, %22EDESTADDREQ%22, %22destination address required%22%7D,%0A%09%7B59, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B60, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B61, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B62, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B63, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B64, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B65, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B66, %22EAFNOSUPPORT%22, %22addr family not supported by protocol%22%7D,%0A%09%7B67, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B68, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B69, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B70, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B71, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B72, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B73, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B74, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B75, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B76, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B77, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B78, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B79, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B80, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B81, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B82, %22ERESTART%22, %22restart the system call%22%7D,%0A%09%7B83, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B84, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B85, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B86, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B88, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B89, %22ECORRUPT%22, %22invalid file system control data detected%22%7D,%0A%09%7B90, %22ESYSERROR%22, %22for future use %22%7D,%0A%09%7B93, %22EREMOTE%22, %22item is not local to host%22%7D,%0A%09%7B94, %22ENOTRECOVERABLE%22, %22state not recoverable %22%7D,%0A%09%7B95, %22EOWNERDEAD%22, %22previous owner died %22%7D,%0A%09%7B109, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B110, %22EMEDIA%22, %22media surface error%22%7D,%0A%09%7B111, %22ESOFT%22, %22I/O completed, but needs relocation%22%7D,%0A%09%7B112, %22ENOATTR%22, %22no attribute found%22%7D,%0A%09%7B113, %22ESAD%22, %22security Authentication Denied%22%7D,%0A%09%7B114, %22ENOTRUST%22, %22not a Trusted Program%22%7D,%0A%09%7B115, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B116, %22EILSEQ%22, %22invalid wide character%22%7D,%0A%09%7B117, %22ECANCELED%22, %22asynchronous I/O cancelled%22%7D,%0A%09%7B118, %22ENOSR%22, %22out of STREAMS resources%22%7D,%0A%09%7B119, %22ETIME%22, %22system call timed out%22%7D,%0A%09%7B120, %22EBADMSG%22, %22next message has wrong type%22%7D,%0A%09%7B121, %22EPROTO%22, %22error in protocol%22%7D,%0A%09%7B122, %22ENODATA%22, %22no message on stream head read q%22%7D,%0A%09%7B123, %22ENOSTR%22, %22fd not associated with a stream%22%7D,%0A%09%7B124, %22ENOTSUP%22, %22unsupported attribute value%22%7D,%0A%09%7B125, %22EMULTIHOP%22, %22multihop is not allowed%22%7D,%0A%09%7B126, %22ENOLINK%22, %22the server link has been severed%22%7D,%0A%09%7B127, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22IOT/Abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible/complete%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B27, %22SIGMSG%22, %22input device data%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGPWR%22, %22power-failure%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B33, %22SIGDANGER%22, %22paging space low%22%7D,%0A%09%7B34, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B35, %22SIGMIGRATE%22, %22signal 35%22%7D,%0A%09%7B36, %22SIGPRE%22, %22signal 36%22%7D,%0A%09%7B37, %22SIGVIRT%22, %22signal 37%22%7D,%0A%09%7B38, %22SIGTALRM%22, %22signal 38%22%7D,%0A%09%7B39, %22SIGWAITING%22, %22signal 39%22%7D,%0A%09%7B48, %22SIGSYSERROR%22, %22signal 48%22%7D,%0A%09%7B49, %22SIGCAPI%22, %22signal 49%22%7D,%0A%09%7B58, %22SIGRECONFIG%22, %22signal 58%22%7D,%0A%09%7B59, %22SIGCPUFAIL%22, %22CPU Failure Predicted%22%7D,%0A%09%7B60, %22SIGKAP%22, %22monitor mode granted%22%7D,%0A%09%7B61, %22SIGRETRACT%22, %22monitor mode retracted%22%7D,%0A%09%7B62, %22SIGSOUND%22, %22sound completed%22%7D,%0A%09%7B63, %22SIGSAK%22, %22secure attention%22%7D,%0A%7D%0A
+ f 5bb4184ea5279afbaaf0080f4b097f7f4f80262a4cfb127fb66ed222675379ff vendor/golang.org/x/sys/unix/zerrors_aix_ppc64.go
dmppatch 2
@@ -0,0 +1,53462 @@
+// mkerrors.sh -maix64%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build ppc64,aix%0A%0A// Created by cgo -godefs - DO NOT EDIT%0A// cgo -godefs -- -maix64 _const.go%0A%0Apackage unix%0A%0Aimport %22syscall%22%0A%0Aconst (%0A%09AF_APPLETALK                  = 0x10%0A%09AF_BYPASS                     = 0x19%0A%09AF_CCITT                      = 0xa%0A%09AF_CHAOS                      = 0x5%0A%09AF_DATAKIT                    = 0x9%0A%09AF_DECnet                     = 0xc%0A%09AF_DLI                        = 0xd%0A%09AF_ECMA                       = 0x8%0A%09AF_HYLINK                     = 0xf%0A%09AF_IMPLINK                    = 0x3%0A%09AF_INET                       = 0x2%0A%09AF_INET6                      = 0x18%0A%09AF_INTF                       = 0x14%0A%09AF_ISO                        = 0x7%0A%09AF_LAT                        = 0xe%0A%09AF_LINK                       = 0x12%0A%09AF_LOCAL                      = 0x1%0A%09AF_MAX                        = 0x1e%0A%09AF_NDD                        = 0x17%0A%09AF_NETWARE                    = 0x16%0A%09AF_NS                         = 0x6%0A%09AF_OSI                        = 0x7%0A%09AF_PUP                        = 0x4%0A%09AF_RIF                        = 0x15%0A%09AF_ROUTE                      = 0x11%0A%09AF_SNA                        = 0xb%0A%09AF_UNIX                       = 0x1%0A%09AF_UNSPEC                     = 0x0%0A%09ALTWERASE                     = 0x400000%0A%09ARPHRD_802_3                  = 0x6%0A%09ARPHRD_802_5                  = 0x6%0A%09ARPHRD_ETHER                  = 0x1%0A%09ARPHRD_FDDI                   = 0x1%0A%09B0                            = 0x0%0A%09B110                          = 0x3%0A%09B1200                         = 0x9%0A%09B134                          = 0x4%0A%09B150                          = 0x5%0A%09B1800                         = 0xa%0A%09B19200                        = 0xe%0A%09B200                          = 0x6%0A%09B2400                         = 0xb%0A%09B300                          = 0x7%0A%09B38400                        = 0xf%0A%09B4800                         = 0xc%0A%09B50                           = 0x1%0A%09B600                          = 0x8%0A%09B75                           = 0x2%0A%09B9600                         = 0xd%0A%09BRKINT                        = 0x2%0A%09BS0                           = 0x0%0A%09BS1                           = 0x1000%0A%09BSDLY                         = 0x1000%0A%09CAP_AACCT                     = 0x6%0A%09CAP_ARM_APPLICATION           = 0x5%0A%09CAP_BYPASS_RAC_VMM            = 0x3%0A%09CAP_CLEAR                     = 0x0%0A%09CAP_CREDENTIALS               = 0x7%0A%09CAP_EFFECTIVE                 = 0x1%0A%09CAP_EWLM_AGENT                = 0x4%0A%09CAP_INHERITABLE               = 0x2%0A%09CAP_MAXIMUM                   = 0x7%0A%09CAP_NUMA_ATTACH               = 0x2%0A%09CAP_PERMITTED                 = 0x3%0A%09CAP_PROPAGATE                 = 0x1%0A%09CAP_PROPOGATE                 = 0x1%0A%09CAP_SET                       = 0x1%0A%09CBAUD                         = 0xf%0A%09CFLUSH                        = 0xf%0A%09CIBAUD                        = 0xf0000%0A%09CLOCAL                        = 0x800%0A%09CLOCK_MONOTONIC               = 0xa%0A%09CLOCK_PROCESS_CPUTIME_ID      = 0xb%0A%09CLOCK_REALTIME                = 0x9%0A%09CLOCK_THREAD_CPUTIME_ID       = 0xc%0A%09CR0                           = 0x0%0A%09CR1                           = 0x100%0A%09CR2                           = 0x200%0A%09CR3                           = 0x300%0A%09CRDLY                         = 0x300%0A%09CREAD                         = 0x80%0A%09CS5                           = 0x0%0A%09CS6                           = 0x10%0A%09CS7                           = 0x20%0A%09CS8                           = 0x30%0A%09CSIOCGIFCONF                  = -0x3fef96dc%0A%09CSIZE                         = 0x30%0A%09CSMAP_DIR                     = %22/usr/lib/nls/csmap/%22%0A%09CSTART                        = '%5C021'%0A%09CSTOP                         = '%5C023'%0A%09CSTOPB                        = 0x40%0A%09CSUSP                         = 0x1a%0A%09ECHO                          = 0x8%0A%09ECHOCTL                       = 0x20000%0A%09ECHOE                         = 0x10%0A%09ECHOK                         = 0x20%0A%09ECHOKE                        = 0x80000%0A%09ECHONL                        = 0x40%0A%09ECHOPRT                       = 0x40000%0A%09ECH_ICMPID                    = 0x2%0A%09ETHERNET_CSMACD               = 0x6%0A%09EVENP                         = 0x80%0A%09EXCONTINUE                    = 0x0%0A%09EXDLOK                        = 0x3%0A%09EXIO                          = 0x2%0A%09EXPGIO                        = 0x0%0A%09EXRESUME                      = 0x2%0A%09EXRETURN                      = 0x1%0A%09EXSIG                         = 0x4%0A%09EXTA                          = 0xe%0A%09EXTB                          = 0xf%0A%09EXTRAP                        = 0x1%0A%09EYEC_RTENTRYA                 = 0x257274656e747241%0A%09EYEC_RTENTRYF                 = 0x257274656e747246%0A%09E_ACC                         = 0x0%0A%09FD_CLOEXEC                    = 0x1%0A%09FD_SETSIZE                    = 0xfffe%0A%09FF0                           = 0x0%0A%09FF1                           = 0x2000%0A%09FFDLY                         = 0x2000%0A%09FLUSHBAND                     = 0x40%0A%09FLUSHLOW                      = 0x8%0A%09FLUSHO                        = 0x100000%0A%09FLUSHR                        = 0x1%0A%09FLUSHRW                       = 0x3%0A%09FLUSHW                        = 0x2%0A%09F_CLOSEM                      = 0xa%0A%09F_DUP2FD                      = 0xe%0A%09F_DUPFD                       = 0x0%0A%09F_GETFD                       = 0x1%0A%09F_GETFL                       = 0x3%0A%09F_GETLK                       = 0xb%0A%09F_GETLK64                     = 0xb%0A%09F_GETOWN                      = 0x8%0A%09F_LOCK                        = 0x1%0A%09F_OK                          = 0x0%0A%09F_RDLCK                       = 0x1%0A%09F_SETFD                       = 0x2%0A%09F_SETFL                       = 0x4%0A%09F_SETLK                       = 0xc%0A%09F_SETLK64                     = 0xc%0A%09F_SETLKW                      = 0xd%0A%09F_SETLKW64                    = 0xd%0A%09F_SETOWN                      = 0x9%0A%09F_TEST                        = 0x3%0A%09F_TLOCK                       = 0x2%0A%09F_TSTLK                       = 0xf%0A%09F_ULOCK                       = 0x0%0A%09F_UNLCK                       = 0x3%0A%09F_WRLCK                       = 0x2%0A%09HUPCL                         = 0x400%0A%09IBSHIFT                       = 0x10%0A%09ICANON                        = 0x2%0A%09ICMP6_FILTER                  = 0x26%0A%09ICMP6_SEC_SEND_DEL            = 0x46%0A%09ICMP6_SEC_SEND_GET            = 0x47%0A%09ICMP6_SEC_SEND_SET            = 0x44%0A%09ICMP6_SEC_SEND_SET_CGA_ADDR   = 0x45%0A%09ICRNL                         = 0x100%0A%09IEXTEN                        = 0x200000%0A%09IFA_FIRSTALIAS                = 0x2000%0A%09IFA_ROUTE                     = 0x1%0A%09IFF_64BIT                     = 0x4000000%0A%09IFF_ALLCAST                   = 0x20000%0A%09IFF_ALLMULTI                  = 0x200%0A%09IFF_BPF                       = 0x8000000%0A%09IFF_BRIDGE                    = 0x40000%0A%09IFF_BROADCAST                 = 0x2%0A%09IFF_CANTCHANGE                = 0x80c52%0A%09IFF_CHECKSUM_OFFLOAD          = 0x10000000%0A%09IFF_D1                        = 0x8000%0A%09IFF_D2                        = 0x4000%0A%09IFF_D3                        = 0x2000%0A%09IFF_D4                        = 0x1000%0A%09IFF_DEBUG                     = 0x4%0A%09IFF_DEVHEALTH                 = 0x4000%0A%09IFF_DO_HW_LOOPBACK            = 0x10000%0A%09IFF_GROUP_ROUTING             = 0x2000000%0A%09IFF_IFBUFMGT                  = 0x800000%0A%09IFF_LINK0                     = 0x100000%0A%09IFF_LINK1                     = 0x200000%0A%09IFF_LINK2                     = 0x400000%0A%09IFF_LOOPBACK                  = 0x8%0A%09IFF_MULTICAST                 = 0x80000%0A%09IFF_NOARP                     = 0x80%0A%09IFF_NOECHO                    = 0x800%0A%09IFF_NOTRAILERS                = 0x20%0A%09IFF_OACTIVE                   = 0x400%0A%09IFF_POINTOPOINT               = 0x10%0A%09IFF_PROMISC                   = 0x100%0A%09IFF_PSEG                      = 0x40000000%0A%09IFF_RUNNING                   = 0x40%0A%09IFF_SIMPLEX                   = 0x800%0A%09IFF_SNAP                      = 0x8000%0A%09IFF_TCP_DISABLE_CKSUM         = 0x20000000%0A%09IFF_TCP_NOCKSUM               = 0x1000000%0A%09IFF_UP                        = 0x1%0A%09IFF_VIPA                      = 0x80000000%0A%09IFNAMSIZ                      = 0x10%0A%09IFO_FLUSH                     = 0x1%0A%09IFT_1822                      = 0x2%0A%09IFT_AAL5                      = 0x31%0A%09IFT_ARCNET                    = 0x23%0A%09IFT_ARCNETPLUS                = 0x24%0A%09IFT_ATM                       = 0x25%0A%09IFT_CEPT                      = 0x13%0A%09IFT_CLUSTER                   = 0x3e%0A%09IFT_DS3                       = 0x1e%0A%09IFT_EON                       = 0x19%0A%09IFT_ETHER                     = 0x6%0A%09IFT_FCS                       = 0x3a%0A%09IFT_FDDI                      = 0xf%0A%09IFT_FRELAY                    = 0x20%0A%09IFT_FRELAYDCE                 = 0x2c%0A%09IFT_GIFTUNNEL                 = 0x3c%0A%09IFT_HDH1822                   = 0x3%0A%09IFT_HF                        = 0x3d%0A%09IFT_HIPPI                     = 0x2f%0A%09IFT_HSSI                      = 0x2e%0A%09IFT_HY                        = 0xe%0A%09IFT_IB                        = 0xc7%0A%09IFT_ISDNBASIC                 = 0x14%0A%09IFT_ISDNPRIMARY               = 0x15%0A%09IFT_ISO88022LLC               = 0x29%0A%09IFT_ISO88023                  = 0x7%0A%09IFT_ISO88024                  = 0x8%0A%09IFT_ISO88025                  = 0x9%0A%09IFT_ISO88026                  = 0xa%0A%09IFT_LAPB                      = 0x10%0A%09IFT_LOCALTALK                 = 0x2a%0A%09IFT_LOOP                      = 0x18%0A%09IFT_MIOX25                    = 0x26%0A%09IFT_MODEM                     = 0x30%0A%09IFT_NSIP                      = 0x1b%0A%09IFT_OTHER                     = 0x1%0A%09IFT_P10                       = 0xc%0A%09IFT_P80                       = 0xd%0A%09IFT_PARA                      = 0x22%0A%09IFT_PPP                       = 0x17%0A%09IFT_PROPMUX                   = 0x36%0A%09IFT_PROPVIRTUAL               = 0x35%0A%09IFT_PTPSERIAL                 = 0x16%0A%09IFT_RS232                     = 0x21%0A%09IFT_SDLC                      = 0x11%0A%09IFT_SIP                       = 0x1f%0A%09IFT_SLIP                      = 0x1c%0A%09IFT_SMDSDXI                   = 0x2b%0A%09IFT_SMDSICIP                  = 0x34%0A%09IFT_SN                        = 0x38%0A%09IFT_SONET                     = 0x27%0A%09IFT_SONETPATH                 = 0x32%0A%09IFT_SONETVT                   = 0x33%0A%09IFT_SP                        = 0x39%0A%09IFT_STARLAN                   = 0xb%0A%09IFT_T1                        = 0x12%0A%09IFT_TUNNEL                    = 0x3b%0A%09IFT_ULTRA                     = 0x1d%0A%09IFT_V35                       = 0x2d%0A%09IFT_VIPA                      = 0x37%0A%09IFT_X25                       = 0x5%0A%09IFT_X25DDN                    = 0x4%0A%09IFT_X25PLE                    = 0x28%0A%09IFT_XETHER                    = 0x1a%0A%09IGNBRK                        = 0x1%0A%09IGNCR                         = 0x80%0A%09IGNPAR                        = 0x4%0A%09IMAXBEL                       = 0x10000%0A%09INLCR                         = 0x40%0A%09INPCK                         = 0x10%0A%09IN_CLASSA_HOST                = 0xffffff%0A%09IN_CLASSA_MAX                 = 0x80%0A%09IN_CLASSA_NET                 = 0xff000000%0A%09IN_CLASSA_NSHIFT              = 0x18%0A%09IN_CLASSB_HOST                = 0xffff%0A%09IN_CLASSB_MAX                 = 0x10000%0A%09IN_CLASSB_NET                 = 0xffff0000%0A%09IN_CLASSB_NSHIFT              = 0x10%0A%09IN_CLASSC_HOST                = 0xff%0A%09IN_CLASSC_NET                 = 0xffffff00%0A%09IN_CLASSC_NSHIFT              = 0x8%0A%09IN_CLASSD_HOST                = 0xfffffff%0A%09IN_CLASSD_NET                 = 0xf0000000%0A%09IN_CLASSD_NSHIFT              = 0x1c%0A%09IN_LOOPBACKNET                = 0x7f%0A%09IN_USE                        = 0x1%0A%09IPPROTO_AH                    = 0x33%0A%09IPPROTO_BIP                   = 0x53%0A%09IPPROTO_DSTOPTS               = 0x3c%0A%09IPPROTO_EGP                   = 0x8%0A%09IPPROTO_EON                   = 0x50%0A%09IPPROTO_ESP                   = 0x32%0A%09IPPROTO_FRAGMENT              = 0x2c%0A%09IPPROTO_GGP                   = 0x3%0A%09IPPROTO_GIF                   = 0x8c%0A%09IPPROTO_GRE                   = 0x2f%0A%09IPPROTO_HOPOPTS               = 0x0%0A%09IPPROTO_ICMP                  = 0x1%0A%09IPPROTO_ICMPV6                = 0x3a%0A%09IPPROTO_IDP                   = 0x16%0A%09IPPROTO_IGMP                  = 0x2%0A%09IPPROTO_IP                    = 0x0%0A%09IPPROTO_IPIP                  = 0x4%0A%09IPPROTO_IPV6                  = 0x29%0A%09IPPROTO_LOCAL                 = 0x3f%0A%09IPPROTO_MAX                   = 0x100%0A%09IPPROTO_MH                    = 0x87%0A%09IPPROTO_NONE                  = 0x3b%0A%09IPPROTO_PUP                   = 0xc%0A%09IPPROTO_QOS                   = 0x2d%0A%09IPPROTO_RAW                   = 0xff%0A%09IPPROTO_ROUTING               = 0x2b%0A%09IPPROTO_RSVP                  = 0x2e%0A%09IPPROTO_SCTP                  = 0x84%0A%09IPPROTO_TCP                   = 0x6%0A%09IPPROTO_TP                    = 0x1d%0A%09IPPROTO_UDP                   = 0x11%0A%09IPV6_ADDRFORM                 = 0x16%0A%09IPV6_ADDR_PREFERENCES         = 0x4a%0A%09IPV6_ADD_MEMBERSHIP           = 0xc%0A%09IPV6_AIXRAWSOCKET             = 0x39%0A%09IPV6_CHECKSUM                 = 0x27%0A%09IPV6_DONTFRAG                 = 0x2d%0A%09IPV6_DROP_MEMBERSHIP          = 0xd%0A%09IPV6_DSTOPTS                  = 0x36%0A%09IPV6_FLOWINFO_FLOWLABEL       = 0xffffff%0A%09IPV6_FLOWINFO_PRIFLOW         = 0xfffffff%0A%09IPV6_FLOWINFO_PRIORITY        = 0xf000000%0A%09IPV6_FLOWINFO_SRFLAG          = 0x10000000%0A%09IPV6_FLOWINFO_VERSION         = 0xf0000000%0A%09IPV6_HOPLIMIT                 = 0x28%0A%09IPV6_HOPOPTS                  = 0x34%0A%09IPV6_JOIN_GROUP               = 0xc%0A%09IPV6_LEAVE_GROUP              = 0xd%0A%09IPV6_MIPDSTOPTS               = 0x36%0A%09IPV6_MULTICAST_HOPS           = 0xa%0A%09IPV6_MULTICAST_IF             = 0x9%0A%09IPV6_MULTICAST_LOOP           = 0xb%0A%09IPV6_NEXTHOP                  = 0x30%0A%09IPV6_NOPROBE                  = 0x1c%0A%09IPV6_PATHMTU                  = 0x2e%0A%09IPV6_PKTINFO                  = 0x21%0A%09IPV6_PKTOPTIONS               = 0x24%0A%09IPV6_PRIORITY_10              = 0xa000000%0A%09IPV6_PRIORITY_11              = 0xb000000%0A%09IPV6_PRIORITY_12              = 0xc000000%0A%09IPV6_PRIORITY_13              = 0xd000000%0A%09IPV6_PRIORITY_14              = 0xe000000%0A%09IPV6_PRIORITY_15              = 0xf000000%0A%09IPV6_PRIORITY_8               = 0x8000000%0A%09IPV6_PRIORITY_9               = 0x9000000%0A%09IPV6_PRIORITY_BULK            = 0x4000000%0A%09IPV6_PRIORITY_CONTROL         = 0x7000000%0A%09IPV6_PRIORITY_FILLER          = 0x1000000%0A%09IPV6_PRIORITY_INTERACTIVE     = 0x6000000%0A%09IPV6_PRIORITY_RESERVED1       = 0x3000000%0A%09IPV6_PRIORITY_RESERVED2       = 0x5000000%0A%09IPV6_PRIORITY_UNATTENDED      = 0x2000000%0A%09IPV6_PRIORITY_UNCHARACTERIZED = 0x0%0A%09IPV6_RECVDSTOPTS              = 0x38%0A%09IPV6_RECVHOPLIMIT             = 0x29%0A%09IPV6_RECVHOPOPTS              = 0x35%0A%09IPV6_RECVHOPS                 = 0x22%0A%09IPV6_RECVIF                   = 0x1e%0A%09IPV6_RECVPATHMTU              = 0x2f%0A%09IPV6_RECVPKTINFO              = 0x23%0A%09IPV6_RECVRTHDR                = 0x33%0A%09IPV6_RECVSRCRT                = 0x1d%0A%09IPV6_RECVTCLASS               = 0x2a%0A%09IPV6_RTHDR                    = 0x32%0A%09IPV6_RTHDRDSTOPTS             = 0x37%0A%09IPV6_RTHDR_TYPE_0             = 0x0%0A%09IPV6_RTHDR_TYPE_2             = 0x2%0A%09IPV6_SENDIF                   = 0x1f%0A%09IPV6_SRFLAG_LOOSE             = 0x0%0A%09IPV6_SRFLAG_STRICT            = 0x10000000%0A%09IPV6_TCLASS                   = 0x2b%0A%09IPV6_TOKEN_LENGTH             = 0x40%0A%09IPV6_UNICAST_HOPS             = 0x4%0A%09IPV6_USE_MIN_MTU              = 0x2c%0A%09IPV6_V6ONLY                   = 0x25%0A%09IPV6_VERSION                  = 0x60000000%0A%09IP_ADDRFORM                   = 0x16%0A%09IP_ADD_MEMBERSHIP             = 0xc%0A%09IP_ADD_SOURCE_MEMBERSHIP      = 0x3c%0A%09IP_BLOCK_SOURCE               = 0x3a%0A%09IP_BROADCAST_IF               = 0x10%0A%09IP_CACHE_LINE_SIZE            = 0x80%0A%09IP_DEFAULT_MULTICAST_LOOP     = 0x1%0A%09IP_DEFAULT_MULTICAST_TTL      = 0x1%0A%09IP_DF                         = 0x4000%0A%09IP_DHCPMODE                   = 0x11%0A%09IP_DONTFRAG                   = 0x19%0A%09IP_DROP_MEMBERSHIP            = 0xd%0A%09IP_DROP_SOURCE_MEMBERSHIP     = 0x3d%0A%09IP_FINDPMTU                   = 0x1a%0A%09IP_HDRINCL                    = 0x2%0A%09IP_INC_MEMBERSHIPS            = 0x14%0A%09IP_INIT_MEMBERSHIP            = 0x14%0A%09IP_MAXPACKET                  = 0xffff%0A%09IP_MF                         = 0x2000%0A%09IP_MSS                        = 0x240%0A%09IP_MULTICAST_HOPS             = 0xa%0A%09IP_MULTICAST_IF               = 0x9%0A%09IP_MULTICAST_LOOP             = 0xb%0A%09IP_MULTICAST_TTL              = 0xa%0A%09IP_OPT                        = 0x1b%0A%09IP_OPTIONS                    = 0x1%0A%09IP_PMTUAGE                    = 0x1b%0A%09IP_RECVDSTADDR                = 0x7%0A%09IP_RECVIF                     = 0x14%0A%09IP_RECVIFINFO                 = 0xf%0A%09IP_RECVINTERFACE              = 0x20%0A%09IP_RECVMACHDR                 = 0xe%0A%09IP_RECVOPTS                   = 0x5%0A%09IP_RECVRETOPTS                = 0x6%0A%09IP_RECVTTL                    = 0x22%0A%09IP_RETOPTS                    = 0x8%0A%09IP_SOURCE_FILTER              = 0x48%0A%09IP_TOS                        = 0x3%0A%09IP_TTL                        = 0x4%0A%09IP_UNBLOCK_SOURCE             = 0x3b%0A%09IP_UNICAST_HOPS               = 0x4%0A%09ISIG                          = 0x1%0A%09ISTRIP                        = 0x20%0A%09IUCLC                         = 0x800%0A%09IXANY                         = 0x1000%0A%09IXOFF                         = 0x400%0A%09IXON                          = 0x200%0A%09I_FLUSH                       = 0x20005305%0A%09LNOFLSH                       = 0x8000%0A%09LOCK_EX                       = 0x2%0A%09LOCK_NB                       = 0x4%0A%09LOCK_SH                       = 0x1%0A%09LOCK_UN                       = 0x8%0A%09MADV_DONTNEED                 = 0x4%0A%09MADV_NORMAL                   = 0x0%0A%09MADV_RANDOM                   = 0x1%0A%09MADV_SEQUENTIAL               = 0x2%0A%09MADV_SPACEAVAIL               = 0x5%0A%09MADV_WILLNEED                 = 0x3%0A%09MAP_ANON                      = 0x10%0A%09MAP_ANONYMOUS                 = 0x10%0A%09MAP_FILE                      = 0x0%0A%09MAP_FIXED                     = 0x100%0A%09MAP_PRIVATE                   = 0x2%0A%09MAP_SHARED                    = 0x1%0A%09MAP_TYPE                      = 0xf0%0A%09MAP_VARIABLE                  = 0x0%0A%09MCL_CURRENT                   = 0x100%0A%09MCL_FUTURE                    = 0x200%0A%09MSG_ANY                       = 0x4%0A%09MSG_ARGEXT                    = 0x400%0A%09MSG_BAND                      = 0x2%0A%09MSG_COMPAT                    = 0x8000%0A%09MSG_CTRUNC                    = 0x20%0A%09MSG_DONTROUTE                 = 0x4%0A%09MSG_EOR                       = 0x8%0A%09MSG_HIPRI                     = 0x1%0A%09MSG_MAXIOVLEN                 = 0x10%0A%09MSG_MPEG2                     = 0x80%0A%09MSG_NONBLOCK                  = 0x4000%0A%09MSG_NOSIGNAL                  = 0x100%0A%09MSG_OOB                       = 0x1%0A%09MSG_PEEK                      = 0x2%0A%09MSG_TRUNC                     = 0x10%0A%09MSG_WAITALL                   = 0x40%0A%09MSG_WAITFORONE                = 0x200%0A%09MS_ASYNC                      = 0x10%0A%09MS_EINTR                      = 0x80%0A%09MS_INVALIDATE                 = 0x40%0A%09MS_PER_SEC                    = 0x3e8%0A%09MS_SYNC                       = 0x20%0A%09NL0                           = 0x0%0A%09NL1                           = 0x4000%0A%09NL2                           = 0x8000%0A%09NL3                           = 0xc000%0A%09NLDLY                         = 0x4000%0A%09NOFLSH                        = 0x80%0A%09NOFLUSH                       = 0x80000000%0A%09OCRNL                         = 0x8%0A%09OFDEL                         = 0x80%0A%09OFILL                         = 0x40%0A%09OLCUC                         = 0x2%0A%09ONLCR                         = 0x4%0A%09ONLRET                        = 0x20%0A%09ONOCR                         = 0x10%0A%09ONOEOT                        = 0x80000%0A%09OPOST                         = 0x1%0A%09OXTABS                        = 0x40000%0A%09O_ACCMODE                     = 0x23%0A%09O_APPEND                      = 0x8%0A%09O_CIO                         = 0x80%0A%09O_CIOR                        = 0x800000000%0A%09O_CLOEXEC                     = 0x800000%0A%09O_CREAT                       = 0x100%0A%09O_DEFER                       = 0x2000%0A%09O_DELAY                       = 0x4000%0A%09O_DIRECT                      = 0x8000000%0A%09O_DIRECTORY                   = 0x80000%0A%09O_DSYNC                       = 0x400000%0A%09O_EFSOFF                      = 0x400000000%0A%09O_EFSON                       = 0x200000000%0A%09O_EXCL                        = 0x400%0A%09O_EXEC                        = 0x20%0A%09O_LARGEFILE                   = 0x4000000%0A%09O_NDELAY                      = 0x8000%0A%09O_NOCACHE                     = 0x100000%0A%09O_NOCTTY                      = 0x800%0A%09O_NOFOLLOW                    = 0x1000000%0A%09O_NONBLOCK                    = 0x4%0A%09O_NONE                        = 0x3%0A%09O_NSHARE                      = 0x10000%0A%09O_RAW                         = 0x100000000%0A%09O_RDONLY                      = 0x0%0A%09O_RDWR                        = 0x2%0A%09O_RSHARE                      = 0x1000%0A%09O_RSYNC                       = 0x200000%0A%09O_SEARCH                      = 0x20%0A%09O_SNAPSHOT                    = 0x40%0A%09O_SYNC                        = 0x10%0A%09O_TRUNC                       = 0x200%0A%09O_TTY_INIT                    = 0x0%0A%09O_WRONLY                      = 0x1%0A%09PARENB                        = 0x100%0A%09PAREXT                        = 0x100000%0A%09PARMRK                        = 0x8%0A%09PARODD                        = 0x200%0A%09PENDIN                        = 0x20000000%0A%09PRIO_PGRP                     = 0x1%0A%09PRIO_PROCESS                  = 0x0%0A%09PRIO_USER                     = 0x2%0A%09PROT_EXEC                     = 0x4%0A%09PROT_NONE                     = 0x0%0A%09PROT_READ                     = 0x1%0A%09PROT_WRITE                    = 0x2%0A%09PR_64BIT                      = 0x20%0A%09PR_ADDR                       = 0x2%0A%09PR_ARGEXT                     = 0x400%0A%09PR_ATOMIC                     = 0x1%0A%09PR_CONNREQUIRED               = 0x4%0A%09PR_FASTHZ                     = 0x5%0A%09PR_INP                        = 0x40%0A%09PR_INTRLEVEL                  = 0x8000%0A%09PR_MLS                        = 0x100%0A%09PR_MLS_1_LABEL                = 0x200%0A%09PR_NOEOR                      = 0x4000%0A%09PR_RIGHTS                     = 0x10%0A%09PR_SLOWHZ                     = 0x2%0A%09PR_WANTRCVD                   = 0x8%0A%09RLIMIT_AS                     = 0x6%0A%09RLIMIT_CORE                   = 0x4%0A%09RLIMIT_CPU                    = 0x0%0A%09RLIMIT_DATA                   = 0x2%0A%09RLIMIT_FSIZE                  = 0x1%0A%09RLIMIT_NOFILE                 = 0x7%0A%09RLIMIT_NPROC                  = 0x9%0A%09RLIMIT_RSS                    = 0x5%0A%09RLIMIT_STACK                  = 0x3%0A%09RLIM_INFINITY                 = 0x7fffffffffffffff%0A%09RTAX_AUTHOR                   = 0x6%0A%09RTAX_BRD                      = 0x7%0A%09RTAX_DST                      = 0x0%0A%09RTAX_GATEWAY                  = 0x1%0A%09RTAX_GENMASK                  = 0x3%0A%09RTAX_IFA                      = 0x5%0A%09RTAX_IFP                      = 0x4%0A%09RTAX_MAX                      = 0x8%0A%09RTAX_NETMASK                  = 0x2%0A%09RTA_AUTHOR                    = 0x40%0A%09RTA_BRD                       = 0x80%0A%09RTA_DOWNSTREAM                = 0x100%0A%09RTA_DST                       = 0x1%0A%09RTA_GATEWAY                   = 0x2%0A%09RTA_GENMASK                   = 0x8%0A%09RTA_IFA                       = 0x20%0A%09RTA_IFP                       = 0x10%0A%09RTA_NETMASK                   = 0x4%0A%09RTC_IA64                      = 0x3%0A%09RTC_POWER                     = 0x1%0A%09RTC_POWER_PC                  = 0x2%0A%09RTF_ACTIVE_DGD                = 0x1000000%0A%09RTF_BCE                       = 0x80000%0A%09RTF_BLACKHOLE                 = 0x1000%0A%09RTF_BROADCAST                 = 0x400000%0A%09RTF_BUL                       = 0x2000%0A%09RTF_CLONE                     = 0x10000%0A%09RTF_CLONED                    = 0x20000%0A%09RTF_CLONING                   = 0x100%0A%09RTF_DONE                      = 0x40%0A%09RTF_DYNAMIC                   = 0x10%0A%09RTF_FREE_IN_PROG              = 0x4000000%0A%09RTF_GATEWAY                   = 0x2%0A%09RTF_HOST                      = 0x4%0A%09RTF_LLINFO                    = 0x400%0A%09RTF_LOCAL                     = 0x200000%0A%09RTF_MASK                      = 0x80%0A%09RTF_MODIFIED                  = 0x20%0A%09RTF_MULTICAST                 = 0x800000%0A%09RTF_PERMANENT6                = 0x8000000%0A%09RTF_PINNED                    = 0x100000%0A%09RTF_PROTO1                    = 0x8000%0A%09RTF_PROTO2                    = 0x4000%0A%09RTF_PROTO3                    = 0x40000%0A%09RTF_REJECT                    = 0x8%0A%09RTF_SMALLMTU                  = 0x40000%0A%09RTF_STATIC                    = 0x800%0A%09RTF_STOPSRCH                  = 0x2000000%0A%09RTF_UNREACHABLE               = 0x10000000%0A%09RTF_UP                        = 0x1%0A%09RTF_XRESOLVE                  = 0x200%0A%09RTM_ADD                       = 0x1%0A%09RTM_CHANGE                    = 0x3%0A%09RTM_DELADDR                   = 0xd%0A%09RTM_DELETE                    = 0x2%0A%09RTM_EXPIRE                    = 0xf%0A%09RTM_GET                       = 0x4%0A%09RTM_GETNEXT                   = 0x11%0A%09RTM_IFINFO                    = 0xe%0A%09RTM_LOCK                      = 0x8%0A%09RTM_LOSING                    = 0x5%0A%09RTM_MISS                      = 0x7%0A%09RTM_NEWADDR                   = 0xc%0A%09RTM_OLDADD                    = 0x9%0A%09RTM_OLDDEL                    = 0xa%0A%09RTM_REDIRECT                  = 0x6%0A%09RTM_RESOLVE                   = 0xb%0A%09RTM_RTLOST                    = 0x10%0A%09RTM_RTTUNIT                   = 0xf4240%0A%09RTM_SAMEADDR                  = 0x12%0A%09RTM_SET                       = 0x13%0A%09RTM_VERSION                   = 0x2%0A%09RTM_VERSION_GR                = 0x4%0A%09RTM_VERSION_GR_COMPAT         = 0x3%0A%09RTM_VERSION_POLICY            = 0x5%0A%09RTM_VERSION_POLICY_EXT        = 0x6%0A%09RTM_VERSION_POLICY_PRFN       = 0x7%0A%09RTV_EXPIRE                    = 0x4%0A%09RTV_HOPCOUNT                  = 0x2%0A%09RTV_MTU                       = 0x1%0A%09RTV_RPIPE                     = 0x8%0A%09RTV_RTT                       = 0x40%0A%09RTV_RTTVAR                    = 0x80%0A%09RTV_SPIPE                     = 0x10%0A%09RTV_SSTHRESH                  = 0x20%0A%09RUSAGE_CHILDREN               = -0x1%0A%09RUSAGE_SELF                   = 0x0%0A%09RUSAGE_THREAD                 = 0x1%0A%09SCM_RIGHTS                    = 0x1%0A%09SHUT_RD                       = 0x0%0A%09SHUT_RDWR                     = 0x2%0A%09SHUT_WR                       = 0x1%0A%09SIGMAX64                      = 0xff%0A%09SIGQUEUE_MAX                  = 0x20%0A%09SIOCADDIFVIPA                 = 0x20006942%0A%09SIOCADDMTU                    = -0x7ffb9690%0A%09SIOCADDMULTI                  = -0x7fdf96cf%0A%09SIOCADDNETID                  = -0x7fd796a9%0A%09SIOCADDRT                     = -0x7fc78df6%0A%09SIOCAIFADDR                   = -0x7fbf96e6%0A%09SIOCATMARK                    = 0x40047307%0A%09SIOCDARP                      = -0x7fb396e0%0A%09SIOCDELIFVIPA                 = 0x20006943%0A%09SIOCDELMTU                    = -0x7ffb968f%0A%09SIOCDELMULTI                  = -0x7fdf96ce%0A%09SIOCDELPMTU                   = -0x7fd78ff6%0A%09SIOCDELRT                     = -0x7fc78df5%0A%09SIOCDIFADDR                   = -0x7fd796e7%0A%09SIOCDNETOPT                   = -0x3ffe9680%0A%09SIOCDX25XLATE                 = -0x7fd7969b%0A%09SIOCFIFADDR                   = -0x7fdf966d%0A%09SIOCGARP                      = -0x3fb396da%0A%09SIOCGETMTUS                   = 0x2000696f%0A%09SIOCGETSGCNT                  = -0x3feb8acc%0A%09SIOCGETVIFCNT                 = -0x3feb8acd%0A%09SIOCGHIWAT                    = 0x40047301%0A%09SIOCGIFADDR                   = -0x3fd796df%0A%09SIOCGIFADDRS                  = 0x2000698c%0A%09SIOCGIFBAUDRATE               = -0x3fd79693%0A%09SIOCGIFBRDADDR                = -0x3fd796dd%0A%09SIOCGIFCONF                   = -0x3fef96bb%0A%09SIOCGIFCONFGLOB               = -0x3fef9670%0A%09SIOCGIFDSTADDR                = -0x3fd796de%0A%09SIOCGIFFLAGS                  = -0x3fd796ef%0A%09SIOCGIFGIDLIST                = 0x20006968%0A%09SIOCGIFHWADDR                 = -0x3fab966b%0A%09SIOCGIFMETRIC                 = -0x3fd796e9%0A%09SIOCGIFMTU                    = -0x3fd796aa%0A%09SIOCGIFNETMASK                = -0x3fd796db%0A%09SIOCGIFOPTIONS                = -0x3fd796d6%0A%09SIOCGISNO                     = -0x3fd79695%0A%09SIOCGLOADF                    = -0x3ffb967e%0A%09SIOCGLOWAT                    = 0x40047303%0A%09SIOCGNETOPT                   = -0x3ffe96a5%0A%09SIOCGNETOPT1                  = -0x3fdf967f%0A%09SIOCGNMTUS                    = 0x2000696e%0A%09SIOCGPGRP                     = 0x40047309%0A%09SIOCGSIZIFCONF                = 0x4004696a%0A%09SIOCGSRCFILTER                = -0x3fe796cb%0A%09SIOCGTUNEPHASE                = -0x3ffb9676%0A%09SIOCGX25XLATE                 = -0x3fd7969c%0A%09SIOCIFATTACH                  = -0x7fdf9699%0A%09SIOCIFDETACH                  = -0x7fdf969a%0A%09SIOCIFGETPKEY                 = -0x7fdf969b%0A%09SIOCIF_ATM_DARP               = -0x7fdf9683%0A%09SIOCIF_ATM_DUMPARP            = -0x7fdf9685%0A%09SIOCIF_ATM_GARP               = -0x7fdf9682%0A%09SIOCIF_ATM_IDLE               = -0x7fdf9686%0A%09SIOCIF_ATM_SARP               = -0x7fdf9681%0A%09SIOCIF_ATM_SNMPARP            = -0x7fdf9687%0A%09SIOCIF_ATM_SVC                = -0x7fdf9684%0A%09SIOCIF_ATM_UBR                = -0x7fdf9688%0A%09SIOCIF_DEVHEALTH              = -0x7ffb966c%0A%09SIOCIF_IB_ARP_INCOMP          = -0x7fdf9677%0A%09SIOCIF_IB_ARP_TIMER           = -0x7fdf9678%0A%09SIOCIF_IB_CLEAR_PINFO         = -0x3fdf966f%0A%09SIOCIF_IB_DEL_ARP             = -0x7fdf967f%0A%09SIOCIF_IB_DEL_PINFO           = -0x3fdf9670%0A%09SIOCIF_IB_DUMP_ARP            = -0x7fdf9680%0A%09SIOCIF_IB_GET_ARP             = -0x7fdf967e%0A%09SIOCIF_IB_GET_INFO            = -0x3f879675%0A%09SIOCIF_IB_GET_STATS           = -0x3f879672%0A%09SIOCIF_IB_NOTIFY_ADDR_REM     = -0x3f87966a%0A%09SIOCIF_IB_RESET_STATS         = -0x3f879671%0A%09SIOCIF_IB_RESIZE_CQ           = -0x7fdf9679%0A%09SIOCIF_IB_SET_ARP             = -0x7fdf967d%0A%09SIOCIF_IB_SET_PKEY            = -0x7fdf967c%0A%09SIOCIF_IB_SET_PORT            = -0x7fdf967b%0A%09SIOCIF_IB_SET_QKEY            = -0x7fdf9676%0A%09SIOCIF_IB_SET_QSIZE           = -0x7fdf967a%0A%09SIOCLISTIFVIPA                = 0x20006944%0A%09SIOCSARP                      = -0x7fb396e2%0A%09SIOCSHIWAT                    = 0xffffffff80047300%0A%09SIOCSIFADDR                   = -0x7fd796f4%0A%09SIOCSIFADDRORI                = -0x7fdb9673%0A%09SIOCSIFBRDADDR                = -0x7fd796ed%0A%09SIOCSIFDSTADDR                = -0x7fd796f2%0A%09SIOCSIFFLAGS                  = -0x7fd796f0%0A%09SIOCSIFGIDLIST                = 0x20006969%0A%09SIOCSIFMETRIC                 = -0x7fd796e8%0A%09SIOCSIFMTU                    = -0x7fd796a8%0A%09SIOCSIFNETDUMP                = -0x7fd796e4%0A%09SIOCSIFNETMASK                = -0x7fd796ea%0A%09SIOCSIFOPTIONS                = -0x7fd796d7%0A%09SIOCSIFSUBCHAN                = -0x7fd796e5%0A%09SIOCSISNO                     = -0x7fd79694%0A%09SIOCSLOADF                    = -0x3ffb967d%0A%09SIOCSLOWAT                    = 0xffffffff80047302%0A%09SIOCSNETOPT                   = -0x7ffe96a6%0A%09SIOCSPGRP                     = 0xffffffff80047308%0A%09SIOCSX25XLATE                 = -0x7fd7969d%0A%09SOCK_CONN_DGRAM               = 0x6%0A%09SOCK_DGRAM                    = 0x2%0A%09SOCK_RAW                      = 0x3%0A%09SOCK_RDM                      = 0x4%0A%09SOCK_SEQPACKET                = 0x5%0A%09SOCK_STREAM                   = 0x1%0A%09SOL_SOCKET                    = 0xffff%0A%09SOMAXCONN                     = 0x400%0A%09SO_ACCEPTCONN                 = 0x2%0A%09SO_AUDIT                      = 0x8000%0A%09SO_BROADCAST                  = 0x20%0A%09SO_CKSUMRECV                  = 0x800%0A%09SO_DEBUG                      = 0x1%0A%09SO_DONTROUTE                  = 0x10%0A%09SO_ERROR                      = 0x1007%0A%09SO_KEEPALIVE                  = 0x8%0A%09SO_KERNACCEPT                 = 0x2000%0A%09SO_LINGER                     = 0x80%0A%09SO_NOMULTIPATH                = 0x4000%0A%09SO_NOREUSEADDR                = 0x1000%0A%09SO_OOBINLINE                  = 0x100%0A%09SO_PEERID                     = 0x1009%0A%09SO_RCVBUF                     = 0x1002%0A%09SO_RCVLOWAT                   = 0x1004%0A%09SO_RCVTIMEO                   = 0x1006%0A%09SO_REUSEADDR                  = 0x4%0A%09SO_REUSEPORT                  = 0x200%0A%09SO_SNDBUF                     = 0x1001%0A%09SO_SNDLOWAT                   = 0x1003%0A%09SO_SNDTIMEO                   = 0x1005%0A%09SO_TIMESTAMPNS                = 0x100a%0A%09SO_TYPE                       = 0x1008%0A%09SO_USELOOPBACK                = 0x40%0A%09SO_USE_IFBUFS                 = 0x400%0A%09S_BANDURG                     = 0x400%0A%09S_EMODFMT                     = 0x3c000000%0A%09S_ENFMT                       = 0x400%0A%09S_ERROR                       = 0x100%0A%09S_HANGUP                      = 0x200%0A%09S_HIPRI                       = 0x2%0A%09S_ICRYPTO                     = 0x80000%0A%09S_IEXEC                       = 0x40%0A%09S_IFBLK                       = 0x6000%0A%09S_IFCHR                       = 0x2000%0A%09S_IFDIR                       = 0x4000%0A%09S_IFIFO                       = 0x1000%0A%09S_IFJOURNAL                   = 0x10000%0A%09S_IFLNK                       = 0xa000%0A%09S_IFMPX                       = 0x2200%0A%09S_IFMT                        = 0xf000%0A%09S_IFPDIR                      = 0x4000000%0A%09S_IFPSDIR                     = 0x8000000%0A%09S_IFPSSDIR                    = 0xc000000%0A%09S_IFREG                       = 0x8000%0A%09S_IFSOCK                      = 0xc000%0A%09S_IFSYSEA                     = 0x30000000%0A%09S_INPUT                       = 0x1%0A%09S_IREAD                       = 0x100%0A%09S_IRGRP                       = 0x20%0A%09S_IROTH                       = 0x4%0A%09S_IRUSR                       = 0x100%0A%09S_IRWXG                       = 0x38%0A%09S_IRWXO                       = 0x7%0A%09S_IRWXU                       = 0x1c0%0A%09S_ISGID                       = 0x400%0A%09S_ISUID                       = 0x800%0A%09S_ISVTX                       = 0x200%0A%09S_ITCB                        = 0x1000000%0A%09S_ITP                         = 0x800000%0A%09S_IWGRP                       = 0x10%0A%09S_IWOTH                       = 0x2%0A%09S_IWRITE                      = 0x80%0A%09S_IWUSR                       = 0x80%0A%09S_IXACL                       = 0x2000000%0A%09S_IXATTR                      = 0x40000%0A%09S_IXGRP                       = 0x8%0A%09S_IXINTERFACE                 = 0x100000%0A%09S_IXMOD                       = 0x40000000%0A%09S_IXOTH                       = 0x1%0A%09S_IXUSR                       = 0x40%0A%09S_MSG                         = 0x8%0A%09S_OUTPUT                      = 0x4%0A%09S_RDBAND                      = 0x20%0A%09S_RDNORM                      = 0x10%0A%09S_RESERVED1                   = 0x20000%0A%09S_RESERVED2                   = 0x200000%0A%09S_RESERVED3                   = 0x400000%0A%09S_RESERVED4                   = 0x80000000%0A%09S_RESFMT1                     = 0x10000000%0A%09S_RESFMT10                    = 0x34000000%0A%09S_RESFMT11                    = 0x38000000%0A%09S_RESFMT12                    = 0x3c000000%0A%09S_RESFMT2                     = 0x14000000%0A%09S_RESFMT3                     = 0x18000000%0A%09S_RESFMT4                     = 0x1c000000%0A%09S_RESFMT5                     = 0x20000000%0A%09S_RESFMT6                     = 0x24000000%0A%09S_RESFMT7                     = 0x28000000%0A%09S_RESFMT8                     = 0x2c000000%0A%09S_WRBAND                      = 0x80%0A%09S_WRNORM                      = 0x40%0A%09TAB0                          = 0x0%0A%09TAB1                          = 0x400%0A%09TAB2                          = 0x800%0A%09TAB3                          = 0xc00%0A%09TABDLY                        = 0xc00%0A%09TCFLSH                        = 0x540c%0A%09TCGETA                        = 0x5405%0A%09TCGETS                        = 0x5401%0A%09TCIFLUSH                      = 0x0%0A%09TCIOFF                        = 0x2%0A%09TCIOFLUSH                     = 0x2%0A%09TCION                         = 0x3%0A%09TCOFLUSH                      = 0x1%0A%09TCOOFF                        = 0x0%0A%09TCOON                         = 0x1%0A%09TCP_24DAYS_WORTH_OF_SLOWTICKS = 0x3f4800%0A%09TCP_ACLADD                    = 0x23%0A%09TCP_ACLBIND                   = 0x26%0A%09TCP_ACLCLEAR                  = 0x22%0A%09TCP_ACLDEL                    = 0x24%0A%09TCP_ACLDENY                   = 0x8%0A%09TCP_ACLFLUSH                  = 0x21%0A%09TCP_ACLGID                    = 0x1%0A%09TCP_ACLLS                     = 0x25%0A%09TCP_ACLSUBNET                 = 0x4%0A%09TCP_ACLUID                    = 0x2%0A%09TCP_CWND_DF                   = 0x16%0A%09TCP_CWND_IF                   = 0x15%0A%09TCP_DELAY_ACK_FIN             = 0x2%0A%09TCP_DELAY_ACK_SYN             = 0x1%0A%09TCP_FASTNAME                  = 0x101080a%0A%09TCP_KEEPCNT                   = 0x13%0A%09TCP_KEEPIDLE                  = 0x11%0A%09TCP_KEEPINTVL                 = 0x12%0A%09TCP_LSPRIV                    = 0x29%0A%09TCP_LUID                      = 0x20%0A%09TCP_MAXBURST                  = 0x8%0A%09TCP_MAXDF                     = 0x64%0A%09TCP_MAXIF                     = 0x64%0A%09TCP_MAXSEG                    = 0x2%0A%09TCP_MAXWIN                    = 0xffff%0A%09TCP_MAXWINDOWSCALE            = 0xe%0A%09TCP_MAX_SACK                  = 0x4%0A%09TCP_MSS                       = 0x5b4%0A%09TCP_NODELAY                   = 0x1%0A%09TCP_NODELAYACK                = 0x14%0A%09TCP_NOREDUCE_CWND_EXIT_FRXMT  = 0x19%0A%09TCP_NOREDUCE_CWND_IN_FRXMT    = 0x18%0A%09TCP_NOTENTER_SSTART           = 0x17%0A%09TCP_OPT                       = 0x19%0A%09TCP_RFC1323                   = 0x4%0A%09TCP_SETPRIV                   = 0x27%0A%09TCP_STDURG                    = 0x10%0A%09TCP_TIMESTAMP_OPTLEN          = 0xc%0A%09TCP_UNSETPRIV                 = 0x28%0A%09TCSAFLUSH                     = 0x2%0A%09TCSBRK                        = 0x5409%0A%09TCSETA                        = 0x5406%0A%09TCSETAF                       = 0x5408%0A%09TCSETAW                       = 0x5407%0A%09TCSETS                        = 0x5402%0A%09TCSETSF                       = 0x5404%0A%09TCSETSW                       = 0x5403%0A%09TCXONC                        = 0x540b%0A%09TIOC                          = 0x5400%0A%09TIOCCBRK                      = 0x2000747a%0A%09TIOCCDTR                      = 0x20007478%0A%09TIOCCONS                      = 0xffffffff80047462%0A%09TIOCEXCL                      = 0x2000740d%0A%09TIOCFLUSH                     = 0xffffffff80047410%0A%09TIOCGETC                      = 0x40067412%0A%09TIOCGETD                      = 0x40047400%0A%09TIOCGETP                      = 0x40067408%0A%09TIOCGLTC                      = 0x40067474%0A%09TIOCGPGRP                     = 0x40047477%0A%09TIOCGSID                      = 0x40047448%0A%09TIOCGSIZE                     = 0x40087468%0A%09TIOCGWINSZ                    = 0x40087468%0A%09TIOCHPCL                      = 0x20007402%0A%09TIOCLBIC                      = 0xffffffff8004747e%0A%09TIOCLBIS                      = 0xffffffff8004747f%0A%09TIOCLGET                      = 0x4004747c%0A%09TIOCLSET                      = 0xffffffff8004747d%0A%09TIOCMBIC                      = 0xffffffff8004746b%0A%09TIOCMBIS                      = 0xffffffff8004746c%0A%09TIOCMGET                      = 0x4004746a%0A%09TIOCMIWAIT                    = 0xffffffff80047464%0A%09TIOCMODG                      = 0x40047403%0A%09TIOCMODS                      = 0xffffffff80047404%0A%09TIOCMSET                      = 0xffffffff8004746d%0A%09TIOCM_CAR                     = 0x40%0A%09TIOCM_CD                      = 0x40%0A%09TIOCM_CTS                     = 0x20%0A%09TIOCM_DSR                     = 0x100%0A%09TIOCM_DTR                     = 0x2%0A%09TIOCM_LE                      = 0x1%0A%09TIOCM_RI                      = 0x80%0A%09TIOCM_RNG                     = 0x80%0A%09TIOCM_RTS                     = 0x4%0A%09TIOCM_SR                      = 0x10%0A%09TIOCM_ST                      = 0x8%0A%09TIOCNOTTY                     = 0x20007471%0A%09TIOCNXCL                      = 0x2000740e%0A%09TIOCOUTQ                      = 0x40047473%0A%09TIOCPKT                       = 0xffffffff80047470%0A%09TIOCPKT_DATA                  = 0x0%0A%09TIOCPKT_DOSTOP                = 0x20%0A%09TIOCPKT_FLUSHREAD             = 0x1%0A%09TIOCPKT_FLUSHWRITE            = 0x2%0A%09TIOCPKT_NOSTOP                = 0x10%0A%09TIOCPKT_START                 = 0x8%0A%09TIOCPKT_STOP                  = 0x4%0A%09TIOCREMOTE                    = 0xffffffff80047469%0A%09TIOCSBRK                      = 0x2000747b%0A%09TIOCSDTR                      = 0x20007479%0A%09TIOCSETC                      = 0xffffffff80067411%0A%09TIOCSETD                      = 0xffffffff80047401%0A%09TIOCSETN                      = 0xffffffff8006740a%0A%09TIOCSETP                      = 0xffffffff80067409%0A%09TIOCSLTC                      = 0xffffffff80067475%0A%09TIOCSPGRP                     = 0xffffffff80047476%0A%09TIOCSSIZE                     = 0xffffffff80087467%0A%09TIOCSTART                     = 0x2000746e%0A%09TIOCSTI                       = 0xffffffff80017472%0A%09TIOCSTOP                      = 0x2000746f%0A%09TIOCSWINSZ                    = 0xffffffff80087467%0A%09TIOCUCNTL                     = 0xffffffff80047466%0A%09TOSTOP                        = 0x10000%0A%09UTIME_NOW                     = -0x2%0A%09UTIME_OMIT                    = -0x3%0A%09VDISCRD                       = 0xc%0A%09VDSUSP                        = 0xa%0A%09VEOF                          = 0x4%0A%09VEOL                          = 0x5%0A%09VEOL2                         = 0x6%0A%09VERASE                        = 0x2%0A%09VINTR                         = 0x0%0A%09VKILL                         = 0x3%0A%09VLNEXT                        = 0xe%0A%09VMIN                          = 0x4%0A%09VQUIT                         = 0x1%0A%09VREPRINT                      = 0xb%0A%09VSTART                        = 0x7%0A%09VSTOP                         = 0x8%0A%09VSTRT                         = 0x7%0A%09VSUSP                         = 0x9%0A%09VT0                           = 0x0%0A%09VT1                           = 0x8000%0A%09VTDELAY                       = 0x2000%0A%09VTDLY                         = 0x8000%0A%09VTIME                         = 0x5%0A%09VWERSE                        = 0xd%0A%09WPARSTART                     = 0x1%0A%09WPARSTOP                      = 0x2%0A%09WPARTTYNAME                   = %22Global%22%0A%09XCASE                         = 0x4%0A%09XTABS                         = 0xc00%0A%09_FDATAFLUSH                   = 0x2000000000%0A)%0A%0A// Errors%0Aconst (%0A%09E2BIG           = syscall.Errno(0x7)%0A%09EACCES          = syscall.Errno(0xd)%0A%09EADDRINUSE      = syscall.Errno(0x43)%0A%09EADDRNOTAVAIL   = syscall.Errno(0x44)%0A%09EAFNOSUPPORT    = syscall.Errno(0x42)%0A%09EAGAIN          = syscall.Errno(0xb)%0A%09EALREADY        = syscall.Errno(0x38)%0A%09EBADF           = syscall.Errno(0x9)%0A%09EBADMSG         = syscall.Errno(0x78)%0A%09EBUSY           = syscall.Errno(0x10)%0A%09ECANCELED       = syscall.Errno(0x75)%0A%09ECHILD          = syscall.Errno(0xa)%0A%09ECHRNG          = syscall.Errno(0x25)%0A%09ECLONEME        = syscall.Errno(0x52)%0A%09ECONNABORTED    = syscall.Errno(0x48)%0A%09ECONNREFUSED    = syscall.Errno(0x4f)%0A%09ECONNRESET      = syscall.Errno(0x49)%0A%09ECORRUPT        = syscall.Errno(0x59)%0A%09EDEADLK         = syscall.Errno(0x2d)%0A%09EDESTADDREQ     = syscall.Errno(0x3a)%0A%09EDESTADDRREQ    = syscall.Errno(0x3a)%0A%09EDIST           = syscall.Errno(0x35)%0A%09EDOM            = syscall.Errno(0x21)%0A%09EDQUOT          = syscall.Errno(0x58)%0A%09EEXIST          = syscall.Errno(0x11)%0A%09EFAULT          = syscall.Errno(0xe)%0A%09EFBIG           = syscall.Errno(0x1b)%0A%09EFORMAT         = syscall.Errno(0x30)%0A%09EHOSTDOWN       = syscall.Errno(0x50)%0A%09EHOSTUNREACH    = syscall.Errno(0x51)%0A%09EIDRM           = syscall.Errno(0x24)%0A%09EILSEQ          = syscall.Errno(0x74)%0A%09EINPROGRESS     = syscall.Errno(0x37)%0A%09EINTR           = syscall.Errno(0x4)%0A%09EINVAL          = syscall.Errno(0x16)%0A%09EIO             = syscall.Errno(0x5)%0A%09EISCONN         = syscall.Errno(0x4b)%0A%09EISDIR          = syscall.Errno(0x15)%0A%09EL2HLT          = syscall.Errno(0x2c)%0A%09EL2NSYNC        = syscall.Errno(0x26)%0A%09EL3HLT          = syscall.Errno(0x27)%0A%09EL3RST          = syscall.Errno(0x28)%0A%09ELNRNG          = syscall.Errno(0x29)%0A%09ELOOP           = syscall.Errno(0x55)%0A%09EMEDIA          = syscall.Errno(0x6e)%0A%09EMFILE          = syscall.Errno(0x18)%0A%09EMLINK          = syscall.Errno(0x1f)%0A%09EMSGSIZE        = syscall.Errno(0x3b)%0A%09EMULTIHOP       = syscall.Errno(0x7d)%0A%09ENAMETOOLONG    = syscall.Errno(0x56)%0A%09ENETDOWN        = syscall.Errno(0x45)%0A%09ENETRESET       = syscall.Errno(0x47)%0A%09ENETUNREACH     = syscall.Errno(0x46)%0A%09ENFILE          = syscall.Errno(0x17)%0A%09ENOATTR         = syscall.Errno(0x70)%0A%09ENOBUFS         = syscall.Errno(0x4a)%0A%09ENOCONNECT      = syscall.Errno(0x32)%0A%09ENOCSI          = syscall.Errno(0x2b)%0A%09ENODATA         = syscall.Errno(0x7a)%0A%09ENODEV          = syscall.Errno(0x13)%0A%09ENOENT          = syscall.Errno(0x2)%0A%09ENOEXEC         = syscall.Errno(0x8)%0A%09ENOLCK          = syscall.Errno(0x31)%0A%09ENOLINK         = syscall.Errno(0x7e)%0A%09ENOMEM          = syscall.Errno(0xc)%0A%09ENOMSG          = syscall.Errno(0x23)%0A%09ENOPROTOOPT     = syscall.Errno(0x3d)%0A%09ENOSPC          = syscall.Errno(0x1c)%0A%09ENOSR           = syscall.Errno(0x76)%0A%09ENOSTR          = syscall.Errno(0x7b)%0A%09ENOSYS          = syscall.Errno(0x6d)%0A%09ENOTBLK         = syscall.Errno(0xf)%0A%09ENOTCONN        = syscall.Errno(0x4c)%0A%09ENOTDIR         = syscall.Errno(0x14)%0A%09ENOTEMPTY       = syscall.Errno(0x11)%0A%09ENOTREADY       = syscall.Errno(0x2e)%0A%09ENOTRECOVERABLE = syscall.Errno(0x5e)%0A%09ENOTRUST        = syscall.Errno(0x72)%0A%09ENOTSOCK        = syscall.Errno(0x39)%0A%09ENOTSUP         = syscall.Errno(0x7c)%0A%09ENOTTY          = syscall.Errno(0x19)%0A%09ENXIO           = syscall.Errno(0x6)%0A%09EOPNOTSUPP      = syscall.Errno(0x40)%0A%09EOVERFLOW       = syscall.Errno(0x7f)%0A%09EOWNERDEAD      = syscall.Errno(0x5f)%0A%09EPERM           = syscall.Errno(0x1)%0A%09EPFNOSUPPORT    = syscall.Errno(0x41)%0A%09EPIPE           = syscall.Errno(0x20)%0A%09EPROCLIM        = syscall.Errno(0x53)%0A%09EPROTO          = syscall.Errno(0x79)%0A%09EPROTONOSUPPORT = syscall.Errno(0x3e)%0A%09EPROTOTYPE      = syscall.Errno(0x3c)%0A%09ERANGE          = syscall.Errno(0x22)%0A%09EREMOTE         = syscall.Errno(0x5d)%0A%09ERESTART        = syscall.Errno(0x52)%0A%09EROFS           = syscall.Errno(0x1e)%0A%09ESAD            = syscall.Errno(0x71)%0A%09ESHUTDOWN       = syscall.Errno(0x4d)%0A%09ESOCKTNOSUPPORT = syscall.Errno(0x3f)%0A%09ESOFT           = syscall.Errno(0x6f)%0A%09ESPIPE          = syscall.Errno(0x1d)%0A%09ESRCH           = syscall.Errno(0x3)%0A%09ESTALE          = syscall.Errno(0x34)%0A%09ESYSERROR       = syscall.Errno(0x5a)%0A%09ETIME           = syscall.Errno(0x77)%0A%09ETIMEDOUT       = syscall.Errno(0x4e)%0A%09ETOOMANYREFS    = syscall.Errno(0x73)%0A%09ETXTBSY         = syscall.Errno(0x1a)%0A%09EUNATCH         = syscall.Errno(0x2a)%0A%09EUSERS          = syscall.Errno(0x54)%0A%09EWOULDBLOCK     = syscall.Errno(0xb)%0A%09EWRPROTECT      = syscall.Errno(0x2f)%0A%09EXDEV           = syscall.Errno(0x12)%0A)%0A%0A// Signals%0Aconst (%0A%09SIGABRT     = syscall.Signal(0x6)%0A%09SIGAIO      = syscall.Signal(0x17)%0A%09SIGALRM     = syscall.Signal(0xe)%0A%09SIGALRM1    = syscall.Signal(0x26)%0A%09SIGBUS      = syscall.Signal(0xa)%0A%09SIGCAPI     = syscall.Signal(0x31)%0A%09SIGCHLD     = syscall.Signal(0x14)%0A%09SIGCLD      = syscall.Signal(0x14)%0A%09SIGCONT     = syscall.Signal(0x13)%0A%09SIGCPUFAIL  = syscall.Signal(0x3b)%0A%09SIGDANGER   = syscall.Signal(0x21)%0A%09SIGEMT      = syscall.Signal(0x7)%0A%09SIGFPE      = syscall.Signal(0x8)%0A%09SIGGRANT    = syscall.Signal(0x3c)%0A%09SIGHUP      = syscall.Signal(0x1)%0A%09SIGILL      = syscall.Signal(0x4)%0A%09SIGINT      = syscall.Signal(0x2)%0A%09SIGIO       = syscall.Signal(0x17)%0A%09SIGIOINT    = syscall.Signal(0x10)%0A%09SIGIOT      = syscall.Signal(0x6)%0A%09SIGKAP      = syscall.Signal(0x3c)%0A%09SIGKILL     = syscall.Signal(0x9)%0A%09SIGLOST     = syscall.Signal(0x6)%0A%09SIGMAX      = syscall.Signal(0xff)%0A%09SIGMAX32    = syscall.Signal(0x3f)%0A%09SIGMIGRATE  = syscall.Signal(0x23)%0A%09SIGMSG      = syscall.Signal(0x1b)%0A%09SIGPIPE     = syscall.Signal(0xd)%0A%09SIGPOLL     = syscall.Signal(0x17)%0A%09SIGPRE      = syscall.Signal(0x24)%0A%09SIGPROF     = syscall.Signal(0x20)%0A%09SIGPTY      = syscall.Signal(0x17)%0A%09SIGPWR      = syscall.Signal(0x1d)%0A%09SIGQUIT     = syscall.Signal(0x3)%0A%09SIGRECONFIG = syscall.Signal(0x3a)%0A%09SIGRETRACT  = syscall.Signal(0x3d)%0A%09SIGSAK      = syscall.Signal(0x3f)%0A%09SIGSEGV     = syscall.Signal(0xb)%0A%09SIGSOUND    = syscall.Signal(0x3e)%0A%09SIGSTOP     = syscall.Signal(0x11)%0A%09SIGSYS      = syscall.Signal(0xc)%0A%09SIGSYSERROR = syscall.Signal(0x30)%0A%09SIGTALRM    = syscall.Signal(0x26)%0A%09SIGTERM     = syscall.Signal(0xf)%0A%09SIGTRAP     = syscall.Signal(0x5)%0A%09SIGTSTP     = syscall.Signal(0x12)%0A%09SIGTTIN     = syscall.Signal(0x15)%0A%09SIGTTOU     = syscall.Signal(0x16)%0A%09SIGURG      = syscall.Signal(0x10)%0A%09SIGUSR1     = syscall.Signal(0x1e)%0A%09SIGUSR2     = syscall.Signal(0x1f)%0A%09SIGVIRT     = syscall.Signal(0x25)%0A%09SIGVTALRM   = syscall.Signal(0x22)%0A%09SIGWAITING  = syscall.Signal(0x27)%0A%09SIGWINCH    = syscall.Signal(0x1c)%0A%09SIGXCPU     = syscall.Signal(0x18)%0A%09SIGXFSZ     = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22not owner%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22I/O error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22arg list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file number%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EWOULDBLOCK%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22not enough space%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22ENOTEMPTY%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22file table overflow%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22not a typewriter%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22deadlock condition if locked%22%7D,%0A%09%7B46, %22ENOTREADY%22, %22device not ready%22%7D,%0A%09%7B47, %22EWRPROTECT%22, %22write-protected media%22%7D,%0A%09%7B48, %22EFORMAT%22, %22unformatted or incompatible media%22%7D,%0A%09%7B49, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22ENOCONNECT%22, %22cannot Establish Connection%22%7D,%0A%09%7B52, %22ESTALE%22, %22missing file or filesystem%22%7D,%0A%09%7B53, %22EDIST%22, %22requests blocked by Administrator%22%7D,%0A%09%7B55, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B56, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B57, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B58, %22EDESTADDREQ%22, %22destination address required%22%7D,%0A%09%7B59, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B60, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B61, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B62, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B63, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B64, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B65, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B66, %22EAFNOSUPPORT%22, %22addr family not supported by protocol%22%7D,%0A%09%7B67, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B68, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B69, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B70, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B71, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B72, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B73, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B74, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B75, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B76, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B77, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B78, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B79, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B80, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B81, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B82, %22ERESTART%22, %22restart the system call%22%7D,%0A%09%7B83, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B84, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B85, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B86, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B88, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B89, %22ECORRUPT%22, %22invalid file system control data detected%22%7D,%0A%09%7B90, %22ESYSERROR%22, %22for future use %22%7D,%0A%09%7B93, %22EREMOTE%22, %22item is not local to host%22%7D,%0A%09%7B94, %22ENOTRECOVERABLE%22, %22state not recoverable %22%7D,%0A%09%7B95, %22EOWNERDEAD%22, %22previous owner died %22%7D,%0A%09%7B109, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B110, %22EMEDIA%22, %22media surface error%22%7D,%0A%09%7B111, %22ESOFT%22, %22I/O completed, but needs relocation%22%7D,%0A%09%7B112, %22ENOATTR%22, %22no attribute found%22%7D,%0A%09%7B113, %22ESAD%22, %22security Authentication Denied%22%7D,%0A%09%7B114, %22ENOTRUST%22, %22not a Trusted Program%22%7D,%0A%09%7B115, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B116, %22EILSEQ%22, %22invalid wide character%22%7D,%0A%09%7B117, %22ECANCELED%22, %22asynchronous I/O cancelled%22%7D,%0A%09%7B118, %22ENOSR%22, %22out of STREAMS resources%22%7D,%0A%09%7B119, %22ETIME%22, %22system call timed out%22%7D,%0A%09%7B120, %22EBADMSG%22, %22next message has wrong type%22%7D,%0A%09%7B121, %22EPROTO%22, %22error in protocol%22%7D,%0A%09%7B122, %22ENODATA%22, %22no message on stream head read q%22%7D,%0A%09%7B123, %22ENOSTR%22, %22fd not associated with a stream%22%7D,%0A%09%7B124, %22ENOTSUP%22, %22unsupported attribute value%22%7D,%0A%09%7B125, %22EMULTIHOP%22, %22multihop is not allowed%22%7D,%0A%09%7B126, %22ENOLINK%22, %22the server link has been severed%22%7D,%0A%09%7B127, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22IOT/Abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible/complete%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B27, %22SIGMSG%22, %22input device data%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGPWR%22, %22power-failure%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B33, %22SIGDANGER%22, %22paging space low%22%7D,%0A%09%7B34, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B35, %22SIGMIGRATE%22, %22signal 35%22%7D,%0A%09%7B36, %22SIGPRE%22, %22signal 36%22%7D,%0A%09%7B37, %22SIGVIRT%22, %22signal 37%22%7D,%0A%09%7B38, %22SIGTALRM%22, %22signal 38%22%7D,%0A%09%7B39, %22SIGWAITING%22, %22signal 39%22%7D,%0A%09%7B48, %22SIGSYSERROR%22, %22signal 48%22%7D,%0A%09%7B49, %22SIGCAPI%22, %22signal 49%22%7D,%0A%09%7B58, %22SIGRECONFIG%22, %22signal 58%22%7D,%0A%09%7B59, %22SIGCPUFAIL%22, %22CPU Failure Predicted%22%7D,%0A%09%7B60, %22SIGGRANT%22, %22monitor mode granted%22%7D,%0A%09%7B61, %22SIGRETRACT%22, %22monitor mode retracted%22%7D,%0A%09%7B62, %22SIGSOUND%22, %22sound completed%22%7D,%0A%09%7B63, %22SIGMAX32%22, %22secure attention%22%7D,%0A%09%7B255, %22SIGMAX%22, %22signal 255%22%7D,%0A%7D%0A
- f 61105021886fa245193d39381c8399b33769573a1536b678a4f2a33294084706 vendor/golang.org/x/sys/unix/zerrors_darwin_386.go
+ f 56d6a52ad97c002c82ddf73514134c765d5aa1da0bd4a37aa5cd25fd22c740e6 vendor/golang.org/x/sys/unix/zerrors_darwin_386.go
dmppatch 3
@@ -67340,8 +67340,7171 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EPWROFF%22, %22device power is off%22%7D,%0A%09%7B83, %22EDEVERR%22, %22device error%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EBADEXEC%22, %22bad executable (or shared library)%22%7D,%0A%09%7B86, %22EBADARCH%22, %22bad CPU type in executable%22%7D,%0A%09%7B87, %22ESHLIBVERS%22, %22shared library version mismatch%22%7D,%0A%09%7B88, %22EBADMACHO%22, %22malformed Mach-o file%22%7D,%0A%09%7B89, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B90, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B91, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B92, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B95, %22EMULTIHOP%22, %22EMULTIHOP (Reserved)%22%7D,%0A%09%7B96, %22ENODATA%22, %22no message available on STREAM%22%7D,%0A%09%7B97, %22ENOLINK%22, %22ENOLINK (Reserved)%22%7D,%0A%09%7B98, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B99, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B100, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B101, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B102, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B103, %22ENOPOLICY%22, %22policy not found%22%7D,%0A%09%7B104, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B105, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%09%7B106, %22EQFULL%22, %22interface output queue is full%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%7D%0A
- f d539341351cefca79153ce7eb7eed5774ef79adfca1ea78ffaa1b1202b8efe15 vendor/golang.org/x/sys/unix/zerrors_darwin_amd64.go
+ f acde9c12dd94d6e4892414217f9fe5d6ebc661b2f14c7a9302c8cf2bd7d6ea32 vendor/golang.org/x/sys/unix/zerrors_darwin_amd64.go
dmppatch 3
@@ -67342,8 +67342,7171 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EPWROFF%22, %22device power is off%22%7D,%0A%09%7B83, %22EDEVERR%22, %22device error%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EBADEXEC%22, %22bad executable (or shared library)%22%7D,%0A%09%7B86, %22EBADARCH%22, %22bad CPU type in executable%22%7D,%0A%09%7B87, %22ESHLIBVERS%22, %22shared library version mismatch%22%7D,%0A%09%7B88, %22EBADMACHO%22, %22malformed Mach-o file%22%7D,%0A%09%7B89, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B90, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B91, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B92, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B95, %22EMULTIHOP%22, %22EMULTIHOP (Reserved)%22%7D,%0A%09%7B96, %22ENODATA%22, %22no message available on STREAM%22%7D,%0A%09%7B97, %22ENOLINK%22, %22ENOLINK (Reserved)%22%7D,%0A%09%7B98, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B99, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B100, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B101, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B102, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B103, %22ENOPOLICY%22, %22policy not found%22%7D,%0A%09%7B104, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B105, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%09%7B106, %22EQFULL%22, %22interface output queue is full%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%7D%0A
- f 55d7d6271d55dd78cc0b2a8fecf3e1336fdf8ec17d12013403e8e2527d2fbe2f vendor/golang.org/x/sys/unix/zerrors_darwin_arm.go
+ f 7b0cad835fd595d7f5d70f0b3398f17e6c37c0d2ba66b4d4a59f9861c6732748 vendor/golang.org/x/sys/unix/zerrors_darwin_arm.go
dmppatch 3
@@ -67330,8 +67330,7171 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EPWROFF%22, %22device power is off%22%7D,%0A%09%7B83, %22EDEVERR%22, %22device error%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EBADEXEC%22, %22bad executable (or shared library)%22%7D,%0A%09%7B86, %22EBADARCH%22, %22bad CPU type in executable%22%7D,%0A%09%7B87, %22ESHLIBVERS%22, %22shared library version mismatch%22%7D,%0A%09%7B88, %22EBADMACHO%22, %22malformed Mach-o file%22%7D,%0A%09%7B89, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B90, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B91, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B92, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B95, %22EMULTIHOP%22, %22EMULTIHOP (Reserved)%22%7D,%0A%09%7B96, %22ENODATA%22, %22no message available on STREAM%22%7D,%0A%09%7B97, %22ENOLINK%22, %22ENOLINK (Reserved)%22%7D,%0A%09%7B98, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B99, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B100, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B101, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B102, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B103, %22ENOPOLICY%22, %22policy not found%22%7D,%0A%09%7B104, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B105, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%09%7B106, %22EQFULL%22, %22interface output queue is full%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%7D%0A
- f 95679bc312caf01f8eb06937be8e8b254d97f70675b21f41debe4bc8adae6c90 vendor/golang.org/x/sys/unix/zerrors_darwin_arm64.go
+ f 3705115758d0628af056d65429e7704dbea4388d20ea3ece8e5bc8f409686161 vendor/golang.org/x/sys/unix/zerrors_darwin_arm64.go
dmppatch 3
@@ -67342,8 +67342,7171 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EPWROFF%22, %22device power is off%22%7D,%0A%09%7B83, %22EDEVERR%22, %22device error%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EBADEXEC%22, %22bad executable (or shared library)%22%7D,%0A%09%7B86, %22EBADARCH%22, %22bad CPU type in executable%22%7D,%0A%09%7B87, %22ESHLIBVERS%22, %22shared library version mismatch%22%7D,%0A%09%7B88, %22EBADMACHO%22, %22malformed Mach-o file%22%7D,%0A%09%7B89, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B90, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B91, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B92, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B95, %22EMULTIHOP%22, %22EMULTIHOP (Reserved)%22%7D,%0A%09%7B96, %22ENODATA%22, %22no message available on STREAM%22%7D,%0A%09%7B97, %22ENOLINK%22, %22ENOLINK (Reserved)%22%7D,%0A%09%7B98, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B99, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B100, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B101, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B102, %22EOPNOTSUPP%22, %22operation not supported on socket%22%7D,%0A%09%7B103, %22ENOPOLICY%22, %22policy not found%22%7D,%0A%09%7B104, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B105, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%09%7B106, %22EQFULL%22, %22interface output queue is full%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%7D%0A
- f d78143017ec135cc3be5b88a7ac73dd6c7462a57a8667dcb3b7c9ed6770d6419 vendor/golang.org/x/sys/unix/zerrors_dragonfly_amd64.go
+ f 2cc563f87ef5580b28c8db48d6ed8c19e06da919ce6a16dae82ab27e2a179779 vendor/golang.org/x/sys/unix/zerrors_dragonfly_amd64.go
dmppatch 16
@@ -113,48 +113,59 @@
 ly%0A%0A
-// Created by cgo -godefs - DO NOT EDIT%0A
+// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A
 // c
@@ -36855,24 +36855,1523 @@
       = 0x2%0A
+%09MNT_ASYNC                         = 0x40%0A%09MNT_AUTOMOUNTED                   = 0x20%0A%09MNT_CMDFLAGS                      = 0xf0000%0A%09MNT_DEFEXPORTED                   = 0x200%0A%09MNT_DELEXPORT                     = 0x20000%0A%09MNT_EXKERB                        = 0x800%0A%09MNT_EXPORTANON                    = 0x400%0A%09MNT_EXPORTED                      = 0x100%0A%09MNT_EXPUBLIC                      = 0x20000000%0A%09MNT_EXRDONLY                      = 0x80%0A%09MNT_FORCE                         = 0x80000%0A%09MNT_IGNORE                        = 0x800000%0A%09MNT_LAZY                          = 0x4%0A%09MNT_LOCAL                         = 0x1000%0A%09MNT_NOATIME                       = 0x10000000%0A%09MNT_NOCLUSTERR                    = 0x40000000%0A%09MNT_NOCLUSTERW                    = 0x80000000%0A%09MNT_NODEV                         = 0x10%0A%09MNT_NOEXEC                        = 0x4%0A%09MNT_NOSUID                        = 0x8%0A%09MNT_NOSYMFOLLOW                   = 0x400000%0A%09MNT_NOWAIT                        = 0x2%0A%09MNT_QUOTA                         = 0x2000%0A%09MNT_RDONLY                        = 0x1%0A%09MNT_RELOAD                        = 0x40000%0A%09MNT_ROOTFS                        = 0x4000%0A%09MNT_SOFTDEP                       = 0x200000%0A%09MNT_SUIDDIR                       = 0x100000%0A%09MNT_SYNCHRONOUS                   = 0x2%0A%09MNT_TRIM                          = 0x1000000%0A%09MNT_UPDATE                        = 0x10000%0A%09MNT_USER                          = 0x8000%0A%09MNT_VISFLAGMASK                   = 0xf1f0ffff%0A%09MNT_WAIT                          = 0x1%0A
 %09MSG_CMSG_CL
@@ -50983,16 +50983,1299 @@
  = 0x40%0A
+%09S_BLKSIZE                         = 0x200%0A%09S_IEXEC                           = 0x40%0A%09S_IFBLK                           = 0x6000%0A%09S_IFCHR                           = 0x2000%0A%09S_IFDB                            = 0x9000%0A%09S_IFDIR                           = 0x4000%0A%09S_IFIFO                           = 0x1000%0A%09S_IFLNK                           = 0xa000%0A%09S_IFMT                            = 0xf000%0A%09S_IFREG                           = 0x8000%0A%09S_IFSOCK                          = 0xc000%0A%09S_IFWHT                           = 0xe000%0A%09S_IREAD                           = 0x100%0A%09S_IRGRP                           = 0x20%0A%09S_IROTH                           = 0x4%0A%09S_IRUSR                           = 0x100%0A%09S_IRWXG                           = 0x38%0A%09S_IRWXO                           = 0x7%0A%09S_IRWXU                           = 0x1c0%0A%09S_ISGID                           = 0x400%0A%09S_ISTXT                           = 0x200%0A%09S_ISUID                           = 0x800%0A%09S_ISVTX                           = 0x200%0A%09S_IWGRP                           = 0x10%0A%09S_IWOTH                           = 0x2%0A%09S_IWRITE                          = 0x80%0A%09S_IWUSR                           = 0x80%0A%09S_IXGRP                           = 0x8%0A%09S_IXOTH                           = 0x1%0A%09S_IXUSR                           = 0x40%0A
 %09TCIFLUS
@@ -61598,8 +61598,7081 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT     = syscall.Signal(0x6)%0A%09SIGALRM     = syscall.Signal(0xe)%0A%09SIGBUS      = syscall.Signal(0xa)%0A%09SIGCHLD     = syscall.Signal(0x14)%0A%09SIGCKPT     = syscall.Signal(0x21)%0A%09SIGCKPTEXIT = syscall.Signal(0x22)%0A%09SIGCONT     = syscall.Signal(0x13)%0A%09SIGEMT      = syscall.Signal(0x7)%0A%09SIGFPE      = syscall.Signal(0x8)%0A%09SIGHUP      = syscall.Signal(0x1)%0A%09SIGILL      = syscall.Signal(0x4)%0A%09SIGINFO     = syscall.Signal(0x1d)%0A%09SIGINT      = syscall.Signal(0x2)%0A%09SIGIO       = syscall.Signal(0x17)%0A%09SIGIOT      = syscall.Signal(0x6)%0A%09SIGKILL     = syscall.Signal(0x9)%0A%09SIGPIPE     = syscall.Signal(0xd)%0A%09SIGPROF     = syscall.Signal(0x1b)%0A%09SIGQUIT     = syscall.Signal(0x3)%0A%09SIGSEGV     = syscall.Signal(0xb)%0A%09SIGSTOP     = syscall.Signal(0x11)%0A%09SIGSYS      = syscall.Signal(0xc)%0A%09SIGTERM     = syscall.Signal(0xf)%0A%09SIGTHR      = syscall.Signal(0x20)%0A%09SIGTRAP     = syscall.Signal(0x5)%0A%09SIGTSTP     = syscall.Signal(0x12)%0A%09SIGTTIN     = syscall.Signal(0x15)%0A%09SIGTTOU     = syscall.Signal(0x16)%0A%09SIGURG      = syscall.Signal(0x10)%0A%09SIGUSR1     = syscall.Signal(0x1e)%0A%09SIGUSR2     = syscall.Signal(0x1f)%0A%09SIGVTALRM   = syscall.Signal(0x1a)%0A%09SIGWINCH    = syscall.Signal(0x1c)%0A%09SIGXCPU     = syscall.Signal(0x18)%0A%09SIGXFSZ     = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EWOULDBLOCK%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B86, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B87, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B88, %22EDOOFUS%22, %22programming error%22%7D,%0A%09%7B89, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B90, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B91, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B92, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B93, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B94, %22EUNUSED94%22, %22unknown error: 94%22%7D,%0A%09%7B95, %22EUNUSED95%22, %22unknown error: 95%22%7D,%0A%09%7B96, %22EUNUSED96%22, %22unknown error: 96%22%7D,%0A%09%7B97, %22EUNUSED97%22, %22unknown error: 97%22%7D,%0A%09%7B98, %22EUNUSED98%22, %22unknown error: 98%22%7D,%0A%09%7B99, %22ELAST%22, %22unknown error: 99%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22thread Scheduler%22%7D,%0A%09%7B33, %22SIGCKPT%22, %22checkPoint%22%7D,%0A%09%7B34, %22SIGCKPTEXIT%22, %22checkPointExit%22%7D,%0A%7D%0A
- f 1dc86d1337bdddc33c069776c0b862433157ef33feb0961a0fc0ac358dcdbf46 vendor/golang.org/x/sys/unix/zerrors_freebsd_386.go
+ f 9ed273a2456ed4be2512c5b240bbe07ddf2933c07b98772bb3c01602eac04fe7 vendor/golang.org/x/sys/unix/zerrors_freebsd_386.go
dmppatch 7
@@ -54328,16 +54328,1168 @@
 0000000%0A
+%09S_BLKSIZE                      = 0x200%0A%09S_IEXEC                        = 0x40%0A%09S_IFBLK                        = 0x6000%0A%09S_IFCHR                        = 0x2000%0A%09S_IFDIR                        = 0x4000%0A%09S_IFIFO                        = 0x1000%0A%09S_IFLNK                        = 0xa000%0A%09S_IFMT                         = 0xf000%0A%09S_IFREG                        = 0x8000%0A%09S_IFSOCK                       = 0xc000%0A%09S_IFWHT                        = 0xe000%0A%09S_IREAD                        = 0x100%0A%09S_IRGRP                        = 0x20%0A%09S_IROTH                        = 0x4%0A%09S_IRUSR                        = 0x100%0A%09S_IRWXG                        = 0x38%0A%09S_IRWXO                        = 0x7%0A%09S_IRWXU                        = 0x1c0%0A%09S_ISGID                        = 0x400%0A%09S_ISTXT                        = 0x200%0A%09S_ISUID                        = 0x800%0A%09S_ISVTX                        = 0x200%0A%09S_IWGRP                        = 0x10%0A%09S_IWOTH                        = 0x2%0A%09S_IWRITE                       = 0x80%0A%09S_IWUSR                        = 0x80%0A%09S_IXGRP                        = 0x8%0A%09S_IXOTH                        = 0x1%0A%09S_IXUSR                        = 0x40%0A
 %09TAB0   
@@ -64613,8 +64613,6889 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGLIBRT  = syscall.Signal(0x21)%0A%09SIGLWP    = syscall.Signal(0x20)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B86, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B87, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B88, %22EDOOFUS%22, %22programming error%22%7D,%0A%09%7B89, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B90, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B91, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B92, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B93, %22ENOTCAPABLE%22, %22capabilities insufficient%22%7D,%0A%09%7B94, %22ECAPMODE%22, %22not permitted in capability mode%22%7D,%0A%09%7B95, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B96, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22unknown signal%22%7D,%0A%09%7B33, %22SIGLIBRT%22, %22unknown signal%22%7D,%0A%7D%0A
- f 3bf1d6e817d41a60d52aedfa07e908901b8ccfb32730a2d93fa90ee9dc1e7108 vendor/golang.org/x/sys/unix/zerrors_freebsd_amd64.go
+ f f3ad8d252e72d16d89cd5d6c7598e8fd7708235e1d028a0be6c56fd9d1a8e24f vendor/golang.org/x/sys/unix/zerrors_freebsd_amd64.go
dmppatch 7
@@ -54380,16 +54380,1168 @@
 0000000%0A
+%09S_BLKSIZE                      = 0x200%0A%09S_IEXEC                        = 0x40%0A%09S_IFBLK                        = 0x6000%0A%09S_IFCHR                        = 0x2000%0A%09S_IFDIR                        = 0x4000%0A%09S_IFIFO                        = 0x1000%0A%09S_IFLNK                        = 0xa000%0A%09S_IFMT                         = 0xf000%0A%09S_IFREG                        = 0x8000%0A%09S_IFSOCK                       = 0xc000%0A%09S_IFWHT                        = 0xe000%0A%09S_IREAD                        = 0x100%0A%09S_IRGRP                        = 0x20%0A%09S_IROTH                        = 0x4%0A%09S_IRUSR                        = 0x100%0A%09S_IRWXG                        = 0x38%0A%09S_IRWXO                        = 0x7%0A%09S_IRWXU                        = 0x1c0%0A%09S_ISGID                        = 0x400%0A%09S_ISTXT                        = 0x200%0A%09S_ISUID                        = 0x800%0A%09S_ISVTX                        = 0x200%0A%09S_IWGRP                        = 0x10%0A%09S_IWOTH                        = 0x2%0A%09S_IWRITE                       = 0x80%0A%09S_IWUSR                        = 0x80%0A%09S_IXGRP                        = 0x8%0A%09S_IXOTH                        = 0x1%0A%09S_IXUSR                        = 0x40%0A
 %09TAB0   
@@ -64665,8 +64665,6889 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGLIBRT  = syscall.Signal(0x21)%0A%09SIGLWP    = syscall.Signal(0x20)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B86, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B87, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B88, %22EDOOFUS%22, %22programming error%22%7D,%0A%09%7B89, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B90, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B91, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B92, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B93, %22ENOTCAPABLE%22, %22capabilities insufficient%22%7D,%0A%09%7B94, %22ECAPMODE%22, %22not permitted in capability mode%22%7D,%0A%09%7B95, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B96, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22unknown signal%22%7D,%0A%09%7B33, %22SIGLIBRT%22, %22unknown signal%22%7D,%0A%7D%0A
- f f9b6f3536ca15d4b6c8e6db37b86d82b077d82d93034c5adca9df0aeb5ad0dc3 vendor/golang.org/x/sys/unix/zerrors_freebsd_arm.go
+ f 2f29bb62e1d829e9ac1263a3d395a708da5382de8ad5ab29a922a19d6f475bdb vendor/golang.org/x/sys/unix/zerrors_freebsd_arm.go
dmppatch 7
@@ -54686,16 +54686,1168 @@
 0000000%0A
+%09S_BLKSIZE                      = 0x200%0A%09S_IEXEC                        = 0x40%0A%09S_IFBLK                        = 0x6000%0A%09S_IFCHR                        = 0x2000%0A%09S_IFDIR                        = 0x4000%0A%09S_IFIFO                        = 0x1000%0A%09S_IFLNK                        = 0xa000%0A%09S_IFMT                         = 0xf000%0A%09S_IFREG                        = 0x8000%0A%09S_IFSOCK                       = 0xc000%0A%09S_IFWHT                        = 0xe000%0A%09S_IREAD                        = 0x100%0A%09S_IRGRP                        = 0x20%0A%09S_IROTH                        = 0x4%0A%09S_IRUSR                        = 0x100%0A%09S_IRWXG                        = 0x38%0A%09S_IRWXO                        = 0x7%0A%09S_IRWXU                        = 0x1c0%0A%09S_ISGID                        = 0x400%0A%09S_ISTXT                        = 0x200%0A%09S_ISUID                        = 0x800%0A%09S_ISVTX                        = 0x200%0A%09S_IWGRP                        = 0x10%0A%09S_IWOTH                        = 0x2%0A%09S_IWRITE                       = 0x80%0A%09S_IWUSR                        = 0x80%0A%09S_IXGRP                        = 0x8%0A%09S_IXOTH                        = 0x1%0A%09S_IXUSR                        = 0x40%0A
 %09TAB0   
@@ -64971,8 +64971,6889 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGLIBRT  = syscall.Signal(0x21)%0A%09SIGLWP    = syscall.Signal(0x20)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B86, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B87, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B88, %22EDOOFUS%22, %22programming error%22%7D,%0A%09%7B89, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B90, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B91, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B92, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B93, %22ENOTCAPABLE%22, %22capabilities insufficient%22%7D,%0A%09%7B94, %22ECAPMODE%22, %22not permitted in capability mode%22%7D,%0A%09%7B95, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B96, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22unknown signal%22%7D,%0A%09%7B33, %22SIGLIBRT%22, %22unknown signal%22%7D,%0A%7D%0A
- f 09c6eb8f2be57878b575bb4c8790e0bc9b7425c5d5e9676ea67b60fe26221305 vendor/golang.org/x/sys/unix/zerrors_linux_386.go
+ f 77971395a48bf20809fa2fe73d4c1e15dafecc0982be95e7303861c4b24bb703 vendor/golang.org/x/sys/unix/zerrors_linux_386.go
dmppatch 27
@@ -2691,16 +2691,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44403,16 +44403,749 @@
   = 0x4%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -82544,16 +82544,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -86861,16 +86861,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -97791,16 +97791,777 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x40186f40%0A%09UBI_IOCDET                           = 0x40046f41%0A%09UBI_IOCEBCH                          = 0x40044f02%0A%09UBI_IOCEBER                          = 0x40044f01%0A%09UBI_IOCEBISMAP                       = 0x80044f05%0A%09UBI_IOCEBMAP                         = 0x40084f03%0A%09UBI_IOCEBUNMAP                       = 0x40044f04%0A%09UBI_IOCMKVOL                         = 0x40986f00%0A%09UBI_IOCRMVOL                         = 0x40046f01%0A%09UBI_IOCRNVOL                         = 0x51106f03%0A%09UBI_IOCRSVOL                         = 0x400c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x40104f06%0A%09UBI_IOCVOLCRBLK                      = 0x40804f07%0A%09UBI_IOCVOLRMBLK                      = 0x4f08%0A%09UBI_IOCVOLUP                         = 0x40084f00%0A
 %09UDF_SUP
@@ -104820,16 +104820,919 @@
   = 0x4%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -111105,8 +111105,8428 @@
 0x36)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f 73608c6636825666deb10e59c495458ddba75cec357943eef8015feab39e47a4 vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
+ f e86d0977999451a8e317f552709e0ba543bd5072426528b47273cb46d1b28fe3 vendor/golang.org/x/sys/unix/zerrors_linux_amd64.go
dmppatch 27
@@ -2693,16 +2693,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44405,16 +44405,749 @@
   = 0x4%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -82596,16 +82596,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -86913,16 +86913,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -97843,16 +97843,777 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x40186f40%0A%09UBI_IOCDET                           = 0x40046f41%0A%09UBI_IOCEBCH                          = 0x40044f02%0A%09UBI_IOCEBER                          = 0x40044f01%0A%09UBI_IOCEBISMAP                       = 0x80044f05%0A%09UBI_IOCEBMAP                         = 0x40084f03%0A%09UBI_IOCEBUNMAP                       = 0x40044f04%0A%09UBI_IOCMKVOL                         = 0x40986f00%0A%09UBI_IOCRMVOL                         = 0x40046f01%0A%09UBI_IOCRNVOL                         = 0x51106f03%0A%09UBI_IOCRSVOL                         = 0x400c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x40104f06%0A%09UBI_IOCVOLCRBLK                      = 0x40804f07%0A%09UBI_IOCVOLRMBLK                      = 0x4f08%0A%09UBI_IOCVOLUP                         = 0x40084f00%0A
 %09UDF_SUP
@@ -104828,16 +104828,919 @@
   = 0x4%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -111113,8 +111113,8428 @@
 0x36)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f d9ed8ff20c0a4ab7024125aaae53e4b4e8a57d6b9f830b1f68e375bc4b69dc55 vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
+ f 4bab03a3716857dd32a7f52f83e22b2b6a823485dfacc317a445831d2915dde1 vendor/golang.org/x/sys/unix/zerrors_linux_arm.go
dmppatch 27
@@ -2681,16 +2681,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44297,16 +44297,749 @@
   = 0x4%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -82850,16 +82850,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -87167,16 +87167,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -98097,16 +98097,777 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x40186f40%0A%09UBI_IOCDET                           = 0x40046f41%0A%09UBI_IOCEBCH                          = 0x40044f02%0A%09UBI_IOCEBER                          = 0x40044f01%0A%09UBI_IOCEBISMAP                       = 0x80044f05%0A%09UBI_IOCEBMAP                         = 0x40084f03%0A%09UBI_IOCEBUNMAP                       = 0x40044f04%0A%09UBI_IOCMKVOL                         = 0x40986f00%0A%09UBI_IOCRMVOL                         = 0x40046f01%0A%09UBI_IOCRNVOL                         = 0x51106f03%0A%09UBI_IOCRSVOL                         = 0x400c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x40104f06%0A%09UBI_IOCVOLCRBLK                      = 0x40804f07%0A%09UBI_IOCVOLRMBLK                      = 0x4f08%0A%09UBI_IOCVOLUP                         = 0x40084f00%0A
 %09UDF_SUP
@@ -105082,16 +105082,919 @@
   = 0x4%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -111367,8 +111367,8428 @@
 0x36)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f e77fa87e255e0687e0c2dfaab76f7e50d76b11d6ac5d09a1e0466af3caed22d6 vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
+ f 62a25ae714cb3e3faf99a3eda0c0103d77f700e0ace0ca0e7dc5d0f490d2e55b vendor/golang.org/x/sys/unix/zerrors_linux_arm64.go
dmppatch 27
@@ -2711,16 +2711,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44480,16 +44480,749 @@
   = 0x4%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -82177,16 +82177,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -86545,16 +86545,148 @@
 3564501%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -97475,16 +97475,777 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x40186f40%0A%09UBI_IOCDET                           = 0x40046f41%0A%09UBI_IOCEBCH                          = 0x40044f02%0A%09UBI_IOCEBER                          = 0x40044f01%0A%09UBI_IOCEBISMAP                       = 0x80044f05%0A%09UBI_IOCEBMAP                         = 0x40084f03%0A%09UBI_IOCEBUNMAP                       = 0x40044f04%0A%09UBI_IOCMKVOL                         = 0x40986f00%0A%09UBI_IOCRMVOL                         = 0x40046f01%0A%09UBI_IOCRNVOL                         = 0x51106f03%0A%09UBI_IOCRSVOL                         = 0x400c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x40104f06%0A%09UBI_IOCVOLCRBLK                      = 0x40804f07%0A%09UBI_IOCVOLRMBLK                      = 0x4f08%0A%09UBI_IOCVOLUP                         = 0x40084f00%0A
 %09UDF_SUP
@@ -104460,16 +104460,919 @@
   = 0x4%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -110745,8 +110745,8428 @@
 0x36)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f ca158dd7ad5a8023c807c8280fee6e4227c2b71a5e085f39d6416ce0b1df893d vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
+ f d4086a2720a52bf04eaf84bf06bc49e3c8897b486a29623ae90d14ca80fbe34f vendor/golang.org/x/sys/unix/zerrors_linux_mips.go
dmppatch 27
@@ -2682,16 +2682,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44362,16 +44362,749 @@
   = 0x4%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -82653,16 +82653,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -87050,16 +87050,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -98068,16 +98068,781 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x80186f40%0A%09UBI_IOCDET                           = 0x80046f41%0A%09UBI_IOCEBCH                          = 0x80044f02%0A%09UBI_IOCEBER                          = 0x80044f01%0A%09UBI_IOCEBISMAP                       = 0x40044f05%0A%09UBI_IOCEBMAP                         = 0x80084f03%0A%09UBI_IOCEBUNMAP                       = 0x80044f04%0A%09UBI_IOCMKVOL                         = 0x80986f00%0A%09UBI_IOCRMVOL                         = 0x80046f01%0A%09UBI_IOCRNVOL                         = 0x91106f03%0A%09UBI_IOCRSVOL                         = 0x800c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x80104f06%0A%09UBI_IOCVOLCRBLK                      = 0x80804f07%0A%09UBI_IOCVOLRMBLK                      = 0x20004f08%0A%09UBI_IOCVOLUP                         = 0x80084f00%0A
 %09UDF_SUP
@@ -105102,16 +105102,919 @@
   = 0x4%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -111466,8 +111466,8559 @@
 0x34)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x12)%0A%09SIGCLD    = syscall.Signal(0x12)%0A%09SIGCONT   = syscall.Signal(0x19)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x16)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x16)%0A%09SIGPROF   = syscall.Signal(0x1d)%0A%09SIGPWR    = syscall.Signal(0x13)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x17)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x18)%0A%09SIGTTIN   = syscall.Signal(0x1a)%0A%09SIGTTOU   = syscall.Signal(0x1b)%0A%09SIGURG    = syscall.Signal(0x15)%0A%09SIGUSR1   = syscall.Signal(0x10)%0A%09SIGUSR2   = syscall.Signal(0x11)%0A%09SIGVTALRM = syscall.Signal(0x1c)%0A%09SIGWINCH  = syscall.Signal(0x14)%0A%09SIGXCPU   = syscall.Signal(0x1e)%0A%09SIGXFSZ   = syscall.Signal(0x1f)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B51, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B53, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B54, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B89, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B90, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B91, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B135, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B137, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B138, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B139, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B140, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B141, %22EINIT%22, %22unknown error 141%22%7D,%0A%09%7B142, %22EREMDEV%22, %22unknown error 142%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B158, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B159, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B160, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B161, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B162, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B163, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B164, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B165, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B166, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B167, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B168, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%09%7B1133, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%7D%0A
- f 1efb854c742c39a64a30c70e0b379c00d907d3b0404bd9e8aca9efd95d31cb47 vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
+ f 4e24d95e9f7e5a78ab05d5cb768d944036d6cee2e0f24122394b29c152ea5c14 vendor/golang.org/x/sys/unix/zerrors_linux_mips64.go
dmppatch 27
@@ -2684,16 +2684,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44358,16 +44358,749 @@
   = 0x4%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -82654,16 +82654,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -87051,16 +87051,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -98069,16 +98069,781 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x80186f40%0A%09UBI_IOCDET                           = 0x80046f41%0A%09UBI_IOCEBCH                          = 0x80044f02%0A%09UBI_IOCEBER                          = 0x80044f01%0A%09UBI_IOCEBISMAP                       = 0x40044f05%0A%09UBI_IOCEBMAP                         = 0x80084f03%0A%09UBI_IOCEBUNMAP                       = 0x80044f04%0A%09UBI_IOCMKVOL                         = 0x80986f00%0A%09UBI_IOCRMVOL                         = 0x80046f01%0A%09UBI_IOCRNVOL                         = 0x91106f03%0A%09UBI_IOCRSVOL                         = 0x800c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x80104f06%0A%09UBI_IOCVOLCRBLK                      = 0x80804f07%0A%09UBI_IOCVOLRMBLK                      = 0x20004f08%0A%09UBI_IOCVOLUP                         = 0x80084f00%0A
 %09UDF_SUP
@@ -105103,16 +105103,919 @@
   = 0x4%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -111467,8 +111467,8559 @@
 0x34)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x12)%0A%09SIGCLD    = syscall.Signal(0x12)%0A%09SIGCONT   = syscall.Signal(0x19)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x16)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x16)%0A%09SIGPROF   = syscall.Signal(0x1d)%0A%09SIGPWR    = syscall.Signal(0x13)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x17)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x18)%0A%09SIGTTIN   = syscall.Signal(0x1a)%0A%09SIGTTOU   = syscall.Signal(0x1b)%0A%09SIGURG    = syscall.Signal(0x15)%0A%09SIGUSR1   = syscall.Signal(0x10)%0A%09SIGUSR2   = syscall.Signal(0x11)%0A%09SIGVTALRM = syscall.Signal(0x1c)%0A%09SIGWINCH  = syscall.Signal(0x14)%0A%09SIGXCPU   = syscall.Signal(0x1e)%0A%09SIGXFSZ   = syscall.Signal(0x1f)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B51, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B53, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B54, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B89, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B90, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B91, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B135, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B137, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B138, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B139, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B140, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B141, %22EINIT%22, %22unknown error 141%22%7D,%0A%09%7B142, %22EREMDEV%22, %22unknown error 142%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B158, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B159, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B160, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B161, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B162, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B163, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B164, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B165, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B166, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B167, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B168, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%09%7B1133, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%7D%0A
- f df307b9e034e93fe4381ce0d4b1295a4b2b04c31e568622da9f6cfd6d58b4193 vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
+ f 948136c059d64439a33206e9732623e6497b6fd89dc892675fdf607ed7e37fc0 vendor/golang.org/x/sys/unix/zerrors_linux_mips64le.go
dmppatch 27
@@ -2686,16 +2686,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44360,16 +44360,749 @@
   = 0x4%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -82656,16 +82656,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -87053,16 +87053,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -98071,16 +98071,781 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x80186f40%0A%09UBI_IOCDET                           = 0x80046f41%0A%09UBI_IOCEBCH                          = 0x80044f02%0A%09UBI_IOCEBER                          = 0x80044f01%0A%09UBI_IOCEBISMAP                       = 0x40044f05%0A%09UBI_IOCEBMAP                         = 0x80084f03%0A%09UBI_IOCEBUNMAP                       = 0x80044f04%0A%09UBI_IOCMKVOL                         = 0x80986f00%0A%09UBI_IOCRMVOL                         = 0x80046f01%0A%09UBI_IOCRNVOL                         = 0x91106f03%0A%09UBI_IOCRSVOL                         = 0x800c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x80104f06%0A%09UBI_IOCVOLCRBLK                      = 0x80804f07%0A%09UBI_IOCVOLRMBLK                      = 0x20004f08%0A%09UBI_IOCVOLUP                         = 0x80084f00%0A
 %09UDF_SUP
@@ -105105,16 +105105,919 @@
   = 0x4%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -111469,8 +111469,8559 @@
 0x34)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x12)%0A%09SIGCLD    = syscall.Signal(0x12)%0A%09SIGCONT   = syscall.Signal(0x19)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x16)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x16)%0A%09SIGPROF   = syscall.Signal(0x1d)%0A%09SIGPWR    = syscall.Signal(0x13)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x17)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x18)%0A%09SIGTTIN   = syscall.Signal(0x1a)%0A%09SIGTTOU   = syscall.Signal(0x1b)%0A%09SIGURG    = syscall.Signal(0x15)%0A%09SIGUSR1   = syscall.Signal(0x10)%0A%09SIGUSR2   = syscall.Signal(0x11)%0A%09SIGVTALRM = syscall.Signal(0x1c)%0A%09SIGWINCH  = syscall.Signal(0x14)%0A%09SIGXCPU   = syscall.Signal(0x1e)%0A%09SIGXFSZ   = syscall.Signal(0x1f)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B51, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B53, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B54, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B89, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B90, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B91, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B135, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B137, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B138, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B139, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B140, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B141, %22EINIT%22, %22unknown error 141%22%7D,%0A%09%7B142, %22EREMDEV%22, %22unknown error 142%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B158, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B159, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B160, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B161, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B162, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B163, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B164, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B165, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B166, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B167, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B168, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%09%7B1133, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%7D%0A
- f 9c37fe24f15408c4e7e94925b97dac3a157b7e4ae0f0e095bdc1446c5bd50af7 vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
+ f 77e9526a2f3fa83d8be5d4fd38ecd940a371183779f9cbe21529ad039aac143c vendor/golang.org/x/sys/unix/zerrors_linux_mipsle.go
dmppatch 27
@@ -2684,16 +2684,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44364,16 +44364,749 @@
   = 0x4%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -82655,16 +82655,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -87052,16 +87052,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -98070,16 +98070,781 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x80186f40%0A%09UBI_IOCDET                           = 0x80046f41%0A%09UBI_IOCEBCH                          = 0x80044f02%0A%09UBI_IOCEBER                          = 0x80044f01%0A%09UBI_IOCEBISMAP                       = 0x40044f05%0A%09UBI_IOCEBMAP                         = 0x80084f03%0A%09UBI_IOCEBUNMAP                       = 0x80044f04%0A%09UBI_IOCMKVOL                         = 0x80986f00%0A%09UBI_IOCRMVOL                         = 0x80046f01%0A%09UBI_IOCRNVOL                         = 0x91106f03%0A%09UBI_IOCRSVOL                         = 0x800c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x80104f06%0A%09UBI_IOCVOLCRBLK                      = 0x80804f07%0A%09UBI_IOCVOLRMBLK                      = 0x20004f08%0A%09UBI_IOCVOLUP                         = 0x80084f00%0A
 %09UDF_SUP
@@ -105104,16 +105104,919 @@
   = 0x4%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -111468,8 +111468,8559 @@
 0x34)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x12)%0A%09SIGCLD    = syscall.Signal(0x12)%0A%09SIGCONT   = syscall.Signal(0x19)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x16)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x16)%0A%09SIGPROF   = syscall.Signal(0x1d)%0A%09SIGPWR    = syscall.Signal(0x13)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x17)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x18)%0A%09SIGTTIN   = syscall.Signal(0x1a)%0A%09SIGTTOU   = syscall.Signal(0x1b)%0A%09SIGURG    = syscall.Signal(0x15)%0A%09SIGUSR1   = syscall.Signal(0x10)%0A%09SIGUSR2   = syscall.Signal(0x11)%0A%09SIGVTALRM = syscall.Signal(0x1c)%0A%09SIGWINCH  = syscall.Signal(0x14)%0A%09SIGXCPU   = syscall.Signal(0x1e)%0A%09SIGXFSZ   = syscall.Signal(0x1f)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B50, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B51, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B53, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B54, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B89, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B90, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B91, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B135, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B137, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B138, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B139, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B140, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B141, %22EINIT%22, %22unknown error 141%22%7D,%0A%09%7B142, %22EREMDEV%22, %22unknown error 142%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B158, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B159, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B160, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B161, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B162, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B163, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B164, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B165, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B166, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B167, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B168, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%09%7B1133, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%7D%0A
- f 15eee7330416d56ec88cbe16d4a2e11e5a4e4e6def4373bf1c1a77edcc969c03 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
+ f 448120e26a285e9c8ed8065fe37aa8ac7bdd59888d5a675211a21f94e445d5d4 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64.go
dmppatch 27
@@ -2683,16 +2683,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44287,16 +44287,749 @@
  0x8000%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -85150,16 +85150,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -89467,16 +89467,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -100677,16 +100677,781 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x80186f40%0A%09UBI_IOCDET                           = 0x80046f41%0A%09UBI_IOCEBCH                          = 0x80044f02%0A%09UBI_IOCEBER                          = 0x80044f01%0A%09UBI_IOCEBISMAP                       = 0x40044f05%0A%09UBI_IOCEBMAP                         = 0x80084f03%0A%09UBI_IOCEBUNMAP                       = 0x80044f04%0A%09UBI_IOCMKVOL                         = 0x80986f00%0A%09UBI_IOCRMVOL                         = 0x80046f01%0A%09UBI_IOCRNVOL                         = 0x91106f03%0A%09UBI_IOCRSVOL                         = 0x800c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x80104f06%0A%09UBI_IOCVOLCRBLK                      = 0x80804f07%0A%09UBI_IOCVOLRMBLK                      = 0x20004f08%0A%09UBI_IOCVOLUP                         = 0x80084f00%0A
 %09UDF_SUP
@@ -107671,16 +107671,919 @@
  0x4000%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -113955,8 +113955,8479 @@
 0x36)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B58, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f 707e038115e597e843bdb7bf00c002b185fe9fbcfb6104a6abbedde23b9be90b vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
+ f 67acfb53ef1d23ad865403db7bfbff1805d08aeab6cfc82137fab15599ed56d5 vendor/golang.org/x/sys/unix/zerrors_linux_ppc64le.go
dmppatch 27
@@ -2685,16 +2685,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44289,16 +44289,749 @@
  0x8000%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -85152,16 +85152,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -89469,16 +89469,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -100679,16 +100679,781 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x80186f40%0A%09UBI_IOCDET                           = 0x80046f41%0A%09UBI_IOCEBCH                          = 0x80044f02%0A%09UBI_IOCEBER                          = 0x80044f01%0A%09UBI_IOCEBISMAP                       = 0x40044f05%0A%09UBI_IOCEBMAP                         = 0x80084f03%0A%09UBI_IOCEBUNMAP                       = 0x80044f04%0A%09UBI_IOCMKVOL                         = 0x80986f00%0A%09UBI_IOCRMVOL                         = 0x80046f01%0A%09UBI_IOCRNVOL                         = 0x91106f03%0A%09UBI_IOCRSVOL                         = 0x800c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x80104f06%0A%09UBI_IOCVOLCRBLK                      = 0x80804f07%0A%09UBI_IOCVOLRMBLK                      = 0x20004f08%0A%09UBI_IOCVOLUP                         = 0x80084f00%0A
 %09UDF_SUP
@@ -107673,16 +107673,919 @@
  0x4000%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -113957,8 +113957,8479 @@
 0x36)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B58, %22EDEADLOCK%22, %22file locking deadlock error%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
+ f d24b01cbd77f786f2120a05c0f981390260b62d33a02dd679725c4c84283c725 vendor/golang.org/x/sys/unix/zerrors_linux_riscv64.go
dmppatch 2
@@ -0,0 +1,118943 @@
+// mkerrors.sh -Wall -Werror -static -I/tmp/include%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build riscv64,linux%0A%0A// Code generated by cmd/cgo -godefs; DO NOT EDIT.%0A// cgo -godefs -- -Wall -Werror -static -I/tmp/include _const.go%0A%0Apackage unix%0A%0Aimport %22syscall%22%0A%0Aconst (%0A%09AAFS_MAGIC                           = 0x5a3c69f0%0A%09ADFS_SUPER_MAGIC                     = 0xadf5%0A%09AFFS_SUPER_MAGIC                     = 0xadff%0A%09AFS_FS_MAGIC                         = 0x6b414653%0A%09AFS_SUPER_MAGIC                      = 0x5346414f%0A%09AF_ALG                               = 0x26%0A%09AF_APPLETALK                         = 0x5%0A%09AF_ASH                               = 0x12%0A%09AF_ATMPVC                            = 0x8%0A%09AF_ATMSVC                            = 0x14%0A%09AF_AX25                              = 0x3%0A%09AF_BLUETOOTH                         = 0x1f%0A%09AF_BRIDGE                            = 0x7%0A%09AF_CAIF                              = 0x25%0A%09AF_CAN                               = 0x1d%0A%09AF_DECnet                            = 0xc%0A%09AF_ECONET                            = 0x13%0A%09AF_FILE                              = 0x1%0A%09AF_IB                                = 0x1b%0A%09AF_IEEE802154                        = 0x24%0A%09AF_INET                              = 0x2%0A%09AF_INET6                             = 0xa%0A%09AF_IPX                               = 0x4%0A%09AF_IRDA                              = 0x17%0A%09AF_ISDN                              = 0x22%0A%09AF_IUCV                              = 0x20%0A%09AF_KCM                               = 0x29%0A%09AF_KEY                               = 0xf%0A%09AF_LLC                               = 0x1a%0A%09AF_LOCAL                             = 0x1%0A%09AF_MAX                               = 0x2c%0A%09AF_MPLS                              = 0x1c%0A%09AF_NETBEUI                           = 0xd%0A%09AF_NETLINK                           = 0x10%0A%09AF_NETROM                            = 0x6%0A%09AF_NFC                               = 0x27%0A%09AF_PACKET                            = 0x11%0A%09AF_PHONET                            = 0x23%0A%09AF_PPPOX                             = 0x18%0A%09AF_QIPCRTR                           = 0x2a%0A%09AF_RDS                               = 0x15%0A%09AF_ROSE                              = 0xb%0A%09AF_ROUTE                             = 0x10%0A%09AF_RXRPC                             = 0x21%0A%09AF_SECURITY                          = 0xe%0A%09AF_SMC                               = 0x2b%0A%09AF_SNA                               = 0x16%0A%09AF_TIPC                              = 0x1e%0A%09AF_UNIX                              = 0x1%0A%09AF_UNSPEC                            = 0x0%0A%09AF_VSOCK                             = 0x28%0A%09AF_WANPIPE                           = 0x19%0A%09AF_X25                               = 0x9%0A%09AF_XDP                               = 0x2c%0A%09ALG_OP_DECRYPT                       = 0x0%0A%09ALG_OP_ENCRYPT                       = 0x1%0A%09ALG_SET_AEAD_ASSOCLEN                = 0x4%0A%09ALG_SET_AEAD_AUTHSIZE                = 0x5%0A%09ALG_SET_IV                           = 0x2%0A%09ALG_SET_KEY                          = 0x1%0A%09ALG_SET_OP                           = 0x3%0A%09ANON_INODE_FS_MAGIC                  = 0x9041934%0A%09ARPHRD_6LOWPAN                       = 0x339%0A%09ARPHRD_ADAPT                         = 0x108%0A%09ARPHRD_APPLETLK                      = 0x8%0A%09ARPHRD_ARCNET                        = 0x7%0A%09ARPHRD_ASH                           = 0x30d%0A%09ARPHRD_ATM                           = 0x13%0A%09ARPHRD_AX25                          = 0x3%0A%09ARPHRD_BIF                           = 0x307%0A%09ARPHRD_CAIF                          = 0x336%0A%09ARPHRD_CAN                           = 0x118%0A%09ARPHRD_CHAOS                         = 0x5%0A%09ARPHRD_CISCO                         = 0x201%0A%09ARPHRD_CSLIP                         = 0x101%0A%09ARPHRD_CSLIP6                        = 0x103%0A%09ARPHRD_DDCMP                         = 0x205%0A%09ARPHRD_DLCI                          = 0xf%0A%09ARPHRD_ECONET                        = 0x30e%0A%09ARPHRD_EETHER                        = 0x2%0A%09ARPHRD_ETHER                         = 0x1%0A%09ARPHRD_EUI64                         = 0x1b%0A%09ARPHRD_FCAL                          = 0x311%0A%09ARPHRD_FCFABRIC                      = 0x313%0A%09ARPHRD_FCPL                          = 0x312%0A%09ARPHRD_FCPP                          = 0x310%0A%09ARPHRD_FDDI                          = 0x306%0A%09ARPHRD_FRAD                          = 0x302%0A%09ARPHRD_HDLC                          = 0x201%0A%09ARPHRD_HIPPI                         = 0x30c%0A%09ARPHRD_HWX25                         = 0x110%0A%09ARPHRD_IEEE1394                      = 0x18%0A%09ARPHRD_IEEE802                       = 0x6%0A%09ARPHRD_IEEE80211                     = 0x321%0A%09ARPHRD_IEEE80211_PRISM               = 0x322%0A%09ARPHRD_IEEE80211_RADIOTAP            = 0x323%0A%09ARPHRD_IEEE802154                    = 0x324%0A%09ARPHRD_IEEE802154_MONITOR            = 0x325%0A%09ARPHRD_IEEE802_TR                    = 0x320%0A%09ARPHRD_INFINIBAND                    = 0x20%0A%09ARPHRD_IP6GRE                        = 0x337%0A%09ARPHRD_IPDDP                         = 0x309%0A%09ARPHRD_IPGRE                         = 0x30a%0A%09ARPHRD_IRDA                          = 0x30f%0A%09ARPHRD_LAPB                          = 0x204%0A%09ARPHRD_LOCALTLK                      = 0x305%0A%09ARPHRD_LOOPBACK                      = 0x304%0A%09ARPHRD_METRICOM                      = 0x17%0A%09ARPHRD_NETLINK                       = 0x338%0A%09ARPHRD_NETROM                        = 0x0%0A%09ARPHRD_NONE                          = 0xfffe%0A%09ARPHRD_PHONET                        = 0x334%0A%09ARPHRD_PHONET_PIPE                   = 0x335%0A%09ARPHRD_PIMREG                        = 0x30b%0A%09ARPHRD_PPP                           = 0x200%0A%09ARPHRD_PRONET                        = 0x4%0A%09ARPHRD_RAWHDLC                       = 0x206%0A%09ARPHRD_RAWIP                         = 0x207%0A%09ARPHRD_ROSE                          = 0x10e%0A%09ARPHRD_RSRVD                         = 0x104%0A%09ARPHRD_SIT                           = 0x308%0A%09ARPHRD_SKIP                          = 0x303%0A%09ARPHRD_SLIP                          = 0x100%0A%09ARPHRD_SLIP6                         = 0x102%0A%09ARPHRD_TUNNEL                        = 0x300%0A%09ARPHRD_TUNNEL6                       = 0x301%0A%09ARPHRD_VOID                          = 0xffff%0A%09ARPHRD_VSOCKMON                      = 0x33a%0A%09ARPHRD_X25                           = 0x10f%0A%09AUTOFS_SUPER_MAGIC                   = 0x187%0A%09B0                                   = 0x0%0A%09B1000000                             = 0x1008%0A%09B110                                 = 0x3%0A%09B115200                              = 0x1002%0A%09B1152000                             = 0x1009%0A%09B1200                                = 0x9%0A%09B134                                 = 0x4%0A%09B150                                 = 0x5%0A%09B1500000                             = 0x100a%0A%09B1800                                = 0xa%0A%09B19200                               = 0xe%0A%09B200                                 = 0x6%0A%09B2000000                             = 0x100b%0A%09B230400                              = 0x1003%0A%09B2400                                = 0xb%0A%09B2500000                             = 0x100c%0A%09B300                                 = 0x7%0A%09B3000000                             = 0x100d%0A%09B3500000                             = 0x100e%0A%09B38400                               = 0xf%0A%09B4000000                             = 0x100f%0A%09B460800                              = 0x1004%0A%09B4800                                = 0xc%0A%09B50                                  = 0x1%0A%09B500000                              = 0x1005%0A%09B57600                               = 0x1001%0A%09B576000                              = 0x1006%0A%09B600                                 = 0x8%0A%09B75                                  = 0x2%0A%09B921600                              = 0x1007%0A%09B9600                                = 0xd%0A%09BALLOON_KVM_MAGIC                    = 0x13661366%0A%09BDEVFS_MAGIC                         = 0x62646576%0A%09BINFMTFS_MAGIC                       = 0x42494e4d%0A%09BLKBSZGET                            = 0x80081270%0A%09BLKBSZSET                            = 0x40081271%0A%09BLKFLSBUF                            = 0x1261%0A%09BLKFRAGET                            = 0x1265%0A%09BLKFRASET                            = 0x1264%0A%09BLKGETSIZE                           = 0x1260%0A%09BLKGETSIZE64                         = 0x80081272%0A%09BLKPBSZGET                           = 0x127b%0A%09BLKRAGET                             = 0x1263%0A%09BLKRASET                             = 0x1262%0A%09BLKROGET                             = 0x125e%0A%09BLKROSET                             = 0x125d%0A%09BLKRRPART                            = 0x125f%0A%09BLKSECTGET                           = 0x1267%0A%09BLKSECTSET                           = 0x1266%0A%09BLKSSZGET                            = 0x1268%0A%09BOTHER                               = 0x1000%0A%09BPF_A                                = 0x10%0A%09BPF_ABS                              = 0x20%0A%09BPF_ADD                              = 0x0%0A%09BPF_ALU                              = 0x4%0A%09BPF_AND                              = 0x50%0A%09BPF_B                                = 0x10%0A%09BPF_DIV                              = 0x30%0A%09BPF_FS_MAGIC                         = 0xcafe4a11%0A%09BPF_H                                = 0x8%0A%09BPF_IMM                              = 0x0%0A%09BPF_IND                              = 0x40%0A%09BPF_JA                               = 0x0%0A%09BPF_JEQ                              = 0x10%0A%09BPF_JGE                              = 0x30%0A%09BPF_JGT                              = 0x20%0A%09BPF_JMP                              = 0x5%0A%09BPF_JSET                             = 0x40%0A%09BPF_K                                = 0x0%0A%09BPF_LD                               = 0x0%0A%09BPF_LDX                              = 0x1%0A%09BPF_LEN                              = 0x80%0A%09BPF_LL_OFF                           = -0x200000%0A%09BPF_LSH                              = 0x60%0A%09BPF_MAJOR_VERSION                    = 0x1%0A%09BPF_MAXINSNS                         = 0x1000%0A%09BPF_MEM                              = 0x60%0A%09BPF_MEMWORDS                         = 0x10%0A%09BPF_MINOR_VERSION                    = 0x1%0A%09BPF_MISC                             = 0x7%0A%09BPF_MOD                              = 0x90%0A%09BPF_MSH                              = 0xa0%0A%09BPF_MUL                              = 0x20%0A%09BPF_NEG                              = 0x80%0A%09BPF_NET_OFF                          = -0x100000%0A%09BPF_OR                               = 0x40%0A%09BPF_RET                              = 0x6%0A%09BPF_RSH                              = 0x70%0A%09BPF_ST                               = 0x2%0A%09BPF_STX                              = 0x3%0A%09BPF_SUB                              = 0x10%0A%09BPF_TAX                              = 0x0%0A%09BPF_TXA                              = 0x80%0A%09BPF_W                                = 0x0%0A%09BPF_X                                = 0x8%0A%09BPF_XOR                              = 0xa0%0A%09BRKINT                               = 0x2%0A%09BS0                                  = 0x0%0A%09BS1                                  = 0x2000%0A%09BSDLY                                = 0x2000%0A%09BTRFS_SUPER_MAGIC                    = 0x9123683e%0A%09BTRFS_TEST_MAGIC                     = 0x73727279%0A%09CAN_BCM                              = 0x2%0A%09CAN_EFF_FLAG                         = 0x80000000%0A%09CAN_EFF_ID_BITS                      = 0x1d%0A%09CAN_EFF_MASK                         = 0x1fffffff%0A%09CAN_ERR_FLAG                         = 0x20000000%0A%09CAN_ERR_MASK                         = 0x1fffffff%0A%09CAN_INV_FILTER                       = 0x20000000%0A%09CAN_ISOTP                            = 0x6%0A%09CAN_MAX_DLC                          = 0x8%0A%09CAN_MAX_DLEN                         = 0x8%0A%09CAN_MCNET                            = 0x5%0A%09CAN_MTU                              = 0x10%0A%09CAN_NPROTO                           = 0x7%0A%09CAN_RAW                              = 0x1%0A%09CAN_RAW_FILTER_MAX                   = 0x200%0A%09CAN_RTR_FLAG                         = 0x40000000%0A%09CAN_SFF_ID_BITS                      = 0xb%0A%09CAN_SFF_MASK                         = 0x7ff%0A%09CAN_TP16                             = 0x3%0A%09CAN_TP20                             = 0x4%0A%09CBAUD                                = 0x100f%0A%09CBAUDEX                              = 0x1000%0A%09CFLUSH                               = 0xf%0A%09CGROUP2_SUPER_MAGIC                  = 0x63677270%0A%09CGROUP_SUPER_MAGIC                   = 0x27e0eb%0A%09CIBAUD                               = 0x100f0000%0A%09CLOCAL                               = 0x800%0A%09CLOCK_BOOTTIME                       = 0x7%0A%09CLOCK_BOOTTIME_ALARM                 = 0x9%0A%09CLOCK_DEFAULT                        = 0x0%0A%09CLOCK_EXT                            = 0x1%0A%09CLOCK_INT                            = 0x2%0A%09CLOCK_MONOTONIC                      = 0x1%0A%09CLOCK_MONOTONIC_COARSE               = 0x6%0A%09CLOCK_MONOTONIC_RAW                  = 0x4%0A%09CLOCK_PROCESS_CPUTIME_ID             = 0x2%0A%09CLOCK_REALTIME                       = 0x0%0A%09CLOCK_REALTIME_ALARM                 = 0x8%0A%09CLOCK_REALTIME_COARSE                = 0x5%0A%09CLOCK_TAI                            = 0xb%0A%09CLOCK_THREAD_CPUTIME_ID              = 0x3%0A%09CLOCK_TXFROMRX                       = 0x4%0A%09CLOCK_TXINT                          = 0x3%0A%09CLONE_CHILD_CLEARTID                 = 0x200000%0A%09CLONE_CHILD_SETTID                   = 0x1000000%0A%09CLONE_DETACHED                       = 0x400000%0A%09CLONE_FILES                          = 0x400%0A%09CLONE_FS                             = 0x200%0A%09CLONE_IO                             = 0x80000000%0A%09CLONE_NEWCGROUP                      = 0x2000000%0A%09CLONE_NEWIPC                         = 0x8000000%0A%09CLONE_NEWNET                         = 0x40000000%0A%09CLONE_NEWNS                          = 0x20000%0A%09CLONE_NEWPID                         = 0x20000000%0A%09CLONE_NEWUSER                        = 0x10000000%0A%09CLONE_NEWUTS                         = 0x4000000%0A%09CLONE_PARENT                         = 0x8000%0A%09CLONE_PARENT_SETTID                  = 0x100000%0A%09CLONE_PTRACE                         = 0x2000%0A%09CLONE_SETTLS                         = 0x80000%0A%09CLONE_SIGHAND                        = 0x800%0A%09CLONE_SYSVSEM                        = 0x40000%0A%09CLONE_THREAD                         = 0x10000%0A%09CLONE_UNTRACED                       = 0x800000%0A%09CLONE_VFORK                          = 0x4000%0A%09CLONE_VM                             = 0x100%0A%09CMSPAR                               = 0x40000000%0A%09CODA_SUPER_MAGIC                     = 0x73757245%0A%09CR0                                  = 0x0%0A%09CR1                                  = 0x200%0A%09CR2                                  = 0x400%0A%09CR3                                  = 0x600%0A%09CRAMFS_MAGIC                         = 0x28cd3d45%0A%09CRDLY                                = 0x600%0A%09CREAD                                = 0x80%0A%09CRTSCTS                              = 0x80000000%0A%09CS5                                  = 0x0%0A%09CS6                                  = 0x10%0A%09CS7                                  = 0x20%0A%09CS8                                  = 0x30%0A%09CSIGNAL                              = 0xff%0A%09CSIZE                                = 0x30%0A%09CSTART                               = 0x11%0A%09CSTATUS                              = 0x0%0A%09CSTOP                                = 0x13%0A%09CSTOPB                               = 0x40%0A%09CSUSP                                = 0x1a%0A%09DAXFS_MAGIC                          = 0x64646178%0A%09DEBUGFS_MAGIC                        = 0x64626720%0A%09DEVPTS_SUPER_MAGIC                   = 0x1cd1%0A%09DT_BLK                               = 0x6%0A%09DT_CHR                               = 0x2%0A%09DT_DIR                               = 0x4%0A%09DT_FIFO                              = 0x1%0A%09DT_LNK                               = 0xa%0A%09DT_REG                               = 0x8%0A%09DT_SOCK                              = 0xc%0A%09DT_UNKNOWN                           = 0x0%0A%09DT_WHT                               = 0xe%0A%09ECHO                                 = 0x8%0A%09ECHOCTL                              = 0x200%0A%09ECHOE                                = 0x10%0A%09ECHOK                                = 0x20%0A%09ECHOKE                               = 0x800%0A%09ECHONL                               = 0x40%0A%09ECHOPRT                              = 0x400%0A%09ECRYPTFS_SUPER_MAGIC                 = 0xf15f%0A%09EFD_CLOEXEC                          = 0x80000%0A%09EFD_NONBLOCK                         = 0x800%0A%09EFD_SEMAPHORE                        = 0x1%0A%09EFIVARFS_MAGIC                       = 0xde5e81e4%0A%09EFS_SUPER_MAGIC                      = 0x414a53%0A%09ENCODING_DEFAULT                     = 0x0%0A%09ENCODING_FM_MARK                     = 0x3%0A%09ENCODING_FM_SPACE                    = 0x4%0A%09ENCODING_MANCHESTER                  = 0x5%0A%09ENCODING_NRZ                         = 0x1%0A%09ENCODING_NRZI                        = 0x2%0A%09EPOLLERR                             = 0x8%0A%09EPOLLET                              = 0x80000000%0A%09EPOLLEXCLUSIVE                       = 0x10000000%0A%09EPOLLHUP                             = 0x10%0A%09EPOLLIN                              = 0x1%0A%09EPOLLMSG                             = 0x400%0A%09EPOLLONESHOT                         = 0x40000000%0A%09EPOLLOUT                             = 0x4%0A%09EPOLLPRI                             = 0x2%0A%09EPOLLRDBAND                          = 0x80%0A%09EPOLLRDHUP                           = 0x2000%0A%09EPOLLRDNORM                          = 0x40%0A%09EPOLLWAKEUP                          = 0x20000000%0A%09EPOLLWRBAND                          = 0x200%0A%09EPOLLWRNORM                          = 0x100%0A%09EPOLL_CLOEXEC                        = 0x80000%0A%09EPOLL_CTL_ADD                        = 0x1%0A%09EPOLL_CTL_DEL                        = 0x2%0A%09EPOLL_CTL_MOD                        = 0x3%0A%09ETH_P_1588                           = 0x88f7%0A%09ETH_P_8021AD                         = 0x88a8%0A%09ETH_P_8021AH                         = 0x88e7%0A%09ETH_P_8021Q                          = 0x8100%0A%09ETH_P_80221                          = 0x8917%0A%09ETH_P_802_2                          = 0x4%0A%09ETH_P_802_3                          = 0x1%0A%09ETH_P_802_3_MIN                      = 0x600%0A%09ETH_P_802_EX1                        = 0x88b5%0A%09ETH_P_AARP                           = 0x80f3%0A%09ETH_P_AF_IUCV                        = 0xfbfb%0A%09ETH_P_ALL                            = 0x3%0A%09ETH_P_AOE                            = 0x88a2%0A%09ETH_P_ARCNET                         = 0x1a%0A%09ETH_P_ARP                            = 0x806%0A%09ETH_P_ATALK                          = 0x809b%0A%09ETH_P_ATMFATE                        = 0x8884%0A%09ETH_P_ATMMPOA                        = 0x884c%0A%09ETH_P_AX25                           = 0x2%0A%09ETH_P_BATMAN                         = 0x4305%0A%09ETH_P_BPQ                            = 0x8ff%0A%09ETH_P_CAIF                           = 0xf7%0A%09ETH_P_CAN                            = 0xc%0A%09ETH_P_CANFD                          = 0xd%0A%09ETH_P_CONTROL                        = 0x16%0A%09ETH_P_CUST                           = 0x6006%0A%09ETH_P_DDCMP                          = 0x6%0A%09ETH_P_DEC                            = 0x6000%0A%09ETH_P_DIAG                           = 0x6005%0A%09ETH_P_DNA_DL                         = 0x6001%0A%09ETH_P_DNA_RC                         = 0x6002%0A%09ETH_P_DNA_RT                         = 0x6003%0A%09ETH_P_DSA                            = 0x1b%0A%09ETH_P_ECONET                         = 0x18%0A%09ETH_P_EDSA                           = 0xdada%0A%09ETH_P_ERSPAN                         = 0x88be%0A%09ETH_P_ERSPAN2                        = 0x22eb%0A%09ETH_P_FCOE                           = 0x8906%0A%09ETH_P_FIP                            = 0x8914%0A%09ETH_P_HDLC                           = 0x19%0A%09ETH_P_HSR                            = 0x892f%0A%09ETH_P_IBOE                           = 0x8915%0A%09ETH_P_IEEE802154                     = 0xf6%0A%09ETH_P_IEEEPUP                        = 0xa00%0A%09ETH_P_IEEEPUPAT                      = 0xa01%0A%09ETH_P_IFE                            = 0xed3e%0A%09ETH_P_IP                             = 0x800%0A%09ETH_P_IPV6                           = 0x86dd%0A%09ETH_P_IPX                            = 0x8137%0A%09ETH_P_IRDA                           = 0x17%0A%09ETH_P_LAT                            = 0x6004%0A%09ETH_P_LINK_CTL                       = 0x886c%0A%09ETH_P_LOCALTALK                      = 0x9%0A%09ETH_P_LOOP                           = 0x60%0A%09ETH_P_LOOPBACK                       = 0x9000%0A%09ETH_P_MACSEC                         = 0x88e5%0A%09ETH_P_MAP                            = 0xf9%0A%09ETH_P_MOBITEX                        = 0x15%0A%09ETH_P_MPLS_MC                        = 0x8848%0A%09ETH_P_MPLS_UC                        = 0x8847%0A%09ETH_P_MVRP                           = 0x88f5%0A%09ETH_P_NCSI                           = 0x88f8%0A%09ETH_P_NSH                            = 0x894f%0A%09ETH_P_PAE                            = 0x888e%0A%09ETH_P_PAUSE                          = 0x8808%0A%09ETH_P_PHONET                         = 0xf5%0A%09ETH_P_PPPTALK                        = 0x10%0A%09ETH_P_PPP_DISC                       = 0x8863%0A%09ETH_P_PPP_MP                         = 0x8%0A%09ETH_P_PPP_SES                        = 0x8864%0A%09ETH_P_PREAUTH                        = 0x88c7%0A%09ETH_P_PRP                            = 0x88fb%0A%09ETH_P_PUP                            = 0x200%0A%09ETH_P_PUPAT                          = 0x201%0A%09ETH_P_QINQ1                          = 0x9100%0A%09ETH_P_QINQ2                          = 0x9200%0A%09ETH_P_QINQ3                          = 0x9300%0A%09ETH_P_RARP                           = 0x8035%0A%09ETH_P_SCA                            = 0x6007%0A%09ETH_P_SLOW                           = 0x8809%0A%09ETH_P_SNAP                           = 0x5%0A%09ETH_P_TDLS                           = 0x890d%0A%09ETH_P_TEB                            = 0x6558%0A%09ETH_P_TIPC                           = 0x88ca%0A%09ETH_P_TRAILER                        = 0x1c%0A%09ETH_P_TR_802_2                       = 0x11%0A%09ETH_P_TSN                            = 0x22f0%0A%09ETH_P_WAN_PPP                        = 0x7%0A%09ETH_P_WCCP                           = 0x883e%0A%09ETH_P_X25                            = 0x805%0A%09ETH_P_XDSA                           = 0xf8%0A%09EXABYTE_ENABLE_NEST                  = 0xf0%0A%09EXT2_SUPER_MAGIC                     = 0xef53%0A%09EXT3_SUPER_MAGIC                     = 0xef53%0A%09EXT4_SUPER_MAGIC                     = 0xef53%0A%09EXTA                                 = 0xe%0A%09EXTB                                 = 0xf%0A%09EXTPROC                              = 0x10000%0A%09F2FS_SUPER_MAGIC                     = 0xf2f52010%0A%09FALLOC_FL_COLLAPSE_RANGE             = 0x8%0A%09FALLOC_FL_INSERT_RANGE               = 0x20%0A%09FALLOC_FL_KEEP_SIZE                  = 0x1%0A%09FALLOC_FL_NO_HIDE_STALE              = 0x4%0A%09FALLOC_FL_PUNCH_HOLE                 = 0x2%0A%09FALLOC_FL_UNSHARE_RANGE              = 0x40%0A%09FALLOC_FL_ZERO_RANGE                 = 0x10%0A%09FD_CLOEXEC                           = 0x1%0A%09FD_SETSIZE                           = 0x400%0A%09FF0                                  = 0x0%0A%09FF1                                  = 0x8000%0A%09FFDLY                                = 0x8000%0A%09FLUSHO                               = 0x1000%0A%09FS_ENCRYPTION_MODE_AES_128_CBC       = 0x5%0A%09FS_ENCRYPTION_MODE_AES_128_CTS       = 0x6%0A%09FS_ENCRYPTION_MODE_AES_256_CBC       = 0x3%0A%09FS_ENCRYPTION_MODE_AES_256_CTS       = 0x4%0A%09FS_ENCRYPTION_MODE_AES_256_GCM       = 0x2%0A%09FS_ENCRYPTION_MODE_AES_256_XTS       = 0x1%0A%09FS_ENCRYPTION_MODE_INVALID           = 0x0%0A%09FS_ENCRYPTION_MODE_SPECK128_256_CTS  = 0x8%0A%09FS_ENCRYPTION_MODE_SPECK128_256_XTS  = 0x7%0A%09FS_IOC_GET_ENCRYPTION_POLICY         = 0x400c6615%0A%09FS_IOC_GET_ENCRYPTION_PWSALT         = 0x40106614%0A%09FS_IOC_SET_ENCRYPTION_POLICY         = 0x800c6613%0A%09FS_KEY_DESCRIPTOR_SIZE               = 0x8%0A%09FS_KEY_DESC_PREFIX                   = %22fscrypt:%22%0A%09FS_KEY_DESC_PREFIX_SIZE              = 0x8%0A%09FS_MAX_KEY_SIZE                      = 0x40%0A%09FS_POLICY_FLAGS_PAD_16               = 0x2%0A%09FS_POLICY_FLAGS_PAD_32               = 0x3%0A%09FS_POLICY_FLAGS_PAD_4                = 0x0%0A%09FS_POLICY_FLAGS_PAD_8                = 0x1%0A%09FS_POLICY_FLAGS_PAD_MASK             = 0x3%0A%09FS_POLICY_FLAGS_VALID                = 0x3%0A%09FUTEXFS_SUPER_MAGIC                  = 0xbad1dea%0A%09F_ADD_SEALS                          = 0x409%0A%09F_DUPFD                              = 0x0%0A%09F_DUPFD_CLOEXEC                      = 0x406%0A%09F_EXLCK                              = 0x4%0A%09F_GETFD                              = 0x1%0A%09F_GETFL                              = 0x3%0A%09F_GETLEASE                           = 0x401%0A%09F_GETLK                              = 0x5%0A%09F_GETLK64                            = 0x5%0A%09F_GETOWN                             = 0x9%0A%09F_GETOWN_EX                          = 0x10%0A%09F_GETPIPE_SZ                         = 0x408%0A%09F_GETSIG                             = 0xb%0A%09F_GET_FILE_RW_HINT                   = 0x40d%0A%09F_GET_RW_HINT                        = 0x40b%0A%09F_GET_SEALS                          = 0x40a%0A%09F_LOCK                               = 0x1%0A%09F_NOTIFY                             = 0x402%0A%09F_OFD_GETLK                          = 0x24%0A%09F_OFD_SETLK                          = 0x25%0A%09F_OFD_SETLKW                         = 0x26%0A%09F_OK                                 = 0x0%0A%09F_RDLCK                              = 0x0%0A%09F_SEAL_GROW                          = 0x4%0A%09F_SEAL_SEAL                          = 0x1%0A%09F_SEAL_SHRINK                        = 0x2%0A%09F_SEAL_WRITE                         = 0x8%0A%09F_SETFD                              = 0x2%0A%09F_SETFL                              = 0x4%0A%09F_SETLEASE                           = 0x400%0A%09F_SETLK                              = 0x6%0A%09F_SETLK64                            = 0x6%0A%09F_SETLKW                             = 0x7%0A%09F_SETLKW64                           = 0x7%0A%09F_SETOWN                             = 0x8%0A%09F_SETOWN_EX                          = 0xf%0A%09F_SETPIPE_SZ                         = 0x407%0A%09F_SETSIG                             = 0xa%0A%09F_SET_FILE_RW_HINT                   = 0x40e%0A%09F_SET_RW_HINT                        = 0x40c%0A%09F_SHLCK                              = 0x8%0A%09F_TEST                               = 0x3%0A%09F_TLOCK                              = 0x2%0A%09F_ULOCK                              = 0x0%0A%09F_UNLCK                              = 0x2%0A%09F_WRLCK                              = 0x1%0A%09GENL_ADMIN_PERM                      = 0x1%0A%09GENL_CMD_CAP_DO                      = 0x2%0A%09GENL_CMD_CAP_DUMP                    = 0x4%0A%09GENL_CMD_CAP_HASPOL                  = 0x8%0A%09GENL_HDRLEN                          = 0x4%0A%09GENL_ID_CTRL                         = 0x10%0A%09GENL_ID_PMCRAID                      = 0x12%0A%09GENL_ID_VFS_DQUOT                    = 0x11%0A%09GENL_MAX_ID                          = 0x3ff%0A%09GENL_MIN_ID                          = 0x10%0A%09GENL_NAMSIZ                          = 0x10%0A%09GENL_START_ALLOC                     = 0x13%0A%09GENL_UNS_ADMIN_PERM                  = 0x10%0A%09GRND_NONBLOCK                        = 0x1%0A%09GRND_RANDOM                          = 0x2%0A%09HDIO_DRIVE_CMD                       = 0x31f%0A%09HDIO_DRIVE_CMD_AEB                   = 0x31e%0A%09HDIO_DRIVE_CMD_HDR_SIZE              = 0x4%0A%09HDIO_DRIVE_HOB_HDR_SIZE              = 0x8%0A%09HDIO_DRIVE_RESET                     = 0x31c%0A%09HDIO_DRIVE_TASK                      = 0x31e%0A%09HDIO_DRIVE_TASKFILE                  = 0x31d%0A%09HDIO_DRIVE_TASK_HDR_SIZE             = 0x8%0A%09HDIO_GETGEO                          = 0x301%0A%09HDIO_GET_32BIT                       = 0x309%0A%09HDIO_GET_ACOUSTIC                    = 0x30f%0A%09HDIO_GET_ADDRESS                     = 0x310%0A%09HDIO_GET_BUSSTATE                    = 0x31a%0A%09HDIO_GET_DMA                         = 0x30b%0A%09HDIO_GET_IDENTITY                    = 0x30d%0A%09HDIO_GET_KEEPSETTINGS                = 0x308%0A%09HDIO_GET_MULTCOUNT                   = 0x304%0A%09HDIO_GET_NICE                        = 0x30c%0A%09HDIO_GET_NOWERR                      = 0x30a%0A%09HDIO_GET_QDMA                        = 0x305%0A%09HDIO_GET_UNMASKINTR                  = 0x302%0A%09HDIO_GET_WCACHE                      = 0x30e%0A%09HDIO_OBSOLETE_IDENTITY               = 0x307%0A%09HDIO_SCAN_HWIF                       = 0x328%0A%09HDIO_SET_32BIT                       = 0x324%0A%09HDIO_SET_ACOUSTIC                    = 0x32c%0A%09HDIO_SET_ADDRESS                     = 0x32f%0A%09HDIO_SET_BUSSTATE                    = 0x32d%0A%09HDIO_SET_DMA                         = 0x326%0A%09HDIO_SET_KEEPSETTINGS                = 0x323%0A%09HDIO_SET_MULTCOUNT                   = 0x321%0A%09HDIO_SET_NICE                        = 0x329%0A%09HDIO_SET_NOWERR                      = 0x325%0A%09HDIO_SET_PIO_MODE                    = 0x327%0A%09HDIO_SET_QDMA                        = 0x32e%0A%09HDIO_SET_UNMASKINTR                  = 0x322%0A%09HDIO_SET_WCACHE                      = 0x32b%0A%09HDIO_SET_XFER                        = 0x306%0A%09HDIO_TRISTATE_HWIF                   = 0x31b%0A%09HDIO_UNREGISTER_HWIF                 = 0x32a%0A%09HOSTFS_SUPER_MAGIC                   = 0xc0ffee%0A%09HPFS_SUPER_MAGIC                     = 0xf995e849%0A%09HUGETLBFS_MAGIC                      = 0x958458f6%0A%09HUPCL                                = 0x400%0A%09IBSHIFT                              = 0x10%0A%09ICANON                               = 0x2%0A%09ICMPV6_FILTER                        = 0x1%0A%09ICRNL                                = 0x100%0A%09IEXTEN                               = 0x8000%0A%09IFA_F_DADFAILED                      = 0x8%0A%09IFA_F_DEPRECATED                     = 0x20%0A%09IFA_F_HOMEADDRESS                    = 0x10%0A%09IFA_F_MANAGETEMPADDR                 = 0x100%0A%09IFA_F_MCAUTOJOIN                     = 0x400%0A%09IFA_F_NODAD                          = 0x2%0A%09IFA_F_NOPREFIXROUTE                  = 0x200%0A%09IFA_F_OPTIMISTIC                     = 0x4%0A%09IFA_F_PERMANENT                      = 0x80%0A%09IFA_F_SECONDARY                      = 0x1%0A%09IFA_F_STABLE_PRIVACY                 = 0x800%0A%09IFA_F_TEMPORARY                      = 0x1%0A%09IFA_F_TENTATIVE                      = 0x40%0A%09IFA_MAX                              = 0x9%0A%09IFF_ALLMULTI                         = 0x200%0A%09IFF_ATTACH_QUEUE                     = 0x200%0A%09IFF_AUTOMEDIA                        = 0x4000%0A%09IFF_BROADCAST                        = 0x2%0A%09IFF_DEBUG                            = 0x4%0A%09IFF_DETACH_QUEUE                     = 0x400%0A%09IFF_DORMANT                          = 0x20000%0A%09IFF_DYNAMIC                          = 0x8000%0A%09IFF_ECHO                             = 0x40000%0A%09IFF_LOOPBACK                         = 0x8%0A%09IFF_LOWER_UP                         = 0x10000%0A%09IFF_MASTER                           = 0x400%0A%09IFF_MULTICAST                        = 0x1000%0A%09IFF_MULTI_QUEUE                      = 0x100%0A%09IFF_NAPI                             = 0x10%0A%09IFF_NAPI_FRAGS                       = 0x20%0A%09IFF_NOARP                            = 0x80%0A%09IFF_NOFILTER                         = 0x1000%0A%09IFF_NOTRAILERS                       = 0x20%0A%09IFF_NO_PI                            = 0x1000%0A%09IFF_ONE_QUEUE                        = 0x2000%0A%09IFF_PERSIST                          = 0x800%0A%09IFF_POINTOPOINT                      = 0x10%0A%09IFF_PORTSEL                          = 0x2000%0A%09IFF_PROMISC                          = 0x100%0A%09IFF_RUNNING                          = 0x40%0A%09IFF_SLAVE                            = 0x800%0A%09IFF_TAP                              = 0x2%0A%09IFF_TUN                              = 0x1%0A%09IFF_TUN_EXCL                         = 0x8000%0A%09IFF_UP                               = 0x1%0A%09IFF_VNET_HDR                         = 0x4000%0A%09IFF_VOLATILE                         = 0x70c5a%0A%09IFNAMSIZ                             = 0x10%0A%09IGNBRK                               = 0x1%0A%09IGNCR                                = 0x80%0A%09IGNPAR                               = 0x4%0A%09IMAXBEL                              = 0x2000%0A%09INLCR                                = 0x40%0A%09INPCK                                = 0x10%0A%09IN_ACCESS                            = 0x1%0A%09IN_ALL_EVENTS                        = 0xfff%0A%09IN_ATTRIB                            = 0x4%0A%09IN_CLASSA_HOST                       = 0xffffff%0A%09IN_CLASSA_MAX                        = 0x80%0A%09IN_CLASSA_NET                        = 0xff000000%0A%09IN_CLASSA_NSHIFT                     = 0x18%0A%09IN_CLASSB_HOST                       = 0xffff%0A%09IN_CLASSB_MAX                        = 0x10000%0A%09IN_CLASSB_NET                        = 0xffff0000%0A%09IN_CLASSB_NSHIFT                     = 0x10%0A%09IN_CLASSC_HOST                       = 0xff%0A%09IN_CLASSC_NET                        = 0xffffff00%0A%09IN_CLASSC_NSHIFT                     = 0x8%0A%09IN_CLOEXEC                           = 0x80000%0A%09IN_CLOSE                             = 0x18%0A%09IN_CLOSE_NOWRITE                     = 0x10%0A%09IN_CLOSE_WRITE                       = 0x8%0A%09IN_CREATE                            = 0x100%0A%09IN_DELETE                            = 0x200%0A%09IN_DELETE_SELF                       = 0x400%0A%09IN_DONT_FOLLOW                       = 0x2000000%0A%09IN_EXCL_UNLINK                       = 0x4000000%0A%09IN_IGNORED                           = 0x8000%0A%09IN_ISDIR                             = 0x40000000%0A%09IN_LOOPBACKNET                       = 0x7f%0A%09IN_MASK_ADD                          = 0x20000000%0A%09IN_MODIFY                            = 0x2%0A%09IN_MOVE                              = 0xc0%0A%09IN_MOVED_FROM                        = 0x40%0A%09IN_MOVED_TO                          = 0x80%0A%09IN_MOVE_SELF                         = 0x800%0A%09IN_NONBLOCK                          = 0x800%0A%09IN_ONESHOT                           = 0x80000000%0A%09IN_ONLYDIR                           = 0x1000000%0A%09IN_OPEN                              = 0x20%0A%09IN_Q_OVERFLOW                        = 0x4000%0A%09IN_UNMOUNT                           = 0x2000%0A%09IOCTL_VM_SOCKETS_GET_LOCAL_CID       = 0x7b9%0A%09IPPROTO_AH                           = 0x33%0A%09IPPROTO_BEETPH                       = 0x5e%0A%09IPPROTO_COMP                         = 0x6c%0A%09IPPROTO_DCCP                         = 0x21%0A%09IPPROTO_DSTOPTS                      = 0x3c%0A%09IPPROTO_EGP                          = 0x8%0A%09IPPROTO_ENCAP                        = 0x62%0A%09IPPROTO_ESP                          = 0x32%0A%09IPPROTO_FRAGMENT                     = 0x2c%0A%09IPPROTO_GRE                          = 0x2f%0A%09IPPROTO_HOPOPTS                      = 0x0%0A%09IPPROTO_ICMP                         = 0x1%0A%09IPPROTO_ICMPV6                       = 0x3a%0A%09IPPROTO_IDP                          = 0x16%0A%09IPPROTO_IGMP                         = 0x2%0A%09IPPROTO_IP                           = 0x0%0A%09IPPROTO_IPIP                         = 0x4%0A%09IPPROTO_IPV6                         = 0x29%0A%09IPPROTO_MH                           = 0x87%0A%09IPPROTO_MPLS                         = 0x89%0A%09IPPROTO_MTP                          = 0x5c%0A%09IPPROTO_NONE                         = 0x3b%0A%09IPPROTO_PIM                          = 0x67%0A%09IPPROTO_PUP                          = 0xc%0A%09IPPROTO_RAW                          = 0xff%0A%09IPPROTO_ROUTING                      = 0x2b%0A%09IPPROTO_RSVP                         = 0x2e%0A%09IPPROTO_SCTP                         = 0x84%0A%09IPPROTO_TCP                          = 0x6%0A%09IPPROTO_TP                           = 0x1d%0A%09IPPROTO_UDP                          = 0x11%0A%09IPPROTO_UDPLITE                      = 0x88%0A%09IPV6_2292DSTOPTS                     = 0x4%0A%09IPV6_2292HOPLIMIT                    = 0x8%0A%09IPV6_2292HOPOPTS                     = 0x3%0A%09IPV6_2292PKTINFO                     = 0x2%0A%09IPV6_2292PKTOPTIONS                  = 0x6%0A%09IPV6_2292RTHDR                       = 0x5%0A%09IPV6_ADDRFORM                        = 0x1%0A%09IPV6_ADDR_PREFERENCES                = 0x48%0A%09IPV6_ADD_MEMBERSHIP                  = 0x14%0A%09IPV6_AUTHHDR                         = 0xa%0A%09IPV6_AUTOFLOWLABEL                   = 0x46%0A%09IPV6_CHECKSUM                        = 0x7%0A%09IPV6_DONTFRAG                        = 0x3e%0A%09IPV6_DROP_MEMBERSHIP                 = 0x15%0A%09IPV6_DSTOPTS                         = 0x3b%0A%09IPV6_FREEBIND                        = 0x4e%0A%09IPV6_HDRINCL                         = 0x24%0A%09IPV6_HOPLIMIT                        = 0x34%0A%09IPV6_HOPOPTS                         = 0x36%0A%09IPV6_IPSEC_POLICY                    = 0x22%0A%09IPV6_JOIN_ANYCAST                    = 0x1b%0A%09IPV6_JOIN_GROUP                      = 0x14%0A%09IPV6_LEAVE_ANYCAST                   = 0x1c%0A%09IPV6_LEAVE_GROUP                     = 0x15%0A%09IPV6_MINHOPCOUNT                     = 0x49%0A%09IPV6_MTU                             = 0x18%0A%09IPV6_MTU_DISCOVER                    = 0x17%0A%09IPV6_MULTICAST_HOPS                  = 0x12%0A%09IPV6_MULTICAST_IF                    = 0x11%0A%09IPV6_MULTICAST_LOOP                  = 0x13%0A%09IPV6_NEXTHOP                         = 0x9%0A%09IPV6_ORIGDSTADDR                     = 0x4a%0A%09IPV6_PATHMTU                         = 0x3d%0A%09IPV6_PKTINFO                         = 0x32%0A%09IPV6_PMTUDISC_DO                     = 0x2%0A%09IPV6_PMTUDISC_DONT                   = 0x0%0A%09IPV6_PMTUDISC_INTERFACE              = 0x4%0A%09IPV6_PMTUDISC_OMIT                   = 0x5%0A%09IPV6_PMTUDISC_PROBE                  = 0x3%0A%09IPV6_PMTUDISC_WANT                   = 0x1%0A%09IPV6_RECVDSTOPTS                     = 0x3a%0A%09IPV6_RECVERR                         = 0x19%0A%09IPV6_RECVFRAGSIZE                    = 0x4d%0A%09IPV6_RECVHOPLIMIT                    = 0x33%0A%09IPV6_RECVHOPOPTS                     = 0x35%0A%09IPV6_RECVORIGDSTADDR                 = 0x4a%0A%09IPV6_RECVPATHMTU                     = 0x3c%0A%09IPV6_RECVPKTINFO                     = 0x31%0A%09IPV6_RECVRTHDR                       = 0x38%0A%09IPV6_RECVTCLASS                      = 0x42%0A%09IPV6_ROUTER_ALERT                    = 0x16%0A%09IPV6_RTHDR                           = 0x39%0A%09IPV6_RTHDRDSTOPTS                    = 0x37%0A%09IPV6_RTHDR_LOOSE                     = 0x0%0A%09IPV6_RTHDR_STRICT                    = 0x1%0A%09IPV6_RTHDR_TYPE_0                    = 0x0%0A%09IPV6_RXDSTOPTS                       = 0x3b%0A%09IPV6_RXHOPOPTS                       = 0x36%0A%09IPV6_TCLASS                          = 0x43%0A%09IPV6_TRANSPARENT                     = 0x4b%0A%09IPV6_UNICAST_HOPS                    = 0x10%0A%09IPV6_UNICAST_IF                      = 0x4c%0A%09IPV6_V6ONLY                          = 0x1a%0A%09IPV6_XFRM_POLICY                     = 0x23%0A%09IP_ADD_MEMBERSHIP                    = 0x23%0A%09IP_ADD_SOURCE_MEMBERSHIP             = 0x27%0A%09IP_BIND_ADDRESS_NO_PORT              = 0x18%0A%09IP_BLOCK_SOURCE                      = 0x26%0A%09IP_CHECKSUM                          = 0x17%0A%09IP_DEFAULT_MULTICAST_LOOP            = 0x1%0A%09IP_DEFAULT_MULTICAST_TTL             = 0x1%0A%09IP_DF                                = 0x4000%0A%09IP_DROP_MEMBERSHIP                   = 0x24%0A%09IP_DROP_SOURCE_MEMBERSHIP            = 0x28%0A%09IP_FREEBIND                          = 0xf%0A%09IP_HDRINCL                           = 0x3%0A%09IP_IPSEC_POLICY                      = 0x10%0A%09IP_MAXPACKET                         = 0xffff%0A%09IP_MAX_MEMBERSHIPS                   = 0x14%0A%09IP_MF                                = 0x2000%0A%09IP_MINTTL                            = 0x15%0A%09IP_MSFILTER                          = 0x29%0A%09IP_MSS                               = 0x240%0A%09IP_MTU                               = 0xe%0A%09IP_MTU_DISCOVER                      = 0xa%0A%09IP_MULTICAST_ALL                     = 0x31%0A%09IP_MULTICAST_IF                      = 0x20%0A%09IP_MULTICAST_LOOP                    = 0x22%0A%09IP_MULTICAST_TTL                     = 0x21%0A%09IP_NODEFRAG                          = 0x16%0A%09IP_OFFMASK                           = 0x1fff%0A%09IP_OPTIONS                           = 0x4%0A%09IP_ORIGDSTADDR                       = 0x14%0A%09IP_PASSSEC                           = 0x12%0A%09IP_PKTINFO                           = 0x8%0A%09IP_PKTOPTIONS                        = 0x9%0A%09IP_PMTUDISC                          = 0xa%0A%09IP_PMTUDISC_DO                       = 0x2%0A%09IP_PMTUDISC_DONT                     = 0x0%0A%09IP_PMTUDISC_INTERFACE                = 0x4%0A%09IP_PMTUDISC_OMIT                     = 0x5%0A%09IP_PMTUDISC_PROBE                    = 0x3%0A%09IP_PMTUDISC_WANT                     = 0x1%0A%09IP_RECVERR                           = 0xb%0A%09IP_RECVFRAGSIZE                      = 0x19%0A%09IP_RECVOPTS                          = 0x6%0A%09IP_RECVORIGDSTADDR                   = 0x14%0A%09IP_RECVRETOPTS                       = 0x7%0A%09IP_RECVTOS                           = 0xd%0A%09IP_RECVTTL                           = 0xc%0A%09IP_RETOPTS                           = 0x7%0A%09IP_RF                                = 0x8000%0A%09IP_ROUTER_ALERT                      = 0x5%0A%09IP_TOS                               = 0x1%0A%09IP_TRANSPARENT                       = 0x13%0A%09IP_TTL                               = 0x2%0A%09IP_UNBLOCK_SOURCE                    = 0x25%0A%09IP_UNICAST_IF                        = 0x32%0A%09IP_XFRM_POLICY                       = 0x11%0A%09ISIG                                 = 0x1%0A%09ISOFS_SUPER_MAGIC                    = 0x9660%0A%09ISTRIP                               = 0x20%0A%09IUCLC                                = 0x200%0A%09IUTF8                                = 0x4000%0A%09IXANY                                = 0x800%0A%09IXOFF                                = 0x1000%0A%09IXON                                 = 0x400%0A%09JFFS2_SUPER_MAGIC                    = 0x72b6%0A%09KEYCTL_ASSUME_AUTHORITY              = 0x10%0A%09KEYCTL_CHOWN                         = 0x4%0A%09KEYCTL_CLEAR                         = 0x7%0A%09KEYCTL_DESCRIBE                      = 0x6%0A%09KEYCTL_DH_COMPUTE                    = 0x17%0A%09KEYCTL_GET_KEYRING_ID                = 0x0%0A%09KEYCTL_GET_PERSISTENT                = 0x16%0A%09KEYCTL_GET_SECURITY                  = 0x11%0A%09KEYCTL_INSTANTIATE                   = 0xc%0A%09KEYCTL_INSTANTIATE_IOV               = 0x14%0A%09KEYCTL_INVALIDATE                    = 0x15%0A%09KEYCTL_JOIN_SESSION_KEYRING          = 0x1%0A%09KEYCTL_LINK                          = 0x8%0A%09KEYCTL_NEGATE                        = 0xd%0A%09KEYCTL_READ                          = 0xb%0A%09KEYCTL_REJECT                        = 0x13%0A%09KEYCTL_RESTRICT_KEYRING              = 0x1d%0A%09KEYCTL_REVOKE                        = 0x3%0A%09KEYCTL_SEARCH                        = 0xa%0A%09KEYCTL_SESSION_TO_PARENT             = 0x12%0A%09KEYCTL_SETPERM                       = 0x5%0A%09KEYCTL_SET_REQKEY_KEYRING            = 0xe%0A%09KEYCTL_SET_TIMEOUT                   = 0xf%0A%09KEYCTL_UNLINK                        = 0x9%0A%09KEYCTL_UPDATE                        = 0x2%0A%09KEY_REQKEY_DEFL_DEFAULT              = 0x0%0A%09KEY_REQKEY_DEFL_GROUP_KEYRING        = 0x6%0A%09KEY_REQKEY_DEFL_NO_CHANGE            = -0x1%0A%09KEY_REQKEY_DEFL_PROCESS_KEYRING      = 0x2%0A%09KEY_REQKEY_DEFL_REQUESTOR_KEYRING    = 0x7%0A%09KEY_REQKEY_DEFL_SESSION_KEYRING      = 0x3%0A%09KEY_REQKEY_DEFL_THREAD_KEYRING       = 0x1%0A%09KEY_REQKEY_DEFL_USER_KEYRING         = 0x4%0A%09KEY_REQKEY_DEFL_USER_SESSION_KEYRING = 0x5%0A%09KEY_SPEC_GROUP_KEYRING               = -0x6%0A%09KEY_SPEC_PROCESS_KEYRING             = -0x2%0A%09KEY_SPEC_REQKEY_AUTH_KEY             = -0x7%0A%09KEY_SPEC_REQUESTOR_KEYRING           = -0x8%0A%09KEY_SPEC_SESSION_KEYRING             = -0x3%0A%09KEY_SPEC_THREAD_KEYRING              = -0x1%0A%09KEY_SPEC_USER_KEYRING                = -0x4%0A%09KEY_SPEC_USER_SESSION_KEYRING        = -0x5%0A%09LINUX_REBOOT_CMD_CAD_OFF             = 0x0%0A%09LINUX_REBOOT_CMD_CAD_ON              = 0x89abcdef%0A%09LINUX_REBOOT_CMD_HALT                = 0xcdef0123%0A%09LINUX_REBOOT_CMD_KEXEC               = 0x45584543%0A%09LINUX_REBOOT_CMD_POWER_OFF           = 0x4321fedc%0A%09LINUX_REBOOT_CMD_RESTART             = 0x1234567%0A%09LINUX_REBOOT_CMD_RESTART2            = 0xa1b2c3d4%0A%09LINUX_REBOOT_CMD_SW_SUSPEND          = 0xd000fce2%0A%09LINUX_REBOOT_MAGIC1                  = 0xfee1dead%0A%09LINUX_REBOOT_MAGIC2                  = 0x28121969%0A%09LOCK_EX                              = 0x2%0A%09LOCK_NB                              = 0x4%0A%09LOCK_SH                              = 0x1%0A%09LOCK_UN                              = 0x8%0A%09MADV_DODUMP                          = 0x11%0A%09MADV_DOFORK                          = 0xb%0A%09MADV_DONTDUMP                        = 0x10%0A%09MADV_DONTFORK                        = 0xa%0A%09MADV_DONTNEED                        = 0x4%0A%09MADV_FREE                            = 0x8%0A%09MADV_HUGEPAGE                        = 0xe%0A%09MADV_HWPOISON                        = 0x64%0A%09MADV_KEEPONFORK                      = 0x13%0A%09MADV_MERGEABLE                       = 0xc%0A%09MADV_NOHUGEPAGE                      = 0xf%0A%09MADV_NORMAL                          = 0x0%0A%09MADV_RANDOM                          = 0x1%0A%09MADV_REMOVE                          = 0x9%0A%09MADV_SEQUENTIAL                      = 0x2%0A%09MADV_UNMERGEABLE                     = 0xd%0A%09MADV_WILLNEED                        = 0x3%0A%09MADV_WIPEONFORK                      = 0x12%0A%09MAP_ANON                             = 0x20%0A%09MAP_ANONYMOUS                        = 0x20%0A%09MAP_DENYWRITE                        = 0x800%0A%09MAP_EXECUTABLE                       = 0x1000%0A%09MAP_FILE                             = 0x0%0A%09MAP_FIXED                            = 0x10%0A%09MAP_FIXED_NOREPLACE                  = 0x100000%0A%09MAP_GROWSDOWN                        = 0x100%0A%09MAP_HUGETLB                          = 0x40000%0A%09MAP_HUGE_MASK                        = 0x3f%0A%09MAP_HUGE_SHIFT                       = 0x1a%0A%09MAP_LOCKED                           = 0x2000%0A%09MAP_NONBLOCK                         = 0x10000%0A%09MAP_NORESERVE                        = 0x4000%0A%09MAP_POPULATE                         = 0x8000%0A%09MAP_PRIVATE                          = 0x2%0A%09MAP_SHARED                           = 0x1%0A%09MAP_SHARED_VALIDATE                  = 0x3%0A%09MAP_STACK                            = 0x20000%0A%09MAP_SYNC                             = 0x80000%0A%09MAP_TYPE                             = 0xf%0A%09MCL_CURRENT                          = 0x1%0A%09MCL_FUTURE                           = 0x2%0A%09MCL_ONFAULT                          = 0x4%0A%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A%09MINIX2_SUPER_MAGIC                   = 0x2468%0A%09MINIX2_SUPER_MAGIC2                  = 0x2478%0A%09MINIX3_SUPER_MAGIC                   = 0x4d5a%0A%09MINIX_SUPER_MAGIC                    = 0x137f%0A%09MINIX_SUPER_MAGIC2                   = 0x138f%0A%09MNT_DETACH                           = 0x2%0A%09MNT_EXPIRE                           = 0x4%0A%09MNT_FORCE                            = 0x1%0A%09MSDOS_SUPER_MAGIC                    = 0x4d44%0A%09MSG_BATCH                            = 0x40000%0A%09MSG_CMSG_CLOEXEC                     = 0x40000000%0A%09MSG_CONFIRM                          = 0x800%0A%09MSG_CTRUNC                           = 0x8%0A%09MSG_DONTROUTE                        = 0x4%0A%09MSG_DONTWAIT                         = 0x40%0A%09MSG_EOR                              = 0x80%0A%09MSG_ERRQUEUE                         = 0x2000%0A%09MSG_FASTOPEN                         = 0x20000000%0A%09MSG_FIN                              = 0x200%0A%09MSG_MORE                             = 0x8000%0A%09MSG_NOSIGNAL                         = 0x4000%0A%09MSG_OOB                              = 0x1%0A%09MSG_PEEK                             = 0x2%0A%09MSG_PROXY                            = 0x10%0A%09MSG_RST                              = 0x1000%0A%09MSG_SYN                              = 0x400%0A%09MSG_TRUNC                            = 0x20%0A%09MSG_TRYHARD                          = 0x4%0A%09MSG_WAITALL                          = 0x100%0A%09MSG_WAITFORONE                       = 0x10000%0A%09MSG_ZEROCOPY                         = 0x4000000%0A%09MS_ACTIVE                            = 0x40000000%0A%09MS_ASYNC                             = 0x1%0A%09MS_BIND                              = 0x1000%0A%09MS_BORN                              = 0x20000000%0A%09MS_DIRSYNC                           = 0x80%0A%09MS_INVALIDATE                        = 0x2%0A%09MS_I_VERSION                         = 0x800000%0A%09MS_KERNMOUNT                         = 0x400000%0A%09MS_LAZYTIME                          = 0x2000000%0A%09MS_MANDLOCK                          = 0x40%0A%09MS_MGC_MSK                           = 0xffff0000%0A%09MS_MGC_VAL                           = 0xc0ed0000%0A%09MS_MOVE                              = 0x2000%0A%09MS_NOATIME                           = 0x400%0A%09MS_NODEV                             = 0x4%0A%09MS_NODIRATIME                        = 0x800%0A%09MS_NOEXEC                            = 0x8%0A%09MS_NOREMOTELOCK                      = 0x8000000%0A%09MS_NOSEC                             = 0x10000000%0A%09MS_NOSUID                            = 0x2%0A%09MS_NOUSER                            = -0x80000000%0A%09MS_POSIXACL                          = 0x10000%0A%09MS_PRIVATE                           = 0x40000%0A%09MS_RDONLY                            = 0x1%0A%09MS_REC                               = 0x4000%0A%09MS_RELATIME                          = 0x200000%0A%09MS_REMOUNT                           = 0x20%0A%09MS_RMT_MASK                          = 0x2800051%0A%09MS_SHARED                            = 0x100000%0A%09MS_SILENT                            = 0x8000%0A%09MS_SLAVE                             = 0x80000%0A%09MS_STRICTATIME                       = 0x1000000%0A%09MS_SUBMOUNT                          = 0x4000000%0A%09MS_SYNC                              = 0x4%0A%09MS_SYNCHRONOUS                       = 0x10%0A%09MS_UNBINDABLE                        = 0x20000%0A%09MS_VERBOSE                           = 0x8000%0A%09MTD_INODE_FS_MAGIC                   = 0x11307854%0A%09NAME_MAX                             = 0xff%0A%09NCP_SUPER_MAGIC                      = 0x564c%0A%09NETLINK_ADD_MEMBERSHIP               = 0x1%0A%09NETLINK_AUDIT                        = 0x9%0A%09NETLINK_BROADCAST_ERROR              = 0x4%0A%09NETLINK_CAP_ACK                      = 0xa%0A%09NETLINK_CONNECTOR                    = 0xb%0A%09NETLINK_CRYPTO                       = 0x15%0A%09NETLINK_DNRTMSG                      = 0xe%0A%09NETLINK_DROP_MEMBERSHIP              = 0x2%0A%09NETLINK_ECRYPTFS                     = 0x13%0A%09NETLINK_EXT_ACK                      = 0xb%0A%09NETLINK_FIB_LOOKUP                   = 0xa%0A%09NETLINK_FIREWALL                     = 0x3%0A%09NETLINK_GENERIC                      = 0x10%0A%09NETLINK_INET_DIAG                    = 0x4%0A%09NETLINK_IP6_FW                       = 0xd%0A%09NETLINK_ISCSI                        = 0x8%0A%09NETLINK_KOBJECT_UEVENT               = 0xf%0A%09NETLINK_LISTEN_ALL_NSID              = 0x8%0A%09NETLINK_LIST_MEMBERSHIPS             = 0x9%0A%09NETLINK_NETFILTER                    = 0xc%0A%09NETLINK_NFLOG                        = 0x5%0A%09NETLINK_NO_ENOBUFS                   = 0x5%0A%09NETLINK_PKTINFO                      = 0x3%0A%09NETLINK_RDMA                         = 0x14%0A%09NETLINK_ROUTE                        = 0x0%0A%09NETLINK_RX_RING                      = 0x6%0A%09NETLINK_SCSITRANSPORT                = 0x12%0A%09NETLINK_SELINUX                      = 0x7%0A%09NETLINK_SMC                          = 0x16%0A%09NETLINK_SOCK_DIAG                    = 0x4%0A%09NETLINK_TX_RING                      = 0x7%0A%09NETLINK_UNUSED                       = 0x1%0A%09NETLINK_USERSOCK                     = 0x2%0A%09NETLINK_XFRM                         = 0x6%0A%09NETNSA_MAX                           = 0x3%0A%09NETNSA_NSID_NOT_ASSIGNED             = -0x1%0A%09NFNETLINK_V0                         = 0x0%0A%09NFNLGRP_ACCT_QUOTA                   = 0x8%0A%09NFNLGRP_CONNTRACK_DESTROY            = 0x3%0A%09NFNLGRP_CONNTRACK_EXP_DESTROY        = 0x6%0A%09NFNLGRP_CONNTRACK_EXP_NEW            = 0x4%0A%09NFNLGRP_CONNTRACK_EXP_UPDATE         = 0x5%0A%09NFNLGRP_CONNTRACK_NEW                = 0x1%0A%09NFNLGRP_CONNTRACK_UPDATE             = 0x2%0A%09NFNLGRP_MAX                          = 0x9%0A%09NFNLGRP_NFTABLES                     = 0x7%0A%09NFNLGRP_NFTRACE                      = 0x9%0A%09NFNLGRP_NONE                         = 0x0%0A%09NFNL_BATCH_MAX                       = 0x1%0A%09NFNL_MSG_BATCH_BEGIN                 = 0x10%0A%09NFNL_MSG_BATCH_END                   = 0x11%0A%09NFNL_NFA_NEST                        = 0x8000%0A%09NFNL_SUBSYS_ACCT                     = 0x7%0A%09NFNL_SUBSYS_COUNT                    = 0xc%0A%09NFNL_SUBSYS_CTHELPER                 = 0x9%0A%09NFNL_SUBSYS_CTNETLINK                = 0x1%0A%09NFNL_SUBSYS_CTNETLINK_EXP            = 0x2%0A%09NFNL_SUBSYS_CTNETLINK_TIMEOUT        = 0x8%0A%09NFNL_SUBSYS_IPSET                    = 0x6%0A%09NFNL_SUBSYS_NFTABLES                 = 0xa%0A%09NFNL_SUBSYS_NFT_COMPAT               = 0xb%0A%09NFNL_SUBSYS_NONE                     = 0x0%0A%09NFNL_SUBSYS_OSF                      = 0x5%0A%09NFNL_SUBSYS_QUEUE                    = 0x3%0A%09NFNL_SUBSYS_ULOG                     = 0x4%0A%09NFS_SUPER_MAGIC                      = 0x6969%0A%09NILFS_SUPER_MAGIC                    = 0x3434%0A%09NL0                                  = 0x0%0A%09NL1                                  = 0x100%0A%09NLA_ALIGNTO                          = 0x4%0A%09NLA_F_NESTED                         = 0x8000%0A%09NLA_F_NET_BYTEORDER                  = 0x4000%0A%09NLA_HDRLEN                           = 0x4%0A%09NLDLY                                = 0x100%0A%09NLMSG_ALIGNTO                        = 0x4%0A%09NLMSG_DONE                           = 0x3%0A%09NLMSG_ERROR                          = 0x2%0A%09NLMSG_HDRLEN                         = 0x10%0A%09NLMSG_MIN_TYPE                       = 0x10%0A%09NLMSG_NOOP                           = 0x1%0A%09NLMSG_OVERRUN                        = 0x4%0A%09NLM_F_ACK                            = 0x4%0A%09NLM_F_ACK_TLVS                       = 0x200%0A%09NLM_F_APPEND                         = 0x800%0A%09NLM_F_ATOMIC                         = 0x400%0A%09NLM_F_CAPPED                         = 0x100%0A%09NLM_F_CREATE                         = 0x400%0A%09NLM_F_DUMP                           = 0x300%0A%09NLM_F_DUMP_FILTERED                  = 0x20%0A%09NLM_F_DUMP_INTR                      = 0x10%0A%09NLM_F_ECHO                           = 0x8%0A%09NLM_F_EXCL                           = 0x200%0A%09NLM_F_MATCH                          = 0x200%0A%09NLM_F_MULTI                          = 0x2%0A%09NLM_F_NONREC                         = 0x100%0A%09NLM_F_REPLACE                        = 0x100%0A%09NLM_F_REQUEST                        = 0x1%0A%09NLM_F_ROOT                           = 0x100%0A%09NOFLSH                               = 0x80%0A%09NSFS_MAGIC                           = 0x6e736673%0A%09OCFS2_SUPER_MAGIC                    = 0x7461636f%0A%09OCRNL                                = 0x8%0A%09OFDEL                                = 0x80%0A%09OFILL                                = 0x40%0A%09OLCUC                                = 0x2%0A%09ONLCR                                = 0x4%0A%09ONLRET                               = 0x20%0A%09ONOCR                                = 0x10%0A%09OPENPROM_SUPER_MAGIC                 = 0x9fa1%0A%09OPOST                                = 0x1%0A%09OVERLAYFS_SUPER_MAGIC                = 0x794c7630%0A%09O_ACCMODE                            = 0x3%0A%09O_APPEND                             = 0x400%0A%09O_ASYNC                              = 0x2000%0A%09O_CLOEXEC                            = 0x80000%0A%09O_CREAT                              = 0x40%0A%09O_DIRECT                             = 0x4000%0A%09O_DIRECTORY                          = 0x10000%0A%09O_DSYNC                              = 0x1000%0A%09O_EXCL                               = 0x80%0A%09O_FSYNC                              = 0x101000%0A%09O_LARGEFILE                          = 0x0%0A%09O_NDELAY                             = 0x800%0A%09O_NOATIME                            = 0x40000%0A%09O_NOCTTY                             = 0x100%0A%09O_NOFOLLOW                           = 0x20000%0A%09O_NONBLOCK                           = 0x800%0A%09O_PATH                               = 0x200000%0A%09O_RDONLY                             = 0x0%0A%09O_RDWR                               = 0x2%0A%09O_RSYNC                              = 0x101000%0A%09O_SYNC                               = 0x101000%0A%09O_TMPFILE                            = 0x410000%0A%09O_TRUNC                              = 0x200%0A%09O_WRONLY                             = 0x1%0A%09PACKET_ADD_MEMBERSHIP                = 0x1%0A%09PACKET_AUXDATA                       = 0x8%0A%09PACKET_BROADCAST                     = 0x1%0A%09PACKET_COPY_THRESH                   = 0x7%0A%09PACKET_DROP_MEMBERSHIP               = 0x2%0A%09PACKET_FANOUT                        = 0x12%0A%09PACKET_FANOUT_CBPF                   = 0x6%0A%09PACKET_FANOUT_CPU                    = 0x2%0A%09PACKET_FANOUT_DATA                   = 0x16%0A%09PACKET_FANOUT_EBPF                   = 0x7%0A%09PACKET_FANOUT_FLAG_DEFRAG            = 0x8000%0A%09PACKET_FANOUT_FLAG_ROLLOVER          = 0x1000%0A%09PACKET_FANOUT_FLAG_UNIQUEID          = 0x2000%0A%09PACKET_FANOUT_HASH                   = 0x0%0A%09PACKET_FANOUT_LB                     = 0x1%0A%09PACKET_FANOUT_QM                     = 0x5%0A%09PACKET_FANOUT_RND                    = 0x4%0A%09PACKET_FANOUT_ROLLOVER               = 0x3%0A%09PACKET_FASTROUTE                     = 0x6%0A%09PACKET_HDRLEN                        = 0xb%0A%09PACKET_HOST                          = 0x0%0A%09PACKET_KERNEL                        = 0x7%0A%09PACKET_LOOPBACK                      = 0x5%0A%09PACKET_LOSS                          = 0xe%0A%09PACKET_MR_ALLMULTI                   = 0x2%0A%09PACKET_MR_MULTICAST                  = 0x0%0A%09PACKET_MR_PROMISC                    = 0x1%0A%09PACKET_MR_UNICAST                    = 0x3%0A%09PACKET_MULTICAST                     = 0x2%0A%09PACKET_ORIGDEV                       = 0x9%0A%09PACKET_OTHERHOST                     = 0x3%0A%09PACKET_OUTGOING                      = 0x4%0A%09PACKET_QDISC_BYPASS                  = 0x14%0A%09PACKET_RECV_OUTPUT                   = 0x3%0A%09PACKET_RESERVE                       = 0xc%0A%09PACKET_ROLLOVER_STATS                = 0x15%0A%09PACKET_RX_RING                       = 0x5%0A%09PACKET_STATISTICS                    = 0x6%0A%09PACKET_TIMESTAMP                     = 0x11%0A%09PACKET_TX_HAS_OFF                    = 0x13%0A%09PACKET_TX_RING                       = 0xd%0A%09PACKET_TX_TIMESTAMP                  = 0x10%0A%09PACKET_USER                          = 0x6%0A%09PACKET_VERSION                       = 0xa%0A%09PACKET_VNET_HDR                      = 0xf%0A%09PARENB                               = 0x100%0A%09PARITY_CRC16_PR0                     = 0x2%0A%09PARITY_CRC16_PR0_CCITT               = 0x4%0A%09PARITY_CRC16_PR1                     = 0x3%0A%09PARITY_CRC16_PR1_CCITT               = 0x5%0A%09PARITY_CRC32_PR0_CCITT               = 0x6%0A%09PARITY_CRC32_PR1_CCITT               = 0x7%0A%09PARITY_DEFAULT                       = 0x0%0A%09PARITY_NONE                          = 0x1%0A%09PARMRK                               = 0x8%0A%09PARODD                               = 0x200%0A%09PENDIN                               = 0x4000%0A%09PERF_EVENT_IOC_DISABLE               = 0x2401%0A%09PERF_EVENT_IOC_ENABLE                = 0x2400%0A%09PERF_EVENT_IOC_ID                    = 0x80082407%0A%09PERF_EVENT_IOC_MODIFY_ATTRIBUTES     = 0x4008240b%0A%09PERF_EVENT_IOC_PAUSE_OUTPUT          = 0x40042409%0A%09PERF_EVENT_IOC_PERIOD                = 0x40082404%0A%09PERF_EVENT_IOC_QUERY_BPF             = 0xc008240a%0A%09PERF_EVENT_IOC_REFRESH               = 0x2402%0A%09PERF_EVENT_IOC_RESET                 = 0x2403%0A%09PERF_EVENT_IOC_SET_BPF               = 0x40042408%0A%09PERF_EVENT_IOC_SET_FILTER            = 0x40082406%0A%09PERF_EVENT_IOC_SET_OUTPUT            = 0x2405%0A%09PIPEFS_MAGIC                         = 0x50495045%0A%09PRIO_PGRP                            = 0x1%0A%09PRIO_PROCESS                         = 0x0%0A%09PRIO_USER                            = 0x2%0A%09PROC_SUPER_MAGIC                     = 0x9fa0%0A%09PROT_EXEC                            = 0x4%0A%09PROT_GROWSDOWN                       = 0x1000000%0A%09PROT_GROWSUP                         = 0x2000000%0A%09PROT_NONE                            = 0x0%0A%09PROT_READ                            = 0x1%0A%09PROT_WRITE                           = 0x2%0A%09PR_CAPBSET_DROP                      = 0x18%0A%09PR_CAPBSET_READ                      = 0x17%0A%09PR_CAP_AMBIENT                       = 0x2f%0A%09PR_CAP_AMBIENT_CLEAR_ALL             = 0x4%0A%09PR_CAP_AMBIENT_IS_SET                = 0x1%0A%09PR_CAP_AMBIENT_LOWER                 = 0x3%0A%09PR_CAP_AMBIENT_RAISE                 = 0x2%0A%09PR_ENDIAN_BIG                        = 0x0%0A%09PR_ENDIAN_LITTLE                     = 0x1%0A%09PR_ENDIAN_PPC_LITTLE                 = 0x2%0A%09PR_FPEMU_NOPRINT                     = 0x1%0A%09PR_FPEMU_SIGFPE                      = 0x2%0A%09PR_FP_EXC_ASYNC                      = 0x2%0A%09PR_FP_EXC_DISABLED                   = 0x0%0A%09PR_FP_EXC_DIV                        = 0x10000%0A%09PR_FP_EXC_INV                        = 0x100000%0A%09PR_FP_EXC_NONRECOV                   = 0x1%0A%09PR_FP_EXC_OVF                        = 0x20000%0A%09PR_FP_EXC_PRECISE                    = 0x3%0A%09PR_FP_EXC_RES                        = 0x80000%0A%09PR_FP_EXC_SW_ENABLE                  = 0x80%0A%09PR_FP_EXC_UND                        = 0x40000%0A%09PR_FP_MODE_FR                        = 0x1%0A%09PR_FP_MODE_FRE                       = 0x2%0A%09PR_GET_CHILD_SUBREAPER               = 0x25%0A%09PR_GET_DUMPABLE                      = 0x3%0A%09PR_GET_ENDIAN                        = 0x13%0A%09PR_GET_FPEMU                         = 0x9%0A%09PR_GET_FPEXC                         = 0xb%0A%09PR_GET_FP_MODE                       = 0x2e%0A%09PR_GET_KEEPCAPS                      = 0x7%0A%09PR_GET_NAME                          = 0x10%0A%09PR_GET_NO_NEW_PRIVS                  = 0x27%0A%09PR_GET_PDEATHSIG                     = 0x2%0A%09PR_GET_SECCOMP                       = 0x15%0A%09PR_GET_SECUREBITS                    = 0x1b%0A%09PR_GET_SPECULATION_CTRL              = 0x34%0A%09PR_GET_THP_DISABLE                   = 0x2a%0A%09PR_GET_TID_ADDRESS                   = 0x28%0A%09PR_GET_TIMERSLACK                    = 0x1e%0A%09PR_GET_TIMING                        = 0xd%0A%09PR_GET_TSC                           = 0x19%0A%09PR_GET_UNALIGN                       = 0x5%0A%09PR_MCE_KILL                          = 0x21%0A%09PR_MCE_KILL_CLEAR                    = 0x0%0A%09PR_MCE_KILL_DEFAULT                  = 0x2%0A%09PR_MCE_KILL_EARLY                    = 0x1%0A%09PR_MCE_KILL_GET                      = 0x22%0A%09PR_MCE_KILL_LATE                     = 0x0%0A%09PR_MCE_KILL_SET                      = 0x1%0A%09PR_MPX_DISABLE_MANAGEMENT            = 0x2c%0A%09PR_MPX_ENABLE_MANAGEMENT             = 0x2b%0A%09PR_SET_CHILD_SUBREAPER               = 0x24%0A%09PR_SET_DUMPABLE                      = 0x4%0A%09PR_SET_ENDIAN                        = 0x14%0A%09PR_SET_FPEMU                         = 0xa%0A%09PR_SET_FPEXC                         = 0xc%0A%09PR_SET_FP_MODE                       = 0x2d%0A%09PR_SET_KEEPCAPS                      = 0x8%0A%09PR_SET_MM                            = 0x23%0A%09PR_SET_MM_ARG_END                    = 0x9%0A%09PR_SET_MM_ARG_START                  = 0x8%0A%09PR_SET_MM_AUXV                       = 0xc%0A%09PR_SET_MM_BRK                        = 0x7%0A%09PR_SET_MM_END_CODE                   = 0x2%0A%09PR_SET_MM_END_DATA                   = 0x4%0A%09PR_SET_MM_ENV_END                    = 0xb%0A%09PR_SET_MM_ENV_START                  = 0xa%0A%09PR_SET_MM_EXE_FILE                   = 0xd%0A%09PR_SET_MM_MAP                        = 0xe%0A%09PR_SET_MM_MAP_SIZE                   = 0xf%0A%09PR_SET_MM_START_BRK                  = 0x6%0A%09PR_SET_MM_START_CODE                 = 0x1%0A%09PR_SET_MM_START_DATA                 = 0x3%0A%09PR_SET_MM_START_STACK                = 0x5%0A%09PR_SET_NAME                          = 0xf%0A%09PR_SET_NO_NEW_PRIVS                  = 0x26%0A%09PR_SET_PDEATHSIG                     = 0x1%0A%09PR_SET_PTRACER                       = 0x59616d61%0A%09PR_SET_PTRACER_ANY                   = 0xffffffffffffffff%0A%09PR_SET_SECCOMP                       = 0x16%0A%09PR_SET_SECUREBITS                    = 0x1c%0A%09PR_SET_SPECULATION_CTRL              = 0x35%0A%09PR_SET_THP_DISABLE                   = 0x29%0A%09PR_SET_TIMERSLACK                    = 0x1d%0A%09PR_SET_TIMING                        = 0xe%0A%09PR_SET_TSC                           = 0x1a%0A%09PR_SET_UNALIGN                       = 0x6%0A%09PR_SPEC_DISABLE                      = 0x4%0A%09PR_SPEC_ENABLE                       = 0x2%0A%09PR_SPEC_FORCE_DISABLE                = 0x8%0A%09PR_SPEC_NOT_AFFECTED                 = 0x0%0A%09PR_SPEC_PRCTL                        = 0x1%0A%09PR_SPEC_STORE_BYPASS                 = 0x0%0A%09PR_SVE_GET_VL                        = 0x33%0A%09PR_SVE_SET_VL                        = 0x32%0A%09PR_SVE_SET_VL_ONEXEC                 = 0x40000%0A%09PR_SVE_VL_INHERIT                    = 0x20000%0A%09PR_SVE_VL_LEN_MASK                   = 0xffff%0A%09PR_TASK_PERF_EVENTS_DISABLE          = 0x1f%0A%09PR_TASK_PERF_EVENTS_ENABLE           = 0x20%0A%09PR_TIMING_STATISTICAL                = 0x0%0A%09PR_TIMING_TIMESTAMP                  = 0x1%0A%09PR_TSC_ENABLE                        = 0x1%0A%09PR_TSC_SIGSEGV                       = 0x2%0A%09PR_UNALIGN_NOPRINT                   = 0x1%0A%09PR_UNALIGN_SIGBUS                    = 0x2%0A%09PSTOREFS_MAGIC                       = 0x6165676c%0A%09PTRACE_ATTACH                        = 0x10%0A%09PTRACE_CONT                          = 0x7%0A%09PTRACE_DETACH                        = 0x11%0A%09PTRACE_EVENT_CLONE                   = 0x3%0A%09PTRACE_EVENT_EXEC                    = 0x4%0A%09PTRACE_EVENT_EXIT                    = 0x6%0A%09PTRACE_EVENT_FORK                    = 0x1%0A%09PTRACE_EVENT_SECCOMP                 = 0x7%0A%09PTRACE_EVENT_STOP                    = 0x80%0A%09PTRACE_EVENT_VFORK                   = 0x2%0A%09PTRACE_EVENT_VFORK_DONE              = 0x5%0A%09PTRACE_GETEVENTMSG                   = 0x4201%0A%09PTRACE_GETREGS                       = 0xc%0A%09PTRACE_GETREGSET                     = 0x4204%0A%09PTRACE_GETSIGINFO                    = 0x4202%0A%09PTRACE_GETSIGMASK                    = 0x420a%0A%09PTRACE_INTERRUPT                     = 0x4207%0A%09PTRACE_KILL                          = 0x8%0A%09PTRACE_LISTEN                        = 0x4208%0A%09PTRACE_O_EXITKILL                    = 0x100000%0A%09PTRACE_O_MASK                        = 0x3000ff%0A%09PTRACE_O_SUSPEND_SECCOMP             = 0x200000%0A%09PTRACE_O_TRACECLONE                  = 0x8%0A%09PTRACE_O_TRACEEXEC                   = 0x10%0A%09PTRACE_O_TRACEEXIT                   = 0x40%0A%09PTRACE_O_TRACEFORK                   = 0x2%0A%09PTRACE_O_TRACESECCOMP                = 0x80%0A%09PTRACE_O_TRACESYSGOOD                = 0x1%0A%09PTRACE_O_TRACEVFORK                  = 0x4%0A%09PTRACE_O_TRACEVFORKDONE              = 0x20%0A%09PTRACE_PEEKDATA                      = 0x2%0A%09PTRACE_PEEKSIGINFO                   = 0x4209%0A%09PTRACE_PEEKSIGINFO_SHARED            = 0x1%0A%09PTRACE_PEEKTEXT                      = 0x1%0A%09PTRACE_PEEKUSR                       = 0x3%0A%09PTRACE_POKEDATA                      = 0x5%0A%09PTRACE_POKETEXT                      = 0x4%0A%09PTRACE_POKEUSR                       = 0x6%0A%09PTRACE_SECCOMP_GET_FILTER            = 0x420c%0A%09PTRACE_SECCOMP_GET_METADATA          = 0x420d%0A%09PTRACE_SEIZE                         = 0x4206%0A%09PTRACE_SETOPTIONS                    = 0x4200%0A%09PTRACE_SETREGS                       = 0xd%0A%09PTRACE_SETREGSET                     = 0x4205%0A%09PTRACE_SETSIGINFO                    = 0x4203%0A%09PTRACE_SETSIGMASK                    = 0x420b%0A%09PTRACE_SINGLESTEP                    = 0x9%0A%09PTRACE_SYSCALL                       = 0x18%0A%09PTRACE_TRACEME                       = 0x0%0A%09QNX4_SUPER_MAGIC                     = 0x2f%0A%09QNX6_SUPER_MAGIC                     = 0x68191122%0A%09RAMFS_MAGIC                          = 0x858458f6%0A%09RDTGROUP_SUPER_MAGIC                 = 0x7655821%0A%09REISERFS_SUPER_MAGIC                 = 0x52654973%0A%09RENAME_EXCHANGE                      = 0x2%0A%09RENAME_NOREPLACE                     = 0x1%0A%09RENAME_WHITEOUT                      = 0x4%0A%09RLIMIT_AS                            = 0x9%0A%09RLIMIT_CORE                          = 0x4%0A%09RLIMIT_CPU                           = 0x0%0A%09RLIMIT_DATA                          = 0x2%0A%09RLIMIT_FSIZE                         = 0x1%0A%09RLIMIT_LOCKS                         = 0xa%0A%09RLIMIT_MEMLOCK                       = 0x8%0A%09RLIMIT_MSGQUEUE                      = 0xc%0A%09RLIMIT_NICE                          = 0xd%0A%09RLIMIT_NOFILE                        = 0x7%0A%09RLIMIT_NPROC                         = 0x6%0A%09RLIMIT_RSS                           = 0x5%0A%09RLIMIT_RTPRIO                        = 0xe%0A%09RLIMIT_RTTIME                        = 0xf%0A%09RLIMIT_SIGPENDING                    = 0xb%0A%09RLIMIT_STACK                         = 0x3%0A%09RLIM_INFINITY                        = 0xffffffffffffffff%0A%09RTAX_ADVMSS                          = 0x8%0A%09RTAX_CC_ALGO                         = 0x10%0A%09RTAX_CWND                            = 0x7%0A%09RTAX_FASTOPEN_NO_COOKIE              = 0x11%0A%09RTAX_FEATURES                        = 0xc%0A%09RTAX_FEATURE_ALLFRAG                 = 0x8%0A%09RTAX_FEATURE_ECN                     = 0x1%0A%09RTAX_FEATURE_MASK                    = 0xf%0A%09RTAX_FEATURE_SACK                    = 0x2%0A%09RTAX_FEATURE_TIMESTAMP               = 0x4%0A%09RTAX_HOPLIMIT                        = 0xa%0A%09RTAX_INITCWND                        = 0xb%0A%09RTAX_INITRWND                        = 0xe%0A%09RTAX_LOCK                            = 0x1%0A%09RTAX_MAX                             = 0x11%0A%09RTAX_MTU                             = 0x2%0A%09RTAX_QUICKACK                        = 0xf%0A%09RTAX_REORDERING                      = 0x9%0A%09RTAX_RTO_MIN                         = 0xd%0A%09RTAX_RTT                             = 0x4%0A%09RTAX_RTTVAR                          = 0x5%0A%09RTAX_SSTHRESH                        = 0x6%0A%09RTAX_UNSPEC                          = 0x0%0A%09RTAX_WINDOW                          = 0x3%0A%09RTA_ALIGNTO                          = 0x4%0A%09RTA_MAX                              = 0x1d%0A%09RTCF_DIRECTSRC                       = 0x4000000%0A%09RTCF_DOREDIRECT                      = 0x1000000%0A%09RTCF_LOG                             = 0x2000000%0A%09RTCF_MASQ                            = 0x400000%0A%09RTCF_NAT                             = 0x800000%0A%09RTCF_VALVE                           = 0x200000%0A%09RTC_AF                               = 0x20%0A%09RTC_AIE_OFF                          = 0x7002%0A%09RTC_AIE_ON                           = 0x7001%0A%09RTC_ALM_READ                         = 0x80247008%0A%09RTC_ALM_SET                          = 0x40247007%0A%09RTC_EPOCH_READ                       = 0x8008700d%0A%09RTC_EPOCH_SET                        = 0x4008700e%0A%09RTC_IRQF                             = 0x80%0A%09RTC_IRQP_READ                        = 0x8008700b%0A%09RTC_IRQP_SET                         = 0x4008700c%0A%09RTC_MAX_FREQ                         = 0x2000%0A%09RTC_PF                               = 0x40%0A%09RTC_PIE_OFF                          = 0x7006%0A%09RTC_PIE_ON                           = 0x7005%0A%09RTC_PLL_GET                          = 0x80207011%0A%09RTC_PLL_SET                          = 0x40207012%0A%09RTC_RD_TIME                          = 0x80247009%0A%09RTC_SET_TIME                         = 0x4024700a%0A%09RTC_UF                               = 0x10%0A%09RTC_UIE_OFF                          = 0x7004%0A%09RTC_UIE_ON                           = 0x7003%0A%09RTC_VL_CLR                           = 0x7014%0A%09RTC_VL_READ                          = 0x80047013%0A%09RTC_WIE_OFF                          = 0x7010%0A%09RTC_WIE_ON                           = 0x700f%0A%09RTC_WKALM_RD                         = 0x80287010%0A%09RTC_WKALM_SET                        = 0x4028700f%0A%09RTF_ADDRCLASSMASK                    = 0xf8000000%0A%09RTF_ADDRCONF                         = 0x40000%0A%09RTF_ALLONLINK                        = 0x20000%0A%09RTF_BROADCAST                        = 0x10000000%0A%09RTF_CACHE                            = 0x1000000%0A%09RTF_DEFAULT                          = 0x10000%0A%09RTF_DYNAMIC                          = 0x10%0A%09RTF_FLOW                             = 0x2000000%0A%09RTF_GATEWAY                          = 0x2%0A%09RTF_HOST                             = 0x4%0A%09RTF_INTERFACE                        = 0x40000000%0A%09RTF_IRTT                             = 0x100%0A%09RTF_LINKRT                           = 0x100000%0A%09RTF_LOCAL                            = 0x80000000%0A%09RTF_MODIFIED                         = 0x20%0A%09RTF_MSS                              = 0x40%0A%09RTF_MTU                              = 0x40%0A%09RTF_MULTICAST                        = 0x20000000%0A%09RTF_NAT                              = 0x8000000%0A%09RTF_NOFORWARD                        = 0x1000%0A%09RTF_NONEXTHOP                        = 0x200000%0A%09RTF_NOPMTUDISC                       = 0x4000%0A%09RTF_POLICY                           = 0x4000000%0A%09RTF_REINSTATE                        = 0x8%0A%09RTF_REJECT                           = 0x200%0A%09RTF_STATIC                           = 0x400%0A%09RTF_THROW                            = 0x2000%0A%09RTF_UP                               = 0x1%0A%09RTF_WINDOW                           = 0x80%0A%09RTF_XRESOLVE                         = 0x800%0A%09RTM_BASE                             = 0x10%0A%09RTM_DELACTION                        = 0x31%0A%09RTM_DELADDR                          = 0x15%0A%09RTM_DELADDRLABEL                     = 0x49%0A%09RTM_DELLINK                          = 0x11%0A%09RTM_DELMDB                           = 0x55%0A%09RTM_DELNEIGH                         = 0x1d%0A%09RTM_DELNETCONF                       = 0x51%0A%09RTM_DELNSID                          = 0x59%0A%09RTM_DELQDISC                         = 0x25%0A%09RTM_DELROUTE                         = 0x19%0A%09RTM_DELRULE                          = 0x21%0A%09RTM_DELTCLASS                        = 0x29%0A%09RTM_DELTFILTER                       = 0x2d%0A%09RTM_F_CLONED                         = 0x200%0A%09RTM_F_EQUALIZE                       = 0x400%0A%09RTM_F_FIB_MATCH                      = 0x2000%0A%09RTM_F_LOOKUP_TABLE                   = 0x1000%0A%09RTM_F_NOTIFY                         = 0x100%0A%09RTM_F_PREFIX                         = 0x800%0A%09RTM_GETACTION                        = 0x32%0A%09RTM_GETADDR                          = 0x16%0A%09RTM_GETADDRLABEL                     = 0x4a%0A%09RTM_GETANYCAST                       = 0x3e%0A%09RTM_GETDCB                           = 0x4e%0A%09RTM_GETLINK                          = 0x12%0A%09RTM_GETMDB                           = 0x56%0A%09RTM_GETMULTICAST                     = 0x3a%0A%09RTM_GETNEIGH                         = 0x1e%0A%09RTM_GETNEIGHTBL                      = 0x42%0A%09RTM_GETNETCONF                       = 0x52%0A%09RTM_GETNSID                          = 0x5a%0A%09RTM_GETQDISC                         = 0x26%0A%09RTM_GETROUTE                         = 0x1a%0A%09RTM_GETRULE                          = 0x22%0A%09RTM_GETSTATS                         = 0x5e%0A%09RTM_GETTCLASS                        = 0x2a%0A%09RTM_GETTFILTER                       = 0x2e%0A%09RTM_MAX                              = 0x63%0A%09RTM_NEWACTION                        = 0x30%0A%09RTM_NEWADDR                          = 0x14%0A%09RTM_NEWADDRLABEL                     = 0x48%0A%09RTM_NEWCACHEREPORT                   = 0x60%0A%09RTM_NEWLINK                          = 0x10%0A%09RTM_NEWMDB                           = 0x54%0A%09RTM_NEWNDUSEROPT                     = 0x44%0A%09RTM_NEWNEIGH                         = 0x1c%0A%09RTM_NEWNEIGHTBL                      = 0x40%0A%09RTM_NEWNETCONF                       = 0x50%0A%09RTM_NEWNSID                          = 0x58%0A%09RTM_NEWPREFIX                        = 0x34%0A%09RTM_NEWQDISC                         = 0x24%0A%09RTM_NEWROUTE                         = 0x18%0A%09RTM_NEWRULE                          = 0x20%0A%09RTM_NEWSTATS                         = 0x5c%0A%09RTM_NEWTCLASS                        = 0x28%0A%09RTM_NEWTFILTER                       = 0x2c%0A%09RTM_NR_FAMILIES                      = 0x15%0A%09RTM_NR_MSGTYPES                      = 0x54%0A%09RTM_SETDCB                           = 0x4f%0A%09RTM_SETLINK                          = 0x13%0A%09RTM_SETNEIGHTBL                      = 0x43%0A%09RTNH_ALIGNTO                         = 0x4%0A%09RTNH_COMPARE_MASK                    = 0x19%0A%09RTNH_F_DEAD                          = 0x1%0A%09RTNH_F_LINKDOWN                      = 0x10%0A%09RTNH_F_OFFLOAD                       = 0x8%0A%09RTNH_F_ONLINK                        = 0x4%0A%09RTNH_F_PERVASIVE                     = 0x2%0A%09RTNH_F_UNRESOLVED                    = 0x20%0A%09RTN_MAX                              = 0xb%0A%09RTPROT_BABEL                         = 0x2a%0A%09RTPROT_BGP                           = 0xba%0A%09RTPROT_BIRD                          = 0xc%0A%09RTPROT_BOOT                          = 0x3%0A%09RTPROT_DHCP                          = 0x10%0A%09RTPROT_DNROUTED                      = 0xd%0A%09RTPROT_EIGRP                         = 0xc0%0A%09RTPROT_GATED                         = 0x8%0A%09RTPROT_ISIS                          = 0xbb%0A%09RTPROT_KERNEL                        = 0x2%0A%09RTPROT_MROUTED                       = 0x11%0A%09RTPROT_MRT                           = 0xa%0A%09RTPROT_NTK                           = 0xf%0A%09RTPROT_OSPF                          = 0xbc%0A%09RTPROT_RA                            = 0x9%0A%09RTPROT_REDIRECT                      = 0x1%0A%09RTPROT_RIP                           = 0xbd%0A%09RTPROT_STATIC                        = 0x4%0A%09RTPROT_UNSPEC                        = 0x0%0A%09RTPROT_XORP                          = 0xe%0A%09RTPROT_ZEBRA                         = 0xb%0A%09RT_CLASS_DEFAULT                     = 0xfd%0A%09RT_CLASS_LOCAL                       = 0xff%0A%09RT_CLASS_MAIN                        = 0xfe%0A%09RT_CLASS_MAX                         = 0xff%0A%09RT_CLASS_UNSPEC                      = 0x0%0A%09RUSAGE_CHILDREN                      = -0x1%0A%09RUSAGE_SELF                          = 0x0%0A%09RUSAGE_THREAD                        = 0x1%0A%09SCM_CREDENTIALS                      = 0x2%0A%09SCM_RIGHTS                           = 0x1%0A%09SCM_TIMESTAMP                        = 0x1d%0A%09SCM_TIMESTAMPING                     = 0x25%0A%09SCM_TIMESTAMPING_OPT_STATS           = 0x36%0A%09SCM_TIMESTAMPING_PKTINFO             = 0x3a%0A%09SCM_TIMESTAMPNS                      = 0x23%0A%09SCM_WIFI_STATUS                      = 0x29%0A%09SECCOMP_MODE_DISABLED                = 0x0%0A%09SECCOMP_MODE_FILTER                  = 0x2%0A%09SECCOMP_MODE_STRICT                  = 0x1%0A%09SECURITYFS_MAGIC                     = 0x73636673%0A%09SELINUX_MAGIC                        = 0xf97cff8c%0A%09SHUT_RD                              = 0x0%0A%09SHUT_RDWR                            = 0x2%0A%09SHUT_WR                              = 0x1%0A%09SIOCADDDLCI                          = 0x8980%0A%09SIOCADDMULTI                         = 0x8931%0A%09SIOCADDRT                            = 0x890b%0A%09SIOCATMARK                           = 0x8905%0A%09SIOCBONDCHANGEACTIVE                 = 0x8995%0A%09SIOCBONDENSLAVE                      = 0x8990%0A%09SIOCBONDINFOQUERY                    = 0x8994%0A%09SIOCBONDRELEASE                      = 0x8991%0A%09SIOCBONDSETHWADDR                    = 0x8992%0A%09SIOCBONDSLAVEINFOQUERY               = 0x8993%0A%09SIOCBRADDBR                          = 0x89a0%0A%09SIOCBRADDIF                          = 0x89a2%0A%09SIOCBRDELBR                          = 0x89a1%0A%09SIOCBRDELIF                          = 0x89a3%0A%09SIOCDARP                             = 0x8953%0A%09SIOCDELDLCI                          = 0x8981%0A%09SIOCDELMULTI                         = 0x8932%0A%09SIOCDELRT                            = 0x890c%0A%09SIOCDEVPRIVATE                       = 0x89f0%0A%09SIOCDIFADDR                          = 0x8936%0A%09SIOCDRARP                            = 0x8960%0A%09SIOCETHTOOL                          = 0x8946%0A%09SIOCGARP                             = 0x8954%0A%09SIOCGHWTSTAMP                        = 0x89b1%0A%09SIOCGIFADDR                          = 0x8915%0A%09SIOCGIFBR                            = 0x8940%0A%09SIOCGIFBRDADDR                       = 0x8919%0A%09SIOCGIFCONF                          = 0x8912%0A%09SIOCGIFCOUNT                         = 0x8938%0A%09SIOCGIFDSTADDR                       = 0x8917%0A%09SIOCGIFENCAP                         = 0x8925%0A%09SIOCGIFFLAGS                         = 0x8913%0A%09SIOCGIFHWADDR                        = 0x8927%0A%09SIOCGIFINDEX                         = 0x8933%0A%09SIOCGIFMAP                           = 0x8970%0A%09SIOCGIFMEM                           = 0x891f%0A%09SIOCGIFMETRIC                        = 0x891d%0A%09SIOCGIFMTU                           = 0x8921%0A%09SIOCGIFNAME                          = 0x8910%0A%09SIOCGIFNETMASK                       = 0x891b%0A%09SIOCGIFPFLAGS                        = 0x8935%0A%09SIOCGIFSLAVE                         = 0x8929%0A%09SIOCGIFTXQLEN                        = 0x8942%0A%09SIOCGIFVLAN                          = 0x8982%0A%09SIOCGMIIPHY                          = 0x8947%0A%09SIOCGMIIREG                          = 0x8948%0A%09SIOCGPGRP                            = 0x8904%0A%09SIOCGRARP                            = 0x8961%0A%09SIOCGSKNS                            = 0x894c%0A%09SIOCGSTAMP                           = 0x8906%0A%09SIOCGSTAMPNS                         = 0x8907%0A%09SIOCINQ                              = 0x541b%0A%09SIOCOUTQ                             = 0x5411%0A%09SIOCOUTQNSD                          = 0x894b%0A%09SIOCPROTOPRIVATE                     = 0x89e0%0A%09SIOCRTMSG                            = 0x890d%0A%09SIOCSARP                             = 0x8955%0A%09SIOCSHWTSTAMP                        = 0x89b0%0A%09SIOCSIFADDR                          = 0x8916%0A%09SIOCSIFBR                            = 0x8941%0A%09SIOCSIFBRDADDR                       = 0x891a%0A%09SIOCSIFDSTADDR                       = 0x8918%0A%09SIOCSIFENCAP                         = 0x8926%0A%09SIOCSIFFLAGS                         = 0x8914%0A%09SIOCSIFHWADDR                        = 0x8924%0A%09SIOCSIFHWBROADCAST                   = 0x8937%0A%09SIOCSIFLINK                          = 0x8911%0A%09SIOCSIFMAP                           = 0x8971%0A%09SIOCSIFMEM                           = 0x8920%0A%09SIOCSIFMETRIC                        = 0x891e%0A%09SIOCSIFMTU                           = 0x8922%0A%09SIOCSIFNAME                          = 0x8923%0A%09SIOCSIFNETMASK                       = 0x891c%0A%09SIOCSIFPFLAGS                        = 0x8934%0A%09SIOCSIFSLAVE                         = 0x8930%0A%09SIOCSIFTXQLEN                        = 0x8943%0A%09SIOCSIFVLAN                          = 0x8983%0A%09SIOCSMIIREG                          = 0x8949%0A%09SIOCSPGRP                            = 0x8902%0A%09SIOCSRARP                            = 0x8962%0A%09SIOCWANDEV                           = 0x894a%0A%09SMACK_MAGIC                          = 0x43415d53%0A%09SMART_AUTOSAVE                       = 0xd2%0A%09SMART_AUTO_OFFLINE                   = 0xdb%0A%09SMART_DISABLE                        = 0xd9%0A%09SMART_ENABLE                         = 0xd8%0A%09SMART_HCYL_PASS                      = 0xc2%0A%09SMART_IMMEDIATE_OFFLINE              = 0xd4%0A%09SMART_LCYL_PASS                      = 0x4f%0A%09SMART_READ_LOG_SECTOR                = 0xd5%0A%09SMART_READ_THRESHOLDS                = 0xd1%0A%09SMART_READ_VALUES                    = 0xd0%0A%09SMART_SAVE                           = 0xd3%0A%09SMART_STATUS                         = 0xda%0A%09SMART_WRITE_LOG_SECTOR               = 0xd6%0A%09SMART_WRITE_THRESHOLDS               = 0xd7%0A%09SMB_SUPER_MAGIC                      = 0x517b%0A%09SOCKFS_MAGIC                         = 0x534f434b%0A%09SOCK_CLOEXEC                         = 0x80000%0A%09SOCK_DCCP                            = 0x6%0A%09SOCK_DGRAM                           = 0x2%0A%09SOCK_IOC_TYPE                        = 0x89%0A%09SOCK_NONBLOCK                        = 0x800%0A%09SOCK_PACKET                          = 0xa%0A%09SOCK_RAW                             = 0x3%0A%09SOCK_RDM                             = 0x4%0A%09SOCK_SEQPACKET                       = 0x5%0A%09SOCK_STREAM                          = 0x1%0A%09SOL_AAL                              = 0x109%0A%09SOL_ALG                              = 0x117%0A%09SOL_ATM                              = 0x108%0A%09SOL_CAIF                             = 0x116%0A%09SOL_CAN_BASE                         = 0x64%0A%09SOL_DCCP                             = 0x10d%0A%09SOL_DECNET                           = 0x105%0A%09SOL_ICMPV6                           = 0x3a%0A%09SOL_IP                               = 0x0%0A%09SOL_IPV6                             = 0x29%0A%09SOL_IRDA                             = 0x10a%0A%09SOL_IUCV                             = 0x115%0A%09SOL_KCM                              = 0x119%0A%09SOL_LLC                              = 0x10c%0A%09SOL_NETBEUI                          = 0x10b%0A%09SOL_NETLINK                          = 0x10e%0A%09SOL_NFC                              = 0x118%0A%09SOL_PACKET                           = 0x107%0A%09SOL_PNPIPE                           = 0x113%0A%09SOL_PPPOL2TP                         = 0x111%0A%09SOL_RAW                              = 0xff%0A%09SOL_RDS                              = 0x114%0A%09SOL_RXRPC                            = 0x110%0A%09SOL_SOCKET                           = 0x1%0A%09SOL_TCP                              = 0x6%0A%09SOL_TIPC                             = 0x10f%0A%09SOL_TLS                              = 0x11a%0A%09SOL_X25                              = 0x106%0A%09SOL_XDP                              = 0x11b%0A%09SOMAXCONN                            = 0x80%0A%09SO_ACCEPTCONN                        = 0x1e%0A%09SO_ATTACH_BPF                        = 0x32%0A%09SO_ATTACH_FILTER                     = 0x1a%0A%09SO_ATTACH_REUSEPORT_CBPF             = 0x33%0A%09SO_ATTACH_REUSEPORT_EBPF             = 0x34%0A%09SO_BINDTODEVICE                      = 0x19%0A%09SO_BPF_EXTENSIONS                    = 0x30%0A%09SO_BROADCAST                         = 0x6%0A%09SO_BSDCOMPAT                         = 0xe%0A%09SO_BUSY_POLL                         = 0x2e%0A%09SO_CNX_ADVICE                        = 0x35%0A%09SO_COOKIE                            = 0x39%0A%09SO_DEBUG                             = 0x1%0A%09SO_DETACH_BPF                        = 0x1b%0A%09SO_DETACH_FILTER                     = 0x1b%0A%09SO_DOMAIN                            = 0x27%0A%09SO_DONTROUTE                         = 0x5%0A%09SO_ERROR                             = 0x4%0A%09SO_GET_FILTER                        = 0x1a%0A%09SO_INCOMING_CPU                      = 0x31%0A%09SO_INCOMING_NAPI_ID                  = 0x38%0A%09SO_KEEPALIVE                         = 0x9%0A%09SO_LINGER                            = 0xd%0A%09SO_LOCK_FILTER                       = 0x2c%0A%09SO_MARK                              = 0x24%0A%09SO_MAX_PACING_RATE                   = 0x2f%0A%09SO_MEMINFO                           = 0x37%0A%09SO_NOFCS                             = 0x2b%0A%09SO_NO_CHECK                          = 0xb%0A%09SO_OOBINLINE                         = 0xa%0A%09SO_PASSCRED                          = 0x10%0A%09SO_PASSSEC                           = 0x22%0A%09SO_PEEK_OFF                          = 0x2a%0A%09SO_PEERCRED                          = 0x11%0A%09SO_PEERGROUPS                        = 0x3b%0A%09SO_PEERNAME                          = 0x1c%0A%09SO_PEERSEC                           = 0x1f%0A%09SO_PRIORITY                          = 0xc%0A%09SO_PROTOCOL                          = 0x26%0A%09SO_RCVBUF                            = 0x8%0A%09SO_RCVBUFFORCE                       = 0x21%0A%09SO_RCVLOWAT                          = 0x12%0A%09SO_RCVTIMEO                          = 0x14%0A%09SO_REUSEADDR                         = 0x2%0A%09SO_REUSEPORT                         = 0xf%0A%09SO_RXQ_OVFL                          = 0x28%0A%09SO_SECURITY_AUTHENTICATION           = 0x16%0A%09SO_SECURITY_ENCRYPTION_NETWORK       = 0x18%0A%09SO_SECURITY_ENCRYPTION_TRANSPORT     = 0x17%0A%09SO_SELECT_ERR_QUEUE                  = 0x2d%0A%09SO_SNDBUF                            = 0x7%0A%09SO_SNDBUFFORCE                       = 0x20%0A%09SO_SNDLOWAT                          = 0x13%0A%09SO_SNDTIMEO                          = 0x15%0A%09SO_TIMESTAMP                         = 0x1d%0A%09SO_TIMESTAMPING                      = 0x25%0A%09SO_TIMESTAMPNS                       = 0x23%0A%09SO_TYPE                              = 0x3%0A%09SO_VM_SOCKETS_BUFFER_MAX_SIZE        = 0x2%0A%09SO_VM_SOCKETS_BUFFER_MIN_SIZE        = 0x1%0A%09SO_VM_SOCKETS_BUFFER_SIZE            = 0x0%0A%09SO_VM_SOCKETS_CONNECT_TIMEOUT        = 0x6%0A%09SO_VM_SOCKETS_NONBLOCK_TXRX          = 0x7%0A%09SO_VM_SOCKETS_PEER_HOST_VM_ID        = 0x3%0A%09SO_VM_SOCKETS_TRUSTED                = 0x5%0A%09SO_WIFI_STATUS                       = 0x29%0A%09SO_ZEROCOPY                          = 0x3c%0A%09SPLICE_F_GIFT                        = 0x8%0A%09SPLICE_F_MORE                        = 0x4%0A%09SPLICE_F_MOVE                        = 0x1%0A%09SPLICE_F_NONBLOCK                    = 0x2%0A%09SQUASHFS_MAGIC                       = 0x73717368%0A%09STACK_END_MAGIC                      = 0x57ac6e9d%0A%09STATX_ALL                            = 0xfff%0A%09STATX_ATIME                          = 0x20%0A%09STATX_ATTR_APPEND                    = 0x20%0A%09STATX_ATTR_AUTOMOUNT                 = 0x1000%0A%09STATX_ATTR_COMPRESSED                = 0x4%0A%09STATX_ATTR_ENCRYPTED                 = 0x800%0A%09STATX_ATTR_IMMUTABLE                 = 0x10%0A%09STATX_ATTR_NODUMP                    = 0x40%0A%09STATX_BASIC_STATS                    = 0x7ff%0A%09STATX_BLOCKS                         = 0x400%0A%09STATX_BTIME                          = 0x800%0A%09STATX_CTIME                          = 0x80%0A%09STATX_GID                            = 0x10%0A%09STATX_INO                            = 0x100%0A%09STATX_MODE                           = 0x2%0A%09STATX_MTIME                          = 0x40%0A%09STATX_NLINK                          = 0x4%0A%09STATX_SIZE                           = 0x200%0A%09STATX_TYPE                           = 0x1%0A%09STATX_UID                            = 0x8%0A%09STATX__RESERVED                      = 0x80000000%0A%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A%09SYSFS_MAGIC                          = 0x62656572%0A%09S_BLKSIZE                            = 0x200%0A%09S_IEXEC                              = 0x40%0A%09S_IFBLK                              = 0x6000%0A%09S_IFCHR                              = 0x2000%0A%09S_IFDIR                              = 0x4000%0A%09S_IFIFO                              = 0x1000%0A%09S_IFLNK                              = 0xa000%0A%09S_IFMT                               = 0xf000%0A%09S_IFREG                              = 0x8000%0A%09S_IFSOCK                             = 0xc000%0A%09S_IREAD                              = 0x100%0A%09S_IRGRP                              = 0x20%0A%09S_IROTH                              = 0x4%0A%09S_IRUSR                              = 0x100%0A%09S_IRWXG                              = 0x38%0A%09S_IRWXO                              = 0x7%0A%09S_IRWXU                              = 0x1c0%0A%09S_ISGID                              = 0x400%0A%09S_ISUID                              = 0x800%0A%09S_ISVTX                              = 0x200%0A%09S_IWGRP                              = 0x10%0A%09S_IWOTH                              = 0x2%0A%09S_IWRITE                             = 0x80%0A%09S_IWUSR                              = 0x80%0A%09S_IXGRP                              = 0x8%0A%09S_IXOTH                              = 0x1%0A%09S_IXUSR                              = 0x40%0A%09TAB0                                 = 0x0%0A%09TAB1                                 = 0x800%0A%09TAB2                                 = 0x1000%0A%09TAB3                                 = 0x1800%0A%09TABDLY                               = 0x1800%0A%09TASKSTATS_CMD_ATTR_MAX               = 0x4%0A%09TASKSTATS_CMD_MAX                    = 0x2%0A%09TASKSTATS_GENL_NAME                  = %22TASKSTATS%22%0A%09TASKSTATS_GENL_VERSION               = 0x1%0A%09TASKSTATS_TYPE_MAX                   = 0x6%0A%09TASKSTATS_VERSION                    = 0x8%0A%09TCFLSH                               = 0x540b%0A%09TCGETA                               = 0x5405%0A%09TCGETS                               = 0x5401%0A%09TCGETS2                              = 0x802c542a%0A%09TCGETX                               = 0x5432%0A%09TCIFLUSH                             = 0x0%0A%09TCIOFF                               = 0x2%0A%09TCIOFLUSH                            = 0x2%0A%09TCION                                = 0x3%0A%09TCOFLUSH                             = 0x1%0A%09TCOOFF                               = 0x0%0A%09TCOON                                = 0x1%0A%09TCP_CC_INFO                          = 0x1a%0A%09TCP_CONGESTION                       = 0xd%0A%09TCP_COOKIE_IN_ALWAYS                 = 0x1%0A%09TCP_COOKIE_MAX                       = 0x10%0A%09TCP_COOKIE_MIN                       = 0x8%0A%09TCP_COOKIE_OUT_NEVER                 = 0x2%0A%09TCP_COOKIE_PAIR_SIZE                 = 0x20%0A%09TCP_COOKIE_TRANSACTIONS              = 0xf%0A%09TCP_CORK                             = 0x3%0A%09TCP_DEFER_ACCEPT                     = 0x9%0A%09TCP_FASTOPEN                         = 0x17%0A%09TCP_FASTOPEN_CONNECT                 = 0x1e%0A%09TCP_FASTOPEN_KEY                     = 0x21%0A%09TCP_FASTOPEN_NO_COOKIE               = 0x22%0A%09TCP_INFO                             = 0xb%0A%09TCP_KEEPCNT                          = 0x6%0A%09TCP_KEEPIDLE                         = 0x4%0A%09TCP_KEEPINTVL                        = 0x5%0A%09TCP_LINGER2                          = 0x8%0A%09TCP_MAXSEG                           = 0x2%0A%09TCP_MAXWIN                           = 0xffff%0A%09TCP_MAX_WINSHIFT                     = 0xe%0A%09TCP_MD5SIG                           = 0xe%0A%09TCP_MD5SIG_EXT                       = 0x20%0A%09TCP_MD5SIG_FLAG_PREFIX               = 0x1%0A%09TCP_MD5SIG_MAXKEYLEN                 = 0x50%0A%09TCP_MSS                              = 0x200%0A%09TCP_MSS_DEFAULT                      = 0x218%0A%09TCP_MSS_DESIRED                      = 0x4c4%0A%09TCP_NODELAY                          = 0x1%0A%09TCP_NOTSENT_LOWAT                    = 0x19%0A%09TCP_QUEUE_SEQ                        = 0x15%0A%09TCP_QUICKACK                         = 0xc%0A%09TCP_REPAIR                           = 0x13%0A%09TCP_REPAIR_OPTIONS                   = 0x16%0A%09TCP_REPAIR_QUEUE                     = 0x14%0A%09TCP_REPAIR_WINDOW                    = 0x1d%0A%09TCP_SAVED_SYN                        = 0x1c%0A%09TCP_SAVE_SYN                         = 0x1b%0A%09TCP_SYNCNT                           = 0x7%0A%09TCP_S_DATA_IN                        = 0x4%0A%09TCP_S_DATA_OUT                       = 0x8%0A%09TCP_THIN_DUPACK                      = 0x11%0A%09TCP_THIN_LINEAR_TIMEOUTS             = 0x10%0A%09TCP_TIMESTAMP                        = 0x18%0A%09TCP_ULP                              = 0x1f%0A%09TCP_USER_TIMEOUT                     = 0x12%0A%09TCP_WINDOW_CLAMP                     = 0xa%0A%09TCSAFLUSH                            = 0x2%0A%09TCSBRK                               = 0x5409%0A%09TCSBRKP                              = 0x5425%0A%09TCSETA                               = 0x5406%0A%09TCSETAF                              = 0x5408%0A%09TCSETAW                              = 0x5407%0A%09TCSETS                               = 0x5402%0A%09TCSETS2                              = 0x402c542b%0A%09TCSETSF                              = 0x5404%0A%09TCSETSF2                             = 0x402c542d%0A%09TCSETSW                              = 0x5403%0A%09TCSETSW2                             = 0x402c542c%0A%09TCSETX                               = 0x5433%0A%09TCSETXF                              = 0x5434%0A%09TCSETXW                              = 0x5435%0A%09TCXONC                               = 0x540a%0A%09TIOCCBRK                             = 0x5428%0A%09TIOCCONS                             = 0x541d%0A%09TIOCEXCL                             = 0x540c%0A%09TIOCGDEV                             = 0x80045432%0A%09TIOCGETD                             = 0x5424%0A%09TIOCGEXCL                            = 0x80045440%0A%09TIOCGICOUNT                          = 0x545d%0A%09TIOCGLCKTRMIOS                       = 0x5456%0A%09TIOCGPGRP                            = 0x540f%0A%09TIOCGPKT                             = 0x80045438%0A%09TIOCGPTLCK                           = 0x80045439%0A%09TIOCGPTN                             = 0x80045430%0A%09TIOCGPTPEER                          = 0x5441%0A%09TIOCGRS485                           = 0x542e%0A%09TIOCGSERIAL                          = 0x541e%0A%09TIOCGSID                             = 0x5429%0A%09TIOCGSOFTCAR                         = 0x5419%0A%09TIOCGWINSZ                           = 0x5413%0A%09TIOCINQ                              = 0x541b%0A%09TIOCLINUX                            = 0x541c%0A%09TIOCMBIC                             = 0x5417%0A%09TIOCMBIS                             = 0x5416%0A%09TIOCMGET                             = 0x5415%0A%09TIOCMIWAIT                           = 0x545c%0A%09TIOCMSET                             = 0x5418%0A%09TIOCM_CAR                            = 0x40%0A%09TIOCM_CD                             = 0x40%0A%09TIOCM_CTS                            = 0x20%0A%09TIOCM_DSR                            = 0x100%0A%09TIOCM_DTR                            = 0x2%0A%09TIOCM_LE                             = 0x1%0A%09TIOCM_RI                             = 0x80%0A%09TIOCM_RNG                            = 0x80%0A%09TIOCM_RTS                            = 0x4%0A%09TIOCM_SR                             = 0x10%0A%09TIOCM_ST                             = 0x8%0A%09TIOCNOTTY                            = 0x5422%0A%09TIOCNXCL                             = 0x540d%0A%09TIOCOUTQ                             = 0x5411%0A%09TIOCPKT                              = 0x5420%0A%09TIOCPKT_DATA                         = 0x0%0A%09TIOCPKT_DOSTOP                       = 0x20%0A%09TIOCPKT_FLUSHREAD                    = 0x1%0A%09TIOCPKT_FLUSHWRITE                   = 0x2%0A%09TIOCPKT_IOCTL                        = 0x40%0A%09TIOCPKT_NOSTOP                       = 0x10%0A%09TIOCPKT_START                        = 0x8%0A%09TIOCPKT_STOP                         = 0x4%0A%09TIOCSBRK                             = 0x5427%0A%09TIOCSCTTY                            = 0x540e%0A%09TIOCSERCONFIG                        = 0x5453%0A%09TIOCSERGETLSR                        = 0x5459%0A%09TIOCSERGETMULTI                      = 0x545a%0A%09TIOCSERGSTRUCT                       = 0x5458%0A%09TIOCSERGWILD                         = 0x5454%0A%09TIOCSERSETMULTI                      = 0x545b%0A%09TIOCSERSWILD                         = 0x5455%0A%09TIOCSER_TEMT                         = 0x1%0A%09TIOCSETD                             = 0x5423%0A%09TIOCSIG                              = 0x40045436%0A%09TIOCSLCKTRMIOS                       = 0x5457%0A%09TIOCSPGRP                            = 0x5410%0A%09TIOCSPTLCK                           = 0x40045431%0A%09TIOCSRS485                           = 0x542f%0A%09TIOCSSERIAL                          = 0x541f%0A%09TIOCSSOFTCAR                         = 0x541a%0A%09TIOCSTI                              = 0x5412%0A%09TIOCSWINSZ                           = 0x5414%0A%09TIOCVHANGUP                          = 0x5437%0A%09TMPFS_MAGIC                          = 0x1021994%0A%09TOSTOP                               = 0x100%0A%09TPACKET_ALIGNMENT                    = 0x10%0A%09TPACKET_HDRLEN                       = 0x34%0A%09TP_STATUS_AVAILABLE                  = 0x0%0A%09TP_STATUS_BLK_TMO                    = 0x20%0A%09TP_STATUS_COPY                       = 0x2%0A%09TP_STATUS_CSUMNOTREADY               = 0x8%0A%09TP_STATUS_CSUM_VALID                 = 0x80%0A%09TP_STATUS_KERNEL                     = 0x0%0A%09TP_STATUS_LOSING                     = 0x4%0A%09TP_STATUS_SENDING                    = 0x2%0A%09TP_STATUS_SEND_REQUEST               = 0x1%0A%09TP_STATUS_TS_RAW_HARDWARE            = -0x80000000%0A%09TP_STATUS_TS_SOFTWARE                = 0x20000000%0A%09TP_STATUS_TS_SYS_HARDWARE            = 0x40000000%0A%09TP_STATUS_USER                       = 0x1%0A%09TP_STATUS_VLAN_TPID_VALID            = 0x40%0A%09TP_STATUS_VLAN_VALID                 = 0x10%0A%09TP_STATUS_WRONG_FORMAT               = 0x4%0A%09TRACEFS_MAGIC                        = 0x74726163%0A%09TS_COMM_LEN                          = 0x20%0A%09TUNATTACHFILTER                      = 0x401054d5%0A%09TUNDETACHFILTER                      = 0x401054d6%0A%09TUNGETFEATURES                       = 0x800454cf%0A%09TUNGETFILTER                         = 0x801054db%0A%09TUNGETIFF                            = 0x800454d2%0A%09TUNGETSNDBUF                         = 0x800454d3%0A%09TUNGETVNETBE                         = 0x800454df%0A%09TUNGETVNETHDRSZ                      = 0x800454d7%0A%09TUNGETVNETLE                         = 0x800454dd%0A%09TUNSETDEBUG                          = 0x400454c9%0A%09TUNSETFILTEREBPF                     = 0x800454e1%0A%09TUNSETGROUP                          = 0x400454ce%0A%09TUNSETIFF                            = 0x400454ca%0A%09TUNSETIFINDEX                        = 0x400454da%0A%09TUNSETLINK                           = 0x400454cd%0A%09TUNSETNOCSUM                         = 0x400454c8%0A%09TUNSETOFFLOAD                        = 0x400454d0%0A%09TUNSETOWNER                          = 0x400454cc%0A%09TUNSETPERSIST                        = 0x400454cb%0A%09TUNSETQUEUE                          = 0x400454d9%0A%09TUNSETSNDBUF                         = 0x400454d4%0A%09TUNSETSTEERINGEBPF                   = 0x800454e0%0A%09TUNSETTXFILTER                       = 0x400454d1%0A%09TUNSETVNETBE                         = 0x400454de%0A%09TUNSETVNETHDRSZ                      = 0x400454d8%0A%09TUNSETVNETLE                         = 0x400454dc%0A%09UBI_IOCATT                           = 0x40186f40%0A%09UBI_IOCDET                           = 0x40046f41%0A%09UBI_IOCEBCH                          = 0x40044f02%0A%09UBI_IOCEBER                          = 0x40044f01%0A%09UBI_IOCEBISMAP                       = 0x80044f05%0A%09UBI_IOCEBMAP                         = 0x40084f03%0A%09UBI_IOCEBUNMAP                       = 0x40044f04%0A%09UBI_IOCMKVOL                         = 0x40986f00%0A%09UBI_IOCRMVOL                         = 0x40046f01%0A%09UBI_IOCRNVOL                         = 0x51106f03%0A%09UBI_IOCRSVOL                         = 0x400c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x40104f06%0A%09UBI_IOCVOLCRBLK                      = 0x40804f07%0A%09UBI_IOCVOLRMBLK                      = 0x4f08%0A%09UBI_IOCVOLUP                         = 0x40084f00%0A%09UDF_SUPER_MAGIC                      = 0x15013346%0A%09UMOUNT_NOFOLLOW                      = 0x8%0A%09USBDEVICE_SUPER_MAGIC                = 0x9fa2%0A%09UTIME_NOW                            = 0x3fffffff%0A%09UTIME_OMIT                           = 0x3ffffffe%0A%09V9FS_MAGIC                           = 0x1021997%0A%09VDISCARD                             = 0xd%0A%09VEOF                                 = 0x4%0A%09VEOL                                 = 0xb%0A%09VEOL2                                = 0x10%0A%09VERASE                               = 0x2%0A%09VINTR                                = 0x0%0A%09VKILL                                = 0x3%0A%09VLNEXT                               = 0xf%0A%09VMADDR_CID_ANY                       = 0xffffffff%0A%09VMADDR_CID_HOST                      = 0x2%0A%09VMADDR_CID_HYPERVISOR                = 0x0%0A%09VMADDR_CID_RESERVED                  = 0x1%0A%09VMADDR_PORT_ANY                      = 0xffffffff%0A%09VMIN                                 = 0x6%0A%09VM_SOCKETS_INVALID_VERSION           = 0xffffffff%0A%09VQUIT                                = 0x1%0A%09VREPRINT                             = 0xc%0A%09VSTART                               = 0x8%0A%09VSTOP                                = 0x9%0A%09VSUSP                                = 0xa%0A%09VSWTC                                = 0x7%0A%09VT0                                  = 0x0%0A%09VT1                                  = 0x4000%0A%09VTDLY                                = 0x4000%0A%09VTIME                                = 0x5%0A%09VWERASE                              = 0xe%0A%09WALL                                 = 0x40000000%0A%09WCLONE                               = 0x80000000%0A%09WCONTINUED                           = 0x8%0A%09WDIOC_GETBOOTSTATUS                  = 0x80045702%0A%09WDIOC_GETPRETIMEOUT                  = 0x80045709%0A%09WDIOC_GETSTATUS                      = 0x80045701%0A%09WDIOC_GETSUPPORT                     = 0x80285700%0A%09WDIOC_GETTEMP                        = 0x80045703%0A%09WDIOC_GETTIMELEFT                    = 0x8004570a%0A%09WDIOC_GETTIMEOUT                     = 0x80045707%0A%09WDIOC_KEEPALIVE                      = 0x80045705%0A%09WDIOC_SETOPTIONS                     = 0x80045704%0A%09WDIOC_SETPRETIMEOUT                  = 0xc0045708%0A%09WDIOC_SETTIMEOUT                     = 0xc0045706%0A%09WEXITED                              = 0x4%0A%09WIN_ACKMEDIACHANGE                   = 0xdb%0A%09WIN_CHECKPOWERMODE1                  = 0xe5%0A%09WIN_CHECKPOWERMODE2                  = 0x98%0A%09WIN_DEVICE_RESET                     = 0x8%0A%09WIN_DIAGNOSE                         = 0x90%0A%09WIN_DOORLOCK                         = 0xde%0A%09WIN_DOORUNLOCK                       = 0xdf%0A%09WIN_DOWNLOAD_MICROCODE               = 0x92%0A%09WIN_FLUSH_CACHE                      = 0xe7%0A%09WIN_FLUSH_CACHE_EXT                  = 0xea%0A%09WIN_FORMAT                           = 0x50%0A%09WIN_GETMEDIASTATUS                   = 0xda%0A%09WIN_IDENTIFY                         = 0xec%0A%09WIN_IDENTIFY_DMA                     = 0xee%0A%09WIN_IDLEIMMEDIATE                    = 0xe1%0A%09WIN_INIT                             = 0x60%0A%09WIN_MEDIAEJECT                       = 0xed%0A%09WIN_MULTREAD                         = 0xc4%0A%09WIN_MULTREAD_EXT                     = 0x29%0A%09WIN_MULTWRITE                        = 0xc5%0A%09WIN_MULTWRITE_EXT                    = 0x39%0A%09WIN_NOP                              = 0x0%0A%09WIN_PACKETCMD                        = 0xa0%0A%09WIN_PIDENTIFY                        = 0xa1%0A%09WIN_POSTBOOT                         = 0xdc%0A%09WIN_PREBOOT                          = 0xdd%0A%09WIN_QUEUED_SERVICE                   = 0xa2%0A%09WIN_READ                             = 0x20%0A%09WIN_READDMA                          = 0xc8%0A%09WIN_READDMA_EXT                      = 0x25%0A%09WIN_READDMA_ONCE                     = 0xc9%0A%09WIN_READDMA_QUEUED                   = 0xc7%0A%09WIN_READDMA_QUEUED_EXT               = 0x26%0A%09WIN_READ_BUFFER                      = 0xe4%0A%09WIN_READ_EXT                         = 0x24%0A%09WIN_READ_LONG                        = 0x22%0A%09WIN_READ_LONG_ONCE                   = 0x23%0A%09WIN_READ_NATIVE_MAX                  = 0xf8%0A%09WIN_READ_NATIVE_MAX_EXT              = 0x27%0A%09WIN_READ_ONCE                        = 0x21%0A%09WIN_RECAL                            = 0x10%0A%09WIN_RESTORE                          = 0x10%0A%09WIN_SECURITY_DISABLE                 = 0xf6%0A%09WIN_SECURITY_ERASE_PREPARE           = 0xf3%0A%09WIN_SECURITY_ERASE_UNIT              = 0xf4%0A%09WIN_SECURITY_FREEZE_LOCK             = 0xf5%0A%09WIN_SECURITY_SET_PASS                = 0xf1%0A%09WIN_SECURITY_UNLOCK                  = 0xf2%0A%09WIN_SEEK                             = 0x70%0A%09WIN_SETFEATURES                      = 0xef%0A%09WIN_SETIDLE1                         = 0xe3%0A%09WIN_SETIDLE2                         = 0x97%0A%09WIN_SETMULT                          = 0xc6%0A%09WIN_SET_MAX                          = 0xf9%0A%09WIN_SET_MAX_EXT                      = 0x37%0A%09WIN_SLEEPNOW1                        = 0xe6%0A%09WIN_SLEEPNOW2                        = 0x99%0A%09WIN_SMART                            = 0xb0%0A%09WIN_SPECIFY                          = 0x91%0A%09WIN_SRST                             = 0x8%0A%09WIN_STANDBY                          = 0xe2%0A%09WIN_STANDBY2                         = 0x96%0A%09WIN_STANDBYNOW1                      = 0xe0%0A%09WIN_STANDBYNOW2                      = 0x94%0A%09WIN_VERIFY                           = 0x40%0A%09WIN_VERIFY_EXT                       = 0x42%0A%09WIN_VERIFY_ONCE                      = 0x41%0A%09WIN_WRITE                            = 0x30%0A%09WIN_WRITEDMA                         = 0xca%0A%09WIN_WRITEDMA_EXT                     = 0x35%0A%09WIN_WRITEDMA_ONCE                    = 0xcb%0A%09WIN_WRITEDMA_QUEUED                  = 0xcc%0A%09WIN_WRITEDMA_QUEUED_EXT              = 0x36%0A%09WIN_WRITE_BUFFER                     = 0xe8%0A%09WIN_WRITE_EXT                        = 0x34%0A%09WIN_WRITE_LONG                       = 0x32%0A%09WIN_WRITE_LONG_ONCE                  = 0x33%0A%09WIN_WRITE_ONCE                       = 0x31%0A%09WIN_WRITE_SAME                       = 0xe9%0A%09WIN_WRITE_VERIFY                     = 0x3c%0A%09WNOHANG                              = 0x1%0A%09WNOTHREAD                            = 0x20000000%0A%09WNOWAIT                              = 0x1000000%0A%09WORDSIZE                             = 0x40%0A%09WSTOPPED                             = 0x2%0A%09WUNTRACED                            = 0x2%0A%09XATTR_CREATE                         = 0x1%0A%09XATTR_REPLACE                        = 0x2%0A%09XCASE                                = 0x4%0A%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A%09XENFS_SUPER_MAGIC                    = 0xabba1974%0A%09XTABS                                = 0x1800%0A%09ZSMALLOC_MAGIC                       = 0x58295829%0A)%0A%0A// Errors%0Aconst (%0A%09E2BIG           = syscall.Errno(0x7)%0A%09EACCES          = syscall.Errno(0xd)%0A%09EADDRINUSE      = syscall.Errno(0x62)%0A%09EADDRNOTAVAIL   = syscall.Errno(0x63)%0A%09EADV            = syscall.Errno(0x44)%0A%09EAFNOSUPPORT    = syscall.Errno(0x61)%0A%09EAGAIN          = syscall.Errno(0xb)%0A%09EALREADY        = syscall.Errno(0x72)%0A%09EBADE           = syscall.Errno(0x34)%0A%09EBADF           = syscall.Errno(0x9)%0A%09EBADFD          = syscall.Errno(0x4d)%0A%09EBADMSG         = syscall.Errno(0x4a)%0A%09EBADR           = syscall.Errno(0x35)%0A%09EBADRQC         = syscall.Errno(0x38)%0A%09EBADSLT         = syscall.Errno(0x39)%0A%09EBFONT          = syscall.Errno(0x3b)%0A%09EBUSY           = syscall.Errno(0x10)%0A%09ECANCELED       = syscall.Errno(0x7d)%0A%09ECHILD          = syscall.Errno(0xa)%0A%09ECHRNG          = syscall.Errno(0x2c)%0A%09ECOMM           = syscall.Errno(0x46)%0A%09ECONNABORTED    = syscall.Errno(0x67)%0A%09ECONNREFUSED    = syscall.Errno(0x6f)%0A%09ECONNRESET      = syscall.Errno(0x68)%0A%09EDEADLK         = syscall.Errno(0x23)%0A%09EDEADLOCK       = syscall.Errno(0x23)%0A%09EDESTADDRREQ    = syscall.Errno(0x59)%0A%09EDOM            = syscall.Errno(0x21)%0A%09EDOTDOT         = syscall.Errno(0x49)%0A%09EDQUOT          = syscall.Errno(0x7a)%0A%09EEXIST          = syscall.Errno(0x11)%0A%09EFAULT          = syscall.Errno(0xe)%0A%09EFBIG           = syscall.Errno(0x1b)%0A%09EHOSTDOWN       = syscall.Errno(0x70)%0A%09EHOSTUNREACH    = syscall.Errno(0x71)%0A%09EHWPOISON       = syscall.Errno(0x85)%0A%09EIDRM           = syscall.Errno(0x2b)%0A%09EILSEQ          = syscall.Errno(0x54)%0A%09EINPROGRESS     = syscall.Errno(0x73)%0A%09EINTR           = syscall.Errno(0x4)%0A%09EINVAL          = syscall.Errno(0x16)%0A%09EIO             = syscall.Errno(0x5)%0A%09EISCONN         = syscall.Errno(0x6a)%0A%09EISDIR          = syscall.Errno(0x15)%0A%09EISNAM          = syscall.Errno(0x78)%0A%09EKEYEXPIRED     = syscall.Errno(0x7f)%0A%09EKEYREJECTED    = syscall.Errno(0x81)%0A%09EKEYREVOKED     = syscall.Errno(0x80)%0A%09EL2HLT          = syscall.Errno(0x33)%0A%09EL2NSYNC        = syscall.Errno(0x2d)%0A%09EL3HLT          = syscall.Errno(0x2e)%0A%09EL3RST          = syscall.Errno(0x2f)%0A%09ELIBACC         = syscall.Errno(0x4f)%0A%09ELIBBAD         = syscall.Errno(0x50)%0A%09ELIBEXEC        = syscall.Errno(0x53)%0A%09ELIBMAX         = syscall.Errno(0x52)%0A%09ELIBSCN         = syscall.Errno(0x51)%0A%09ELNRNG          = syscall.Errno(0x30)%0A%09ELOOP           = syscall.Errno(0x28)%0A%09EMEDIUMTYPE     = syscall.Errno(0x7c)%0A%09EMFILE          = syscall.Errno(0x18)%0A%09EMLINK          = syscall.Errno(0x1f)%0A%09EMSGSIZE        = syscall.Errno(0x5a)%0A%09EMULTIHOP       = syscall.Errno(0x48)%0A%09ENAMETOOLONG    = syscall.Errno(0x24)%0A%09ENAVAIL         = syscall.Errno(0x77)%0A%09ENETDOWN        = syscall.Errno(0x64)%0A%09ENETRESET       = syscall.Errno(0x66)%0A%09ENETUNREACH     = syscall.Errno(0x65)%0A%09ENFILE          = syscall.Errno(0x17)%0A%09ENOANO          = syscall.Errno(0x37)%0A%09ENOBUFS         = syscall.Errno(0x69)%0A%09ENOCSI          = syscall.Errno(0x32)%0A%09ENODATA         = syscall.Errno(0x3d)%0A%09ENODEV          = syscall.Errno(0x13)%0A%09ENOENT          = syscall.Errno(0x2)%0A%09ENOEXEC         = syscall.Errno(0x8)%0A%09ENOKEY          = syscall.Errno(0x7e)%0A%09ENOLCK          = syscall.Errno(0x25)%0A%09ENOLINK         = syscall.Errno(0x43)%0A%09ENOMEDIUM       = syscall.Errno(0x7b)%0A%09ENOMEM          = syscall.Errno(0xc)%0A%09ENOMSG          = syscall.Errno(0x2a)%0A%09ENONET          = syscall.Errno(0x40)%0A%09ENOPKG          = syscall.Errno(0x41)%0A%09ENOPROTOOPT     = syscall.Errno(0x5c)%0A%09ENOSPC          = syscall.Errno(0x1c)%0A%09ENOSR           = syscall.Errno(0x3f)%0A%09ENOSTR          = syscall.Errno(0x3c)%0A%09ENOSYS          = syscall.Errno(0x26)%0A%09ENOTBLK         = syscall.Errno(0xf)%0A%09ENOTCONN        = syscall.Errno(0x6b)%0A%09ENOTDIR         = syscall.Errno(0x14)%0A%09ENOTEMPTY       = syscall.Errno(0x27)%0A%09ENOTNAM         = syscall.Errno(0x76)%0A%09ENOTRECOVERABLE = syscall.Errno(0x83)%0A%09ENOTSOCK        = syscall.Errno(0x58)%0A%09ENOTSUP         = syscall.Errno(0x5f)%0A%09ENOTTY          = syscall.Errno(0x19)%0A%09ENOTUNIQ        = syscall.Errno(0x4c)%0A%09ENXIO           = syscall.Errno(0x6)%0A%09EOPNOTSUPP      = syscall.Errno(0x5f)%0A%09EOVERFLOW       = syscall.Errno(0x4b)%0A%09EOWNERDEAD      = syscall.Errno(0x82)%0A%09EPERM           = syscall.Errno(0x1)%0A%09EPFNOSUPPORT    = syscall.Errno(0x60)%0A%09EPIPE           = syscall.Errno(0x20)%0A%09EPROTO          = syscall.Errno(0x47)%0A%09EPROTONOSUPPORT = syscall.Errno(0x5d)%0A%09EPROTOTYPE      = syscall.Errno(0x5b)%0A%09ERANGE          = syscall.Errno(0x22)%0A%09EREMCHG         = syscall.Errno(0x4e)%0A%09EREMOTE         = syscall.Errno(0x42)%0A%09EREMOTEIO       = syscall.Errno(0x79)%0A%09ERESTART        = syscall.Errno(0x55)%0A%09ERFKILL         = syscall.Errno(0x84)%0A%09EROFS           = syscall.Errno(0x1e)%0A%09ESHUTDOWN       = syscall.Errno(0x6c)%0A%09ESOCKTNOSUPPORT = syscall.Errno(0x5e)%0A%09ESPIPE          = syscall.Errno(0x1d)%0A%09ESRCH           = syscall.Errno(0x3)%0A%09ESRMNT          = syscall.Errno(0x45)%0A%09ESTALE          = syscall.Errno(0x74)%0A%09ESTRPIPE        = syscall.Errno(0x56)%0A%09ETIME           = syscall.Errno(0x3e)%0A%09ETIMEDOUT       = syscall.Errno(0x6e)%0A%09ETOOMANYREFS    = syscall.Errno(0x6d)%0A%09ETXTBSY         = syscall.Errno(0x1a)%0A%09EUCLEAN         = syscall.Errno(0x75)%0A%09EUNATCH         = syscall.Errno(0x31)%0A%09EUSERS          = syscall.Errno(0x57)%0A%09EWOULDBLOCK     = syscall.Errno(0xb)%0A%09EXDEV           = syscall.Errno(0x12)%0A%09EXFULL          = syscall.Errno(0x36)%0A)%0A%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f 33e83c609b5162fd687d0c7005f5039dc216f896227c1d5a1237d880eb5c508b vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
+ f 969cb9cbfffcb6a8a09ecf431f6730f0ccb2bee1318a85cb5b9a19a5753c5443 vendor/golang.org/x/sys/unix/zerrors_linux_s390x.go
dmppatch 27
@@ -2711,16 +2711,61 @@
   = 0x9%0A
+%09AF_XDP                               = 0x2c%0A
 %09ALG_OP_
@@ -44327,16 +44327,749 @@
   = 0x4%0A
+%09MFD_ALLOW_SEALING                    = 0x2%0A%09MFD_CLOEXEC                          = 0x1%0A%09MFD_HUGETLB                          = 0x4%0A%09MFD_HUGE_16GB                        = -0x78000000%0A%09MFD_HUGE_16MB                        = 0x60000000%0A%09MFD_HUGE_1GB                         = 0x78000000%0A%09MFD_HUGE_1MB                         = 0x50000000%0A%09MFD_HUGE_256MB                       = 0x70000000%0A%09MFD_HUGE_2GB                         = 0x7c000000%0A%09MFD_HUGE_2MB                         = 0x54000000%0A%09MFD_HUGE_512KB                       = 0x4c000000%0A%09MFD_HUGE_64KB                        = 0x40000000%0A%09MFD_HUGE_8MB                         = 0x5c000000%0A%09MFD_HUGE_MASK                        = 0x3f%0A%09MFD_HUGE_SHIFT                       = 0x1a%0A
 %09MINIX2_
@@ -85349,16 +85349,62 @@
 = 0x106%0A
+%09SOL_XDP                              = 0x11b%0A
 %09SOMAXCO
@@ -89666,16 +89666,148 @@
 0000000%0A
+%09SYNC_FILE_RANGE_WAIT_AFTER           = 0x4%0A%09SYNC_FILE_RANGE_WAIT_BEFORE          = 0x1%0A%09SYNC_FILE_RANGE_WRITE                = 0x2%0A
 %09SYSFS_M
@@ -100596,16 +100596,777 @@
 00454dc%0A
+%09UBI_IOCATT                           = 0x40186f40%0A%09UBI_IOCDET                           = 0x40046f41%0A%09UBI_IOCEBCH                          = 0x40044f02%0A%09UBI_IOCEBER                          = 0x40044f01%0A%09UBI_IOCEBISMAP                       = 0x80044f05%0A%09UBI_IOCEBMAP                         = 0x40084f03%0A%09UBI_IOCEBUNMAP                       = 0x40044f04%0A%09UBI_IOCMKVOL                         = 0x40986f00%0A%09UBI_IOCRMVOL                         = 0x40046f01%0A%09UBI_IOCRNVOL                         = 0x51106f03%0A%09UBI_IOCRSVOL                         = 0x400c6f02%0A%09UBI_IOCSETVOLPROP                    = 0x40104f06%0A%09UBI_IOCVOLCRBLK                      = 0x40804f07%0A%09UBI_IOCVOLRMBLK                      = 0x4f08%0A%09UBI_IOCVOLUP                         = 0x40084f00%0A
 %09UDF_SUP
@@ -107581,16 +107581,919 @@
   = 0x4%0A
+%09XDP_COPY                             = 0x2%0A%09XDP_FLAGS_DRV_MODE                   = 0x4%0A%09XDP_FLAGS_HW_MODE                    = 0x8%0A%09XDP_FLAGS_MASK                       = 0xf%0A%09XDP_FLAGS_MODES                      = 0xe%0A%09XDP_FLAGS_SKB_MODE                   = 0x2%0A%09XDP_FLAGS_UPDATE_IF_NOEXIST          = 0x1%0A%09XDP_MMAP_OFFSETS                     = 0x1%0A%09XDP_PGOFF_RX_RING                    = 0x0%0A%09XDP_PGOFF_TX_RING                    = 0x80000000%0A%09XDP_RX_RING                          = 0x2%0A%09XDP_SHARED_UMEM                      = 0x1%0A%09XDP_STATISTICS                       = 0x7%0A%09XDP_TX_RING                          = 0x3%0A%09XDP_UMEM_COMPLETION_RING             = 0x6%0A%09XDP_UMEM_FILL_RING                   = 0x5%0A%09XDP_UMEM_PGOFF_COMPLETION_RING       = 0x180000000%0A%09XDP_UMEM_PGOFF_FILL_RING             = 0x100000000%0A%09XDP_UMEM_REG                         = 0x4%0A%09XDP_ZEROCOPY                         = 0x4%0A
 %09XENFS_S
@@ -113866,8 +113866,8428 @@
 0x36)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0x7)%0A%09SIGCHLD   = syscall.Signal(0x11)%0A%09SIGCLD    = syscall.Signal(0x11)%0A%09SIGCONT   = syscall.Signal(0x12)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x1d)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x1d)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1e)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTKFLT = syscall.Signal(0x10)%0A%09SIGSTOP   = syscall.Signal(0x13)%0A%09SIGSYS    = syscall.Signal(0x1f)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x14)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x17)%0A%09SIGUSR1   = syscall.Signal(0xa)%0A%09SIGUSR2   = syscall.Signal(0xc)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device or resource busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22invalid cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22numerical result out of range%22%7D,%0A%09%7B35, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B36, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B37, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B38, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B39, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B40, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B42, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B43, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B44, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B45, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B46, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B47, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B48, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B49, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B50, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B51, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B52, %22EBADE%22, %22invalid exchange%22%7D,%0A%09%7B53, %22EBADR%22, %22invalid request descriptor%22%7D,%0A%09%7B54, %22EXFULL%22, %22exchange full%22%7D,%0A%09%7B55, %22ENOANO%22, %22no anode%22%7D,%0A%09%7B56, %22EBADRQC%22, %22invalid request code%22%7D,%0A%09%7B57, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B59, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B60, %22ENOSTR%22, %22device not a stream%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of streams resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B73, %22EDOTDOT%22, %22RFS specific error%22%7D,%0A%09%7B74, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B75, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B76, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B77, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B78, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B79, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B80, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B81, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B82, %22ELIBMAX%22, %22attempting to link in too many shared libraries%22%7D,%0A%09%7B83, %22ELIBEXEC%22, %22cannot exec a shared library directly%22%7D,%0A%09%7B84, %22EILSEQ%22, %22invalid or incomplete multibyte or wide character%22%7D,%0A%09%7B85, %22ERESTART%22, %22interrupted system call should be restarted%22%7D,%0A%09%7B86, %22ESTRPIPE%22, %22streams pipe error%22%7D,%0A%09%7B87, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B88, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B89, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B90, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B91, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B92, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B93, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B94, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B95, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B96, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B97, %22EAFNOSUPPORT%22, %22address family not supported by protocol%22%7D,%0A%09%7B98, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B99, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B100, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B101, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B102, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B103, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B104, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B105, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B106, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B107, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B108, %22ESHUTDOWN%22, %22cannot send after transport endpoint shutdown%22%7D,%0A%09%7B109, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B110, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B111, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B112, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B113, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B114, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B115, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B116, %22ESTALE%22, %22stale file handle%22%7D,%0A%09%7B117, %22EUCLEAN%22, %22structure needs cleaning%22%7D,%0A%09%7B118, %22ENOTNAM%22, %22not a XENIX named type file%22%7D,%0A%09%7B119, %22ENAVAIL%22, %22no XENIX semaphores available%22%7D,%0A%09%7B120, %22EISNAM%22, %22is a named type file%22%7D,%0A%09%7B121, %22EREMOTEIO%22, %22remote I/O error%22%7D,%0A%09%7B122, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B123, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B124, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B125, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B126, %22ENOKEY%22, %22required key not available%22%7D,%0A%09%7B127, %22EKEYEXPIRED%22, %22key has expired%22%7D,%0A%09%7B128, %22EKEYREVOKED%22, %22key has been revoked%22%7D,%0A%09%7B129, %22EKEYREJECTED%22, %22key was rejected by service%22%7D,%0A%09%7B130, %22EOWNERDEAD%22, %22owner died%22%7D,%0A%09%7B131, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B132, %22ERFKILL%22, %22operation not possible due to RF-kill%22%7D,%0A%09%7B133, %22EHWPOISON%22, %22memory page has hardware error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/breakpoint trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22aborted%22%7D,%0A%09%7B7, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGSTKFLT%22, %22stack fault%22%7D,%0A%09%7B17, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B18, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B19, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B20, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22CPU time limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22file size limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window changed%22%7D,%0A%09%7B29, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B30, %22SIGPWR%22, %22power failure%22%7D,%0A%09%7B31, %22SIGSYS%22, %22bad system call%22%7D,%0A%7D%0A
- f 1411123e2f961ce7e76bed8bbdeecfd67de77f75dc6c082420f9769fa138e66d vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go
+ f e931952818749293c6d7f66715ab4cea1c06da6e689867c6403fcdccfbd002a7 vendor/golang.org/x/sys/unix/zerrors_linux_sparc64.go
dmppatch 3
@@ -79534,8 +79534,6401 @@
 0x68)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCLD    = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGLOST   = syscall.Signal(0x1d)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPOLL   = syscall.Signal(0x17)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x1d)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errors = %5B...%5Dstring%7B%0A%091:   %22operation not permitted%22,%0A%092:   %22no such file or directory%22,%0A%093:   %22no such process%22,%0A%094:   %22interrupted system call%22,%0A%095:   %22input/output error%22,%0A%096:   %22no such device or address%22,%0A%097:   %22argument list too long%22,%0A%098:   %22exec format error%22,%0A%099:   %22bad file descriptor%22,%0A%0910:  %22no child processes%22,%0A%0911:  %22resource temporarily unavailable%22,%0A%0912:  %22cannot allocate memory%22,%0A%0913:  %22permission denied%22,%0A%0914:  %22bad address%22,%0A%0915:  %22block device required%22,%0A%0916:  %22device or resource busy%22,%0A%0917:  %22file exists%22,%0A%0918:  %22invalid cross-device link%22,%0A%0919:  %22no such device%22,%0A%0920:  %22not a directory%22,%0A%0921:  %22is a directory%22,%0A%0922:  %22invalid argument%22,%0A%0923:  %22too many open files in system%22,%0A%0924:  %22too many open files%22,%0A%0925:  %22inappropriate ioctl for device%22,%0A%0926:  %22text file busy%22,%0A%0927:  %22file too large%22,%0A%0928:  %22no space left on device%22,%0A%0929:  %22illegal seek%22,%0A%0930:  %22read-only file system%22,%0A%0931:  %22too many links%22,%0A%0932:  %22broken pipe%22,%0A%0933:  %22numerical argument out of domain%22,%0A%0934:  %22numerical result out of range%22,%0A%0936:  %22operation now in progress%22,%0A%0937:  %22operation already in progress%22,%0A%0938:  %22socket operation on non-socket%22,%0A%0939:  %22destination address required%22,%0A%0940:  %22message too long%22,%0A%0941:  %22protocol wrong type for socket%22,%0A%0942:  %22protocol not available%22,%0A%0943:  %22protocol not supported%22,%0A%0944:  %22socket type not supported%22,%0A%0945:  %22operation not supported%22,%0A%0946:  %22protocol family not supported%22,%0A%0947:  %22address family not supported by protocol%22,%0A%0948:  %22address already in use%22,%0A%0949:  %22cannot assign requested address%22,%0A%0950:  %22network is down%22,%0A%0951:  %22network is unreachable%22,%0A%0952:  %22network dropped connection on reset%22,%0A%0953:  %22software caused connection abort%22,%0A%0954:  %22connection reset by peer%22,%0A%0955:  %22no buffer space available%22,%0A%0956:  %22transport endpoint is already connected%22,%0A%0957:  %22transport endpoint is not connected%22,%0A%0958:  %22cannot send after transport endpoint shutdown%22,%0A%0959:  %22too many references: cannot splice%22,%0A%0960:  %22connection timed out%22,%0A%0961:  %22connection refused%22,%0A%0962:  %22too many levels of symbolic links%22,%0A%0963:  %22file name too long%22,%0A%0964:  %22host is down%22,%0A%0965:  %22no route to host%22,%0A%0966:  %22directory not empty%22,%0A%0967:  %22too many processes%22,%0A%0968:  %22too many users%22,%0A%0969:  %22disk quota exceeded%22,%0A%0970:  %22stale file handle%22,%0A%0971:  %22object is remote%22,%0A%0972:  %22device not a stream%22,%0A%0973:  %22timer expired%22,%0A%0974:  %22out of streams resources%22,%0A%0975:  %22no message of desired type%22,%0A%0976:  %22bad message%22,%0A%0977:  %22identifier removed%22,%0A%0978:  %22resource deadlock avoided%22,%0A%0979:  %22no locks available%22,%0A%0980:  %22machine is not on the network%22,%0A%0981:  %22unknown error 81%22,%0A%0982:  %22link has been severed%22,%0A%0983:  %22advertise error%22,%0A%0984:  %22srmount error%22,%0A%0985:  %22communication error on send%22,%0A%0986:  %22protocol error%22,%0A%0987:  %22multihop attempted%22,%0A%0988:  %22RFS specific error%22,%0A%0989:  %22remote address changed%22,%0A%0990:  %22function not implemented%22,%0A%0991:  %22streams pipe error%22,%0A%0992:  %22value too large for defined data type%22,%0A%0993:  %22file descriptor in bad state%22,%0A%0994:  %22channel number out of range%22,%0A%0995:  %22level 2 not synchronized%22,%0A%0996:  %22level 3 halted%22,%0A%0997:  %22level 3 reset%22,%0A%0998:  %22link number out of range%22,%0A%0999:  %22protocol driver not attached%22,%0A%09100: %22no CSI structure available%22,%0A%09101: %22level 2 halted%22,%0A%09102: %22invalid exchange%22,%0A%09103: %22invalid request descriptor%22,%0A%09104: %22exchange full%22,%0A%09105: %22no anode%22,%0A%09106: %22invalid request code%22,%0A%09107: %22invalid slot%22,%0A%09108: %22file locking deadlock error%22,%0A%09109: %22bad font file format%22,%0A%09110: %22cannot exec a shared library directly%22,%0A%09111: %22no data available%22,%0A%09112: %22accessing a corrupted shared library%22,%0A%09113: %22package not installed%22,%0A%09114: %22can not access a needed shared library%22,%0A%09115: %22name not unique on network%22,%0A%09116: %22interrupted system call should be restarted%22,%0A%09117: %22structure needs cleaning%22,%0A%09118: %22not a XENIX named type file%22,%0A%09119: %22no XENIX semaphores available%22,%0A%09120: %22is a named type file%22,%0A%09121: %22remote I/O error%22,%0A%09122: %22invalid or incomplete multibyte or wide character%22,%0A%09123: %22attempting to link in too many shared libraries%22,%0A%09124: %22.lib section in a.out corrupted%22,%0A%09125: %22no medium found%22,%0A%09126: %22wrong medium type%22,%0A%09127: %22operation canceled%22,%0A%09128: %22required key not available%22,%0A%09129: %22key has expired%22,%0A%09130: %22key has been revoked%22,%0A%09131: %22key was rejected by service%22,%0A%09132: %22owner died%22,%0A%09133: %22state not recoverable%22,%0A%09134: %22operation not possible due to RF-kill%22,%0A%09135: %22memory page has hardware error%22,%0A%7D%0A%0A// Signal table%0Avar signals = %5B...%5Dstring%7B%0A%091:  %22hangup%22,%0A%092:  %22interrupt%22,%0A%093:  %22quit%22,%0A%094:  %22illegal instruction%22,%0A%095:  %22trace/breakpoint trap%22,%0A%096:  %22aborted%22,%0A%097:  %22EMT trap%22,%0A%098:  %22floating point exception%22,%0A%099:  %22killed%22,%0A%0910: %22bus error%22,%0A%0911: %22segmentation fault%22,%0A%0912: %22bad system call%22,%0A%0913: %22broken pipe%22,%0A%0914: %22alarm clock%22,%0A%0915: %22terminated%22,%0A%0916: %22urgent I/O condition%22,%0A%0917: %22stopped (signal)%22,%0A%0918: %22stopped%22,%0A%0919: %22continued%22,%0A%0920: %22child exited%22,%0A%0921: %22stopped (tty input)%22,%0A%0922: %22stopped (tty output)%22,%0A%0923: %22I/O possible%22,%0A%0924: %22CPU time limit exceeded%22,%0A%0925: %22file size limit exceeded%22,%0A%0926: %22virtual timer expired%22,%0A%0927: %22profiling timer expired%22,%0A%0928: %22window changed%22,%0A%0929: %22resource lost%22,%0A%0930: %22user defined signal 1%22,%0A%0931: %22user defined signal 2%22,%0A%7D%0A
- f 39d9fb38ff98fc4ad05cafcd9519a106c427198e13e63c96c9c61115f89ddb31 vendor/golang.org/x/sys/unix/zerrors_netbsd_386.go
+ f 5f6849fb74240915bc4e47a5fc7fc7ebcf84a2aa41846dae43150322f92e2fd5 vendor/golang.org/x/sys/unix/zerrors_netbsd_386.go
dmppatch 15
@@ -43154,24 +43154,1667 @@
       = 0x2%0A
+%09MNT_ASYNC                         = 0x40%0A%09MNT_BASIC_FLAGS                   = 0xe782807f%0A%09MNT_DEFEXPORTED                   = 0x200%0A%09MNT_DISCARD                       = 0x800000%0A%09MNT_EXKERB                        = 0x800%0A%09MNT_EXNORESPORT                   = 0x8000000%0A%09MNT_EXPORTANON                    = 0x400%0A%09MNT_EXPORTED                      = 0x100%0A%09MNT_EXPUBLIC                      = 0x10000000%0A%09MNT_EXRDONLY                      = 0x80%0A%09MNT_EXTATTR                       = 0x1000000%0A%09MNT_FORCE                         = 0x80000%0A%09MNT_GETARGS                       = 0x400000%0A%09MNT_IGNORE                        = 0x100000%0A%09MNT_LAZY                          = 0x3%0A%09MNT_LOCAL                         = 0x1000%0A%09MNT_LOG                           = 0x2000000%0A%09MNT_NOATIME                       = 0x4000000%0A%09MNT_NOCOREDUMP                    = 0x8000%0A%09MNT_NODEV                         = 0x10%0A%09MNT_NODEVMTIME                    = 0x40000000%0A%09MNT_NOEXEC                        = 0x4%0A%09MNT_NOSUID                        = 0x8%0A%09MNT_NOWAIT                        = 0x2%0A%09MNT_OP_FLAGS                      = 0x4d0000%0A%09MNT_QUOTA                         = 0x2000%0A%09MNT_RDONLY                        = 0x1%0A%09MNT_RELATIME                      = 0x20000%0A%09MNT_RELOAD                        = 0x40000%0A%09MNT_ROOTFS                        = 0x4000%0A%09MNT_SOFTDEP                       = 0x80000000%0A%09MNT_SYMPERM                       = 0x20000000%0A%09MNT_SYNCHRONOUS                   = 0x2%0A%09MNT_UNION                         = 0x20%0A%09MNT_UPDATE                        = 0x10000%0A%09MNT_VISFLAGMASK                   = 0xff90ffff%0A%09MNT_WAIT                          = 0x1%0A
 %09MSG_BCAST  
@@ -48774,16 +48774,57 @@
   = 0x1%0A
+%09RLIMIT_MEMLOCK                    = 0x6%0A
 %09RLIMIT_
@@ -48856,16 +48856,98 @@
   = 0x8%0A
+%09RLIMIT_NPROC                      = 0x7%0A%09RLIMIT_RSS                        = 0x5%0A
 %09RLIMIT_
@@ -67436,8 +67436,6764 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x20)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large or too small%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol option not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B86, %22ENOTSUP%22, %22not supported%22%7D,%0A%09%7B87, %22ECANCELED%22, %22operation Canceled%22%7D,%0A%09%7B88, %22EBADMSG%22, %22bad or Corrupt message%22%7D,%0A%09%7B89, %22ENODATA%22, %22no message available%22%7D,%0A%09%7B90, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B91, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B92, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B95, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B96, %22ELAST%22, %22protocol error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGPWR%22, %22power fail/restart%22%7D,%0A%7D%0A
- f 52d341af732621a247076c0d70595769c90fe36e7b0060c0412e5cca132aca21 vendor/golang.org/x/sys/unix/zerrors_netbsd_amd64.go
+ f 82a91d4ce1a256b609c182d358ae8da7a145e18c5b1f40bf2f227acb328ba87f vendor/golang.org/x/sys/unix/zerrors_netbsd_amd64.go
dmppatch 15
@@ -42736,24 +42736,1667 @@
       = 0x2%0A
+%09MNT_ASYNC                         = 0x40%0A%09MNT_BASIC_FLAGS                   = 0xe782807f%0A%09MNT_DEFEXPORTED                   = 0x200%0A%09MNT_DISCARD                       = 0x800000%0A%09MNT_EXKERB                        = 0x800%0A%09MNT_EXNORESPORT                   = 0x8000000%0A%09MNT_EXPORTANON                    = 0x400%0A%09MNT_EXPORTED                      = 0x100%0A%09MNT_EXPUBLIC                      = 0x10000000%0A%09MNT_EXRDONLY                      = 0x80%0A%09MNT_EXTATTR                       = 0x1000000%0A%09MNT_FORCE                         = 0x80000%0A%09MNT_GETARGS                       = 0x400000%0A%09MNT_IGNORE                        = 0x100000%0A%09MNT_LAZY                          = 0x3%0A%09MNT_LOCAL                         = 0x1000%0A%09MNT_LOG                           = 0x2000000%0A%09MNT_NOATIME                       = 0x4000000%0A%09MNT_NOCOREDUMP                    = 0x8000%0A%09MNT_NODEV                         = 0x10%0A%09MNT_NODEVMTIME                    = 0x40000000%0A%09MNT_NOEXEC                        = 0x4%0A%09MNT_NOSUID                        = 0x8%0A%09MNT_NOWAIT                        = 0x2%0A%09MNT_OP_FLAGS                      = 0x4d0000%0A%09MNT_QUOTA                         = 0x2000%0A%09MNT_RDONLY                        = 0x1%0A%09MNT_RELATIME                      = 0x20000%0A%09MNT_RELOAD                        = 0x40000%0A%09MNT_ROOTFS                        = 0x4000%0A%09MNT_SOFTDEP                       = 0x80000000%0A%09MNT_SYMPERM                       = 0x20000000%0A%09MNT_SYNCHRONOUS                   = 0x2%0A%09MNT_UNION                         = 0x20%0A%09MNT_UPDATE                        = 0x10000%0A%09MNT_VISFLAGMASK                   = 0xff90ffff%0A%09MNT_WAIT                          = 0x1%0A
 %09MSG_BCAST  
@@ -48356,16 +48356,57 @@
   = 0x1%0A
+%09RLIMIT_MEMLOCK                    = 0x6%0A
 %09RLIMIT_
@@ -48438,16 +48438,98 @@
   = 0x8%0A
+%09RLIMIT_NPROC                      = 0x7%0A%09RLIMIT_RSS                        = 0x5%0A
 %09RLIMIT_
@@ -67018,8 +67018,6764 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x20)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large or too small%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol option not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B86, %22ENOTSUP%22, %22not supported%22%7D,%0A%09%7B87, %22ECANCELED%22, %22operation Canceled%22%7D,%0A%09%7B88, %22EBADMSG%22, %22bad or Corrupt message%22%7D,%0A%09%7B89, %22ENODATA%22, %22no message available%22%7D,%0A%09%7B90, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B91, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B92, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B95, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B96, %22ELAST%22, %22protocol error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGPWR%22, %22power fail/restart%22%7D,%0A%7D%0A
- f 290a5b70d4a7171668cccc5ca4c1efbb9b536cc0ff0c6ae9ab0e690e9dfd9cce vendor/golang.org/x/sys/unix/zerrors_netbsd_arm.go
+ f 2c1e0c1eee1813749a17a6bceafee0037a967243bd79ca0dfe576549b66d7c91 vendor/golang.org/x/sys/unix/zerrors_netbsd_arm.go
dmppatch 15
@@ -42308,24 +42308,1667 @@
     = 0x800%0A
+%09MNT_ASYNC                         = 0x40%0A%09MNT_BASIC_FLAGS                   = 0xe782807f%0A%09MNT_DEFEXPORTED                   = 0x200%0A%09MNT_DISCARD                       = 0x800000%0A%09MNT_EXKERB                        = 0x800%0A%09MNT_EXNORESPORT                   = 0x8000000%0A%09MNT_EXPORTANON                    = 0x400%0A%09MNT_EXPORTED                      = 0x100%0A%09MNT_EXPUBLIC                      = 0x10000000%0A%09MNT_EXRDONLY                      = 0x80%0A%09MNT_EXTATTR                       = 0x1000000%0A%09MNT_FORCE                         = 0x80000%0A%09MNT_GETARGS                       = 0x400000%0A%09MNT_IGNORE                        = 0x100000%0A%09MNT_LAZY                          = 0x3%0A%09MNT_LOCAL                         = 0x1000%0A%09MNT_LOG                           = 0x2000000%0A%09MNT_NOATIME                       = 0x4000000%0A%09MNT_NOCOREDUMP                    = 0x8000%0A%09MNT_NODEV                         = 0x10%0A%09MNT_NODEVMTIME                    = 0x40000000%0A%09MNT_NOEXEC                        = 0x4%0A%09MNT_NOSUID                        = 0x8%0A%09MNT_NOWAIT                        = 0x2%0A%09MNT_OP_FLAGS                      = 0x4d0000%0A%09MNT_QUOTA                         = 0x2000%0A%09MNT_RDONLY                        = 0x1%0A%09MNT_RELATIME                      = 0x20000%0A%09MNT_RELOAD                        = 0x40000%0A%09MNT_ROOTFS                        = 0x4000%0A%09MNT_SOFTDEP                       = 0x80000000%0A%09MNT_SYMPERM                       = 0x20000000%0A%09MNT_SYNCHRONOUS                   = 0x2%0A%09MNT_UNION                         = 0x20%0A%09MNT_UPDATE                        = 0x10000%0A%09MNT_VISFLAGMASK                   = 0xff90ffff%0A%09MNT_WAIT                          = 0x1%0A
 %09MSG_BCAST  
@@ -47928,16 +47928,57 @@
   = 0x1%0A
+%09RLIMIT_MEMLOCK                    = 0x6%0A
 %09RLIMIT_
@@ -48010,16 +48010,98 @@
   = 0x8%0A
+%09RLIMIT_NPROC                      = 0x7%0A%09RLIMIT_RSS                        = 0x5%0A
 %09RLIMIT_
@@ -66549,8 +66549,6764 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGPWR    = syscall.Signal(0x20)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large or too small%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol option not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC prog. not avail%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B83, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B84, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B85, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B86, %22ENOTSUP%22, %22not supported%22%7D,%0A%09%7B87, %22ECANCELED%22, %22operation Canceled%22%7D,%0A%09%7B88, %22EBADMSG%22, %22bad or Corrupt message%22%7D,%0A%09%7B89, %22ENODATA%22, %22no message available%22%7D,%0A%09%7B90, %22ENOSR%22, %22no STREAM resources%22%7D,%0A%09%7B91, %22ENOSTR%22, %22not a STREAM%22%7D,%0A%09%7B92, %22ETIME%22, %22STREAM ioctl timeout%22%7D,%0A%09%7B93, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B94, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B95, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B96, %22ELAST%22, %22protocol error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGIOT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22stopped%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGPWR%22, %22power fail/restart%22%7D,%0A%7D%0A
- f c3dfa3ef2aa30a511313c9bcbe4daf94f1e4d0ac250d567ac44c31dd6aade4a6 vendor/golang.org/x/sys/unix/zerrors_openbsd_386.go
+ f c5da25fbffa60a9144d6fd347c8443be71cfe35464ebe041e1ed94aa34d32aeb vendor/golang.org/x/sys/unix/zerrors_openbsd_386.go
dmppatch 7
@@ -37992,24 +37992,1153 @@
       = 0x2%0A
+%09MNT_ASYNC                         = 0x40%0A%09MNT_DEFEXPORTED                   = 0x200%0A%09MNT_DELEXPORT                     = 0x20000%0A%09MNT_DOOMED                        = 0x8000000%0A%09MNT_EXPORTANON                    = 0x400%0A%09MNT_EXPORTED                      = 0x100%0A%09MNT_EXRDONLY                      = 0x80%0A%09MNT_FORCE                         = 0x80000%0A%09MNT_LAZY                          = 0x3%0A%09MNT_LOCAL                         = 0x1000%0A%09MNT_NOATIME                       = 0x8000%0A%09MNT_NODEV                         = 0x10%0A%09MNT_NOEXEC                        = 0x4%0A%09MNT_NOSUID                        = 0x8%0A%09MNT_NOWAIT                        = 0x2%0A%09MNT_QUOTA                         = 0x2000%0A%09MNT_RDONLY                        = 0x1%0A%09MNT_RELOAD                        = 0x40000%0A%09MNT_ROOTFS                        = 0x4000%0A%09MNT_SOFTDEP                       = 0x4000000%0A%09MNT_SYNCHRONOUS                   = 0x2%0A%09MNT_UPDATE                        = 0x10000%0A%09MNT_VISFLAGMASK                   = 0x400ffff%0A%09MNT_WAIT                          = 0x1%0A%09MNT_WANTRDWR                      = 0x2000000%0A%09MNT_WXALLOWED                     = 0x800%0A
 %09MSG_BCAST  
@@ -62787,8 +62787,6559 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EWOULDBLOCK%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC program not available%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIPSEC%22, %22IPsec processing failure%22%7D,%0A%09%7B83, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B84, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B85, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B86, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B87, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B88, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B89, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B90, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B91, %22ELAST%22, %22not supported%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22thread AST%22%7D,%0A%7D%0A
- f 82183ae25e171ee1cb7447580e7382d0558db33cf414d9988da90f48dc0df2a0 vendor/golang.org/x/sys/unix/zerrors_openbsd_amd64.go
+ f 24547b2fd93cab0cd84d1f088807562f18c3654105588636d3d2b2e399504d8f vendor/golang.org/x/sys/unix/zerrors_openbsd_amd64.go
dmppatch 7
@@ -39665,24 +39665,1153 @@
       = 0x2%0A
+%09MNT_ASYNC                         = 0x40%0A%09MNT_DEFEXPORTED                   = 0x200%0A%09MNT_DELEXPORT                     = 0x20000%0A%09MNT_DOOMED                        = 0x8000000%0A%09MNT_EXPORTANON                    = 0x400%0A%09MNT_EXPORTED                      = 0x100%0A%09MNT_EXRDONLY                      = 0x80%0A%09MNT_FORCE                         = 0x80000%0A%09MNT_LAZY                          = 0x3%0A%09MNT_LOCAL                         = 0x1000%0A%09MNT_NOATIME                       = 0x8000%0A%09MNT_NODEV                         = 0x10%0A%09MNT_NOEXEC                        = 0x4%0A%09MNT_NOSUID                        = 0x8%0A%09MNT_NOWAIT                        = 0x2%0A%09MNT_QUOTA                         = 0x2000%0A%09MNT_RDONLY                        = 0x1%0A%09MNT_RELOAD                        = 0x40000%0A%09MNT_ROOTFS                        = 0x4000%0A%09MNT_SOFTDEP                       = 0x4000000%0A%09MNT_SYNCHRONOUS                   = 0x2%0A%09MNT_UPDATE                        = 0x10000%0A%09MNT_VISFLAGMASK                   = 0x400ffff%0A%09MNT_WAIT                          = 0x1%0A%09MNT_WANTRDWR                      = 0x2000000%0A%09MNT_WXALLOWED                     = 0x800%0A
 %09MSG_BCAST  
@@ -67194,8 +67194,6718 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC program not available%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIPSEC%22, %22IPsec processing failure%22%7D,%0A%09%7B83, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B84, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B85, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B86, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B87, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B88, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B89, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B90, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B91, %22ENOTSUP%22, %22not supported%22%7D,%0A%09%7B92, %22EBADMSG%22, %22bad message%22%7D,%0A%09%7B93, %22ENOTRECOVERABLE%22, %22state not recoverable%22%7D,%0A%09%7B94, %22EOWNERDEAD%22, %22previous owner died%22%7D,%0A%09%7B95, %22ELAST%22, %22protocol error%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22thread AST%22%7D,%0A%7D%0A
- f 776e6010c212d42d24100fd8ecc4bee86b7679100b57ed2cb26631d4df26c46b vendor/golang.org/x/sys/unix/zerrors_openbsd_arm.go
+ f 5d04ab8ba4bf0a3792fcc5be8ddb5c4e17b65400fd4e2e859c90a5b35a0bb96b vendor/golang.org/x/sys/unix/zerrors_openbsd_arm.go
dmppatch 7
@@ -37976,24 +37976,1153 @@
       = 0x2%0A
+%09MNT_ASYNC                         = 0x40%0A%09MNT_DEFEXPORTED                   = 0x200%0A%09MNT_DELEXPORT                     = 0x20000%0A%09MNT_DOOMED                        = 0x8000000%0A%09MNT_EXPORTANON                    = 0x400%0A%09MNT_EXPORTED                      = 0x100%0A%09MNT_EXRDONLY                      = 0x80%0A%09MNT_FORCE                         = 0x80000%0A%09MNT_LAZY                          = 0x3%0A%09MNT_LOCAL                         = 0x1000%0A%09MNT_NOATIME                       = 0x8000%0A%09MNT_NODEV                         = 0x10%0A%09MNT_NOEXEC                        = 0x4%0A%09MNT_NOSUID                        = 0x8%0A%09MNT_NOWAIT                        = 0x2%0A%09MNT_QUOTA                         = 0x2000%0A%09MNT_RDONLY                        = 0x1%0A%09MNT_RELOAD                        = 0x40000%0A%09MNT_ROOTFS                        = 0x4000%0A%09MNT_SOFTDEP                       = 0x4000000%0A%09MNT_SYNCHRONOUS                   = 0x2%0A%09MNT_UPDATE                        = 0x10000%0A%09MNT_VISFLAGMASK                   = 0x400ffff%0A%09MNT_WAIT                          = 0x1%0A%09MNT_WANTRDWR                      = 0x2000000%0A%09MNT_WXALLOWED                     = 0x800%0A
 %09MSG_BCAST  
@@ -62863,8 +62863,6559 @@
 0x12)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT   = syscall.Signal(0x6)%0A%09SIGALRM   = syscall.Signal(0xe)%0A%09SIGBUS    = syscall.Signal(0xa)%0A%09SIGCHLD   = syscall.Signal(0x14)%0A%09SIGCONT   = syscall.Signal(0x13)%0A%09SIGEMT    = syscall.Signal(0x7)%0A%09SIGFPE    = syscall.Signal(0x8)%0A%09SIGHUP    = syscall.Signal(0x1)%0A%09SIGILL    = syscall.Signal(0x4)%0A%09SIGINFO   = syscall.Signal(0x1d)%0A%09SIGINT    = syscall.Signal(0x2)%0A%09SIGIO     = syscall.Signal(0x17)%0A%09SIGIOT    = syscall.Signal(0x6)%0A%09SIGKILL   = syscall.Signal(0x9)%0A%09SIGPIPE   = syscall.Signal(0xd)%0A%09SIGPROF   = syscall.Signal(0x1b)%0A%09SIGQUIT   = syscall.Signal(0x3)%0A%09SIGSEGV   = syscall.Signal(0xb)%0A%09SIGSTOP   = syscall.Signal(0x11)%0A%09SIGSYS    = syscall.Signal(0xc)%0A%09SIGTERM   = syscall.Signal(0xf)%0A%09SIGTHR    = syscall.Signal(0x20)%0A%09SIGTRAP   = syscall.Signal(0x5)%0A%09SIGTSTP   = syscall.Signal(0x12)%0A%09SIGTTIN   = syscall.Signal(0x15)%0A%09SIGTTOU   = syscall.Signal(0x16)%0A%09SIGURG    = syscall.Signal(0x10)%0A%09SIGUSR1   = syscall.Signal(0x1e)%0A%09SIGUSR2   = syscall.Signal(0x1f)%0A%09SIGVTALRM = syscall.Signal(0x1a)%0A%09SIGWINCH  = syscall.Signal(0x1c)%0A%09SIGXCPU   = syscall.Signal(0x18)%0A%09SIGXFSZ   = syscall.Signal(0x19)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22operation not permitted%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22input/output error%22%7D,%0A%09%7B6, %22ENXIO%22, %22device not configured%22%7D,%0A%09%7B7, %22E2BIG%22, %22argument list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file descriptor%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EDEADLK%22, %22resource deadlock avoided%22%7D,%0A%09%7B12, %22ENOMEM%22, %22cannot allocate memory%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22operation not supported by device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22too many open files in system%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22numerical argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22EWOULDBLOCK%22, %22resource temporarily unavailable%22%7D,%0A%09%7B36, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B37, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B38, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B39, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B40, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B41, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B42, %22ENOPROTOOPT%22, %22protocol not available%22%7D,%0A%09%7B43, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B44, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B45, %22EOPNOTSUPP%22, %22operation not supported%22%7D,%0A%09%7B46, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B47, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B48, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B49, %22EADDRNOTAVAIL%22, %22can't assign requested address%22%7D,%0A%09%7B50, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B51, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B52, %22ENETRESET%22, %22network dropped connection on reset%22%7D,%0A%09%7B53, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B54, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B55, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B56, %22EISCONN%22, %22socket is already connected%22%7D,%0A%09%7B57, %22ENOTCONN%22, %22socket is not connected%22%7D,%0A%09%7B58, %22ESHUTDOWN%22, %22can't send after socket shutdown%22%7D,%0A%09%7B59, %22ETOOMANYREFS%22, %22too many references: can't splice%22%7D,%0A%09%7B60, %22ETIMEDOUT%22, %22operation timed out%22%7D,%0A%09%7B61, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B62, %22ELOOP%22, %22too many levels of symbolic links%22%7D,%0A%09%7B63, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B64, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B65, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B66, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B67, %22EPROCLIM%22, %22too many processes%22%7D,%0A%09%7B68, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B69, %22EDQUOT%22, %22disk quota exceeded%22%7D,%0A%09%7B70, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%09%7B71, %22EREMOTE%22, %22too many levels of remote in path%22%7D,%0A%09%7B72, %22EBADRPC%22, %22RPC struct is bad%22%7D,%0A%09%7B73, %22ERPCMISMATCH%22, %22RPC version wrong%22%7D,%0A%09%7B74, %22EPROGUNAVAIL%22, %22RPC program not available%22%7D,%0A%09%7B75, %22EPROGMISMATCH%22, %22program version wrong%22%7D,%0A%09%7B76, %22EPROCUNAVAIL%22, %22bad procedure for program%22%7D,%0A%09%7B77, %22ENOLCK%22, %22no locks available%22%7D,%0A%09%7B78, %22ENOSYS%22, %22function not implemented%22%7D,%0A%09%7B79, %22EFTYPE%22, %22inappropriate file type or format%22%7D,%0A%09%7B80, %22EAUTH%22, %22authentication error%22%7D,%0A%09%7B81, %22ENEEDAUTH%22, %22need authenticator%22%7D,%0A%09%7B82, %22EIPSEC%22, %22IPsec processing failure%22%7D,%0A%09%7B83, %22ENOATTR%22, %22attribute not found%22%7D,%0A%09%7B84, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B85, %22ENOMEDIUM%22, %22no medium found%22%7D,%0A%09%7B86, %22EMEDIUMTYPE%22, %22wrong medium type%22%7D,%0A%09%7B87, %22EOVERFLOW%22, %22value too large to be stored in data type%22%7D,%0A%09%7B88, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B89, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B90, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B91, %22ELAST%22, %22not supported%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/BPT trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort trap%22%7D,%0A%09%7B7, %22SIGEMT%22, %22EMT trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22floating point exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad system call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGURG%22, %22urgent I/O condition%22%7D,%0A%09%7B17, %22SIGSTOP%22, %22suspended (signal)%22%7D,%0A%09%7B18, %22SIGTSTP%22, %22suspended%22%7D,%0A%09%7B19, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B20, %22SIGCHLD%22, %22child exited%22%7D,%0A%09%7B21, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B22, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B23, %22SIGIO%22, %22I/O possible%22%7D,%0A%09%7B24, %22SIGXCPU%22, %22cputime limit exceeded%22%7D,%0A%09%7B25, %22SIGXFSZ%22, %22filesize limit exceeded%22%7D,%0A%09%7B26, %22SIGVTALRM%22, %22virtual timer expired%22%7D,%0A%09%7B27, %22SIGPROF%22, %22profiling timer expired%22%7D,%0A%09%7B28, %22SIGWINCH%22, %22window size changes%22%7D,%0A%09%7B29, %22SIGINFO%22, %22information request%22%7D,%0A%09%7B30, %22SIGUSR1%22, %22user defined signal 1%22%7D,%0A%09%7B31, %22SIGUSR2%22, %22user defined signal 2%22%7D,%0A%09%7B32, %22SIGTHR%22, %22thread AST%22%7D,%0A%7D%0A
- f 897767a397667a321776a5cba443e227b7a328fd989b6379a583c2fd06860e70 vendor/golang.org/x/sys/unix/zerrors_solaris_amd64.go
+ f 7a8f6848a8390030ecc66d5c71e3726d368d0300717cb11ccd4743f63d43116a vendor/golang.org/x/sys/unix/zerrors_solaris_amd64.go
dmppatch 11
@@ -38954,16 +38954,1293 @@
   = 0x2%0A
+%09S_ENFMT                       = 0x400%0A%09S_IAMB                        = 0x1ff%0A%09S_IEXEC                       = 0x40%0A%09S_IFBLK                       = 0x6000%0A%09S_IFCHR                       = 0x2000%0A%09S_IFDIR                       = 0x4000%0A%09S_IFDOOR                      = 0xd000%0A%09S_IFIFO                       = 0x1000%0A%09S_IFLNK                       = 0xa000%0A%09S_IFMT                        = 0xf000%0A%09S_IFNAM                       = 0x5000%0A%09S_IFPORT                      = 0xe000%0A%09S_IFREG                       = 0x8000%0A%09S_IFSOCK                      = 0xc000%0A%09S_INSEM                       = 0x1%0A%09S_INSHD                       = 0x2%0A%09S_IREAD                       = 0x100%0A%09S_IRGRP                       = 0x20%0A%09S_IROTH                       = 0x4%0A%09S_IRUSR                       = 0x100%0A%09S_IRWXG                       = 0x38%0A%09S_IRWXO                       = 0x7%0A%09S_IRWXU                       = 0x1c0%0A%09S_ISGID                       = 0x400%0A%09S_ISUID                       = 0x800%0A%09S_ISVTX                       = 0x200%0A%09S_IWGRP                       = 0x10%0A%09S_IWOTH                       = 0x2%0A%09S_IWRITE                      = 0x80%0A%09S_IWUSR                       = 0x80%0A%09S_IXGRP                       = 0x8%0A%09S_IXOTH                       = 0x1%0A%09S_IXUSR                       = 0x40%0A
 %09TAB0   
@@ -44374,16 +44374,92 @@
 = 0x100%0A
+%09UTIME_NOW                     = -0x1%0A%09UTIME_OMIT                    = -0x2%0A
 %09VCEOF  
@@ -50719,8 +50719,8742 @@
 0x34)%0A)%0A
+%0A// Signals%0Aconst (%0A%09SIGABRT    = syscall.Signal(0x6)%0A%09SIGALRM    = syscall.Signal(0xe)%0A%09SIGBUS     = syscall.Signal(0xa)%0A%09SIGCANCEL  = syscall.Signal(0x24)%0A%09SIGCHLD    = syscall.Signal(0x12)%0A%09SIGCLD     = syscall.Signal(0x12)%0A%09SIGCONT    = syscall.Signal(0x19)%0A%09SIGEMT     = syscall.Signal(0x7)%0A%09SIGFPE     = syscall.Signal(0x8)%0A%09SIGFREEZE  = syscall.Signal(0x22)%0A%09SIGHUP     = syscall.Signal(0x1)%0A%09SIGILL     = syscall.Signal(0x4)%0A%09SIGINFO    = syscall.Signal(0x29)%0A%09SIGINT     = syscall.Signal(0x2)%0A%09SIGIO      = syscall.Signal(0x16)%0A%09SIGIOT     = syscall.Signal(0x6)%0A%09SIGJVM1    = syscall.Signal(0x27)%0A%09SIGJVM2    = syscall.Signal(0x28)%0A%09SIGKILL    = syscall.Signal(0x9)%0A%09SIGLOST    = syscall.Signal(0x25)%0A%09SIGLWP     = syscall.Signal(0x21)%0A%09SIGPIPE    = syscall.Signal(0xd)%0A%09SIGPOLL    = syscall.Signal(0x16)%0A%09SIGPROF    = syscall.Signal(0x1d)%0A%09SIGPWR     = syscall.Signal(0x13)%0A%09SIGQUIT    = syscall.Signal(0x3)%0A%09SIGSEGV    = syscall.Signal(0xb)%0A%09SIGSTOP    = syscall.Signal(0x17)%0A%09SIGSYS     = syscall.Signal(0xc)%0A%09SIGTERM    = syscall.Signal(0xf)%0A%09SIGTHAW    = syscall.Signal(0x23)%0A%09SIGTRAP    = syscall.Signal(0x5)%0A%09SIGTSTP    = syscall.Signal(0x18)%0A%09SIGTTIN    = syscall.Signal(0x1a)%0A%09SIGTTOU    = syscall.Signal(0x1b)%0A%09SIGURG     = syscall.Signal(0x15)%0A%09SIGUSR1    = syscall.Signal(0x10)%0A%09SIGUSR2    = syscall.Signal(0x11)%0A%09SIGVTALRM  = syscall.Signal(0x1c)%0A%09SIGWAITING = syscall.Signal(0x20)%0A%09SIGWINCH   = syscall.Signal(0x14)%0A%09SIGXCPU    = syscall.Signal(0x1e)%0A%09SIGXFSZ    = syscall.Signal(0x1f)%0A%09SIGXRES    = syscall.Signal(0x26)%0A)%0A%0A// Error table%0Avar errorList = %5B...%5Dstruct %7B%0A%09num  syscall.Errno%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22EPERM%22, %22not owner%22%7D,%0A%09%7B2, %22ENOENT%22, %22no such file or directory%22%7D,%0A%09%7B3, %22ESRCH%22, %22no such process%22%7D,%0A%09%7B4, %22EINTR%22, %22interrupted system call%22%7D,%0A%09%7B5, %22EIO%22, %22I/O error%22%7D,%0A%09%7B6, %22ENXIO%22, %22no such device or address%22%7D,%0A%09%7B7, %22E2BIG%22, %22arg list too long%22%7D,%0A%09%7B8, %22ENOEXEC%22, %22exec format error%22%7D,%0A%09%7B9, %22EBADF%22, %22bad file number%22%7D,%0A%09%7B10, %22ECHILD%22, %22no child processes%22%7D,%0A%09%7B11, %22EAGAIN%22, %22resource temporarily unavailable%22%7D,%0A%09%7B12, %22ENOMEM%22, %22not enough space%22%7D,%0A%09%7B13, %22EACCES%22, %22permission denied%22%7D,%0A%09%7B14, %22EFAULT%22, %22bad address%22%7D,%0A%09%7B15, %22ENOTBLK%22, %22block device required%22%7D,%0A%09%7B16, %22EBUSY%22, %22device busy%22%7D,%0A%09%7B17, %22EEXIST%22, %22file exists%22%7D,%0A%09%7B18, %22EXDEV%22, %22cross-device link%22%7D,%0A%09%7B19, %22ENODEV%22, %22no such device%22%7D,%0A%09%7B20, %22ENOTDIR%22, %22not a directory%22%7D,%0A%09%7B21, %22EISDIR%22, %22is a directory%22%7D,%0A%09%7B22, %22EINVAL%22, %22invalid argument%22%7D,%0A%09%7B23, %22ENFILE%22, %22file table overflow%22%7D,%0A%09%7B24, %22EMFILE%22, %22too many open files%22%7D,%0A%09%7B25, %22ENOTTY%22, %22inappropriate ioctl for device%22%7D,%0A%09%7B26, %22ETXTBSY%22, %22text file busy%22%7D,%0A%09%7B27, %22EFBIG%22, %22file too large%22%7D,%0A%09%7B28, %22ENOSPC%22, %22no space left on device%22%7D,%0A%09%7B29, %22ESPIPE%22, %22illegal seek%22%7D,%0A%09%7B30, %22EROFS%22, %22read-only file system%22%7D,%0A%09%7B31, %22EMLINK%22, %22too many links%22%7D,%0A%09%7B32, %22EPIPE%22, %22broken pipe%22%7D,%0A%09%7B33, %22EDOM%22, %22argument out of domain%22%7D,%0A%09%7B34, %22ERANGE%22, %22result too large%22%7D,%0A%09%7B35, %22ENOMSG%22, %22no message of desired type%22%7D,%0A%09%7B36, %22EIDRM%22, %22identifier removed%22%7D,%0A%09%7B37, %22ECHRNG%22, %22channel number out of range%22%7D,%0A%09%7B38, %22EL2NSYNC%22, %22level 2 not synchronized%22%7D,%0A%09%7B39, %22EL3HLT%22, %22level 3 halted%22%7D,%0A%09%7B40, %22EL3RST%22, %22level 3 reset%22%7D,%0A%09%7B41, %22ELNRNG%22, %22link number out of range%22%7D,%0A%09%7B42, %22EUNATCH%22, %22protocol driver not attached%22%7D,%0A%09%7B43, %22ENOCSI%22, %22no CSI structure available%22%7D,%0A%09%7B44, %22EL2HLT%22, %22level 2 halted%22%7D,%0A%09%7B45, %22EDEADLK%22, %22deadlock situation detected/avoided%22%7D,%0A%09%7B46, %22ENOLCK%22, %22no record locks available%22%7D,%0A%09%7B47, %22ECANCELED%22, %22operation canceled%22%7D,%0A%09%7B48, %22ENOTSUP%22, %22operation not supported%22%7D,%0A%09%7B49, %22EDQUOT%22, %22disc quota exceeded%22%7D,%0A%09%7B50, %22EBADE%22, %22bad exchange descriptor%22%7D,%0A%09%7B51, %22EBADR%22, %22bad request descriptor%22%7D,%0A%09%7B52, %22EXFULL%22, %22message tables full%22%7D,%0A%09%7B53, %22ENOANO%22, %22anode table overflow%22%7D,%0A%09%7B54, %22EBADRQC%22, %22bad request code%22%7D,%0A%09%7B55, %22EBADSLT%22, %22invalid slot%22%7D,%0A%09%7B56, %22EDEADLOCK%22, %22file locking deadlock%22%7D,%0A%09%7B57, %22EBFONT%22, %22bad font file format%22%7D,%0A%09%7B58, %22EOWNERDEAD%22, %22owner of the lock died%22%7D,%0A%09%7B59, %22ENOTRECOVERABLE%22, %22lock is not recoverable%22%7D,%0A%09%7B60, %22ENOSTR%22, %22not a stream device%22%7D,%0A%09%7B61, %22ENODATA%22, %22no data available%22%7D,%0A%09%7B62, %22ETIME%22, %22timer expired%22%7D,%0A%09%7B63, %22ENOSR%22, %22out of stream resources%22%7D,%0A%09%7B64, %22ENONET%22, %22machine is not on the network%22%7D,%0A%09%7B65, %22ENOPKG%22, %22package not installed%22%7D,%0A%09%7B66, %22EREMOTE%22, %22object is remote%22%7D,%0A%09%7B67, %22ENOLINK%22, %22link has been severed%22%7D,%0A%09%7B68, %22EADV%22, %22advertise error%22%7D,%0A%09%7B69, %22ESRMNT%22, %22srmount error%22%7D,%0A%09%7B70, %22ECOMM%22, %22communication error on send%22%7D,%0A%09%7B71, %22EPROTO%22, %22protocol error%22%7D,%0A%09%7B72, %22ELOCKUNMAPPED%22, %22locked lock was unmapped %22%7D,%0A%09%7B73, %22ENOTACTIVE%22, %22facility is not active%22%7D,%0A%09%7B74, %22EMULTIHOP%22, %22multihop attempted%22%7D,%0A%09%7B77, %22EBADMSG%22, %22not a data message%22%7D,%0A%09%7B78, %22ENAMETOOLONG%22, %22file name too long%22%7D,%0A%09%7B79, %22EOVERFLOW%22, %22value too large for defined data type%22%7D,%0A%09%7B80, %22ENOTUNIQ%22, %22name not unique on network%22%7D,%0A%09%7B81, %22EBADFD%22, %22file descriptor in bad state%22%7D,%0A%09%7B82, %22EREMCHG%22, %22remote address changed%22%7D,%0A%09%7B83, %22ELIBACC%22, %22can not access a needed shared library%22%7D,%0A%09%7B84, %22ELIBBAD%22, %22accessing a corrupted shared library%22%7D,%0A%09%7B85, %22ELIBSCN%22, %22.lib section in a.out corrupted%22%7D,%0A%09%7B86, %22ELIBMAX%22, %22attempting to link in more shared libraries than system limit%22%7D,%0A%09%7B87, %22ELIBEXEC%22, %22can not exec a shared library directly%22%7D,%0A%09%7B88, %22EILSEQ%22, %22illegal byte sequence%22%7D,%0A%09%7B89, %22ENOSYS%22, %22operation not applicable%22%7D,%0A%09%7B90, %22ELOOP%22, %22number of symbolic links encountered during path name traversal exceeds MAXSYMLINKS%22%7D,%0A%09%7B91, %22ERESTART%22, %22error 91%22%7D,%0A%09%7B92, %22ESTRPIPE%22, %22error 92%22%7D,%0A%09%7B93, %22ENOTEMPTY%22, %22directory not empty%22%7D,%0A%09%7B94, %22EUSERS%22, %22too many users%22%7D,%0A%09%7B95, %22ENOTSOCK%22, %22socket operation on non-socket%22%7D,%0A%09%7B96, %22EDESTADDRREQ%22, %22destination address required%22%7D,%0A%09%7B97, %22EMSGSIZE%22, %22message too long%22%7D,%0A%09%7B98, %22EPROTOTYPE%22, %22protocol wrong type for socket%22%7D,%0A%09%7B99, %22ENOPROTOOPT%22, %22option not supported by protocol%22%7D,%0A%09%7B120, %22EPROTONOSUPPORT%22, %22protocol not supported%22%7D,%0A%09%7B121, %22ESOCKTNOSUPPORT%22, %22socket type not supported%22%7D,%0A%09%7B122, %22EOPNOTSUPP%22, %22operation not supported on transport endpoint%22%7D,%0A%09%7B123, %22EPFNOSUPPORT%22, %22protocol family not supported%22%7D,%0A%09%7B124, %22EAFNOSUPPORT%22, %22address family not supported by protocol family%22%7D,%0A%09%7B125, %22EADDRINUSE%22, %22address already in use%22%7D,%0A%09%7B126, %22EADDRNOTAVAIL%22, %22cannot assign requested address%22%7D,%0A%09%7B127, %22ENETDOWN%22, %22network is down%22%7D,%0A%09%7B128, %22ENETUNREACH%22, %22network is unreachable%22%7D,%0A%09%7B129, %22ENETRESET%22, %22network dropped connection because of reset%22%7D,%0A%09%7B130, %22ECONNABORTED%22, %22software caused connection abort%22%7D,%0A%09%7B131, %22ECONNRESET%22, %22connection reset by peer%22%7D,%0A%09%7B132, %22ENOBUFS%22, %22no buffer space available%22%7D,%0A%09%7B133, %22EISCONN%22, %22transport endpoint is already connected%22%7D,%0A%09%7B134, %22ENOTCONN%22, %22transport endpoint is not connected%22%7D,%0A%09%7B143, %22ESHUTDOWN%22, %22cannot send after socket shutdown%22%7D,%0A%09%7B144, %22ETOOMANYREFS%22, %22too many references: cannot splice%22%7D,%0A%09%7B145, %22ETIMEDOUT%22, %22connection timed out%22%7D,%0A%09%7B146, %22ECONNREFUSED%22, %22connection refused%22%7D,%0A%09%7B147, %22EHOSTDOWN%22, %22host is down%22%7D,%0A%09%7B148, %22EHOSTUNREACH%22, %22no route to host%22%7D,%0A%09%7B149, %22EALREADY%22, %22operation already in progress%22%7D,%0A%09%7B150, %22EINPROGRESS%22, %22operation now in progress%22%7D,%0A%09%7B151, %22ESTALE%22, %22stale NFS file handle%22%7D,%0A%7D%0A%0A// Signal table%0Avar signalList = %5B...%5Dstruct %7B%0A%09num  syscall.Signal%0A%09name string%0A%09desc string%0A%7D%7B%0A%09%7B1, %22SIGHUP%22, %22hangup%22%7D,%0A%09%7B2, %22SIGINT%22, %22interrupt%22%7D,%0A%09%7B3, %22SIGQUIT%22, %22quit%22%7D,%0A%09%7B4, %22SIGILL%22, %22illegal Instruction%22%7D,%0A%09%7B5, %22SIGTRAP%22, %22trace/Breakpoint Trap%22%7D,%0A%09%7B6, %22SIGABRT%22, %22abort%22%7D,%0A%09%7B7, %22SIGEMT%22, %22emulation Trap%22%7D,%0A%09%7B8, %22SIGFPE%22, %22arithmetic Exception%22%7D,%0A%09%7B9, %22SIGKILL%22, %22killed%22%7D,%0A%09%7B10, %22SIGBUS%22, %22bus Error%22%7D,%0A%09%7B11, %22SIGSEGV%22, %22segmentation Fault%22%7D,%0A%09%7B12, %22SIGSYS%22, %22bad System Call%22%7D,%0A%09%7B13, %22SIGPIPE%22, %22broken Pipe%22%7D,%0A%09%7B14, %22SIGALRM%22, %22alarm Clock%22%7D,%0A%09%7B15, %22SIGTERM%22, %22terminated%22%7D,%0A%09%7B16, %22SIGUSR1%22, %22user Signal 1%22%7D,%0A%09%7B17, %22SIGUSR2%22, %22user Signal 2%22%7D,%0A%09%7B18, %22SIGCHLD%22, %22child Status Changed%22%7D,%0A%09%7B19, %22SIGPWR%22, %22power-Fail/Restart%22%7D,%0A%09%7B20, %22SIGWINCH%22, %22window Size Change%22%7D,%0A%09%7B21, %22SIGURG%22, %22urgent Socket Condition%22%7D,%0A%09%7B22, %22SIGIO%22, %22pollable Event%22%7D,%0A%09%7B23, %22SIGSTOP%22, %22stopped (signal)%22%7D,%0A%09%7B24, %22SIGTSTP%22, %22stopped (user)%22%7D,%0A%09%7B25, %22SIGCONT%22, %22continued%22%7D,%0A%09%7B26, %22SIGTTIN%22, %22stopped (tty input)%22%7D,%0A%09%7B27, %22SIGTTOU%22, %22stopped (tty output)%22%7D,%0A%09%7B28, %22SIGVTALRM%22, %22virtual Timer Expired%22%7D,%0A%09%7B29, %22SIGPROF%22, %22profiling Timer Expired%22%7D,%0A%09%7B30, %22SIGXCPU%22, %22cpu Limit Exceeded%22%7D,%0A%09%7B31, %22SIGXFSZ%22, %22file Size Limit Exceeded%22%7D,%0A%09%7B32, %22SIGWAITING%22, %22no runnable lwp%22%7D,%0A%09%7B33, %22SIGLWP%22, %22inter-lwp signal%22%7D,%0A%09%7B34, %22SIGFREEZE%22, %22checkpoint Freeze%22%7D,%0A%09%7B35, %22SIGTHAW%22, %22checkpoint Thaw%22%7D,%0A%09%7B36, %22SIGCANCEL%22, %22thread Cancellation%22%7D,%0A%09%7B37, %22SIGLOST%22, %22resource Lost%22%7D,%0A%09%7B38, %22SIGXRES%22, %22resource Control Exceeded%22%7D,%0A%09%7B39, %22SIGJVM1%22, %22reserved for JVM 1%22%7D,%0A%09%7B40, %22SIGJVM2%22, %22reserved for JVM 2%22%7D,%0A%09%7B41, %22SIGINFO%22, %22information Request%22%7D,%0A%7D%0A
- f 98fa9c84019d67138d776aad1eeec6dba05d40dc43120cd3bd503af07e7a2ba2 vendor/golang.org/x/sys/unix/zptrace386_linux.go
+ f 792c9ff4d00513df5080e2407c65fb821dc11cd14056e418f041b51b4d19a67d vendor/golang.org/x/sys/unix/zptrace386_linux.go
dmppatch 3
@@ -125,8 +125,1746 @@
 ge unix%0A
+%0Aimport %22unsafe%22%0A%0A// PtraceRegs386 is the registers used by 386 binaries.%0Atype PtraceRegs386 struct %7B%0A%09Ebx      int32%0A%09Ecx      int32%0A%09Edx      int32%0A%09Esi      int32%0A%09Edi      int32%0A%09Ebp      int32%0A%09Eax      int32%0A%09Xds      int32%0A%09Xes      int32%0A%09Xfs      int32%0A%09Xgs      int32%0A%09Orig_eax int32%0A%09Eip      int32%0A%09Xcs      int32%0A%09Eflags   int32%0A%09Esp      int32%0A%09Xss      int32%0A%7D%0A%0A// PtraceGetRegs386 fetches the registers used by 386 binaries.%0Afunc PtraceGetRegs386(pid int, regsout *PtraceRegs386) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegs386 sets the registers used by 386 binaries.%0Afunc PtraceSetRegs386(pid int, regs *PtraceRegs386) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0A// PtraceRegsAmd64 is the registers used by amd64 binaries.%0Atype PtraceRegsAmd64 struct %7B%0A%09R15      uint64%0A%09R14      uint64%0A%09R13      uint64%0A%09R12      uint64%0A%09Rbp      uint64%0A%09Rbx      uint64%0A%09R11      uint64%0A%09R10      uint64%0A%09R9       uint64%0A%09R8       uint64%0A%09Rax      uint64%0A%09Rcx      uint64%0A%09Rdx      uint64%0A%09Rsi      uint64%0A%09Rdi      uint64%0A%09Orig_rax uint64%0A%09Rip      uint64%0A%09Cs       uint64%0A%09Eflags   uint64%0A%09Rsp      uint64%0A%09Ss       uint64%0A%09Fs_base  uint64%0A%09Gs_base  uint64%0A%09Ds       uint64%0A%09Es       uint64%0A%09Fs       uint64%0A%09Gs       uint64%0A%7D%0A%0A// PtraceGetRegsAmd64 fetches the registers used by amd64 binaries.%0Afunc PtraceGetRegsAmd64(pid int, regsout *PtraceRegsAmd64) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsAmd64 sets the registers used by amd64 binaries.%0Afunc PtraceSetRegsAmd64(pid int, regs *PtraceRegsAmd64) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A
- f ed7a6d10d98325f0461220b52696a7233f7319e75658197bf01b0ae26e81d8db vendor/golang.org/x/sys/unix/zptracearm_linux.go
+ f 6253ec7ba005d6f156f5f5cd8ee7d8d598fcbf038f948bb46abd98fa21e7c714 vendor/golang.org/x/sys/unix/zptracearm_linux.go
dmppatch 3
@@ -125,8 +125,1097 @@
 ge unix%0A
+%0Aimport %22unsafe%22%0A%0A// PtraceRegsArm is the registers used by arm binaries.%0Atype PtraceRegsArm struct %7B%0A%09Uregs %5B18%5Duint32%0A%7D%0A%0A// PtraceGetRegsArm fetches the registers used by arm binaries.%0Afunc PtraceGetRegsArm(pid int, regsout *PtraceRegsArm) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsArm sets the registers used by arm binaries.%0Afunc PtraceSetRegsArm(pid int, regs *PtraceRegsArm) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0A// PtraceRegsArm64 is the registers used by arm64 binaries.%0Atype PtraceRegsArm64 struct %7B%0A%09Regs   %5B31%5Duint64%0A%09Sp     uint64%0A%09Pc     uint64%0A%09Pstate uint64%0A%7D%0A%0A// PtraceGetRegsArm64 fetches the registers used by arm64 binaries.%0Afunc PtraceGetRegsArm64(pid int, regsout *PtraceRegsArm64) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsArm64 sets the registers used by arm64 binaries.%0Afunc PtraceSetRegsArm64(pid int, regs *PtraceRegsArm64) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A
- f 2fd010fed63ee9fb79a10a19ea81d2fd8cae6f0196099780964e8a1c3cc0476e vendor/golang.org/x/sys/unix/zptracemips_linux.go
+ f bf857d0dcb43752a63dc82734f653143481c327b1f10e6a68df15c2dcc94169e vendor/golang.org/x/sys/unix/zptracemips_linux.go
dmppatch 3
@@ -129,8 +129,1283 @@
 ge unix%0A
+%0Aimport %22unsafe%22%0A%0A// PtraceRegsMips is the registers used by mips binaries.%0Atype PtraceRegsMips struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0A// PtraceGetRegsMips fetches the registers used by mips binaries.%0Afunc PtraceGetRegsMips(pid int, regsout *PtraceRegsMips) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsMips sets the registers used by mips binaries.%0Afunc PtraceSetRegsMips(pid int, regs *PtraceRegsMips) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0A// PtraceRegsMips64 is the registers used by mips64 binaries.%0Atype PtraceRegsMips64 struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0A// PtraceGetRegsMips64 fetches the registers used by mips64 binaries.%0Afunc PtraceGetRegsMips64(pid int, regsout *PtraceRegsMips64) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsMips64 sets the registers used by mips64 binaries.%0Afunc PtraceSetRegsMips64(pid int, regs *PtraceRegsMips64) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A
- f 73cf97b28a0652ea7960f5b894b48335ba64cbf682ffe42867a569bdbdba20d1 vendor/golang.org/x/sys/unix/zptracemipsle_linux.go
+ f 9242dc56c12da60f55bd6bed6ec08f04a3966903f14ee1e843c14be374717f21 vendor/golang.org/x/sys/unix/zptracemipsle_linux.go
dmppatch 3
@@ -137,8 +137,1327 @@
 ge unix%0A
+%0Aimport %22unsafe%22%0A%0A// PtraceRegsMipsle is the registers used by mipsle binaries.%0Atype PtraceRegsMipsle struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0A// PtraceGetRegsMipsle fetches the registers used by mipsle binaries.%0Afunc PtraceGetRegsMipsle(pid int, regsout *PtraceRegsMipsle) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsMipsle sets the registers used by mipsle binaries.%0Afunc PtraceSetRegsMipsle(pid int, regs *PtraceRegsMipsle) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A%0A// PtraceRegsMips64le is the registers used by mips64le binaries.%0Atype PtraceRegsMips64le struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0A// PtraceGetRegsMips64le fetches the registers used by mips64le binaries.%0Afunc PtraceGetRegsMips64le(pid int, regsout *PtraceRegsMips64le) error %7B%0A%09return ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))%0A%7D%0A%0A// PtraceSetRegsMips64le sets the registers used by mips64le binaries.%0Afunc PtraceSetRegsMips64le(pid int, regs *PtraceRegsMips64le) error %7B%0A%09return ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))%0A%7D%0A
+ f 6bc3f3ccde975911d8a81e65fd8e74e4de7cd613016697472c310e4cbb05cfa8 vendor/golang.org/x/sys/unix/zsyscall_aix_ppc.go
dmppatch 2
@@ -0,0 +1,37727 @@
+// mksyscall_aix.pl -aix -tags aix,ppc syscall_aix.go syscall_aix_ppc.go%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build aix,ppc%0A%0Apackage unix%0A%0A/*%0A#include %3Cstdint.h%3E%0Aint utimes(uintptr_t, uintptr_t);%0Aint utimensat(int, uintptr_t, uintptr_t, int);%0Aint getcwd(uintptr_t, size_t);%0Aint accept(int, uintptr_t, uintptr_t);%0Aint getdirent(int, uintptr_t, size_t);%0Aint wait4(int, uintptr_t, int, uintptr_t);%0Aint ioctl(int, int, uintptr_t);%0Aint fcntl(uintptr_t, int, uintptr_t);%0Aint acct(uintptr_t);%0Aint chdir(uintptr_t);%0Aint chroot(uintptr_t);%0Aint close(int);%0Aint dup(int);%0Aint dup3(int, int, int);%0Avoid exit(int);%0Aint faccessat(int, uintptr_t, unsigned int, int);%0Aint fallocate(int, unsigned int, long long, long long);%0Aint fchdir(int);%0Aint fchmod(int, unsigned int);%0Aint fchmodat(int, uintptr_t, unsigned int, int);%0Aint fchownat(int, uintptr_t, int, int, int);%0Aint fdatasync(int);%0Aint fsync(int);%0Aint getpgid(int);%0Aint getpgrp();%0Aint getpid();%0Aint getppid();%0Aint getpriority(int, int);%0Aint getrusage(int, uintptr_t);%0Aint getsid(int);%0Aint kill(int, int);%0Aint syslog(int, uintptr_t, size_t);%0Aint mkdir(int, uintptr_t, unsigned int);%0Aint mkdirat(int, uintptr_t, unsigned int);%0Aint mkfifo(uintptr_t, unsigned int);%0Aint mknod(uintptr_t, unsigned int, int);%0Aint mknodat(int, uintptr_t, unsigned int, int);%0Aint nanosleep(uintptr_t, uintptr_t);%0Aint open64(uintptr_t, int, unsigned int);%0Aint openat(int, uintptr_t, int, unsigned int);%0Aint read(int, uintptr_t, size_t);%0Aint readlink(uintptr_t, uintptr_t, size_t);%0Aint removexattr(uintptr_t, uintptr_t);%0Aint renameat(int, uintptr_t, int, uintptr_t);%0Aint setdomainname(uintptr_t, size_t);%0Aint sethostname(uintptr_t, size_t);%0Aint setpgid(int, int);%0Aint setsid();%0Aint settimeofday(uintptr_t);%0Aint setuid(int);%0Aint setgid(int);%0Aint setpriority(int, int, int);%0Aint statx(int, uintptr_t, int, int, uintptr_t);%0Aint sync();%0Along long tee(int, int, int, int);%0Auintptr_t times(uintptr_t);%0Aint umask(int);%0Aint uname(uintptr_t);%0Aint unlink(uintptr_t);%0Aint unlinkat(int, uintptr_t, int);%0Aint unshare(int);%0Aint ustat(int, uintptr_t);%0Aint write(int, uintptr_t, size_t);%0Aint dup2(int, int);%0Aint posix_fadvise64(int, long long, long long, int);%0Aint fchown(int, int, int);%0Aint fstat(int, uintptr_t);%0Aint fstatat(int, uintptr_t, uintptr_t, int);%0Aint fstatfs(int, uintptr_t);%0Aint ftruncate(int, long long);%0Aint getegid();%0Aint geteuid();%0Aint getgid();%0Aint getuid();%0Aint lchown(uintptr_t, int, int);%0Aint listen(int, int);%0Aint lstat(uintptr_t, uintptr_t);%0Aint pause();%0Aint pread64(int, uintptr_t, size_t, long long);%0Aint pwrite64(int, uintptr_t, size_t, long long);%0Aint pselect(int, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);%0Aint setregid(int, int);%0Aint setreuid(int, int);%0Aint shutdown(int, int);%0Along long splice(int, uintptr_t, int, uintptr_t, int, int);%0Aint stat(uintptr_t, uintptr_t);%0Aint statfs(uintptr_t, uintptr_t);%0Aint truncate(uintptr_t, long long);%0Aint bind(int, uintptr_t, uintptr_t);%0Aint connect(int, uintptr_t, uintptr_t);%0Aint getgroups(int, uintptr_t);%0Aint setgroups(int, uintptr_t);%0Aint getsockopt(int, int, int, uintptr_t, uintptr_t);%0Aint setsockopt(int, int, int, uintptr_t, uintptr_t);%0Aint socket(int, int, int);%0Aint socketpair(int, int, int, uintptr_t);%0Aint getpeername(int, uintptr_t, uintptr_t);%0Aint getsockname(int, uintptr_t, uintptr_t);%0Aint recvfrom(int, uintptr_t, size_t, int, uintptr_t, uintptr_t);%0Aint sendto(int, uintptr_t, size_t, int, uintptr_t, uintptr_t);%0Aint recvmsg(int, uintptr_t, int);%0Aint sendmsg(int, uintptr_t, int);%0Aint munmap(uintptr_t, uintptr_t);%0Aint madvise(uintptr_t, size_t, int);%0Aint mprotect(uintptr_t, size_t, int);%0Aint mlock(uintptr_t, size_t);%0Aint mlockall(int);%0Aint msync(uintptr_t, size_t, int);%0Aint munlock(uintptr_t, size_t);%0Aint munlockall();%0Aint pipe(uintptr_t);%0Aint pipe2(uintptr_t, int);%0Aint poll(uintptr_t, int, int);%0Aint gettimeofday(uintptr_t, uintptr_t);%0Aint time(uintptr_t);%0Aint utime(uintptr_t, uintptr_t);%0Aint getrlimit64(int, uintptr_t);%0Aint setrlimit64(int, uintptr_t);%0Along long lseek64(int, long long, int);%0Auintptr_t mmap(uintptr_t, uintptr_t, int, int, int, long long);%0A%0A*/%0Aimport %22C%22%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.utimes(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(times))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flag int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.utimensat(C.int(dirfd), C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(times))), C.int(flag))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getcwd(buf %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(buf)%0A%09r0, er := C.getcwd(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, er := C.accept(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(rsa))), C.uintptr_t(uintptr(unsafe.Pointer(addrlen))))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdirent(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(buf)%0A%09r0, er := C.getdirent(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid Pid_t, status *_C_int, options int, rusage *Rusage) (wpid Pid_t, err error) %7B%0A%09r0, er := C.wait4(C.int(pid), C.uintptr_t(uintptr(unsafe.Pointer(status))), C.int(options), C.uintptr_t(uintptr(unsafe.Pointer(rusage))))%0A%09wpid = Pid_t(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ioctl(fd int, req uint, arg uintptr) (err error) %7B%0A%09r0, er := C.ioctl(C.int(fd), C.int(req), C.uintptr_t(arg))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc FcntlInt(fd uintptr, cmd int, arg int) (r int, err error) %7B%0A%09r0, er := C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(arg))%0A%09r = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc FcntlFlock(fd uintptr, cmd int, lk *Flock_t) (err error) %7B%0A%09r0, er := C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(uintptr(unsafe.Pointer(lk))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.acct(C.uintptr_t(_p0))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.chdir(C.uintptr_t(_p0))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.chroot(C.uintptr_t(_p0))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09r0, er := C.close(C.int(fd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, er := C.dup(C.int(oldfd))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09r0, er := C.dup3(C.int(oldfd), C.int(newfd), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09C.exit(C.int(code))%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.faccessat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09r0, er := C.fallocate(C.int(fd), C.uint(mode), C.longlong(off), C.longlong(len))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09r0, er := C.fchdir(C.int(fd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09r0, er := C.fchmod(C.int(fd), C.uint(mode))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.fchmodat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.fchownat(C.int(dirfd), C.uintptr_t(_p0), C.int(uid), C.int(gid), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, er := C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(arg))%0A%09val = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09r0, er := C.fdatasync(C.int(fd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09r0, er := C.fsync(C.int(fd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, er := C.getpgid(C.int(pid))%0A%09pgid = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pid int) %7B%0A%09r0, _ := C.getpgrp()%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := C.getpid()%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := C.getppid()%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, er := C.getpriority(C.int(which), C.int(who))%0A%09prio = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09r0, er := C.getrusage(C.int(who), C.uintptr_t(uintptr(unsafe.Pointer(rusage))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, er := C.getsid(C.int(pid))%0A%09sid = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09r0, er := C.kill(C.int(pid), C.int(sig))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(buf)%0A%09r0, er := C.syslog(C.int(typ), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(dirfd int, path string, mode uint32) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mkdir(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mkdirat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mkfifo(C.uintptr_t(_p0), C.uint(mode))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mknod(C.uintptr_t(_p0), C.uint(mode), C.int(dev))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mknodat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(dev))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09r0, er := C.nanosleep(C.uintptr_t(uintptr(unsafe.Pointer(time))), C.uintptr_t(uintptr(unsafe.Pointer(leftover))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.open64(C.uintptr_t(_p0), C.int(mode), C.uint(perm))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.openat(C.int(dirfd), C.uintptr_t(_p0), C.int(flags), C.uint(mode))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc read(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.read(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09var _p1 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = &buf%5B0%5D%0A%09%7D%0A%09var _p2 int%0A%09_p2 = len(buf)%0A%09r0, er := C.readlink(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(_p1))), C.size_t(_p2))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09_p1 := uintptr(unsafe.Pointer(C.CString(attr)))%0A%09r0, er := C.removexattr(C.uintptr_t(_p0), C.uintptr_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(oldpath)))%0A%09_p1 := uintptr(unsafe.Pointer(C.CString(newpath)))%0A%09r0, er := C.renameat(C.int(olddirfd), C.uintptr_t(_p0), C.int(newdirfd), C.uintptr_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.setdomainname(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.sethostname(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09r0, er := C.setpgid(C.int(pid), C.int(pgid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, er := C.setsid()%0A%09pid = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09r0, er := C.settimeofday(C.uintptr_t(uintptr(unsafe.Pointer(tv))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09r0, er := C.setuid(C.int(uid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(uid int) (err error) %7B%0A%09r0, er := C.setgid(C.int(uid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09r0, er := C.setpriority(C.int(which), C.int(who), C.int(prio))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.statx(C.int(dirfd), C.uintptr_t(_p0), C.int(flags), C.int(mask), C.uintptr_t(uintptr(unsafe.Pointer(stat))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09C.sync()%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, er := C.tee(C.int(rfd), C.int(wfd), C.int(len), C.int(flags))%0A%09n = int64(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, er := C.times(C.uintptr_t(uintptr(unsafe.Pointer(tms))))%0A%09ticks = uintptr(r0)%0A%09if uintptr(r0) == %5Euintptr(0) && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := C.umask(C.int(mask))%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09r0, er := C.uname(C.uintptr_t(uintptr(unsafe.Pointer(buf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.unlink(C.uintptr_t(_p0))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.unlinkat(C.int(dirfd), C.uintptr_t(_p0), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09r0, er := C.unshare(C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09r0, er := C.ustat(C.int(dev), C.uintptr_t(uintptr(unsafe.Pointer(ubuf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.write(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, er := C.read(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(p))), C.size_t(np))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, er := C.write(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(p))), C.size_t(np))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09r0, er := C.dup2(C.int(oldfd), C.int(newfd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09r0, er := C.posix_fadvise64(C.int(fd), C.longlong(offset), C.longlong(length), C.int(advice))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09r0, er := C.fchown(C.int(fd), C.int(uid), C.int(gid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09r0, er := C.fstat(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(stat))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.fstatat(C.int(dirfd), C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(stat))), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09r0, er := C.fstatfs(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(buf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09r0, er := C.ftruncate(C.int(fd), C.longlong(length))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := C.getegid()%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := C.geteuid()%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := C.getgid()%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := C.getuid()%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.lchown(C.uintptr_t(_p0), C.int(uid), C.int(gid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09r0, er := C.listen(C.int(s), C.int(n))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.lstat(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(stat))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09r0, er := C.pause()%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.pread64(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.longlong(offset))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.pwrite64(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.longlong(offset))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, er := C.pselect(C.int(nfd), C.uintptr_t(uintptr(unsafe.Pointer(r))), C.uintptr_t(uintptr(unsafe.Pointer(w))), C.uintptr_t(uintptr(unsafe.Pointer(e))), C.uintptr_t(uintptr(unsafe.Pointer(timeout))), C.uintptr_t(uintptr(unsafe.Pointer(sigmask))))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09r0, er := C.setregid(C.int(rgid), C.int(egid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09r0, er := C.setreuid(C.int(ruid), C.int(euid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09r0, er := C.shutdown(C.int(fd), C.int(how))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, er := C.splice(C.int(rfd), C.uintptr_t(uintptr(unsafe.Pointer(roff))), C.int(wfd), C.uintptr_t(uintptr(unsafe.Pointer(woff))), C.int(len), C.int(flags))%0A%09n = int64(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.stat(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(stat))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.statfs(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(buf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.truncate(C.uintptr_t(_p0), C.longlong(length))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09r0, er := C.bind(C.int(s), C.uintptr_t(uintptr(addr)), C.uintptr_t(uintptr(addrlen)))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09r0, er := C.connect(C.int(s), C.uintptr_t(uintptr(addr)), C.uintptr_t(uintptr(addrlen)))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, er := C.getgroups(C.int(n), C.uintptr_t(uintptr(unsafe.Pointer(list))))%0A%09nn = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09r0, er := C.setgroups(C.int(n), C.uintptr_t(uintptr(unsafe.Pointer(list))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09r0, er := C.getsockopt(C.int(s), C.int(level), C.int(name), C.uintptr_t(uintptr(val)), C.uintptr_t(uintptr(unsafe.Pointer(vallen))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09r0, er := C.setsockopt(C.int(s), C.int(level), C.int(name), C.uintptr_t(uintptr(val)), C.uintptr_t(vallen))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, er := C.socket(C.int(domain), C.int(typ), C.int(proto))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09r0, er := C.socketpair(C.int(domain), C.int(typ), C.int(proto), C.uintptr_t(uintptr(unsafe.Pointer(fd))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09r0, er := C.getpeername(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(rsa))), C.uintptr_t(uintptr(unsafe.Pointer(addrlen))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09r0, er := C.getsockname(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(rsa))), C.uintptr_t(uintptr(unsafe.Pointer(addrlen))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.recvfrom(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(flags), C.uintptr_t(uintptr(unsafe.Pointer(from))), C.uintptr_t(uintptr(unsafe.Pointer(fromlen))))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(buf)%0A%09r0, er := C.sendto(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(flags), C.uintptr_t(uintptr(to)), C.uintptr_t(uintptr(addrlen)))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, er := C.recvmsg(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(msg))), C.int(flags))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, er := C.sendmsg(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(msg))), C.int(flags))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09r0, er := C.munmap(C.uintptr_t(addr), C.uintptr_t(length))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.madvise(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(advice))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.mprotect(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(prot))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.mlock(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09r0, er := C.mlockall(C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.msync(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.munlock(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09r0, er := C.munlockall()%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09r0, er := C.pipe(C.uintptr_t(uintptr(unsafe.Pointer(p))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09r0, er := C.pipe2(C.uintptr_t(uintptr(unsafe.Pointer(p))), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, er := C.poll(C.uintptr_t(uintptr(unsafe.Pointer(fds))), C.int(nfds), C.int(timeout))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tv *Timeval, tzp *Timezone) (err error) %7B%0A%09r0, er := C.gettimeofday(C.uintptr_t(uintptr(unsafe.Pointer(tv))), C.uintptr_t(uintptr(unsafe.Pointer(tzp))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, er := C.time(C.uintptr_t(uintptr(unsafe.Pointer(t))))%0A%09tt = Time_t(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.utime(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(buf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09r0, er := C.getrlimit64(C.int(resource), C.uintptr_t(uintptr(unsafe.Pointer(rlim))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09r0, er := C.setrlimit64(C.int(resource), C.uintptr_t(uintptr(unsafe.Pointer(rlim))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, er := C.lseek64(C.int(fd), C.longlong(offset), C.int(whence))%0A%09off = int64(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, er := C.mmap(C.uintptr_t(addr), C.uintptr_t(length), C.int(prot), C.int(flags), C.int(fd), C.longlong(offset))%0A%09xaddr = uintptr(r0)%0A%09if uintptr(r0) == %5Euintptr(0) && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A
+ f 48e404795b2e9f142c88b5cbb7b31516d53810d2c05cbb0249c377e14b947b89 vendor/golang.org/x/sys/unix/zsyscall_aix_ppc64.go
dmppatch 2
@@ -0,0 +1,37725 @@
+// mksyscall_aix.pl -aix -tags aix,ppc64 syscall_aix.go syscall_aix_ppc64.go%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build aix,ppc64%0A%0Apackage unix%0A%0A/*%0A#include %3Cstdint.h%3E%0Aint utimes(uintptr_t, uintptr_t);%0Aint utimensat(int, uintptr_t, uintptr_t, int);%0Aint getcwd(uintptr_t, size_t);%0Aint accept(int, uintptr_t, uintptr_t);%0Aint getdirent(int, uintptr_t, size_t);%0Aint wait4(int, uintptr_t, int, uintptr_t);%0Aint ioctl(int, int, uintptr_t);%0Aint fcntl(uintptr_t, int, uintptr_t);%0Aint acct(uintptr_t);%0Aint chdir(uintptr_t);%0Aint chroot(uintptr_t);%0Aint close(int);%0Aint dup(int);%0Aint dup3(int, int, int);%0Avoid exit(int);%0Aint faccessat(int, uintptr_t, unsigned int, int);%0Aint fallocate(int, unsigned int, long long, long long);%0Aint fchdir(int);%0Aint fchmod(int, unsigned int);%0Aint fchmodat(int, uintptr_t, unsigned int, int);%0Aint fchownat(int, uintptr_t, int, int, int);%0Aint fdatasync(int);%0Aint fsync(int);%0Aint getpgid(int);%0Aint getpgrp();%0Aint getpid();%0Aint getppid();%0Aint getpriority(int, int);%0Aint getrusage(int, uintptr_t);%0Aint getsid(int);%0Aint kill(int, int);%0Aint syslog(int, uintptr_t, size_t);%0Aint mkdir(int, uintptr_t, unsigned int);%0Aint mkdirat(int, uintptr_t, unsigned int);%0Aint mkfifo(uintptr_t, unsigned int);%0Aint mknod(uintptr_t, unsigned int, int);%0Aint mknodat(int, uintptr_t, unsigned int, int);%0Aint nanosleep(uintptr_t, uintptr_t);%0Aint open64(uintptr_t, int, unsigned int);%0Aint openat(int, uintptr_t, int, unsigned int);%0Aint read(int, uintptr_t, size_t);%0Aint readlink(uintptr_t, uintptr_t, size_t);%0Aint removexattr(uintptr_t, uintptr_t);%0Aint renameat(int, uintptr_t, int, uintptr_t);%0Aint setdomainname(uintptr_t, size_t);%0Aint sethostname(uintptr_t, size_t);%0Aint setpgid(int, int);%0Aint setsid();%0Aint settimeofday(uintptr_t);%0Aint setuid(int);%0Aint setgid(int);%0Aint setpriority(int, int, int);%0Aint statx(int, uintptr_t, int, int, uintptr_t);%0Aint sync();%0Along long tee(int, int, int, int);%0Auintptr_t times(uintptr_t);%0Aint umask(int);%0Aint uname(uintptr_t);%0Aint unlink(uintptr_t);%0Aint unlinkat(int, uintptr_t, int);%0Aint unshare(int);%0Aint ustat(int, uintptr_t);%0Aint write(int, uintptr_t, size_t);%0Aint dup2(int, int);%0Aint posix_fadvise64(int, long long, long long, int);%0Aint fchown(int, int, int);%0Aint fstat(int, uintptr_t);%0Aint fstatat(int, uintptr_t, uintptr_t, int);%0Aint fstatfs(int, uintptr_t);%0Aint ftruncate(int, long long);%0Aint getegid();%0Aint geteuid();%0Aint getgid();%0Aint getuid();%0Aint lchown(uintptr_t, int, int);%0Aint listen(int, int);%0Aint lstat(uintptr_t, uintptr_t);%0Aint pause();%0Aint pread64(int, uintptr_t, size_t, long long);%0Aint pwrite64(int, uintptr_t, size_t, long long);%0Aint pselect(int, uintptr_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);%0Aint setregid(int, int);%0Aint setreuid(int, int);%0Aint shutdown(int, int);%0Along long splice(int, uintptr_t, int, uintptr_t, int, int);%0Aint stat(uintptr_t, uintptr_t);%0Aint statfs(uintptr_t, uintptr_t);%0Aint truncate(uintptr_t, long long);%0Aint bind(int, uintptr_t, uintptr_t);%0Aint connect(int, uintptr_t, uintptr_t);%0Aint getgroups(int, uintptr_t);%0Aint setgroups(int, uintptr_t);%0Aint getsockopt(int, int, int, uintptr_t, uintptr_t);%0Aint setsockopt(int, int, int, uintptr_t, uintptr_t);%0Aint socket(int, int, int);%0Aint socketpair(int, int, int, uintptr_t);%0Aint getpeername(int, uintptr_t, uintptr_t);%0Aint getsockname(int, uintptr_t, uintptr_t);%0Aint recvfrom(int, uintptr_t, size_t, int, uintptr_t, uintptr_t);%0Aint sendto(int, uintptr_t, size_t, int, uintptr_t, uintptr_t);%0Aint recvmsg(int, uintptr_t, int);%0Aint sendmsg(int, uintptr_t, int);%0Aint munmap(uintptr_t, uintptr_t);%0Aint madvise(uintptr_t, size_t, int);%0Aint mprotect(uintptr_t, size_t, int);%0Aint mlock(uintptr_t, size_t);%0Aint mlockall(int);%0Aint msync(uintptr_t, size_t, int);%0Aint munlock(uintptr_t, size_t);%0Aint munlockall();%0Aint pipe(uintptr_t);%0Aint pipe2(uintptr_t, int);%0Aint poll(uintptr_t, int, int);%0Aint gettimeofday(uintptr_t, uintptr_t);%0Aint time(uintptr_t);%0Aint utime(uintptr_t, uintptr_t);%0Aint getrlimit(int, uintptr_t);%0Aint setrlimit(int, uintptr_t);%0Along long lseek(int, long long, int);%0Auintptr_t mmap64(uintptr_t, uintptr_t, int, int, int, long long);%0A%0A*/%0Aimport %22C%22%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.utimes(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(times))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flag int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.utimensat(C.int(dirfd), C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(times))), C.int(flag))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getcwd(buf %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(buf)%0A%09r0, er := C.getcwd(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, er := C.accept(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(rsa))), C.uintptr_t(uintptr(unsafe.Pointer(addrlen))))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdirent(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(buf)%0A%09r0, er := C.getdirent(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid Pid_t, status *_C_int, options int, rusage *Rusage) (wpid Pid_t, err error) %7B%0A%09r0, er := C.wait4(C.int(pid), C.uintptr_t(uintptr(unsafe.Pointer(status))), C.int(options), C.uintptr_t(uintptr(unsafe.Pointer(rusage))))%0A%09wpid = Pid_t(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ioctl(fd int, req uint, arg uintptr) (err error) %7B%0A%09r0, er := C.ioctl(C.int(fd), C.int(req), C.uintptr_t(arg))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc FcntlInt(fd uintptr, cmd int, arg int) (r int, err error) %7B%0A%09r0, er := C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(arg))%0A%09r = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc FcntlFlock(fd uintptr, cmd int, lk *Flock_t) (err error) %7B%0A%09r0, er := C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(uintptr(unsafe.Pointer(lk))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.acct(C.uintptr_t(_p0))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.chdir(C.uintptr_t(_p0))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.chroot(C.uintptr_t(_p0))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09r0, er := C.close(C.int(fd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, er := C.dup(C.int(oldfd))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09r0, er := C.dup3(C.int(oldfd), C.int(newfd), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09C.exit(C.int(code))%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.faccessat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09r0, er := C.fallocate(C.int(fd), C.uint(mode), C.longlong(off), C.longlong(len))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09r0, er := C.fchdir(C.int(fd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09r0, er := C.fchmod(C.int(fd), C.uint(mode))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.fchmodat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.fchownat(C.int(dirfd), C.uintptr_t(_p0), C.int(uid), C.int(gid), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, er := C.fcntl(C.uintptr_t(fd), C.int(cmd), C.uintptr_t(arg))%0A%09val = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09r0, er := C.fdatasync(C.int(fd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09r0, er := C.fsync(C.int(fd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, er := C.getpgid(C.int(pid))%0A%09pgid = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pid int) %7B%0A%09r0, _ := C.getpgrp()%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := C.getpid()%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := C.getppid()%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, er := C.getpriority(C.int(which), C.int(who))%0A%09prio = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09r0, er := C.getrusage(C.int(who), C.uintptr_t(uintptr(unsafe.Pointer(rusage))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, er := C.getsid(C.int(pid))%0A%09sid = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09r0, er := C.kill(C.int(pid), C.int(sig))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(buf)%0A%09r0, er := C.syslog(C.int(typ), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(dirfd int, path string, mode uint32) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mkdir(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mkdirat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mkfifo(C.uintptr_t(_p0), C.uint(mode))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mknod(C.uintptr_t(_p0), C.uint(mode), C.int(dev))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.mknodat(C.int(dirfd), C.uintptr_t(_p0), C.uint(mode), C.int(dev))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09r0, er := C.nanosleep(C.uintptr_t(uintptr(unsafe.Pointer(time))), C.uintptr_t(uintptr(unsafe.Pointer(leftover))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.open64(C.uintptr_t(_p0), C.int(mode), C.uint(perm))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.openat(C.int(dirfd), C.uintptr_t(_p0), C.int(flags), C.uint(mode))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc read(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.read(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09var _p1 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = &buf%5B0%5D%0A%09%7D%0A%09var _p2 int%0A%09_p2 = len(buf)%0A%09r0, er := C.readlink(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(_p1))), C.size_t(_p2))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09_p1 := uintptr(unsafe.Pointer(C.CString(attr)))%0A%09r0, er := C.removexattr(C.uintptr_t(_p0), C.uintptr_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(oldpath)))%0A%09_p1 := uintptr(unsafe.Pointer(C.CString(newpath)))%0A%09r0, er := C.renameat(C.int(olddirfd), C.uintptr_t(_p0), C.int(newdirfd), C.uintptr_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.setdomainname(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.sethostname(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09r0, er := C.setpgid(C.int(pid), C.int(pgid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, er := C.setsid()%0A%09pid = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09r0, er := C.settimeofday(C.uintptr_t(uintptr(unsafe.Pointer(tv))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09r0, er := C.setuid(C.int(uid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(uid int) (err error) %7B%0A%09r0, er := C.setgid(C.int(uid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09r0, er := C.setpriority(C.int(which), C.int(who), C.int(prio))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.statx(C.int(dirfd), C.uintptr_t(_p0), C.int(flags), C.int(mask), C.uintptr_t(uintptr(unsafe.Pointer(stat))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09C.sync()%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, er := C.tee(C.int(rfd), C.int(wfd), C.int(len), C.int(flags))%0A%09n = int64(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, er := C.times(C.uintptr_t(uintptr(unsafe.Pointer(tms))))%0A%09ticks = uintptr(r0)%0A%09if uintptr(r0) == %5Euintptr(0) && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := C.umask(C.int(mask))%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09r0, er := C.uname(C.uintptr_t(uintptr(unsafe.Pointer(buf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.unlink(C.uintptr_t(_p0))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.unlinkat(C.int(dirfd), C.uintptr_t(_p0), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09r0, er := C.unshare(C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09r0, er := C.ustat(C.int(dev), C.uintptr_t(uintptr(unsafe.Pointer(ubuf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.write(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, er := C.read(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(p))), C.size_t(np))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, er := C.write(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(p))), C.size_t(np))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09r0, er := C.dup2(C.int(oldfd), C.int(newfd))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09r0, er := C.posix_fadvise64(C.int(fd), C.longlong(offset), C.longlong(length), C.int(advice))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09r0, er := C.fchown(C.int(fd), C.int(uid), C.int(gid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09r0, er := C.fstat(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(stat))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.fstatat(C.int(dirfd), C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(stat))), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09r0, er := C.fstatfs(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(buf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09r0, er := C.ftruncate(C.int(fd), C.longlong(length))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := C.getegid()%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := C.geteuid()%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := C.getgid()%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := C.getuid()%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.lchown(C.uintptr_t(_p0), C.int(uid), C.int(gid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09r0, er := C.listen(C.int(s), C.int(n))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.lstat(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(stat))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09r0, er := C.pause()%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.pread64(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.longlong(offset))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.pwrite64(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.longlong(offset))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, er := C.pselect(C.int(nfd), C.uintptr_t(uintptr(unsafe.Pointer(r))), C.uintptr_t(uintptr(unsafe.Pointer(w))), C.uintptr_t(uintptr(unsafe.Pointer(e))), C.uintptr_t(uintptr(unsafe.Pointer(timeout))), C.uintptr_t(uintptr(unsafe.Pointer(sigmask))))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09r0, er := C.setregid(C.int(rgid), C.int(egid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09r0, er := C.setreuid(C.int(ruid), C.int(euid))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09r0, er := C.shutdown(C.int(fd), C.int(how))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, er := C.splice(C.int(rfd), C.uintptr_t(uintptr(unsafe.Pointer(roff))), C.int(wfd), C.uintptr_t(uintptr(unsafe.Pointer(woff))), C.int(len), C.int(flags))%0A%09n = int64(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.stat(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(stat))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.statfs(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(buf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.truncate(C.uintptr_t(_p0), C.longlong(length))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09r0, er := C.bind(C.int(s), C.uintptr_t(uintptr(addr)), C.uintptr_t(uintptr(addrlen)))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09r0, er := C.connect(C.int(s), C.uintptr_t(uintptr(addr)), C.uintptr_t(uintptr(addrlen)))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, er := C.getgroups(C.int(n), C.uintptr_t(uintptr(unsafe.Pointer(list))))%0A%09nn = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09r0, er := C.setgroups(C.int(n), C.uintptr_t(uintptr(unsafe.Pointer(list))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09r0, er := C.getsockopt(C.int(s), C.int(level), C.int(name), C.uintptr_t(uintptr(val)), C.uintptr_t(uintptr(unsafe.Pointer(vallen))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09r0, er := C.setsockopt(C.int(s), C.int(level), C.int(name), C.uintptr_t(uintptr(val)), C.uintptr_t(vallen))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, er := C.socket(C.int(domain), C.int(typ), C.int(proto))%0A%09fd = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09r0, er := C.socketpair(C.int(domain), C.int(typ), C.int(proto), C.uintptr_t(uintptr(unsafe.Pointer(fd))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09r0, er := C.getpeername(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(rsa))), C.uintptr_t(uintptr(unsafe.Pointer(addrlen))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09r0, er := C.getsockname(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(rsa))), C.uintptr_t(uintptr(unsafe.Pointer(addrlen))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(p)%0A%09r0, er := C.recvfrom(C.int(fd), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(flags), C.uintptr_t(uintptr(unsafe.Pointer(from))), C.uintptr_t(uintptr(unsafe.Pointer(fromlen))))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(buf)%0A%09r0, er := C.sendto(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(flags), C.uintptr_t(uintptr(to)), C.uintptr_t(uintptr(addrlen)))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, er := C.recvmsg(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(msg))), C.int(flags))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, er := C.sendmsg(C.int(s), C.uintptr_t(uintptr(unsafe.Pointer(msg))), C.int(flags))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09r0, er := C.munmap(C.uintptr_t(addr), C.uintptr_t(length))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.madvise(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(advice))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.mprotect(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(prot))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.mlock(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09r0, er := C.mlockall(C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.msync(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09var _p1 int%0A%09_p1 = len(b)%0A%09r0, er := C.munlock(C.uintptr_t(uintptr(unsafe.Pointer(_p0))), C.size_t(_p1))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09r0, er := C.munlockall()%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09r0, er := C.pipe(C.uintptr_t(uintptr(unsafe.Pointer(p))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09r0, er := C.pipe2(C.uintptr_t(uintptr(unsafe.Pointer(p))), C.int(flags))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, er := C.poll(C.uintptr_t(uintptr(unsafe.Pointer(fds))), C.int(nfds), C.int(timeout))%0A%09n = int(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tv *Timeval, tzp *Timezone) (err error) %7B%0A%09r0, er := C.gettimeofday(C.uintptr_t(uintptr(unsafe.Pointer(tv))), C.uintptr_t(uintptr(unsafe.Pointer(tzp))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, er := C.time(C.uintptr_t(uintptr(unsafe.Pointer(t))))%0A%09tt = Time_t(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09_p0 := uintptr(unsafe.Pointer(C.CString(path)))%0A%09r0, er := C.utime(C.uintptr_t(_p0), C.uintptr_t(uintptr(unsafe.Pointer(buf))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09r0, er := C.getrlimit(C.int(resource), C.uintptr_t(uintptr(unsafe.Pointer(rlim))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09r0, er := C.setrlimit(C.int(resource), C.uintptr_t(uintptr(unsafe.Pointer(rlim))))%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, er := C.lseek(C.int(fd), C.longlong(offset), C.int(whence))%0A%09off = int64(r0)%0A%09if r0 == -1 && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, er := C.mmap64(C.uintptr_t(addr), C.uintptr_t(length), C.int(prot), C.int(flags), C.int(fd), C.longlong(offset))%0A%09xaddr = uintptr(r0)%0A%09if uintptr(r0) == %5Euintptr(0) && er != nil %7B%0A%09%09err = er%0A%09%7D%0A%09return%0A%7D%0A
- f 3888c0f1694a1f1bb45d314836c5e192a41a91e335fb941b64682f27d945183f vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go
+ f 623d773d3895b5b964280e1352e3b12ebd29877c436ab16b8c833030357fd11b vendor/golang.org/x/sys/unix/zsyscall_darwin_386.go
dmppatch 15
@@ -200,16 +200,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -223,16 +223,14078 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getxattr(path string, attr string, dest *byte, size int, position uint32, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(position), uintptr(options))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fgetxattr(fd int, attr string, dest *byte, size int, position uint32, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(position), uintptr(options))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setxattr(path string, attr string, data *byte, size int, position uint32, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(data)), uintptr(size), uintptr(position), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fsetxattr(fd int, attr string, data *byte, size int, position uint32, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(data)), uintptr(size), uintptr(position), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc removexattr(path string, attr string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fremovexattr(fd int, attr string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc listxattr(path string, dest *byte, size int, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(options), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc flistxattr(fd int, dest *byte, size int, options int) (sz int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_FLISTXATTR, uintptr(fd), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(options), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kill(pid int, signum int, posix int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -14592,24 +14592,15978 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exchangedata(path1 string, path2 string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path1)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(path2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := RawSyscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -30831,28 +30831,11728 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0, 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setprivexec(flag int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos), uintptr(pos%3E%3E32), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tp *Timeval) (sec int32, usec int32, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09sec = int32(r0)%0A%09usec = int32(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f ae32649e801f28e18514253d9c8f3f6056d71f1b6fb745b65e880a6a213a5de7 vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go
+ f 69f18d87295d6df0403fb610b032bf59d84e6638a4f4719ee1bb3e5f8ba7c4ec vendor/golang.org/x/sys/unix/zsyscall_darwin_amd64.go
dmppatch 15
@@ -201,16 +201,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -224,16 +224,14078 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getxattr(path string, attr string, dest *byte, size int, position uint32, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(position), uintptr(options))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fgetxattr(fd int, attr string, dest *byte, size int, position uint32, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(position), uintptr(options))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setxattr(path string, attr string, data *byte, size int, position uint32, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(data)), uintptr(size), uintptr(position), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fsetxattr(fd int, attr string, data *byte, size int, position uint32, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(data)), uintptr(size), uintptr(position), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc removexattr(path string, attr string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fremovexattr(fd int, attr string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc listxattr(path string, dest *byte, size int, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(options), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc flistxattr(fd int, dest *byte, size int, options int) (sz int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_FLISTXATTR, uintptr(fd), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(options), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kill(pid int, signum int, posix int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -14593,24 +14593,15924 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exchangedata(path1 string, path2 string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path1)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(path2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := RawSyscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -30778,28 +30778,11634 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setprivexec(flag int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos))%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tp *Timeval) (sec int64, usec int32, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09sec = int64(r0)%0A%09usec = int32(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 44458b23de2b2ba870bbda4c8c64852732491ea51fb7609e65db43ae49f66896 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go
+ f e4732acb9e046bd90783b4eb505b92044174a2b1b14c307a49819b251717b60e vendor/golang.org/x/sys/unix/zsyscall_darwin_arm.go
dmppatch 15
@@ -200,16 +200,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -223,16 +223,14078 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getxattr(path string, attr string, dest *byte, size int, position uint32, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(position), uintptr(options))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fgetxattr(fd int, attr string, dest *byte, size int, position uint32, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(position), uintptr(options))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setxattr(path string, attr string, data *byte, size int, position uint32, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(data)), uintptr(size), uintptr(position), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fsetxattr(fd int, attr string, data *byte, size int, position uint32, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(data)), uintptr(size), uintptr(position), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc removexattr(path string, attr string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fremovexattr(fd int, attr string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc listxattr(path string, dest *byte, size int, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(options), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc flistxattr(fd int, dest *byte, size int, options int) (sz int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_FLISTXATTR, uintptr(fd), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(options), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kill(pid int, signum int, posix int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -14592,24 +14592,15978 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exchangedata(path1 string, path2 string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path1)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(path2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := RawSyscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -30831,28 +30831,11728 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0, 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setprivexec(flag int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos), uintptr(pos%3E%3E32), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tp *Timeval) (sec int32, usec int32, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09sec = int32(r0)%0A%09usec = int32(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 11109b3f6cfd1fb9682baaa416430d5569d36b5403d150c45882685eb4133667 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go
+ f d37a4f898685d442ab6a7c2c2a64211be39fb584eb548662e6503e276b2e0a27 vendor/golang.org/x/sys/unix/zsyscall_darwin_arm64.go
dmppatch 15
@@ -201,16 +201,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -224,16 +224,14078 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getxattr(path string, attr string, dest *byte, size int, position uint32, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(position), uintptr(options))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fgetxattr(fd int, attr string, dest *byte, size int, position uint32, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(position), uintptr(options))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setxattr(path string, attr string, data *byte, size int, position uint32, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(data)), uintptr(size), uintptr(position), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fsetxattr(fd int, attr string, data *byte, size int, position uint32, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(data)), uintptr(size), uintptr(position), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc removexattr(path string, attr string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fremovexattr(fd int, attr string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc listxattr(path string, dest *byte, size int, options int) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(options), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc flistxattr(fd int, dest *byte, size int, options int) (sz int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_FLISTXATTR, uintptr(fd), uintptr(unsafe.Pointer(dest)), uintptr(size), uintptr(options), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kill(pid int, signum int, posix int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), uintptr(posix))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -14593,24 +14593,15924 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exchangedata(path1 string, path2 string, options int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path1)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(path2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXCHANGEDATA, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(options))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES64, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := RawSyscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(dirfd int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -30778,28 +30778,11634 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setprivexec(flag int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIVEXEC, uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos))%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc gettimeofday(tp *Timeval) (sec int64, usec int32, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09sec = int64(r0)%0A%09usec = int32(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 2975d804f298a79b4286a73d018549173899282eaadca566c1c0fc6d7c82f85f vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go
+ f c2ef759d3dda120ddf3c75387aeb31d9f456d311da11bf76d8750f70863e3340 vendor/golang.org/x/sys/unix/zsyscall_dragonfly_amd64.go
dmppatch 15
@@ -224,16 +224,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -247,16 +247,11106 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (r int, w int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09r = int(r0)%0A%09w = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc extpread(fd int, p %5B%5Dbyte, flags int, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTPREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc extpwrite(fd int, p %5B%5Dbyte, flags int, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTPWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -11644,24 +11644,13317 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -25222,28 +25222,10601 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(whence), 0, 0)%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 1fe1910bcd94249af4168723c11b2b4a2169c086fa538664f3e5394d0d6242f1 vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go
+ f 42b1ca7a3598e9d247daa789678b1b81f3f94af23cc4f7e59cf130be740b0fde vendor/golang.org/x/sys/unix/zsyscall_freebsd_386.go
dmppatch 15
@@ -204,16 +204,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -228,16 +228,10249 @@
 afe%22%0A)%0A%0A
+var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // THIS 
@@ -10767,24 +10767,23598 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CapEnter() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_ENTER, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsGet(version int, fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS___CAP_RIGHTS_GET, uintptr(version), uintptr(fd), uintptr(unsafe.Pointer(rightsp)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsLimit(fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_RIGHTS_LIMIT, uintptr(fd), uintptr(unsafe.Pointer(rightsp)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_POSIX_FADVISE, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(fdat int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(fdat), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -34626,28 +34626,12507 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0, 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos), uintptr(pos%3E%3E32), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f df5571e681354b09efc43c96cd9fc9c972a4ea2ac6ff49e3e8b05b6f10b1818a vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go
+ f d3d90ef8fe21bb87e869651f857c6f1a52cdffb7e1355ff29395952b9177d3b6 vendor/golang.org/x/sys/unix/zsyscall_freebsd_amd64.go
dmppatch 15
@@ -205,16 +205,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -229,16 +229,10249 @@
 afe%22%0A)%0A%0A
+var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // THIS 
@@ -10768,24 +10768,23508 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CapEnter() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_ENTER, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsGet(version int, fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS___CAP_RIGHTS_GET, uintptr(version), uintptr(fd), uintptr(unsafe.Pointer(rightsp)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsLimit(fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_RIGHTS_LIMIT, uintptr(fd), uintptr(unsafe.Pointer(rightsp)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_POSIX_FADVISE, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(fdat int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(fdat), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -34537,28 +34537,12413 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos))%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f b47a12578b10e195f4afff48f59edea39d6abe4f4335ded6ed70176f60ae2370 vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go
+ f d0cce2f9581c947d66f81abc653ba4a8fe206013c5d4b05cbbc9722795070417 vendor/golang.org/x/sys/unix/zsyscall_freebsd_arm.go
dmppatch 15
@@ -209,16 +209,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -233,16 +233,10249 @@
 afe%22%0A)%0A%0A
+var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // THIS 
@@ -10772,24 +10772,23617 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CapEnter() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_ENTER, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsGet(version int, fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS___CAP_RIGHTS_GET, uintptr(version), uintptr(fd), uintptr(unsafe.Pointer(rightsp)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc capRightsLimit(fd int, rightsp *CapRights) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CAP_RIGHTS_LIMIT, uintptr(fd), uintptr(unsafe.Pointer(rightsp)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_POSIX_FADVISE, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdirentries(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETDIRENTRIES, uintptr(fd), uintptr(_p0), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdtablesize() (size int) %7B%0A%09r0, _, _ := Syscall(SYS_GETDTABLESIZE, 0, 0, 0)%0A%09size = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(pathfd int, path string, linkfd int, link string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(pathfd), uintptr(unsafe.Pointer(_p0)), uintptr(linkfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Openat(fdat int, path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(fdat), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -34650,28 +34650,12517 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(fromfd int, from string, tofd int, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(fromfd), uintptr(unsafe.Pointer(_p0)), uintptr(tofd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Undelete(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNDELETE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(fd int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 025b426d990ee31be6c2fa3acbea7eaba63936124ebd1acdb036bbdb656206ac vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
+ f f328c72b26b213b68c593471773eace1122e3d45c1d0f47cd2ab78b79400cd35 vendor/golang.org/x/sys/unix/zsyscall_linux_386.go
dmppatch 15
@@ -181,16 +181,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -204,16 +204,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -888,24 +888,26050 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off%3E%3E32), uintptr(len), uintptr(len%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27199,28 +27199,24306 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64_64, uintptr(fd), uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN32, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE64, uintptr(fd), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID32, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID32, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID32, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID32, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN32, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), uintptr(offset%3E%3E32), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID32, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID32, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID32, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID32, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(off%3E%3E32), uintptr(n), uintptr(n%3E%3E32), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), uintptr(length), uintptr(length%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f d245b40ce6ffe4284dbd6345df1a9d701e3497d75b179c6b00ed59c447352a52 vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
+ f cfd2405a4ac3438e4ff4683ca5db67cc8128319be43d51987f5de9dca7b0a993 vendor/golang.org/x/sys/unix/zsyscall_linux_amd64.go
dmppatch 15
@@ -182,16 +182,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -205,16 +205,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -889,24 +889,26020 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27170,28 +27170,28808 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 79cf37a2c6ce97df598a3fd127087ab25179ce5a063fe20426f05e3e0d119bad vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
+ f 53e3c9393c475f5cfbfe0e24d5dae3994dba747493a93c45b58ee10908d43e69 vendor/golang.org/x/sys/unix/zsyscall_linux_arm.go
dmppatch 15
@@ -186,16 +186,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -209,16 +209,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -893,24 +893,26050 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off%3E%3E32), uintptr(len), uintptr(len%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27204,28 +27204,27478 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS32, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, flags int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(flags), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN32, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID32, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID32, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID32, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID32, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN32, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID32, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID32, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID32, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID32, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID32, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID32, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE64, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UGETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 923337e072ff3c774fa9788b060528f05142a1a6177b4c6957ce161816a6c902 vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
+ f ce1b66edc0938d6831a4cc4b43e8303cc3ec933d5bc69092eade2c6b87f3e3f5 vendor/golang.org/x/sys/unix/zsyscall_linux_arm64.go
dmppatch 15
@@ -182,16 +182,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -205,16 +205,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -889,24 +889,26020 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27170,28 +27170,25202 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_PWAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 972747d9303a60f3c1767159dd71f229b9900c5b633fc4165871e52c185522d6 vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
+ f 6f253d13dce51f8fd704083b4ab41f968f64f2e260c86905494e212263a5b157 vendor/golang.org/x/sys/unix/zsyscall_linux_mips.go
dmppatch 15
@@ -190,16 +190,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -213,16 +213,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -897,24 +897,26050 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off%3E%3E32), uintptr(off), uintptr(len%3E%3E32), uintptr(len))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27208,28 +27208,29384 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(int64(r0)%3C%3C32 %7C int64(r1))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_FADVISE64, uintptr(fd), 0, uintptr(offset%3E%3E32), uintptr(offset), uintptr(length%3E%3E32), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE64, uintptr(fd), 0, uintptr(length%3E%3E32), uintptr(length), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset%3E%3E32), uintptr(offset))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset%3E%3E32), uintptr(offset))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_SYNC_FILE_RANGE, uintptr(fd), 0, uintptr(off%3E%3E32), uintptr(off), uintptr(n%3E%3E32), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length%3E%3E32), uintptr(length), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (p1 int, p2 int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09p1 = int(r0)%0A%09p2 = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 65c6bfab744c75c24168442766929c0a3fa5dfaf8e806ce0aa084cb48c973f40 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
+ f 1ac7f009232df71d7d0a7d073eb008a24089086f0a055a6af5638e087eb44800 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64.go
dmppatch 15
@@ -186,16 +186,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -209,16 +209,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -893,24 +893,26020 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27174,28 +27174,28485 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fstat(fd int, st *stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc lstat(path string, st *stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc stat(path string, st *stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 3686e926286f6112ef97073beb04f7411b513182cad44476dc12596af0e58671 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
+ f 9e20e28c3853a91a9349d122677413af93832c4db825e60abe557b1d7905e239 vendor/golang.org/x/sys/unix/zsyscall_linux_mips64le.go
dmppatch 15
@@ -190,16 +190,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -213,16 +213,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -897,24 +897,26020 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27178,28 +27178,28485 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fstat(fd int, st *stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc lstat(path string, st *stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc stat(path string, st *stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(st)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f a16c49ba7f8b304161b8f70f9890deb39e380c63262f16cb8758b343fb40af87 vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
+ f 7abd260831651bcca071ac7d57b2ac26eb9700d39eddd80af44a7c93b8e30abf vendor/golang.org/x/sys/unix/zsyscall_linux_mipsle.go
dmppatch 15
@@ -194,16 +194,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -217,16 +217,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -901,24 +901,26050 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(off%3E%3E32), uintptr(len), uintptr(len%3E%3E32))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27212,28 +27212,29384 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_FADVISE64, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(length), uintptr(length%3E%3E32), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE64, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE64, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_SYNC_FILE_RANGE, uintptr(fd), 0, uintptr(off), uintptr(off%3E%3E32), uintptr(n), uintptr(n%3E%3E32), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE64, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT64, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT64, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (p1 int, p2 int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09p1 = int(r0)%0A%09p2 = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap2(addr uintptr, length uintptr, prot int, flags int, fd int, pageOffset uintptr) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP2, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(pageOffset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setrlimit(resource int, rlim *rlimit32) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f cd8e1063cbaea7c6aabb370fbc5557de95455a892c3cc07d56d969c97de4c401 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
+ f a7ca78b3a3991b0ce0a08e53baa5c83c04187aa8102bac5580451b1d71d74a00 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64.go
dmppatch 15
@@ -183,16 +183,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -206,16 +206,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -890,24 +890,26020 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27171,28 +27171,30028 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UGETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc syncFileRange2(fd int, flags int, off int64, n int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE2, uintptr(fd), uintptr(flags), uintptr(off), uintptr(n), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 3a09924f89efa3845aab2896dcc8852c28497cf28d9e2df152aa2efa8f0e59d2 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
+ f 2a064a6d9981d040c3bef53cd01731e84c6a52722d94865bfb6b7f484b898118 vendor/golang.org/x/sys/unix/zsyscall_linux_ppc64le.go
dmppatch 15
@@ -187,16 +187,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -210,16 +210,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -894,24 +894,26020 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27175,28 +27175,30028 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UGETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ioperm(from int, num int, on int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPERM, uintptr(from), uintptr(num), uintptr(on))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Iopl(level int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOPL, uintptr(level), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS__NEWSELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Time(t *Time_t) (tt Time_t, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIME, uintptr(unsafe.Pointer(t)), 0, 0)%0A%09tt = Time_t(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc syncFileRange2(fd int, flags int, off int64, n int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE2, uintptr(fd), uintptr(flags), uintptr(off), uintptr(n), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+ f 04e4f6335e6bc8deb89f3de8bd7fe4074097a60c2a300a437f095dc0c2ad1472 vendor/golang.org/x/sys/unix/zsyscall_linux_riscv64.go
dmppatch 2
@@ -0,0 +1,52377 @@
+// mksyscall.pl -tags linux,riscv64 syscall_linux.go syscall_linux_riscv64.go%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build linux,riscv64%0A%0Apackage unix%0A%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ioctl(fd int, req uint, arg uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_IOCTL, uintptr(fd), uintptr(req), uintptr(arg))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc read(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_PWAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f b8b17c916cd0fa45074fb15fa1782b7c311c62f4388289f4dc0089dfa5d012a4 vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
+ f b08d1f9ad1251449ce11f8632eda7a0e683264c2f9e45ff2c047263824900552 vendor/golang.org/x/sys/unix/zsyscall_linux_s390x.go
dmppatch 15
@@ -182,16 +182,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -205,16 +205,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -889,24 +889,26020 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fgetxattr(fd int, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_FGETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flistxattr(fd int, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_FLISTXATTR, uintptr(fd), uintptr(_p0), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fremovexattr(fd int, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FREMOVEXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsetxattr(fd int, attr string, dest %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSETXATTR, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc MemfdCreate(name string, flags int) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_MEMFD_CREATE, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -27170,28 +27170,23671 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat2(olddirfd int, oldpath string, newdirfd int, newpath string, flags uint) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT2, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc faccessat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate(size int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_NEWFSTATAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_USTAT, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 7ba02566265b32b163069bb8ed12a0a4fc01bad118f8c59f2742cb3a39b87e08 vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go
+ f 7cb8f05b137108a519e7f9636c9f12ca69c272d30968b7daef564ba4e68d7d26 vendor/golang.org/x/sys/unix/zsyscall_linux_sparc64.go
dmppatch 15
@@ -188,16 +188,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -211,16 +211,393 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fchmodat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -895,24 +895,24279 @@
 O NOT EDIT%0A%0A
+func Linkat(olddirfd int, oldpath string, newdirfd int, newpath string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LINKAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_OPENAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ppoll(fds *PollFd, nfds int, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PPOLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlinkat(dirfd int, path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_READLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlinkat(oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINKAT, uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINKAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlInt(cmd int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc KeyctlBuffer(cmd int, arg2 int, buf %5B%5Dbyte, arg5 int) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(buf)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlJoin(cmd int, arg2 string) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg2)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlSearch(cmd int, arg2 int, arg3 string, arg4 string, arg5 int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg3)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(arg4)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(arg5), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlIOV(cmd int, arg2 int, payload %5B%5DIovec, arg5 int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(arg2), uintptr(_p0), uintptr(len(payload)), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc keyctlDH(cmd int, arg2 *KeyctlDHParams, buf %5B%5Dbyte) (ret int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_KEYCTL, uintptr(cmd), uintptr(unsafe.Pointer(arg2)), uintptr(_p0), uintptr(len(buf)), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ptrace(request int, pid int, addr uintptr, data uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PTRACE, uintptr(request), uintptr(pid), uintptr(addr), uintptr(data), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc reboot(magic1 uint, magic2 uint, cmd int, arg string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(arg)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_REBOOT, uintptr(magic1), uintptr(magic2), uintptr(cmd), uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mount(source string, target string, fstype string, flags uintptr, data *byte) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(source)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(fstype)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(flags), uintptr(unsafe.Pointer(data)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Acct(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc AddKey(keyType string, description string, payload %5B%5Dbyte, ringid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(payload) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&payload%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_ADD_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(payload)), uintptr(ringid), 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtimex(buf *Timex) (state int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ADJTIMEX, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09state = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ClockGettime(clockid int32, time *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOCK_GETTIME, uintptr(clockid), uintptr(unsafe.Pointer(time)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc CopyFileRange(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_COPY_FILE_RANGE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(oldfd int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(oldfd), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup3(oldfd int, newfd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP3, uintptr(oldfd), uintptr(newfd), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCreate1(flag int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE1, uintptr(flag), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_EPOLL_CTL, uintptr(epfd), uintptr(op), uintptr(fd), uintptr(unsafe.Pointer(event)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Eventfd(initval uint, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_EVENTFD2, uintptr(initval), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09SyscallNoError(SYS_EXIT_GROUP, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fallocate(fd int, mode uint32, off int64, len int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FALLOCATE, uintptr(fd), uintptr(mode), uintptr(off), uintptr(len), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHOWNAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FDATASYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS64, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrandom(buf %5B%5Dbyte, flags int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETRANDOM, uintptr(_p0), uintptr(len(buf)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettid() (tid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETTID, 0, 0, 0)%0A%09tid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(pathname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_INOTIFY_ADD_WATCH, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(mask))%0A%09watchdesc = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit1(flags int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT1, uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyRmWatch(fd int, watchdesc uint32) (success int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_RM_WATCH, uintptr(fd), uintptr(watchdesc), 0)%0A%09success = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_KILL, uintptr(pid), uintptr(sig), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Klogctl(typ int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_SYSLOG, uintptr(typ), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lgetxattr(path string, attr string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_LGETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(dest)), 0, 0)%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Llistxattr(path string, dest %5B%5Dbyte) (sz int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(dest) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&dest%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_LLISTXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(dest)))%0A%09sz = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lremovexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LREMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lsetxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_LSETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIRAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_MKNODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PerfEventOpen(attr *PerfEventAttr, pid int, cpu int, groupFd int, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PERF_EVENT_OPEN, uintptr(unsafe.Pointer(attr)), uintptr(pid), uintptr(cpu), uintptr(groupFd), uintptr(flags), 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc PivotRoot(newroot string, putold string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(newroot)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(putold)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_PIVOT_ROOT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc prlimit(pid int, resource int, newlimit *Rlimit, old *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_PRLIMIT64, uintptr(pid), uintptr(resource), uintptr(unsafe.Pointer(newlimit)), uintptr(unsafe.Pointer(old)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Prctl(option int, arg2 uintptr, arg3 uintptr, arg4 uintptr, arg5 uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_PRCTL, uintptr(option), uintptr(arg2), uintptr(arg3), uintptr(arg4), uintptr(arg5), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pselect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timespec, sigmask *Sigset_t) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_PSELECT6, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), uintptr(unsafe.Pointer(sigmask)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -25435,28 +25435,27947 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Removexattr(path string, attr string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REMOVEXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_RENAMEAT, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc RequestKey(keyType string, description string, callback string, destRingid int) (id int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(keyType)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(description)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 *byte%0A%09_p2, err = BytePtrFromString(callback)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_REQUEST_KEY, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(unsafe.Pointer(_p2)), uintptr(destRingid), 0, 0)%0A%09id = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setdomainname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETDOMAINNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETHOSTNAME, uintptr(_p0), uintptr(len(p)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setns(fd int, nstype int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETNS, uintptr(fd), uintptr(nstype), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setxattr(path string, attr string, data %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attr)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p2 unsafe.Pointer%0A%09if len(data) %3E 0 %7B%0A%09%09_p2 = unsafe.Pointer(&data%5B0%5D)%0A%09%7D else %7B%0A%09%09_p2 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(_p2), uintptr(len(data)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statx(dirfd int, path string, flags int, mask int, stat *Statx_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_STATX, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mask), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() %7B%0A%09SyscallNoError(SYS_SYNC, 0, 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Syncfs(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNCFS, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sysinfo(info *Sysinfo_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SYSINFO, uintptr(unsafe.Pointer(info)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tee(rfd int, wfd int, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_TEE, uintptr(rfd), uintptr(wfd), uintptr(len), uintptr(flags), 0, 0)%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Tgkill(tgid int, tid int, sig syscall.Signal) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_TGKILL, uintptr(tgid), uintptr(tid), uintptr(sig))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_TIMES, uintptr(unsafe.Pointer(tms)), 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_UMASK, uintptr(mask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_UNAME, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UMOUNT2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unshare(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_UNSHARE, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc exitThread(code int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, p *byte, np int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(np))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc EpollWait(epfd int, events %5B%5DEpollEvent, msec int) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(events) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&events%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EPOLL_WAIT, uintptr(epfd), uintptr(_p0), uintptr(len(events)), uintptr(msec), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FADVISE64, uintptr(fd), uintptr(offset), uintptr(length), uintptr(advice), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(oldfd), uintptr(newfd), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(dirfd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT64, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, buf *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETEUID, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _ := RawSyscallNoError(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc InotifyInit() (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_INOTIFY_INIT, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, n int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(n), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_PAUSE, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE64, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (off int64, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_LSEEK, uintptr(fd), uintptr(offset), uintptr(whence))%0A%09off = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SELECT, uintptr(nfd), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsgid(gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setfsuid(uid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETFSUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(resource int, rlim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(resource), uintptr(unsafe.Pointer(rlim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_SPLICE, uintptr(rfd), uintptr(unsafe.Pointer(roff)), uintptr(wfd), uintptr(unsafe.Pointer(woff)), uintptr(len), uintptr(flags))%0A%09n = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, buf *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc SyncFileRange(fd int, off int64, n int64, flags int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SYNC_FILE_RANGE, uintptr(fd), uintptr(off), uintptr(n), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(n int, list *_Gid_t) (nn int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09nn = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(n int, list *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(n), uintptr(unsafe.Pointer(list)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flags), uintptr(fd), uintptr(offset))%0A%09xaddr = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimesat(dirfd int, path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_FUTIMESAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe2(p *%5B2%5D_C_int, flags int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE2, uintptr(unsafe.Pointer(p)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 727081903aaf39796582c3b9144ea6644f505e5faa3e3f7c685da031dda4485c vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
+ f 238c59679f7cf7891a4248dda708b76b304d482695fc1476ccea11685de051d5 vendor/golang.org/x/sys/unix/zsyscall_netbsd_386.go
dmppatch 15
@@ -208,16 +208,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -232,16 +232,10620 @@
 afe%22%0A)%0A%0A
+var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (fd1 int, fd2 int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09fd1 = int(r0)%0A%09fd2 = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // THIS 
@@ -11142,24 +11142,19932 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_POSIX_FADVISE, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), 0, uintptr(length), uintptr(length%3E%3E32), uintptr(advice), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -31335,28 +31335,8849 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 55ca1d02b4ee2f83be1092e1f73ec48a660d31e9d3de258b47e15651f1f02ee4 vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
+ f 99b6fe9f854d7ca92a24d36e664e020dae66c01f119c2d00ae656f1d371173a4 vendor/golang.org/x/sys/unix/zsyscall_netbsd_amd64.go
dmppatch 15
@@ -209,16 +209,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -233,16 +233,10620 @@
 afe%22%0A)%0A%0A
+var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (fd1 int, fd2 int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09fd1 = int(r0)%0A%09fd2 = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // THIS 
@@ -11143,24 +11143,19823 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_POSIX_FADVISE, uintptr(fd), 0, uintptr(offset), 0, uintptr(length), uintptr(advice))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -31227,28 +31227,8764 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(whence), 0, 0)%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f baf6e6749c989d94c32558f3a80ac1b57eb9961a1a9091e876d06607b7a842cb vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
+ f 857f02dda10488bd61e4f452f50d287678397d0a3d91168372f513a22c38d635 vendor/golang.org/x/sys/unix/zsyscall_netbsd_arm.go
dmppatch 15
@@ -213,16 +213,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -237,16 +237,10620 @@
 afe%22%0A)%0A%0A
+var _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe() (fd1 int, fd2 int, err error) %7B%0A%09r0, r1, e1 := RawSyscall(SYS_PIPE, 0, 0, 0)%0A%09fd1 = int(r0)%0A%09fd2 = int(r1)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A
 // THIS 
@@ -11147,24 +11147,19932 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFd(fd int, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFd(fd int, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FD, uintptr(fd), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p0)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFd(fd int, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FD, uintptr(fd), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetFile(file string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteFile(file string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListFile(file string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(file)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_FILE, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrGetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_GET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrSetLink(link string, attrnamespace int, attrname string, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_SET_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)), uintptr(data), uintptr(nbytes), 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrDeleteLink(link string, attrnamespace int, attrname string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(attrname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_EXTATTR_DELETE_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(unsafe.Pointer(_p1)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc ExtattrListLink(link string, attrnamespace int, data uintptr, nbytes int) (ret int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_EXTATTR_LIST_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(attrnamespace), uintptr(data), uintptr(nbytes), 0, 0)%0A%09ret = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fadvise(fd int, offset int64, length int64, advice int) (err error) %7B%0A%09_, _, e1 := Syscall9(SYS_POSIX_FADVISE, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), 0, uintptr(length), uintptr(length%3E%3E32), uintptr(advice), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -31340,28 +31340,8849 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f a632d85c191eb9c3ceec9c2967109be923f90a34f8e9999d676be9f208dd730d vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
+ f b62c8fb76246bde6b933fd92bd204788033f9b1eaad70d512c70027f5168fd34 vendor/golang.org/x/sys/unix/zsyscall_openbsd_386.go
dmppatch 15
@@ -213,16 +213,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -236,16 +236,10607 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -11134,24 +11134,14191 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrtable() (rtable int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETRTABLE, 0, 0, 0)%0A%09rtable = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -25586,28 +25586,10237 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrtable(rtable int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRTABLE, uintptr(rtable), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 702be529b80843626bb06109794f247ef42c20e6848140e16612aa8d3fbe8cbf vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
+ f b8addcf2367814df1ae0de1317d1b21f6f9eb9d6a04b192587664c2f70ad587a vendor/golang.org/x/sys/unix/zsyscall_openbsd_amd64.go
dmppatch 15
@@ -214,16 +214,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -237,16 +237,10607 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -11135,24 +11135,14127 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrtable() (rtable int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETRTABLE, 0, 0, 0)%0A%09rtable = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -25523,28 +25523,10152 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(whence), 0, 0)%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrtable(rtable int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRTABLE, uintptr(rtable), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), 0, 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f 0a4f30b46fcfd8568bce890589c45fe6c2a14d90712c161ab7b51c989f27fcd8 vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
+ f d6408a91955376df77996486b3f8d2a81bcb480fd1d56824ae35a2412f7f9c3c vendor/golang.org/x/sys/unix/zsyscall_openbsd_arm.go
dmppatch 15
@@ -218,16 +218,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -241,16 +241,10607 @@
 safe%22%0A)%0A
+%0Avar _ syscall.Errno%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGROUPS, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_ACCEPT, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_BIND, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETSOCKNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SHUTDOWN, uintptr(s), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := RawSyscall6(SYS_SOCKETPAIR, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_RECVFROM, uintptr(fd), uintptr(_p0), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_SENDTO, uintptr(s), uintptr(_p0), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_RECVMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_SENDMSG, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc kevent(kq int, change unsafe.Pointer, nchange int, event unsafe.Pointer, nevent int, timeout *Timespec) (n int, err error) %7B%0A%09r0, _, e1 := Syscall6(SYS_KEVENT, uintptr(kq), uintptr(change), uintptr(nchange), uintptr(event), uintptr(nevent), uintptr(unsafe.Pointer(timeout)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc sysctl(mib %5B%5D_C_int, old *byte, oldlen *uintptr, new *byte, newlen uintptr) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(mib) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&mib%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS___SYSCTL, uintptr(_p0), uintptr(len(mib)), uintptr(unsafe.Pointer(old)), uintptr(unsafe.Pointer(oldlen)), uintptr(unsafe.Pointer(new)), uintptr(newlen))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimes(path string, timeval *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UTIMES, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc futimes(fd int, timeval *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FUTIMES, uintptr(fd), uintptr(unsafe.Pointer(timeval)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_POLL, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Madvise(b %5B%5Dbyte, behav int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(behav))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MLOCKALL, uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MPROTECT, uintptr(_p0), uintptr(len(b)), uintptr(prot))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MSYNC, uintptr(_p0), uintptr(len(b)), uintptr(flags))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&b%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MUNLOCK, uintptr(_p0), uintptr(len(b)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNLOCKALL, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc pipe(p *%5B2%5D_C_int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_PIPE, uintptr(unsafe.Pointer(p)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc getdents(fd int, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_GETDENTS, uintptr(fd), uintptr(_p0), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS___GETCWD, uintptr(_p0), uintptr(len(buf)), 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
 %0A// THIS
@@ -11139,24 +11139,14191 @@
 O NOT EDIT%0A%0A
+func Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_ACCESS, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_ADJTIME, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chflags(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHFLAGS, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHMOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_CHROOT, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_DUP, uintptr(fd), 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Dup2(from int, to int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_DUP2, uintptr(from), uintptr(to), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Exit(code int) %7B%0A%09Syscall(SYS_EXIT, uintptr(code), 0, 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FACCESSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHDIR, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchflags(fd int, flags int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHFLAGS, uintptr(fd), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHMOD, uintptr(fd), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FCHMODAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FCHOWN, uintptr(fd), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FLOCK, uintptr(fd), uintptr(how), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_FPATHCONF, uintptr(fd), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTAT, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_FSTATAT, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fstatfs(fd int, stat *Statfs_t) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSTATFS, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_FSYNC, uintptr(fd), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_FTRUNCATE, uintptr(fd), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEGID, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Geteuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETEUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETGID, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETPGID, uintptr(pid), 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpgrp() (pgrp int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPGRP, 0, 0, 0)%0A%09pgrp = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPID, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETPPID, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getpriority(which int, who int) (prio int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_GETPRIORITY, uintptr(which), uintptr(who), 0)%0A%09prio = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrtable() (rtable int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETRTABLE, 0, 0, 0)%0A%09rtable = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETRUSAGE, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getsid(pid int) (sid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_GETSID, uintptr(pid), 0, 0)%0A%09sid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_GETTIMEOFDAY, uintptr(unsafe.Pointer(tv)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := RawSyscall(SYS_GETUID, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Issetugid() (tainted bool) %7B%0A%09r0, _, _ := Syscall(SYS_ISSETUGID, 0, 0, 0)%0A%09tainted = bool(r0 != 0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_KILL, uintptr(pid), uintptr(signum), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Kqueue() (fd int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_KQUEUE, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LCHOWN, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_LISTEN, uintptr(s), uintptr(backlog), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_LSTAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKDIR, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKFIFO, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_MKNOD, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_NANOSLEEP, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_OPEN, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_PATHCONF, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PREAD, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall6(SYS_PWRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)), 0, uintptr(offset), uintptr(offset%3E%3E32))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0A
 func read(fd
@@ -25591,28 +25591,10237 @@
 = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
+%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 unsafe.Pointer%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = unsafe.Pointer(&buf%5B0%5D)%0A%09%7D else %7B%0A%09%09_p1 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_READLINK, uintptr(unsafe.Pointer(_p0)), uintptr(_p1), uintptr(len(buf)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RENAME, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Revoke(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_REVOKE, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_RMDIR, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, r1, e1 := Syscall6(SYS_LSEEK, uintptr(fd), 0, uintptr(offset), uintptr(offset%3E%3E32), uintptr(whence), 0)%0A%09newoffset = int64(int64(r1)%3C%3C32 %7C int64(r0))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := Syscall6(SYS_SELECT, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEGID, uintptr(egid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETEUID, uintptr(euid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETGID, uintptr(gid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setlogin(name string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SETLOGIN, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETPGID, uintptr(pid), uintptr(pgid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SETPRIORITY, uintptr(which), uintptr(who), uintptr(prio))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREGID, uintptr(rgid), uintptr(egid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETREUID, uintptr(ruid), uintptr(euid), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresgid(rgid int, egid int, sgid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESGID, uintptr(rgid), uintptr(egid), uintptr(sgid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setresuid(ruid int, euid int, suid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRESUID, uintptr(ruid), uintptr(euid), uintptr(suid))%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRLIMIT, uintptr(which), uintptr(unsafe.Pointer(lim)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setrtable(rtable int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETRTABLE, uintptr(rtable), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := RawSyscall(SYS_SETSID, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Settimeofday(tp *Timeval) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETTIMEOFDAY, uintptr(unsafe.Pointer(tp)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := RawSyscall(SYS_SETUID, uintptr(uid), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STAT, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Statfs(path string, stat *Statfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_STATFS, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_SYMLINK, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := Syscall(SYS_SYNC, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_TRUNCATE, uintptr(unsafe.Pointer(_p0)), 0, uintptr(length), uintptr(length%3E%3E32), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Umask(newmask int) (oldmask int) %7B%0A%09r0, _, _ := Syscall(SYS_UMASK, uintptr(newmask), 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNLINK, uintptr(unsafe.Pointer(_p0)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc Unmount(path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall(SYS_UNMOUNT, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 unsafe.Pointer%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = unsafe.Pointer(&p%5B0%5D)%0A%09%7D else %7B%0A%09%09_p0 = unsafe.Pointer(&_zero)%0A%09%7D%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := Syscall9(SYS_MMAP, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), 0, uintptr(pos), uintptr(pos%3E%3E32), 0)%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := Syscall(SYS_MUNMAP, uintptr(addr), uintptr(length), 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc readlen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc writelen(fd int, buf *byte, nbuf int) (n int, err error) %7B%0A%09r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(unsafe.Pointer(buf)), uintptr(nbuf))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A%0A// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT%0A%0Afunc utimensat(dirfd int, path string, times *%5B2%5DTimespec, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := Syscall6(SYS_UTIMENSAT, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = errnoErr(e1)%0A%09%7D%0A%09return%0A%7D%0A
- f a0f5c487af0568f4a945d8d5f4ed2de35045e8ce5499a9d6854a918547a1aa68 vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go
+ f 11135d0769c1aa887e90b35d847f8a0d21b56cfe3b1d17d01b035851b514e399 vendor/golang.org/x/sys/unix/zsyscall_solaris_amd64.go
dmppatch 15
@@ -198,16 +198,27 @@
 mport (%0A
+%09%22syscall%22%0A
 %09%22unsafe
@@ -222,16 +222,18664 @@
 afe%22%0A)%0A%0A
+//go:cgo_import_dynamic libc_pipe pipe %22libc.so%22%0A//go:cgo_import_dynamic libc_getsockname getsockname %22libsocket.so%22%0A//go:cgo_import_dynamic libc_getcwd getcwd %22libc.so%22%0A//go:cgo_import_dynamic libc_getgroups getgroups %22libc.so%22%0A//go:cgo_import_dynamic libc_setgroups setgroups %22libc.so%22%0A//go:cgo_import_dynamic libc_wait4 wait4 %22libc.so%22%0A//go:cgo_import_dynamic libc_gethostname gethostname %22libc.so%22%0A//go:cgo_import_dynamic libc_utimes utimes %22libc.so%22%0A//go:cgo_import_dynamic libc_utimensat utimensat %22libc.so%22%0A//go:cgo_import_dynamic libc_fcntl fcntl %22libc.so%22%0A//go:cgo_import_dynamic libc_futimesat futimesat %22libc.so%22%0A//go:cgo_import_dynamic libc_accept accept %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_recvmsg __xnet_recvmsg %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_sendmsg __xnet_sendmsg %22libsocket.so%22%0A//go:cgo_import_dynamic libc_acct acct %22libc.so%22%0A//go:cgo_import_dynamic libc___makedev __makedev %22libc.so%22%0A//go:cgo_import_dynamic libc___major __major %22libc.so%22%0A//go:cgo_import_dynamic libc___minor __minor %22libc.so%22%0A//go:cgo_import_dynamic libc_ioctl ioctl %22libc.so%22%0A//go:cgo_import_dynamic libc_poll poll %22libc.so%22%0A//go:cgo_import_dynamic libc_access access %22libc.so%22%0A//go:cgo_import_dynamic libc_adjtime adjtime %22libc.so%22%0A//go:cgo_import_dynamic libc_chdir chdir %22libc.so%22%0A//go:cgo_import_dynamic libc_chmod chmod %22libc.so%22%0A//go:cgo_import_dynamic libc_chown chown %22libc.so%22%0A//go:cgo_import_dynamic libc_chroot chroot %22libc.so%22%0A//go:cgo_import_dynamic libc_close close %22libc.so%22%0A//go:cgo_import_dynamic libc_creat creat %22libc.so%22%0A//go:cgo_import_dynamic libc_dup dup %22libc.so%22%0A//go:cgo_import_dynamic libc_dup2 dup2 %22libc.so%22%0A//go:cgo_import_dynamic libc_exit exit %22libc.so%22%0A//go:cgo_import_dynamic libc_faccessat faccessat %22libc.so%22%0A//go:cgo_import_dynamic libc_fchdir fchdir %22libc.so%22%0A//go:cgo_import_dynamic libc_fchmod fchmod %22libc.so%22%0A//go:cgo_import_dynamic libc_fchmodat fchmodat %22libc.so%22%0A//go:cgo_import_dynamic libc_fchown fchown %22libc.so%22%0A//go:cgo_import_dynamic libc_fchownat fchownat %22libc.so%22%0A//go:cgo_import_dynamic libc_fdatasync fdatasync %22libc.so%22%0A//go:cgo_import_dynamic libc_flock flock %22libc.so%22%0A//go:cgo_import_dynamic libc_fpathconf fpathconf %22libc.so%22%0A//go:cgo_import_dynamic libc_fstat fstat %22libc.so%22%0A//go:cgo_import_dynamic libc_fstatat fstatat %22libc.so%22%0A//go:cgo_import_dynamic libc_fstatvfs fstatvfs %22libc.so%22%0A//go:cgo_import_dynamic libc_getdents getdents %22libc.so%22%0A//go:cgo_import_dynamic libc_getgid getgid %22libc.so%22%0A//go:cgo_import_dynamic libc_getpid getpid %22libc.so%22%0A//go:cgo_import_dynamic libc_getpgid getpgid %22libc.so%22%0A//go:cgo_import_dynamic libc_getpgrp getpgrp %22libc.so%22%0A//go:cgo_import_dynamic libc_geteuid geteuid %22libc.so%22%0A//go:cgo_import_dynamic libc_getegid getegid %22libc.so%22%0A//go:cgo_import_dynamic libc_getppid getppid %22libc.so%22%0A//go:cgo_import_dynamic libc_getpriority getpriority %22libc.so%22%0A//go:cgo_import_dynamic libc_getrlimit getrlimit %22libc.so%22%0A//go:cgo_import_dynamic libc_getrusage getrusage %22libc.so%22%0A//go:cgo_import_dynamic libc_gettimeofday gettimeofday %22libc.so%22%0A//go:cgo_import_dynamic libc_getuid getuid %22libc.so%22%0A//go:cgo_import_dynamic libc_kill kill %22libc.so%22%0A//go:cgo_import_dynamic libc_lchown lchown %22libc.so%22%0A//go:cgo_import_dynamic libc_link link %22libc.so%22%0A//go:cgo_import_dynamic libc___xnet_llisten __xnet_llisten %22libsocket.so%22%0A//go:cgo_import_dynamic libc_lstat lstat %22libc.so%22%0A//go:cgo_import_dynamic libc_madvise madvise %22libc.so%22%0A//go:cgo_import_dynamic libc_mkdir mkdir %22libc.so%22%0A//go:cgo_import_dynamic libc_mkdirat mkdirat %22libc.so%22%0A//go:cgo_import_dynamic libc_mkfifo mkfifo %22libc.so%22%0A//go:cgo_import_dynamic libc_mkfifoat mkfifoat %22libc.so%22%0A//go:cgo_import_dynamic libc_mknod mknod %22libc.so%22%0A//go:cgo_import_dynamic libc_mknodat mknodat %22libc.so%22%0A//go:cgo_import_dynamic libc_mlock mlock %22libc.so%22%0A//go:cgo_import_dynamic libc_mlockall mlockall %22libc.so%22%0A//go:cgo_import_dynamic libc_mprotect mprotect %22libc.so%22%0A//go:cgo_import_dynamic libc_msync msync %22libc.so%22%0A//go:cgo_import_dynamic libc_munlock munlock %22libc.so%22%0A//go:cgo_import_dynamic libc_munlockall munlockall %22libc.so%22%0A//go:cgo_import_dynamic libc_nanosleep nanosleep %22libc.so%22%0A//go:cgo_import_dynamic libc_open open %22libc.so%22%0A//go:cgo_import_dynamic libc_openat openat %22libc.so%22%0A//go:cgo_import_dynamic libc_pathconf pathconf %22libc.so%22%0A//go:cgo_import_dynamic libc_pause pause %22libc.so%22%0A//go:cgo_import_dynamic libc_pread pread %22libc.so%22%0A//go:cgo_import_dynamic libc_pwrite pwrite %22libc.so%22%0A//go:cgo_import_dynamic libc_read read %22libc.so%22%0A//go:cgo_import_dynamic libc_readlink readlink %22libc.so%22%0A//go:cgo_import_dynamic libc_rename rename %22libc.so%22%0A//go:cgo_import_dynamic libc_renameat renameat %22libc.so%22%0A//go:cgo_import_dynamic libc_rmdir rmdir %22libc.so%22%0A//go:cgo_import_dynamic libc_lseek lseek %22libc.so%22%0A//go:cgo_import_dynamic libc_select select %22libc.so%22%0A//go:cgo_import_dynamic libc_setegid setegid %22libc.so%22%0A//go:cgo_import_dynamic libc_seteuid seteuid %22libc.so%22%0A//go:cgo_import_dynamic libc_setgid setgid %22libc.so%22%0A//go:cgo_import_dynamic libc_sethostname sethostname %22libc.so%22%0A//go:cgo_import_dynamic libc_setpgid setpgid %22libc.so%22%0A//go:cgo_import_dynamic libc_setpriority setpriority %22libc.so%22%0A//go:cgo_import_dynamic libc_setregid setregid %22libc.so%22%0A//go:cgo_import_dynamic libc_setreuid setreuid %22libc.so%22%0A//go:cgo_import_dynamic libc_setrlimit setrlimit %22libc.so%22%0A//go:cgo_import_dynamic libc_setsid setsid %22libc.so%22%0A//go:cgo_import_dynamic libc_setuid setuid %22libc.so%22%0A//go:cgo_import_dynamic libc_shutdown shutdown %22libsocket.so%22%0A//go:cgo_import_dynamic libc_stat stat %22libc.so%22%0A//go:cgo_import_dynamic libc_statvfs statvfs %22libc.so%22%0A//go:cgo_import_dynamic libc_symlink symlink %22libc.so%22%0A//go:cgo_import_dynamic libc_sync sync %22libc.so%22%0A//go:cgo_import_dynamic libc_times times %22libc.so%22%0A//go:cgo_import_dynamic libc_truncate truncate %22libc.so%22%0A//go:cgo_import_dynamic libc_fsync fsync %22libc.so%22%0A//go:cgo_import_dynamic libc_ftruncate ftruncate %22libc.so%22%0A//go:cgo_import_dynamic libc_umask umask %22libc.so%22%0A//go:cgo_import_dynamic libc_uname uname %22libc.so%22%0A//go:cgo_import_dynamic libc_umount umount %22libc.so%22%0A//go:cgo_import_dynamic libc_unlink unlink %22libc.so%22%0A//go:cgo_import_dynamic libc_unlinkat unlinkat %22libc.so%22%0A//go:cgo_import_dynamic libc_ustat ustat %22libc.so%22%0A//go:cgo_import_dynamic libc_utime utime %22libc.so%22%0A//go:cgo_import_dynamic libc___xnet_bind __xnet_bind %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_connect __xnet_connect %22libsocket.so%22%0A//go:cgo_import_dynamic libc_mmap mmap %22libc.so%22%0A//go:cgo_import_dynamic libc_munmap munmap %22libc.so%22%0A//go:cgo_import_dynamic libc_sendfile sendfile %22libsendfile.so%22%0A//go:cgo_import_dynamic libc___xnet_sendto __xnet_sendto %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_socket __xnet_socket %22libsocket.so%22%0A//go:cgo_import_dynamic libc___xnet_socketpair __xnet_socketpair %22libsocket.so%22%0A//go:cgo_import_dynamic libc_write write %22libc.so%22%0A//go:cgo_import_dynamic libc___xnet_getsockopt __xnet_getsockopt %22libsocket.so%22%0A//go:cgo_import_dynamic libc_getpeername getpeername %22libsocket.so%22%0A//go:cgo_import_dynamic libc_setsockopt setsockopt %22libsocket.so%22%0A//go:cgo_import_dynamic libc_recvfrom recvfrom %22libsocket.so%22%0A%0A//go:linkname procpipe libc_pipe%0A//go:linkname procgetsockname libc_getsockname%0A//go:linkname procGetcwd libc_getcwd%0A//go:linkname procgetgroups libc_getgroups%0A//go:linkname procsetgroups libc_setgroups%0A//go:linkname procwait4 libc_wait4%0A//go:linkname procgethostname libc_gethostname%0A//go:linkname procutimes libc_utimes%0A//go:linkname procutimensat libc_utimensat%0A//go:linkname procfcntl libc_fcntl%0A//go:linkname procfutimesat libc_futimesat%0A//go:linkname procaccept libc_accept%0A//go:linkname proc__xnet_recvmsg libc___xnet_recvmsg%0A//go:linkname proc__xnet_sendmsg libc___xnet_sendmsg%0A//go:linkname procacct libc_acct%0A//go:linkname proc__makedev libc___makedev%0A//go:linkname proc__major libc___major%0A//go:linkname proc__minor libc___minor%0A//go:linkname procioctl libc_ioctl%0A//go:linkname procpoll libc_poll%0A//go:linkname procAccess libc_access%0A//go:linkname procAdjtime libc_adjtime%0A//go:linkname procChdir libc_chdir%0A//go:linkname procChmod libc_chmod%0A//go:linkname procChown libc_chown%0A//go:linkname procChroot libc_chroot%0A//go:linkname procClose libc_close%0A//go:linkname procCreat libc_creat%0A//go:linkname procDup libc_dup%0A//go:linkname procDup2 libc_dup2%0A//go:linkname procExit libc_exit%0A//go:linkname procFaccessat libc_faccessat%0A//go:linkname procFchdir libc_fchdir%0A//go:linkname procFchmod libc_fchmod%0A//go:linkname procFchmodat libc_fchmodat%0A//go:linkname procFchown libc_fchown%0A//go:linkname procFchownat libc_fchownat%0A//go:linkname procFdatasync libc_fdatasync%0A//go:linkname procFlock libc_flock%0A//go:linkname procFpathconf libc_fpathconf%0A//go:linkname procFstat libc_fstat%0A//go:linkname procFstatat libc_fstatat%0A//go:linkname procFstatvfs libc_fstatvfs%0A//go:linkname procGetdents libc_getdents%0A//go:linkname procGetgid libc_getgid%0A//go:linkname procGetpid libc_getpid%0A//go:linkname procGetpgid libc_getpgid%0A//go:linkname procGetpgrp libc_getpgrp%0A//go:linkname procGeteuid libc_geteuid%0A//go:linkname procGetegid libc_getegid%0A//go:linkname procGetppid libc_getppid%0A//go:linkname procGetpriority libc_getpriority%0A//go:linkname procGetrlimit libc_getrlimit%0A//go:linkname procGetrusage libc_getrusage%0A//go:linkname procGettimeofday libc_gettimeofday%0A//go:linkname procGetuid libc_getuid%0A//go:linkname procKill libc_kill%0A//go:linkname procLchown libc_lchown%0A//go:linkname procLink libc_link%0A//go:linkname proc__xnet_llisten libc___xnet_llisten%0A//go:linkname procLstat libc_lstat%0A//go:linkname procMadvise libc_madvise%0A//go:linkname procMkdir libc_mkdir%0A//go:linkname procMkdirat libc_mkdirat%0A//go:linkname procMkfifo libc_mkfifo%0A//go:linkname procMkfifoat libc_mkfifoat%0A//go:linkname procMknod libc_mknod%0A//go:linkname procMknodat libc_mknodat%0A//go:linkname procMlock libc_mlock%0A//go:linkname procMlockall libc_mlockall%0A//go:linkname procMprotect libc_mprotect%0A//go:linkname procMsync libc_msync%0A//go:linkname procMunlock libc_munlock%0A//go:linkname procMunlockall libc_munlockall%0A//go:linkname procNanosleep libc_nanosleep%0A//go:linkname procOpen libc_open%0A//go:linkname procOpenat libc_openat%0A//go:linkname procPathconf libc_pathconf%0A//go:linkname procPause libc_pause%0A//go:linkname procPread libc_pread%0A//go:linkname procPwrite libc_pwrite%0A//go:linkname procread libc_read%0A//go:linkname procReadlink libc_readlink%0A//go:linkname procRename libc_rename%0A//go:linkname procRenameat libc_renameat%0A//go:linkname procRmdir libc_rmdir%0A//go:linkname proclseek libc_lseek%0A//go:linkname procSelect libc_select%0A//go:linkname procSetegid libc_setegid%0A//go:linkname procSeteuid libc_seteuid%0A//go:linkname procSetgid libc_setgid%0A//go:linkname procSethostname libc_sethostname%0A//go:linkname procSetpgid libc_setpgid%0A//go:linkname procSetpriority libc_setpriority%0A//go:linkname procSetregid libc_setregid%0A//go:linkname procSetreuid libc_setreuid%0A//go:linkname procSetrlimit libc_setrlimit%0A//go:linkname procSetsid libc_setsid%0A//go:linkname procSetuid libc_setuid%0A//go:linkname procshutdown libc_shutdown%0A//go:linkname procStat libc_stat%0A//go:linkname procStatvfs libc_statvfs%0A//go:linkname procSymlink libc_symlink%0A//go:linkname procSync libc_sync%0A//go:linkname procTimes libc_times%0A//go:linkname procTruncate libc_truncate%0A//go:linkname procFsync libc_fsync%0A//go:linkname procFtruncate libc_ftruncate%0A//go:linkname procUmask libc_umask%0A//go:linkname procUname libc_uname%0A//go:linkname procumount libc_umount%0A//go:linkname procUnlink libc_unlink%0A//go:linkname procUnlinkat libc_unlinkat%0A//go:linkname procUstat libc_ustat%0A//go:linkname procUtime libc_utime%0A//go:linkname proc__xnet_bind libc___xnet_bind%0A//go:linkname proc__xnet_connect libc___xnet_connect%0A//go:linkname procmmap libc_mmap%0A//go:linkname procmunmap libc_munmap%0A//go:linkname procsendfile libc_sendfile%0A//go:linkname proc__xnet_sendto libc___xnet_sendto%0A//go:linkname proc__xnet_socket libc___xnet_socket%0A//go:linkname proc__xnet_socketpair libc___xnet_socketpair%0A//go:linkname procwrite libc_write%0A//go:linkname proc__xnet_getsockopt libc___xnet_getsockopt%0A//go:linkname procgetpeername libc_getpeername%0A//go:linkname procsetsockopt libc_setsockopt%0A//go:linkname procrecvfrom libc_recvfrom%0A%0Avar (%0A%09procpipe,%0A%09procgetsockname,%0A%09procGetcwd,%0A%09procgetgroups,%0A%09procsetgroups,%0A%09procwait4,%0A%09procgethostname,%0A%09procutimes,%0A%09procutimensat,%0A%09procfcntl,%0A%09procfutimesat,%0A%09procaccept,%0A%09proc__xnet_recvmsg,%0A%09proc__xnet_sendmsg,%0A%09procacct,%0A%09proc__makedev,%0A%09proc__major,%0A%09proc__minor,%0A%09procioctl,%0A%09procpoll,%0A%09procAccess,%0A%09procAdjtime,%0A%09procChdir,%0A%09procChmod,%0A%09procChown,%0A%09procChroot,%0A%09procClose,%0A%09procCreat,%0A%09procDup,%0A%09procDup2,%0A%09procExit,%0A%09procFaccessat,%0A%09procFchdir,%0A%09procFchmod,%0A%09procFchmodat,%0A%09procFchown,%0A%09procFchownat,%0A%09procFdatasync,%0A%09procFlock,%0A%09procFpathconf,%0A%09procFstat,%0A%09procFstatat,%0A%09procFstatvfs,%0A%09procGetdents,%0A%09procGetgid,%0A%09procGetpid,%0A%09procGetpgid,%0A%09procGetpgrp,%0A%09procGeteuid,%0A%09procGetegid,%0A%09procGetppid,%0A%09procGetpriority,%0A%09procGetrlimit,%0A%09procGetrusage,%0A%09procGettimeofday,%0A%09procGetuid,%0A%09procKill,%0A%09procLchown,%0A%09procLink,%0A%09proc__xnet_llisten,%0A%09procLstat,%0A%09procMadvise,%0A%09procMkdir,%0A%09procMkdirat,%0A%09procMkfifo,%0A%09procMkfifoat,%0A%09procMknod,%0A%09procMknodat,%0A%09procMlock,%0A%09procMlockall,%0A%09procMprotect,%0A%09procMsync,%0A%09procMunlock,%0A%09procMunlockall,%0A%09procNanosleep,%0A%09procOpen,%0A%09procOpenat,%0A%09procPathconf,%0A%09procPause,%0A%09procPread,%0A%09procPwrite,%0A%09procread,%0A%09procReadlink,%0A%09procRename,%0A%09procRenameat,%0A%09procRmdir,%0A%09proclseek,%0A%09procSelect,%0A%09procSetegid,%0A%09procSeteuid,%0A%09procSetgid,%0A%09procSethostname,%0A%09procSetpgid,%0A%09procSetpriority,%0A%09procSetregid,%0A%09procSetreuid,%0A%09procSetrlimit,%0A%09procSetsid,%0A%09procSetuid,%0A%09procshutdown,%0A%09procStat,%0A%09procStatvfs,%0A%09procSymlink,%0A%09procSync,%0A%09procTimes,%0A%09procTruncate,%0A%09procFsync,%0A%09procFtruncate,%0A%09procUmask,%0A%09procUname,%0A%09procumount,%0A%09procUnlink,%0A%09procUnlinkat,%0A%09procUstat,%0A%09procUtime,%0A%09proc__xnet_bind,%0A%09proc__xnet_connect,%0A%09procmmap,%0A%09procmunmap,%0A%09procsendfile,%0A%09proc__xnet_sendto,%0A%09proc__xnet_socket,%0A%09proc__xnet_socketpair,%0A%09procwrite,%0A%09proc__xnet_getsockopt,%0A%09procgetpeername,%0A%09procsetsockopt,%0A%09procrecvfrom syscallFunc%0A)%0A%0Afunc pipe(p *%5B2%5D_C_int) (n int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procpipe)), 1, uintptr(unsafe.Pointer(p)), 0, 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockname(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procgetsockname)), 3, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getcwd(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procGetcwd)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getgroups(ngid int, gid *_Gid_t) (n int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procgetgroups)), 2, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setgroups(ngid int, gid *_Gid_t) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procsetgroups)), 2, uintptr(ngid), uintptr(unsafe.Pointer(gid)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc wait4(pid int32, statusp *_C_int, options int, rusage *Rusage) (wpid int32, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procwait4)), 4, uintptr(pid), uintptr(unsafe.Pointer(statusp)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)%0A%09wpid = int32(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc gethostname(buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procgethostname)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc utimes(path string, times *%5B2%5DTimeval) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procutimes)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc utimensat(fd int, path string, times *%5B2%5DTimespec, flag int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procutimensat)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(times)), uintptr(flag), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc fcntl(fd int, cmd int, arg int) (val int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procfcntl)), 3, uintptr(fd), uintptr(cmd), uintptr(arg), 0, 0, 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc futimesat(fildes int, path *byte, times *%5B2%5DTimeval) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procfutimesat)), 3, uintptr(fildes), uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(times)), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc accept(s int, rsa *RawSockaddrAny, addrlen *_Socklen) (fd int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procaccept)), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc recvmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_recvmsg)), 3, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendmsg(s int, msg *Msghdr, flags int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_sendmsg)), 3, uintptr(s), uintptr(unsafe.Pointer(msg)), uintptr(flags), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc acct(path *byte) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procacct)), 1, uintptr(unsafe.Pointer(path)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc __makedev(version int, major uint, minor uint) (val uint64) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&proc__makedev)), 3, uintptr(version), uintptr(major), uintptr(minor), 0, 0, 0)%0A%09val = uint64(r0)%0A%09return%0A%7D%0A%0Afunc __major(version int, dev uint64) (val uint) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&proc__major)), 2, uintptr(version), uintptr(dev), 0, 0, 0, 0)%0A%09val = uint(r0)%0A%09return%0A%7D%0A%0Afunc __minor(version int, dev uint64) (val uint) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&proc__minor)), 2, uintptr(version), uintptr(dev), 0, 0, 0, 0)%0A%09val = uint(r0)%0A%09return%0A%7D%0A%0A
 func ioc
@@ -19075,24 +19075,15283 @@
 %0A%09return%0A%7D%0A%0A
+func poll(fds *PollFd, nfds int, timeout int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procpoll)), 3, uintptr(unsafe.Pointer(fds)), uintptr(nfds), uintptr(timeout), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Access(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procAccess)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Adjtime(delta *Timeval, olddelta *Timeval) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procAdjtime)), 2, uintptr(unsafe.Pointer(delta)), uintptr(unsafe.Pointer(olddelta)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Chdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procChdir)), 1, uintptr(unsafe.Pointer(_p0)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procChmod)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Chown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procChown)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Chroot(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procChroot)), 1, uintptr(unsafe.Pointer(_p0)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Close(fd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procClose)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Creat(path string, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procCreat)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Dup(fd int) (nfd int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procDup)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09nfd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Dup2(oldfd int, newfd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procDup2)), 2, uintptr(oldfd), uintptr(newfd), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Exit(code int) %7B%0A%09sysvicall6(uintptr(unsafe.Pointer(&procExit)), 1, uintptr(code), 0, 0, 0, 0, 0)%0A%09return%0A%7D%0A%0Afunc Faccessat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFaccessat)), 4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fchdir(fd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchdir)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fchmod(fd int, mode uint32) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchmod)), 2, uintptr(fd), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fchmodat(dirfd int, path string, mode uint32, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchmodat)), 4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fchown(fd int, uid int, gid int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchown)), 3, uintptr(fd), uintptr(uid), uintptr(gid), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fchownat(dirfd int, path string, uid int, gid int, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFchownat)), 5, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), uintptr(flags), 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fdatasync(fd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFdatasync)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Flock(fd int, how int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFlock)), 2, uintptr(fd), uintptr(how), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fpathconf(fd int, name int) (val int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFpathconf)), 2, uintptr(fd), uintptr(name), 0, 0, 0, 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fstat(fd int, stat *Stat_t) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFstat)), 2, uintptr(fd), uintptr(unsafe.Pointer(stat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fstatat(fd int, path string, stat *Stat_t, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFstatat)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), uintptr(flags), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fstatvfs(fd int, vfsstat *Statvfs_t) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFstatvfs)), 2, uintptr(fd), uintptr(unsafe.Pointer(vfsstat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getdents(fd int, buf %5B%5Dbyte, basep *uintptr) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procGetdents)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(basep)), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getgid() (gid int) %7B%0A%09r0, _, _ := rawSysvicall6(uintptr(unsafe.Pointer(&procGetgid)), 0, 0, 0, 0, 0, 0, 0)%0A%09gid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getpid() (pid int) %7B%0A%09r0, _, _ := rawSysvicall6(uintptr(unsafe.Pointer(&procGetpid)), 0, 0, 0, 0, 0, 0, 0)%0A%09pid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getpgid(pid int) (pgid int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGetpgid)), 1, uintptr(pid), 0, 0, 0, 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getpgrp() (pgid int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGetpgrp)), 0, 0, 0, 0, 0, 0, 0)%0A%09pgid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Geteuid() (euid int) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&procGeteuid)), 0, 0, 0, 0, 0, 0, 0)%0A%09euid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getegid() (egid int) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&procGetegid)), 0, 0, 0, 0, 0, 0, 0)%0A%09egid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getppid() (ppid int) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&procGetppid)), 0, 0, 0, 0, 0, 0, 0)%0A%09ppid = int(r0)%0A%09return%0A%7D%0A%0Afunc Getpriority(which int, who int) (n int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procGetpriority)), 2, uintptr(which), uintptr(who), 0, 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGetrlimit)), 2, uintptr(which), uintptr(unsafe.Pointer(lim)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getrusage(who int, rusage *Rusage) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGetrusage)), 2, uintptr(who), uintptr(unsafe.Pointer(rusage)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procGettimeofday)), 1, uintptr(unsafe.Pointer(tv)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getuid() (uid int) %7B%0A%09r0, _, _ := rawSysvicall6(uintptr(unsafe.Pointer(&procGetuid)), 0, 0, 0, 0, 0, 0, 0)%0A%09uid = int(r0)%0A%09return%0A%7D%0A%0Afunc Kill(pid int, signum syscall.Signal) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procKill)), 2, uintptr(pid), uintptr(signum), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Lchown(path string, uid int, gid int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procLchown)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(uid), uintptr(gid), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Link(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procLink)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Listen(s int, backlog int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_llisten)), 2, uintptr(s), uintptr(backlog), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Lstat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procLstat)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Madvise(b %5B%5Dbyte, advice int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMadvise)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), uintptr(advice), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMkdir)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkdirat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMkdirat)), 3, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkfifo(path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMkfifo)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mkfifoat(dirfd int, path string, mode uint32) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMkfifoat)), 3, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mknod(path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMknod)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mknodat(dirfd int, path string, mode uint32, dev int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMknodat)), 4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(dev), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMlock)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mlockall(flags int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMlockall)), 1, uintptr(flags), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Mprotect(b %5B%5Dbyte, prot int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMprotect)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), uintptr(prot), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Msync(b %5B%5Dbyte, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMsync)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), uintptr(flags), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Munlock(b %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(b) %3E 0 %7B%0A%09%09_p0 = &b%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMunlock)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(b)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Munlockall() (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procMunlockall)), 0, 0, 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Nanosleep(time *Timespec, leftover *Timespec) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procNanosleep)), 2, uintptr(unsafe.Pointer(time)), uintptr(unsafe.Pointer(leftover)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Open(path string, mode int, perm uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procOpen)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm), 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Openat(dirfd int, path string, flags int, mode uint32) (fd int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procOpenat)), 4, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), uintptr(mode), 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Pathconf(path string, name int) (val int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procPathconf)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(name), 0, 0, 0, 0)%0A%09val = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Pause() (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procPause)), 0, 0, 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Pread(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procPread)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Pwrite(fd int, p %5B%5Dbyte, offset int64) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procPwrite)), 4, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(offset), 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0A
 func read(fd
@@ -34600,28 +34600,12017 @@
 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A
+%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p1 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procReadlink)), 3, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), uintptr(len(buf)), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Rename(from string, to string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(from)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(to)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procRename)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Renameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procRenameat)), 4, uintptr(olddirfd), uintptr(unsafe.Pointer(_p0)), uintptr(newdirfd), uintptr(unsafe.Pointer(_p1)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procRmdir)), 1, uintptr(unsafe.Pointer(_p0)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Seek(fd int, offset int64, whence int) (newoffset int64, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proclseek)), 3, uintptr(fd), uintptr(offset), uintptr(whence), 0, 0, 0)%0A%09newoffset = int64(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Select(n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSelect)), 5, uintptr(n), uintptr(unsafe.Pointer(r)), uintptr(unsafe.Pointer(w)), uintptr(unsafe.Pointer(e)), uintptr(unsafe.Pointer(timeout)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setegid(egid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetegid)), 1, uintptr(egid), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Seteuid(euid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSeteuid)), 1, uintptr(euid), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setgid(gid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetgid)), 1, uintptr(gid), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sethostname(p %5B%5Dbyte) (err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSethostname)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setpgid(pid int, pgid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetpgid)), 2, uintptr(pid), uintptr(pgid), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setpriority(which int, who int, prio int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSetpriority)), 3, uintptr(which), uintptr(who), uintptr(prio), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setregid(rgid int, egid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetregid)), 2, uintptr(rgid), uintptr(egid), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setreuid(ruid int, euid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetreuid)), 2, uintptr(ruid), uintptr(euid), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setrlimit(which int, lim *Rlimit) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetrlimit)), 2, uintptr(which), uintptr(unsafe.Pointer(lim)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setsid() (pid int, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetsid)), 0, 0, 0, 0, 0, 0, 0)%0A%09pid = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setuid(uid int) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procSetuid)), 1, uintptr(uid), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Shutdown(s int, how int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procshutdown)), 2, uintptr(s), uintptr(how), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Stat(path string, stat *Stat_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procStat)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(stat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Statvfs(path string, vfsstat *Statvfs_t) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procStatvfs)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(vfsstat)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Symlink(path string, link string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = BytePtrFromString(link)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSymlink)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_p1)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Sync() (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procSync)), 0, 0, 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Times(tms *Tms) (ticks uintptr, err error) %7B%0A%09r0, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procTimes)), 1, uintptr(unsafe.Pointer(tms)), 0, 0, 0, 0, 0)%0A%09ticks = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Truncate(path string, length int64) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procTruncate)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(length), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Fsync(fd int) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFsync)), 1, uintptr(fd), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Ftruncate(fd int, length int64) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procFtruncate)), 2, uintptr(fd), uintptr(length), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Umask(mask int) (oldmask int) %7B%0A%09r0, _, _ := sysvicall6(uintptr(unsafe.Pointer(&procUmask)), 1, uintptr(mask), 0, 0, 0, 0, 0)%0A%09oldmask = int(r0)%0A%09return%0A%7D%0A%0Afunc Uname(buf *Utsname) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procUname)), 1, uintptr(unsafe.Pointer(buf)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Unmount(target string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(target)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procumount)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Unlink(path string) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procUnlink)), 1, uintptr(unsafe.Pointer(_p0)), 0, 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Unlinkat(dirfd int, path string, flags int) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procUnlinkat)), 3, uintptr(dirfd), uintptr(unsafe.Pointer(_p0)), uintptr(flags), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Ustat(dev int, ubuf *Ustat_t) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procUstat)), 2, uintptr(dev), uintptr(unsafe.Pointer(ubuf)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Utime(path string, buf *Utimbuf) (err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = BytePtrFromString(path)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procUtime)), 2, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(buf)), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc bind(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_bind)), 3, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_connect)), 3, uintptr(s), uintptr(addr), uintptr(addrlen), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procmmap)), 6, uintptr(addr), uintptr(length), uintptr(prot), uintptr(flag), uintptr(fd), uintptr(pos))%0A%09ret = uintptr(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc munmap(addr uintptr, length uintptr) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procmunmap)), 2, uintptr(addr), uintptr(length), 0, 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procsendfile)), 4, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)%0A%09written = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc sendto(s int, buf %5B%5Dbyte, flags int, to unsafe.Pointer, addrlen _Socklen) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_sendto)), 6, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(addrlen))%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socket(domain int, typ int, proto int) (fd int, err error) %7B%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_socket)), 3, uintptr(domain), uintptr(typ), uintptr(proto), 0, 0, 0)%0A%09fd = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socketpair(domain int, typ int, proto int, fd *%5B2%5Dint32) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&proc__xnet_socketpair)), 4, uintptr(domain), uintptr(typ), uintptr(proto), uintptr(unsafe.Pointer(fd)), 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc write(fd int, p %5B%5Dbyte) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procwrite)), 3, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), 0, 0, 0)%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&proc__xnet_getsockopt)), 5, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) %7B%0A%09_, _, e1 := rawSysvicall6(uintptr(unsafe.Pointer(&procgetpeername)), 3, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), 0, 0, 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) %7B%0A%09_, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procsetsockopt)), 5, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A%0Afunc recvfrom(fd int, p %5B%5Dbyte, flags int, from *RawSockaddrAny, fromlen *_Socklen) (n int, err error) %7B%0A%09var _p0 *byte%0A%09if len(p) %3E 0 %7B%0A%09%09_p0 = &p%5B0%5D%0A%09%7D%0A%09r0, _, e1 := sysvicall6(uintptr(unsafe.Pointer(&procrecvfrom)), 6, uintptr(fd), uintptr(unsafe.Pointer(_p0)), uintptr(len(p)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))%0A%09n = int(r0)%0A%09if e1 != 0 %7B%0A%09%09err = e1%0A%09%7D%0A%09return%0A%7D%0A
- f 0a6e625c26f26c12e9034772b7c75c0706159c437c6b8294f18006f5a302bfcf vendor/golang.org/x/sys/unix/zsysctl_openbsd_386.go
+ f a9c5f81c8053ae7b474a23f0472078d97ab0a10f376809defeb6eebb85a64104 vendor/golang.org/x/sys/unix/zsysctl_openbsd_386.go
dmppatch 3
@@ -83,8 +83,11902 @@
 ge unix%0A
+%0Atype mibentry struct %7B%0A%09ctlname string%0A%09ctloid  %5B%5D_C_int%0A%7D%0A%0Avar sysctlMib = %5B%5Dmibentry%7B%0A%09%7B%22ddb.console%22, %5B%5D_C_int%7B9, 6%7D%7D,%0A%09%7B%22ddb.log%22, %5B%5D_C_int%7B9, 7%7D%7D,%0A%09%7B%22ddb.max_line%22, %5B%5D_C_int%7B9, 3%7D%7D,%0A%09%7B%22ddb.max_width%22, %5B%5D_C_int%7B9, 2%7D%7D,%0A%09%7B%22ddb.panic%22, %5B%5D_C_int%7B9, 5%7D%7D,%0A%09%7B%22ddb.radix%22, %5B%5D_C_int%7B9, 1%7D%7D,%0A%09%7B%22ddb.tab_stop_width%22, %5B%5D_C_int%7B9, 4%7D%7D,%0A%09%7B%22ddb.trigger%22, %5B%5D_C_int%7B9, 8%7D%7D,%0A%09%7B%22fs.posix.setuid%22, %5B%5D_C_int%7B3, 1, 1%7D%7D,%0A%09%7B%22hw.allowpowerdown%22, %5B%5D_C_int%7B6, 22%7D%7D,%0A%09%7B%22hw.byteorder%22, %5B%5D_C_int%7B6, 4%7D%7D,%0A%09%7B%22hw.cpuspeed%22, %5B%5D_C_int%7B6, 12%7D%7D,%0A%09%7B%22hw.diskcount%22, %5B%5D_C_int%7B6, 10%7D%7D,%0A%09%7B%22hw.disknames%22, %5B%5D_C_int%7B6, 8%7D%7D,%0A%09%7B%22hw.diskstats%22, %5B%5D_C_int%7B6, 9%7D%7D,%0A%09%7B%22hw.machine%22, %5B%5D_C_int%7B6, 1%7D%7D,%0A%09%7B%22hw.model%22, %5B%5D_C_int%7B6, 2%7D%7D,%0A%09%7B%22hw.ncpu%22, %5B%5D_C_int%7B6, 3%7D%7D,%0A%09%7B%22hw.ncpufound%22, %5B%5D_C_int%7B6, 21%7D%7D,%0A%09%7B%22hw.pagesize%22, %5B%5D_C_int%7B6, 7%7D%7D,%0A%09%7B%22hw.physmem%22, %5B%5D_C_int%7B6, 19%7D%7D,%0A%09%7B%22hw.product%22, %5B%5D_C_int%7B6, 15%7D%7D,%0A%09%7B%22hw.serialno%22, %5B%5D_C_int%7B6, 17%7D%7D,%0A%09%7B%22hw.setperf%22, %5B%5D_C_int%7B6, 13%7D%7D,%0A%09%7B%22hw.usermem%22, %5B%5D_C_int%7B6, 20%7D%7D,%0A%09%7B%22hw.uuid%22, %5B%5D_C_int%7B6, 18%7D%7D,%0A%09%7B%22hw.vendor%22, %5B%5D_C_int%7B6, 14%7D%7D,%0A%09%7B%22hw.version%22, %5B%5D_C_int%7B6, 16%7D%7D,%0A%09%7B%22kern.arandom%22, %5B%5D_C_int%7B1, 37%7D%7D,%0A%09%7B%22kern.argmax%22, %5B%5D_C_int%7B1, 8%7D%7D,%0A%09%7B%22kern.boottime%22, %5B%5D_C_int%7B1, 21%7D%7D,%0A%09%7B%22kern.bufcachepercent%22, %5B%5D_C_int%7B1, 72%7D%7D,%0A%09%7B%22kern.ccpu%22, %5B%5D_C_int%7B1, 45%7D%7D,%0A%09%7B%22kern.clockrate%22, %5B%5D_C_int%7B1, 12%7D%7D,%0A%09%7B%22kern.consdev%22, %5B%5D_C_int%7B1, 75%7D%7D,%0A%09%7B%22kern.cp_time%22, %5B%5D_C_int%7B1, 40%7D%7D,%0A%09%7B%22kern.cp_time2%22, %5B%5D_C_int%7B1, 71%7D%7D,%0A%09%7B%22kern.cryptodevallowsoft%22, %5B%5D_C_int%7B1, 53%7D%7D,%0A%09%7B%22kern.domainname%22, %5B%5D_C_int%7B1, 22%7D%7D,%0A%09%7B%22kern.file%22, %5B%5D_C_int%7B1, 73%7D%7D,%0A%09%7B%22kern.forkstat%22, %5B%5D_C_int%7B1, 42%7D%7D,%0A%09%7B%22kern.fscale%22, %5B%5D_C_int%7B1, 46%7D%7D,%0A%09%7B%22kern.fsync%22, %5B%5D_C_int%7B1, 33%7D%7D,%0A%09%7B%22kern.hostid%22, %5B%5D_C_int%7B1, 11%7D%7D,%0A%09%7B%22kern.hostname%22, %5B%5D_C_int%7B1, 10%7D%7D,%0A%09%7B%22kern.intrcnt.nintrcnt%22, %5B%5D_C_int%7B1, 63, 1%7D%7D,%0A%09%7B%22kern.job_control%22, %5B%5D_C_int%7B1, 19%7D%7D,%0A%09%7B%22kern.malloc.buckets%22, %5B%5D_C_int%7B1, 39, 1%7D%7D,%0A%09%7B%22kern.malloc.kmemnames%22, %5B%5D_C_int%7B1, 39, 3%7D%7D,%0A%09%7B%22kern.maxclusters%22, %5B%5D_C_int%7B1, 67%7D%7D,%0A%09%7B%22kern.maxfiles%22, %5B%5D_C_int%7B1, 7%7D%7D,%0A%09%7B%22kern.maxlocksperuid%22, %5B%5D_C_int%7B1, 70%7D%7D,%0A%09%7B%22kern.maxpartitions%22, %5B%5D_C_int%7B1, 23%7D%7D,%0A%09%7B%22kern.maxproc%22, %5B%5D_C_int%7B1, 6%7D%7D,%0A%09%7B%22kern.maxthread%22, %5B%5D_C_int%7B1, 25%7D%7D,%0A%09%7B%22kern.maxvnodes%22, %5B%5D_C_int%7B1, 5%7D%7D,%0A%09%7B%22kern.mbstat%22, %5B%5D_C_int%7B1, 59%7D%7D,%0A%09%7B%22kern.msgbuf%22, %5B%5D_C_int%7B1, 48%7D%7D,%0A%09%7B%22kern.msgbufsize%22, %5B%5D_C_int%7B1, 38%7D%7D,%0A%09%7B%22kern.nchstats%22, %5B%5D_C_int%7B1, 41%7D%7D,%0A%09%7B%22kern.netlivelocks%22, %5B%5D_C_int%7B1, 76%7D%7D,%0A%09%7B%22kern.nfiles%22, %5B%5D_C_int%7B1, 56%7D%7D,%0A%09%7B%22kern.ngroups%22, %5B%5D_C_int%7B1, 18%7D%7D,%0A%09%7B%22kern.nosuidcoredump%22, %5B%5D_C_int%7B1, 32%7D%7D,%0A%09%7B%22kern.nprocs%22, %5B%5D_C_int%7B1, 47%7D%7D,%0A%09%7B%22kern.nselcoll%22, %5B%5D_C_int%7B1, 43%7D%7D,%0A%09%7B%22kern.nthreads%22, %5B%5D_C_int%7B1, 26%7D%7D,%0A%09%7B%22kern.numvnodes%22, %5B%5D_C_int%7B1, 58%7D%7D,%0A%09%7B%22kern.osrelease%22, %5B%5D_C_int%7B1, 2%7D%7D,%0A%09%7B%22kern.osrevision%22, %5B%5D_C_int%7B1, 3%7D%7D,%0A%09%7B%22kern.ostype%22, %5B%5D_C_int%7B1, 1%7D%7D,%0A%09%7B%22kern.osversion%22, %5B%5D_C_int%7B1, 27%7D%7D,%0A%09%7B%22kern.pool_debug%22, %5B%5D_C_int%7B1, 77%7D%7D,%0A%09%7B%22kern.posix1version%22, %5B%5D_C_int%7B1, 17%7D%7D,%0A%09%7B%22kern.proc%22, %5B%5D_C_int%7B1, 66%7D%7D,%0A%09%7B%22kern.random%22, %5B%5D_C_int%7B1, 31%7D%7D,%0A%09%7B%22kern.rawpartition%22, %5B%5D_C_int%7B1, 24%7D%7D,%0A%09%7B%22kern.saved_ids%22, %5B%5D_C_int%7B1, 20%7D%7D,%0A%09%7B%22kern.securelevel%22, %5B%5D_C_int%7B1, 9%7D%7D,%0A%09%7B%22kern.seminfo%22, %5B%5D_C_int%7B1, 61%7D%7D,%0A%09%7B%22kern.shminfo%22, %5B%5D_C_int%7B1, 62%7D%7D,%0A%09%7B%22kern.somaxconn%22, %5B%5D_C_int%7B1, 28%7D%7D,%0A%09%7B%22kern.sominconn%22, %5B%5D_C_int%7B1, 29%7D%7D,%0A%09%7B%22kern.splassert%22, %5B%5D_C_int%7B1, 54%7D%7D,%0A%09%7B%22kern.stackgap_random%22, %5B%5D_C_int%7B1, 50%7D%7D,%0A%09%7B%22kern.sysvipc_info%22, %5B%5D_C_int%7B1, 51%7D%7D,%0A%09%7B%22kern.sysvmsg%22, %5B%5D_C_int%7B1, 34%7D%7D,%0A%09%7B%22kern.sysvsem%22, %5B%5D_C_int%7B1, 35%7D%7D,%0A%09%7B%22kern.sysvshm%22, %5B%5D_C_int%7B1, 36%7D%7D,%0A%09%7B%22kern.timecounter.choice%22, %5B%5D_C_int%7B1, 69, 4%7D%7D,%0A%09%7B%22kern.timecounter.hardware%22, %5B%5D_C_int%7B1, 69, 3%7D%7D,%0A%09%7B%22kern.timecounter.tick%22, %5B%5D_C_int%7B1, 69, 1%7D%7D,%0A%09%7B%22kern.timecounter.timestepwarnings%22, %5B%5D_C_int%7B1, 69, 2%7D%7D,%0A%09%7B%22kern.tty.maxptys%22, %5B%5D_C_int%7B1, 44, 6%7D%7D,%0A%09%7B%22kern.tty.nptys%22, %5B%5D_C_int%7B1, 44, 7%7D%7D,%0A%09%7B%22kern.tty.tk_cancc%22, %5B%5D_C_int%7B1, 44, 4%7D%7D,%0A%09%7B%22kern.tty.tk_nin%22, %5B%5D_C_int%7B1, 44, 1%7D%7D,%0A%09%7B%22kern.tty.tk_nout%22, %5B%5D_C_int%7B1, 44, 2%7D%7D,%0A%09%7B%22kern.tty.tk_rawcc%22, %5B%5D_C_int%7B1, 44, 3%7D%7D,%0A%09%7B%22kern.tty.ttyinfo%22, %5B%5D_C_int%7B1, 44, 5%7D%7D,%0A%09%7B%22kern.ttycount%22, %5B%5D_C_int%7B1, 57%7D%7D,%0A%09%7B%22kern.userasymcrypto%22, %5B%5D_C_int%7B1, 60%7D%7D,%0A%09%7B%22kern.usercrypto%22, %5B%5D_C_int%7B1, 52%7D%7D,%0A%09%7B%22kern.usermount%22, %5B%5D_C_int%7B1, 30%7D%7D,%0A%09%7B%22kern.version%22, %5B%5D_C_int%7B1, 4%7D%7D,%0A%09%7B%22kern.vnode%22, %5B%5D_C_int%7B1, 13%7D%7D,%0A%09%7B%22kern.watchdog.auto%22, %5B%5D_C_int%7B1, 64, 2%7D%7D,%0A%09%7B%22kern.watchdog.period%22, %5B%5D_C_int%7B1, 64, 1%7D%7D,%0A%09%7B%22net.bpf.bufsize%22, %5B%5D_C_int%7B4, 31, 1%7D%7D,%0A%09%7B%22net.bpf.maxbufsize%22, %5B%5D_C_int%7B4, 31, 2%7D%7D,%0A%09%7B%22net.inet.ah.enable%22, %5B%5D_C_int%7B4, 2, 51, 1%7D%7D,%0A%09%7B%22net.inet.ah.stats%22, %5B%5D_C_int%7B4, 2, 51, 2%7D%7D,%0A%09%7B%22net.inet.carp.allow%22, %5B%5D_C_int%7B4, 2, 112, 1%7D%7D,%0A%09%7B%22net.inet.carp.log%22, %5B%5D_C_int%7B4, 2, 112, 3%7D%7D,%0A%09%7B%22net.inet.carp.preempt%22, %5B%5D_C_int%7B4, 2, 112, 2%7D%7D,%0A%09%7B%22net.inet.carp.stats%22, %5B%5D_C_int%7B4, 2, 112, 4%7D%7D,%0A%09%7B%22net.inet.divert.recvspace%22, %5B%5D_C_int%7B4, 2, 258, 1%7D%7D,%0A%09%7B%22net.inet.divert.sendspace%22, %5B%5D_C_int%7B4, 2, 258, 2%7D%7D,%0A%09%7B%22net.inet.divert.stats%22, %5B%5D_C_int%7B4, 2, 258, 3%7D%7D,%0A%09%7B%22net.inet.esp.enable%22, %5B%5D_C_int%7B4, 2, 50, 1%7D%7D,%0A%09%7B%22net.inet.esp.stats%22, %5B%5D_C_int%7B4, 2, 50, 4%7D%7D,%0A%09%7B%22net.inet.esp.udpencap%22, %5B%5D_C_int%7B4, 2, 50, 2%7D%7D,%0A%09%7B%22net.inet.esp.udpencap_port%22, %5B%5D_C_int%7B4, 2, 50, 3%7D%7D,%0A%09%7B%22net.inet.etherip.allow%22, %5B%5D_C_int%7B4, 2, 97, 1%7D%7D,%0A%09%7B%22net.inet.etherip.stats%22, %5B%5D_C_int%7B4, 2, 97, 2%7D%7D,%0A%09%7B%22net.inet.gre.allow%22, %5B%5D_C_int%7B4, 2, 47, 1%7D%7D,%0A%09%7B%22net.inet.gre.wccp%22, %5B%5D_C_int%7B4, 2, 47, 2%7D%7D,%0A%09%7B%22net.inet.icmp.bmcastecho%22, %5B%5D_C_int%7B4, 2, 1, 2%7D%7D,%0A%09%7B%22net.inet.icmp.errppslimit%22, %5B%5D_C_int%7B4, 2, 1, 3%7D%7D,%0A%09%7B%22net.inet.icmp.maskrepl%22, %5B%5D_C_int%7B4, 2, 1, 1%7D%7D,%0A%09%7B%22net.inet.icmp.rediraccept%22, %5B%5D_C_int%7B4, 2, 1, 4%7D%7D,%0A%09%7B%22net.inet.icmp.redirtimeout%22, %5B%5D_C_int%7B4, 2, 1, 5%7D%7D,%0A%09%7B%22net.inet.icmp.stats%22, %5B%5D_C_int%7B4, 2, 1, 7%7D%7D,%0A%09%7B%22net.inet.icmp.tstamprepl%22, %5B%5D_C_int%7B4, 2, 1, 6%7D%7D,%0A%09%7B%22net.inet.igmp.stats%22, %5B%5D_C_int%7B4, 2, 2, 1%7D%7D,%0A%09%7B%22net.inet.ip.arpqueued%22, %5B%5D_C_int%7B4, 2, 0, 36%7D%7D,%0A%09%7B%22net.inet.ip.encdebug%22, %5B%5D_C_int%7B4, 2, 0, 12%7D%7D,%0A%09%7B%22net.inet.ip.forwarding%22, %5B%5D_C_int%7B4, 2, 0, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.congestion%22, %5B%5D_C_int%7B4, 2, 0, 30, 4%7D%7D,%0A%09%7B%22net.inet.ip.ifq.drops%22, %5B%5D_C_int%7B4, 2, 0, 30, 3%7D%7D,%0A%09%7B%22net.inet.ip.ifq.len%22, %5B%5D_C_int%7B4, 2, 0, 30, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.maxlen%22, %5B%5D_C_int%7B4, 2, 0, 30, 2%7D%7D,%0A%09%7B%22net.inet.ip.maxqueue%22, %5B%5D_C_int%7B4, 2, 0, 11%7D%7D,%0A%09%7B%22net.inet.ip.mforwarding%22, %5B%5D_C_int%7B4, 2, 0, 31%7D%7D,%0A%09%7B%22net.inet.ip.mrtproto%22, %5B%5D_C_int%7B4, 2, 0, 34%7D%7D,%0A%09%7B%22net.inet.ip.mrtstats%22, %5B%5D_C_int%7B4, 2, 0, 35%7D%7D,%0A%09%7B%22net.inet.ip.mtu%22, %5B%5D_C_int%7B4, 2, 0, 4%7D%7D,%0A%09%7B%22net.inet.ip.mtudisc%22, %5B%5D_C_int%7B4, 2, 0, 27%7D%7D,%0A%09%7B%22net.inet.ip.mtudisctimeout%22, %5B%5D_C_int%7B4, 2, 0, 28%7D%7D,%0A%09%7B%22net.inet.ip.multipath%22, %5B%5D_C_int%7B4, 2, 0, 32%7D%7D,%0A%09%7B%22net.inet.ip.portfirst%22, %5B%5D_C_int%7B4, 2, 0, 7%7D%7D,%0A%09%7B%22net.inet.ip.porthifirst%22, %5B%5D_C_int%7B4, 2, 0, 9%7D%7D,%0A%09%7B%22net.inet.ip.porthilast%22, %5B%5D_C_int%7B4, 2, 0, 10%7D%7D,%0A%09%7B%22net.inet.ip.portlast%22, %5B%5D_C_int%7B4, 2, 0, 8%7D%7D,%0A%09%7B%22net.inet.ip.redirect%22, %5B%5D_C_int%7B4, 2, 0, 2%7D%7D,%0A%09%7B%22net.inet.ip.sourceroute%22, %5B%5D_C_int%7B4, 2, 0, 5%7D%7D,%0A%09%7B%22net.inet.ip.stats%22, %5B%5D_C_int%7B4, 2, 0, 33%7D%7D,%0A%09%7B%22net.inet.ip.ttl%22, %5B%5D_C_int%7B4, 2, 0, 3%7D%7D,%0A%09%7B%22net.inet.ipcomp.enable%22, %5B%5D_C_int%7B4, 2, 108, 1%7D%7D,%0A%09%7B%22net.inet.ipcomp.stats%22, %5B%5D_C_int%7B4, 2, 108, 2%7D%7D,%0A%09%7B%22net.inet.ipip.allow%22, %5B%5D_C_int%7B4, 2, 4, 1%7D%7D,%0A%09%7B%22net.inet.ipip.stats%22, %5B%5D_C_int%7B4, 2, 4, 2%7D%7D,%0A%09%7B%22net.inet.mobileip.allow%22, %5B%5D_C_int%7B4, 2, 55, 1%7D%7D,%0A%09%7B%22net.inet.pfsync.stats%22, %5B%5D_C_int%7B4, 2, 240, 1%7D%7D,%0A%09%7B%22net.inet.pim.stats%22, %5B%5D_C_int%7B4, 2, 103, 1%7D%7D,%0A%09%7B%22net.inet.tcp.ackonpush%22, %5B%5D_C_int%7B4, 2, 6, 13%7D%7D,%0A%09%7B%22net.inet.tcp.always_keepalive%22, %5B%5D_C_int%7B4, 2, 6, 22%7D%7D,%0A%09%7B%22net.inet.tcp.baddynamic%22, %5B%5D_C_int%7B4, 2, 6, 6%7D%7D,%0A%09%7B%22net.inet.tcp.drop%22, %5B%5D_C_int%7B4, 2, 6, 19%7D%7D,%0A%09%7B%22net.inet.tcp.ecn%22, %5B%5D_C_int%7B4, 2, 6, 14%7D%7D,%0A%09%7B%22net.inet.tcp.ident%22, %5B%5D_C_int%7B4, 2, 6, 9%7D%7D,%0A%09%7B%22net.inet.tcp.keepidle%22, %5B%5D_C_int%7B4, 2, 6, 3%7D%7D,%0A%09%7B%22net.inet.tcp.keepinittime%22, %5B%5D_C_int%7B4, 2, 6, 2%7D%7D,%0A%09%7B%22net.inet.tcp.keepintvl%22, %5B%5D_C_int%7B4, 2, 6, 4%7D%7D,%0A%09%7B%22net.inet.tcp.mssdflt%22, %5B%5D_C_int%7B4, 2, 6, 11%7D%7D,%0A%09%7B%22net.inet.tcp.reasslimit%22, %5B%5D_C_int%7B4, 2, 6, 18%7D%7D,%0A%09%7B%22net.inet.tcp.rfc1323%22, %5B%5D_C_int%7B4, 2, 6, 1%7D%7D,%0A%09%7B%22net.inet.tcp.rfc3390%22, %5B%5D_C_int%7B4, 2, 6, 17%7D%7D,%0A%09%7B%22net.inet.tcp.rstppslimit%22, %5B%5D_C_int%7B4, 2, 6, 12%7D%7D,%0A%09%7B%22net.inet.tcp.sack%22, %5B%5D_C_int%7B4, 2, 6, 10%7D%7D,%0A%09%7B%22net.inet.tcp.sackholelimit%22, %5B%5D_C_int%7B4, 2, 6, 20%7D%7D,%0A%09%7B%22net.inet.tcp.slowhz%22, %5B%5D_C_int%7B4, 2, 6, 5%7D%7D,%0A%09%7B%22net.inet.tcp.stats%22, %5B%5D_C_int%7B4, 2, 6, 21%7D%7D,%0A%09%7B%22net.inet.tcp.synbucketlimit%22, %5B%5D_C_int%7B4, 2, 6, 16%7D%7D,%0A%09%7B%22net.inet.tcp.syncachelimit%22, %5B%5D_C_int%7B4, 2, 6, 15%7D%7D,%0A%09%7B%22net.inet.udp.baddynamic%22, %5B%5D_C_int%7B4, 2, 17, 2%7D%7D,%0A%09%7B%22net.inet.udp.checksum%22, %5B%5D_C_int%7B4, 2, 17, 1%7D%7D,%0A%09%7B%22net.inet.udp.recvspace%22, %5B%5D_C_int%7B4, 2, 17, 3%7D%7D,%0A%09%7B%22net.inet.udp.sendspace%22, %5B%5D_C_int%7B4, 2, 17, 4%7D%7D,%0A%09%7B%22net.inet.udp.stats%22, %5B%5D_C_int%7B4, 2, 17, 5%7D%7D,%0A%09%7B%22net.inet6.divert.recvspace%22, %5B%5D_C_int%7B4, 24, 86, 1%7D%7D,%0A%09%7B%22net.inet6.divert.sendspace%22, %5B%5D_C_int%7B4, 24, 86, 2%7D%7D,%0A%09%7B%22net.inet6.divert.stats%22, %5B%5D_C_int%7B4, 24, 86, 3%7D%7D,%0A%09%7B%22net.inet6.icmp6.errppslimit%22, %5B%5D_C_int%7B4, 24, 30, 14%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_hiwat%22, %5B%5D_C_int%7B4, 24, 30, 16%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_lowat%22, %5B%5D_C_int%7B4, 24, 30, 17%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_debug%22, %5B%5D_C_int%7B4, 24, 30, 18%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_delay%22, %5B%5D_C_int%7B4, 24, 30, 8%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_maxnudhint%22, %5B%5D_C_int%7B4, 24, 30, 15%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_mmaxtries%22, %5B%5D_C_int%7B4, 24, 30, 10%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_prune%22, %5B%5D_C_int%7B4, 24, 30, 6%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_umaxtries%22, %5B%5D_C_int%7B4, 24, 30, 9%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_useloopback%22, %5B%5D_C_int%7B4, 24, 30, 11%7D%7D,%0A%09%7B%22net.inet6.icmp6.nodeinfo%22, %5B%5D_C_int%7B4, 24, 30, 13%7D%7D,%0A%09%7B%22net.inet6.icmp6.rediraccept%22, %5B%5D_C_int%7B4, 24, 30, 2%7D%7D,%0A%09%7B%22net.inet6.icmp6.redirtimeout%22, %5B%5D_C_int%7B4, 24, 30, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.accept_rtadv%22, %5B%5D_C_int%7B4, 24, 17, 12%7D%7D,%0A%09%7B%22net.inet6.ip6.auto_flowlabel%22, %5B%5D_C_int%7B4, 24, 17, 17%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_count%22, %5B%5D_C_int%7B4, 24, 17, 16%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_pending%22, %5B%5D_C_int%7B4, 24, 17, 49%7D%7D,%0A%09%7B%22net.inet6.ip6.defmcasthlim%22, %5B%5D_C_int%7B4, 24, 17, 18%7D%7D,%0A%09%7B%22net.inet6.ip6.forwarding%22, %5B%5D_C_int%7B4, 24, 17, 1%7D%7D,%0A%09%7B%22net.inet6.ip6.forwsrcrt%22, %5B%5D_C_int%7B4, 24, 17, 5%7D%7D,%0A%09%7B%22net.inet6.ip6.hdrnestlimit%22, %5B%5D_C_int%7B4, 24, 17, 15%7D%7D,%0A%09%7B%22net.inet6.ip6.hlim%22, %5B%5D_C_int%7B4, 24, 17, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.log_interval%22, %5B%5D_C_int%7B4, 24, 17, 14%7D%7D,%0A%09%7B%22net.inet6.ip6.maxdynroutes%22, %5B%5D_C_int%7B4, 24, 17, 48%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfragpackets%22, %5B%5D_C_int%7B4, 24, 17, 9%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfrags%22, %5B%5D_C_int%7B4, 24, 17, 41%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifdefrouters%22, %5B%5D_C_int%7B4, 24, 17, 47%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifprefixes%22, %5B%5D_C_int%7B4, 24, 17, 46%7D%7D,%0A%09%7B%22net.inet6.ip6.mforwarding%22, %5B%5D_C_int%7B4, 24, 17, 42%7D%7D,%0A%09%7B%22net.inet6.ip6.mrtproto%22, %5B%5D_C_int%7B4, 24, 17, 8%7D%7D,%0A%09%7B%22net.inet6.ip6.mtudisctimeout%22, %5B%5D_C_int%7B4, 24, 17, 50%7D%7D,%0A%09%7B%22net.inet6.ip6.multicast_mtudisc%22, %5B%5D_C_int%7B4, 24, 17, 44%7D%7D,%0A%09%7B%22net.inet6.ip6.multipath%22, %5B%5D_C_int%7B4, 24, 17, 43%7D%7D,%0A%09%7B%22net.inet6.ip6.neighborgcthresh%22, %5B%5D_C_int%7B4, 24, 17, 45%7D%7D,%0A%09%7B%22net.inet6.ip6.redirect%22, %5B%5D_C_int%7B4, 24, 17, 2%7D%7D,%0A%09%7B%22net.inet6.ip6.rr_prune%22, %5B%5D_C_int%7B4, 24, 17, 22%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck%22, %5B%5D_C_int%7B4, 24, 17, 10%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck_logint%22, %5B%5D_C_int%7B4, 24, 17, 11%7D%7D,%0A%09%7B%22net.inet6.ip6.use_deprecated%22, %5B%5D_C_int%7B4, 24, 17, 21%7D%7D,%0A%09%7B%22net.inet6.ip6.v6only%22, %5B%5D_C_int%7B4, 24, 17, 24%7D%7D,%0A%09%7B%22net.key.sadb_dump%22, %5B%5D_C_int%7B4, 30, 1%7D%7D,%0A%09%7B%22net.key.spd_dump%22, %5B%5D_C_int%7B4, 30, 2%7D%7D,%0A%09%7B%22net.mpls.ifq.congestion%22, %5B%5D_C_int%7B4, 33, 3, 4%7D%7D,%0A%09%7B%22net.mpls.ifq.drops%22, %5B%5D_C_int%7B4, 33, 3, 3%7D%7D,%0A%09%7B%22net.mpls.ifq.len%22, %5B%5D_C_int%7B4, 33, 3, 1%7D%7D,%0A%09%7B%22net.mpls.ifq.maxlen%22, %5B%5D_C_int%7B4, 33, 3, 2%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip%22, %5B%5D_C_int%7B4, 33, 5%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip6%22, %5B%5D_C_int%7B4, 33, 6%7D%7D,%0A%09%7B%22net.mpls.maxloop_inkernel%22, %5B%5D_C_int%7B4, 33, 4%7D%7D,%0A%09%7B%22net.mpls.ttl%22, %5B%5D_C_int%7B4, 33, 2%7D%7D,%0A%09%7B%22net.pflow.stats%22, %5B%5D_C_int%7B4, 34, 1%7D%7D,%0A%09%7B%22net.pipex.enable%22, %5B%5D_C_int%7B4, 35, 1%7D%7D,%0A%09%7B%22vm.anonmin%22, %5B%5D_C_int%7B2, 7%7D%7D,%0A%09%7B%22vm.loadavg%22, %5B%5D_C_int%7B2, 2%7D%7D,%0A%09%7B%22vm.maxslp%22, %5B%5D_C_int%7B2, 10%7D%7D,%0A%09%7B%22vm.nkmempages%22, %5B%5D_C_int%7B2, 6%7D%7D,%0A%09%7B%22vm.psstrings%22, %5B%5D_C_int%7B2, 3%7D%7D,%0A%09%7B%22vm.swapencrypt.enable%22, %5B%5D_C_int%7B2, 5, 0%7D%7D,%0A%09%7B%22vm.swapencrypt.keyscreated%22, %5B%5D_C_int%7B2, 5, 1%7D%7D,%0A%09%7B%22vm.swapencrypt.keysdeleted%22, %5B%5D_C_int%7B2, 5, 2%7D%7D,%0A%09%7B%22vm.uspace%22, %5B%5D_C_int%7B2, 11%7D%7D,%0A%09%7B%22vm.uvmexp%22, %5B%5D_C_int%7B2, 4%7D%7D,%0A%09%7B%22vm.vmmeter%22, %5B%5D_C_int%7B2, 1%7D%7D,%0A%09%7B%22vm.vnodemin%22, %5B%5D_C_int%7B2, 9%7D%7D,%0A%09%7B%22vm.vtextmin%22, %5B%5D_C_int%7B2, 8%7D%7D,%0A%7D%0A
- f a850510e2a0d60cf8614cfa0cf4840f229b65809b59cfe070327e0c7684a5071 vendor/golang.org/x/sys/unix/zsysctl_openbsd_amd64.go
+ f a4ac26190fabaa25eb489e7c8dcd4f122f17856e9f5fdacbfb1735efff0ec9c7 vendor/golang.org/x/sys/unix/zsysctl_openbsd_amd64.go
dmppatch 3
@@ -108,8 +108,11284 @@
 ge unix%0A
+%0Atype mibentry struct %7B%0A%09ctlname string%0A%09ctloid  %5B%5D_C_int%0A%7D%0A%0Avar sysctlMib = %5B%5Dmibentry%7B%0A%09%7B%22ddb.console%22, %5B%5D_C_int%7B9, 6%7D%7D,%0A%09%7B%22ddb.log%22, %5B%5D_C_int%7B9, 7%7D%7D,%0A%09%7B%22ddb.max_line%22, %5B%5D_C_int%7B9, 3%7D%7D,%0A%09%7B%22ddb.max_width%22, %5B%5D_C_int%7B9, 2%7D%7D,%0A%09%7B%22ddb.panic%22, %5B%5D_C_int%7B9, 5%7D%7D,%0A%09%7B%22ddb.profile%22, %5B%5D_C_int%7B9, 9%7D%7D,%0A%09%7B%22ddb.radix%22, %5B%5D_C_int%7B9, 1%7D%7D,%0A%09%7B%22ddb.tab_stop_width%22, %5B%5D_C_int%7B9, 4%7D%7D,%0A%09%7B%22ddb.trigger%22, %5B%5D_C_int%7B9, 8%7D%7D,%0A%09%7B%22fs.posix.setuid%22, %5B%5D_C_int%7B3, 1, 1%7D%7D,%0A%09%7B%22hw.allowpowerdown%22, %5B%5D_C_int%7B6, 22%7D%7D,%0A%09%7B%22hw.byteorder%22, %5B%5D_C_int%7B6, 4%7D%7D,%0A%09%7B%22hw.cpuspeed%22, %5B%5D_C_int%7B6, 12%7D%7D,%0A%09%7B%22hw.diskcount%22, %5B%5D_C_int%7B6, 10%7D%7D,%0A%09%7B%22hw.disknames%22, %5B%5D_C_int%7B6, 8%7D%7D,%0A%09%7B%22hw.diskstats%22, %5B%5D_C_int%7B6, 9%7D%7D,%0A%09%7B%22hw.machine%22, %5B%5D_C_int%7B6, 1%7D%7D,%0A%09%7B%22hw.model%22, %5B%5D_C_int%7B6, 2%7D%7D,%0A%09%7B%22hw.ncpu%22, %5B%5D_C_int%7B6, 3%7D%7D,%0A%09%7B%22hw.ncpufound%22, %5B%5D_C_int%7B6, 21%7D%7D,%0A%09%7B%22hw.pagesize%22, %5B%5D_C_int%7B6, 7%7D%7D,%0A%09%7B%22hw.perfpolicy%22, %5B%5D_C_int%7B6, 23%7D%7D,%0A%09%7B%22hw.physmem%22, %5B%5D_C_int%7B6, 19%7D%7D,%0A%09%7B%22hw.product%22, %5B%5D_C_int%7B6, 15%7D%7D,%0A%09%7B%22hw.serialno%22, %5B%5D_C_int%7B6, 17%7D%7D,%0A%09%7B%22hw.setperf%22, %5B%5D_C_int%7B6, 13%7D%7D,%0A%09%7B%22hw.usermem%22, %5B%5D_C_int%7B6, 20%7D%7D,%0A%09%7B%22hw.uuid%22, %5B%5D_C_int%7B6, 18%7D%7D,%0A%09%7B%22hw.vendor%22, %5B%5D_C_int%7B6, 14%7D%7D,%0A%09%7B%22hw.version%22, %5B%5D_C_int%7B6, 16%7D%7D,%0A%09%7B%22kern.allowkmem%22, %5B%5D_C_int%7B1, 52%7D%7D,%0A%09%7B%22kern.argmax%22, %5B%5D_C_int%7B1, 8%7D%7D,%0A%09%7B%22kern.boottime%22, %5B%5D_C_int%7B1, 21%7D%7D,%0A%09%7B%22kern.bufcachepercent%22, %5B%5D_C_int%7B1, 72%7D%7D,%0A%09%7B%22kern.ccpu%22, %5B%5D_C_int%7B1, 45%7D%7D,%0A%09%7B%22kern.clockrate%22, %5B%5D_C_int%7B1, 12%7D%7D,%0A%09%7B%22kern.consdev%22, %5B%5D_C_int%7B1, 75%7D%7D,%0A%09%7B%22kern.cp_time%22, %5B%5D_C_int%7B1, 40%7D%7D,%0A%09%7B%22kern.cp_time2%22, %5B%5D_C_int%7B1, 71%7D%7D,%0A%09%7B%22kern.dnsjackport%22, %5B%5D_C_int%7B1, 13%7D%7D,%0A%09%7B%22kern.domainname%22, %5B%5D_C_int%7B1, 22%7D%7D,%0A%09%7B%22kern.file%22, %5B%5D_C_int%7B1, 73%7D%7D,%0A%09%7B%22kern.forkstat%22, %5B%5D_C_int%7B1, 42%7D%7D,%0A%09%7B%22kern.fscale%22, %5B%5D_C_int%7B1, 46%7D%7D,%0A%09%7B%22kern.fsync%22, %5B%5D_C_int%7B1, 33%7D%7D,%0A%09%7B%22kern.global_ptrace%22, %5B%5D_C_int%7B1, 81%7D%7D,%0A%09%7B%22kern.hostid%22, %5B%5D_C_int%7B1, 11%7D%7D,%0A%09%7B%22kern.hostname%22, %5B%5D_C_int%7B1, 10%7D%7D,%0A%09%7B%22kern.intrcnt.nintrcnt%22, %5B%5D_C_int%7B1, 63, 1%7D%7D,%0A%09%7B%22kern.job_control%22, %5B%5D_C_int%7B1, 19%7D%7D,%0A%09%7B%22kern.malloc.buckets%22, %5B%5D_C_int%7B1, 39, 1%7D%7D,%0A%09%7B%22kern.malloc.kmemnames%22, %5B%5D_C_int%7B1, 39, 3%7D%7D,%0A%09%7B%22kern.maxclusters%22, %5B%5D_C_int%7B1, 67%7D%7D,%0A%09%7B%22kern.maxfiles%22, %5B%5D_C_int%7B1, 7%7D%7D,%0A%09%7B%22kern.maxlocksperuid%22, %5B%5D_C_int%7B1, 70%7D%7D,%0A%09%7B%22kern.maxpartitions%22, %5B%5D_C_int%7B1, 23%7D%7D,%0A%09%7B%22kern.maxproc%22, %5B%5D_C_int%7B1, 6%7D%7D,%0A%09%7B%22kern.maxthread%22, %5B%5D_C_int%7B1, 25%7D%7D,%0A%09%7B%22kern.maxvnodes%22, %5B%5D_C_int%7B1, 5%7D%7D,%0A%09%7B%22kern.mbstat%22, %5B%5D_C_int%7B1, 59%7D%7D,%0A%09%7B%22kern.msgbuf%22, %5B%5D_C_int%7B1, 48%7D%7D,%0A%09%7B%22kern.msgbufsize%22, %5B%5D_C_int%7B1, 38%7D%7D,%0A%09%7B%22kern.nchstats%22, %5B%5D_C_int%7B1, 41%7D%7D,%0A%09%7B%22kern.netlivelocks%22, %5B%5D_C_int%7B1, 76%7D%7D,%0A%09%7B%22kern.nfiles%22, %5B%5D_C_int%7B1, 56%7D%7D,%0A%09%7B%22kern.ngroups%22, %5B%5D_C_int%7B1, 18%7D%7D,%0A%09%7B%22kern.nosuidcoredump%22, %5B%5D_C_int%7B1, 32%7D%7D,%0A%09%7B%22kern.nprocs%22, %5B%5D_C_int%7B1, 47%7D%7D,%0A%09%7B%22kern.nselcoll%22, %5B%5D_C_int%7B1, 43%7D%7D,%0A%09%7B%22kern.nthreads%22, %5B%5D_C_int%7B1, 26%7D%7D,%0A%09%7B%22kern.numvnodes%22, %5B%5D_C_int%7B1, 58%7D%7D,%0A%09%7B%22kern.osrelease%22, %5B%5D_C_int%7B1, 2%7D%7D,%0A%09%7B%22kern.osrevision%22, %5B%5D_C_int%7B1, 3%7D%7D,%0A%09%7B%22kern.ostype%22, %5B%5D_C_int%7B1, 1%7D%7D,%0A%09%7B%22kern.osversion%22, %5B%5D_C_int%7B1, 27%7D%7D,%0A%09%7B%22kern.pool_debug%22, %5B%5D_C_int%7B1, 77%7D%7D,%0A%09%7B%22kern.posix1version%22, %5B%5D_C_int%7B1, 17%7D%7D,%0A%09%7B%22kern.proc%22, %5B%5D_C_int%7B1, 66%7D%7D,%0A%09%7B%22kern.rawpartition%22, %5B%5D_C_int%7B1, 24%7D%7D,%0A%09%7B%22kern.saved_ids%22, %5B%5D_C_int%7B1, 20%7D%7D,%0A%09%7B%22kern.securelevel%22, %5B%5D_C_int%7B1, 9%7D%7D,%0A%09%7B%22kern.seminfo%22, %5B%5D_C_int%7B1, 61%7D%7D,%0A%09%7B%22kern.shminfo%22, %5B%5D_C_int%7B1, 62%7D%7D,%0A%09%7B%22kern.somaxconn%22, %5B%5D_C_int%7B1, 28%7D%7D,%0A%09%7B%22kern.sominconn%22, %5B%5D_C_int%7B1, 29%7D%7D,%0A%09%7B%22kern.splassert%22, %5B%5D_C_int%7B1, 54%7D%7D,%0A%09%7B%22kern.stackgap_random%22, %5B%5D_C_int%7B1, 50%7D%7D,%0A%09%7B%22kern.sysvipc_info%22, %5B%5D_C_int%7B1, 51%7D%7D,%0A%09%7B%22kern.sysvmsg%22, %5B%5D_C_int%7B1, 34%7D%7D,%0A%09%7B%22kern.sysvsem%22, %5B%5D_C_int%7B1, 35%7D%7D,%0A%09%7B%22kern.sysvshm%22, %5B%5D_C_int%7B1, 36%7D%7D,%0A%09%7B%22kern.timecounter.choice%22, %5B%5D_C_int%7B1, 69, 4%7D%7D,%0A%09%7B%22kern.timecounter.hardware%22, %5B%5D_C_int%7B1, 69, 3%7D%7D,%0A%09%7B%22kern.timecounter.tick%22, %5B%5D_C_int%7B1, 69, 1%7D%7D,%0A%09%7B%22kern.timecounter.timestepwarnings%22, %5B%5D_C_int%7B1, 69, 2%7D%7D,%0A%09%7B%22kern.tty.tk_cancc%22, %5B%5D_C_int%7B1, 44, 4%7D%7D,%0A%09%7B%22kern.tty.tk_nin%22, %5B%5D_C_int%7B1, 44, 1%7D%7D,%0A%09%7B%22kern.tty.tk_nout%22, %5B%5D_C_int%7B1, 44, 2%7D%7D,%0A%09%7B%22kern.tty.tk_rawcc%22, %5B%5D_C_int%7B1, 44, 3%7D%7D,%0A%09%7B%22kern.tty.ttyinfo%22, %5B%5D_C_int%7B1, 44, 5%7D%7D,%0A%09%7B%22kern.ttycount%22, %5B%5D_C_int%7B1, 57%7D%7D,%0A%09%7B%22kern.version%22, %5B%5D_C_int%7B1, 4%7D%7D,%0A%09%7B%22kern.watchdog.auto%22, %5B%5D_C_int%7B1, 64, 2%7D%7D,%0A%09%7B%22kern.watchdog.period%22, %5B%5D_C_int%7B1, 64, 1%7D%7D,%0A%09%7B%22kern.wxabort%22, %5B%5D_C_int%7B1, 74%7D%7D,%0A%09%7B%22net.bpf.bufsize%22, %5B%5D_C_int%7B4, 31, 1%7D%7D,%0A%09%7B%22net.bpf.maxbufsize%22, %5B%5D_C_int%7B4, 31, 2%7D%7D,%0A%09%7B%22net.inet.ah.enable%22, %5B%5D_C_int%7B4, 2, 51, 1%7D%7D,%0A%09%7B%22net.inet.ah.stats%22, %5B%5D_C_int%7B4, 2, 51, 2%7D%7D,%0A%09%7B%22net.inet.carp.allow%22, %5B%5D_C_int%7B4, 2, 112, 1%7D%7D,%0A%09%7B%22net.inet.carp.log%22, %5B%5D_C_int%7B4, 2, 112, 3%7D%7D,%0A%09%7B%22net.inet.carp.preempt%22, %5B%5D_C_int%7B4, 2, 112, 2%7D%7D,%0A%09%7B%22net.inet.carp.stats%22, %5B%5D_C_int%7B4, 2, 112, 4%7D%7D,%0A%09%7B%22net.inet.divert.recvspace%22, %5B%5D_C_int%7B4, 2, 258, 1%7D%7D,%0A%09%7B%22net.inet.divert.sendspace%22, %5B%5D_C_int%7B4, 2, 258, 2%7D%7D,%0A%09%7B%22net.inet.divert.stats%22, %5B%5D_C_int%7B4, 2, 258, 3%7D%7D,%0A%09%7B%22net.inet.esp.enable%22, %5B%5D_C_int%7B4, 2, 50, 1%7D%7D,%0A%09%7B%22net.inet.esp.stats%22, %5B%5D_C_int%7B4, 2, 50, 4%7D%7D,%0A%09%7B%22net.inet.esp.udpencap%22, %5B%5D_C_int%7B4, 2, 50, 2%7D%7D,%0A%09%7B%22net.inet.esp.udpencap_port%22, %5B%5D_C_int%7B4, 2, 50, 3%7D%7D,%0A%09%7B%22net.inet.etherip.allow%22, %5B%5D_C_int%7B4, 2, 97, 1%7D%7D,%0A%09%7B%22net.inet.etherip.stats%22, %5B%5D_C_int%7B4, 2, 97, 2%7D%7D,%0A%09%7B%22net.inet.gre.allow%22, %5B%5D_C_int%7B4, 2, 47, 1%7D%7D,%0A%09%7B%22net.inet.gre.wccp%22, %5B%5D_C_int%7B4, 2, 47, 2%7D%7D,%0A%09%7B%22net.inet.icmp.bmcastecho%22, %5B%5D_C_int%7B4, 2, 1, 2%7D%7D,%0A%09%7B%22net.inet.icmp.errppslimit%22, %5B%5D_C_int%7B4, 2, 1, 3%7D%7D,%0A%09%7B%22net.inet.icmp.maskrepl%22, %5B%5D_C_int%7B4, 2, 1, 1%7D%7D,%0A%09%7B%22net.inet.icmp.rediraccept%22, %5B%5D_C_int%7B4, 2, 1, 4%7D%7D,%0A%09%7B%22net.inet.icmp.redirtimeout%22, %5B%5D_C_int%7B4, 2, 1, 5%7D%7D,%0A%09%7B%22net.inet.icmp.stats%22, %5B%5D_C_int%7B4, 2, 1, 7%7D%7D,%0A%09%7B%22net.inet.icmp.tstamprepl%22, %5B%5D_C_int%7B4, 2, 1, 6%7D%7D,%0A%09%7B%22net.inet.igmp.stats%22, %5B%5D_C_int%7B4, 2, 2, 1%7D%7D,%0A%09%7B%22net.inet.ip.arpdown%22, %5B%5D_C_int%7B4, 2, 0, 40%7D%7D,%0A%09%7B%22net.inet.ip.arpqueued%22, %5B%5D_C_int%7B4, 2, 0, 36%7D%7D,%0A%09%7B%22net.inet.ip.arptimeout%22, %5B%5D_C_int%7B4, 2, 0, 39%7D%7D,%0A%09%7B%22net.inet.ip.encdebug%22, %5B%5D_C_int%7B4, 2, 0, 12%7D%7D,%0A%09%7B%22net.inet.ip.forwarding%22, %5B%5D_C_int%7B4, 2, 0, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.congestion%22, %5B%5D_C_int%7B4, 2, 0, 30, 4%7D%7D,%0A%09%7B%22net.inet.ip.ifq.drops%22, %5B%5D_C_int%7B4, 2, 0, 30, 3%7D%7D,%0A%09%7B%22net.inet.ip.ifq.len%22, %5B%5D_C_int%7B4, 2, 0, 30, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.maxlen%22, %5B%5D_C_int%7B4, 2, 0, 30, 2%7D%7D,%0A%09%7B%22net.inet.ip.maxqueue%22, %5B%5D_C_int%7B4, 2, 0, 11%7D%7D,%0A%09%7B%22net.inet.ip.mforwarding%22, %5B%5D_C_int%7B4, 2, 0, 31%7D%7D,%0A%09%7B%22net.inet.ip.mrtmfc%22, %5B%5D_C_int%7B4, 2, 0, 37%7D%7D,%0A%09%7B%22net.inet.ip.mrtproto%22, %5B%5D_C_int%7B4, 2, 0, 34%7D%7D,%0A%09%7B%22net.inet.ip.mrtstats%22, %5B%5D_C_int%7B4, 2, 0, 35%7D%7D,%0A%09%7B%22net.inet.ip.mrtvif%22, %5B%5D_C_int%7B4, 2, 0, 38%7D%7D,%0A%09%7B%22net.inet.ip.mtu%22, %5B%5D_C_int%7B4, 2, 0, 4%7D%7D,%0A%09%7B%22net.inet.ip.mtudisc%22, %5B%5D_C_int%7B4, 2, 0, 27%7D%7D,%0A%09%7B%22net.inet.ip.mtudisctimeout%22, %5B%5D_C_int%7B4, 2, 0, 28%7D%7D,%0A%09%7B%22net.inet.ip.multipath%22, %5B%5D_C_int%7B4, 2, 0, 32%7D%7D,%0A%09%7B%22net.inet.ip.portfirst%22, %5B%5D_C_int%7B4, 2, 0, 7%7D%7D,%0A%09%7B%22net.inet.ip.porthifirst%22, %5B%5D_C_int%7B4, 2, 0, 9%7D%7D,%0A%09%7B%22net.inet.ip.porthilast%22, %5B%5D_C_int%7B4, 2, 0, 10%7D%7D,%0A%09%7B%22net.inet.ip.portlast%22, %5B%5D_C_int%7B4, 2, 0, 8%7D%7D,%0A%09%7B%22net.inet.ip.redirect%22, %5B%5D_C_int%7B4, 2, 0, 2%7D%7D,%0A%09%7B%22net.inet.ip.sourceroute%22, %5B%5D_C_int%7B4, 2, 0, 5%7D%7D,%0A%09%7B%22net.inet.ip.stats%22, %5B%5D_C_int%7B4, 2, 0, 33%7D%7D,%0A%09%7B%22net.inet.ip.ttl%22, %5B%5D_C_int%7B4, 2, 0, 3%7D%7D,%0A%09%7B%22net.inet.ipcomp.enable%22, %5B%5D_C_int%7B4, 2, 108, 1%7D%7D,%0A%09%7B%22net.inet.ipcomp.stats%22, %5B%5D_C_int%7B4, 2, 108, 2%7D%7D,%0A%09%7B%22net.inet.ipip.allow%22, %5B%5D_C_int%7B4, 2, 4, 1%7D%7D,%0A%09%7B%22net.inet.ipip.stats%22, %5B%5D_C_int%7B4, 2, 4, 2%7D%7D,%0A%09%7B%22net.inet.mobileip.allow%22, %5B%5D_C_int%7B4, 2, 55, 1%7D%7D,%0A%09%7B%22net.inet.pfsync.stats%22, %5B%5D_C_int%7B4, 2, 240, 1%7D%7D,%0A%09%7B%22net.inet.tcp.ackonpush%22, %5B%5D_C_int%7B4, 2, 6, 13%7D%7D,%0A%09%7B%22net.inet.tcp.always_keepalive%22, %5B%5D_C_int%7B4, 2, 6, 22%7D%7D,%0A%09%7B%22net.inet.tcp.baddynamic%22, %5B%5D_C_int%7B4, 2, 6, 6%7D%7D,%0A%09%7B%22net.inet.tcp.drop%22, %5B%5D_C_int%7B4, 2, 6, 19%7D%7D,%0A%09%7B%22net.inet.tcp.ecn%22, %5B%5D_C_int%7B4, 2, 6, 14%7D%7D,%0A%09%7B%22net.inet.tcp.ident%22, %5B%5D_C_int%7B4, 2, 6, 9%7D%7D,%0A%09%7B%22net.inet.tcp.keepidle%22, %5B%5D_C_int%7B4, 2, 6, 3%7D%7D,%0A%09%7B%22net.inet.tcp.keepinittime%22, %5B%5D_C_int%7B4, 2, 6, 2%7D%7D,%0A%09%7B%22net.inet.tcp.keepintvl%22, %5B%5D_C_int%7B4, 2, 6, 4%7D%7D,%0A%09%7B%22net.inet.tcp.mssdflt%22, %5B%5D_C_int%7B4, 2, 6, 11%7D%7D,%0A%09%7B%22net.inet.tcp.reasslimit%22, %5B%5D_C_int%7B4, 2, 6, 18%7D%7D,%0A%09%7B%22net.inet.tcp.rfc1323%22, %5B%5D_C_int%7B4, 2, 6, 1%7D%7D,%0A%09%7B%22net.inet.tcp.rfc3390%22, %5B%5D_C_int%7B4, 2, 6, 17%7D%7D,%0A%09%7B%22net.inet.tcp.rootonly%22, %5B%5D_C_int%7B4, 2, 6, 24%7D%7D,%0A%09%7B%22net.inet.tcp.rstppslimit%22, %5B%5D_C_int%7B4, 2, 6, 12%7D%7D,%0A%09%7B%22net.inet.tcp.sack%22, %5B%5D_C_int%7B4, 2, 6, 10%7D%7D,%0A%09%7B%22net.inet.tcp.sackholelimit%22, %5B%5D_C_int%7B4, 2, 6, 20%7D%7D,%0A%09%7B%22net.inet.tcp.slowhz%22, %5B%5D_C_int%7B4, 2, 6, 5%7D%7D,%0A%09%7B%22net.inet.tcp.stats%22, %5B%5D_C_int%7B4, 2, 6, 21%7D%7D,%0A%09%7B%22net.inet.tcp.synbucketlimit%22, %5B%5D_C_int%7B4, 2, 6, 16%7D%7D,%0A%09%7B%22net.inet.tcp.syncachelimit%22, %5B%5D_C_int%7B4, 2, 6, 15%7D%7D,%0A%09%7B%22net.inet.tcp.synhashsize%22, %5B%5D_C_int%7B4, 2, 6, 25%7D%7D,%0A%09%7B%22net.inet.tcp.synuselimit%22, %5B%5D_C_int%7B4, 2, 6, 23%7D%7D,%0A%09%7B%22net.inet.udp.baddynamic%22, %5B%5D_C_int%7B4, 2, 17, 2%7D%7D,%0A%09%7B%22net.inet.udp.checksum%22, %5B%5D_C_int%7B4, 2, 17, 1%7D%7D,%0A%09%7B%22net.inet.udp.recvspace%22, %5B%5D_C_int%7B4, 2, 17, 3%7D%7D,%0A%09%7B%22net.inet.udp.rootonly%22, %5B%5D_C_int%7B4, 2, 17, 6%7D%7D,%0A%09%7B%22net.inet.udp.sendspace%22, %5B%5D_C_int%7B4, 2, 17, 4%7D%7D,%0A%09%7B%22net.inet.udp.stats%22, %5B%5D_C_int%7B4, 2, 17, 5%7D%7D,%0A%09%7B%22net.inet6.divert.recvspace%22, %5B%5D_C_int%7B4, 24, 86, 1%7D%7D,%0A%09%7B%22net.inet6.divert.sendspace%22, %5B%5D_C_int%7B4, 24, 86, 2%7D%7D,%0A%09%7B%22net.inet6.divert.stats%22, %5B%5D_C_int%7B4, 24, 86, 3%7D%7D,%0A%09%7B%22net.inet6.icmp6.errppslimit%22, %5B%5D_C_int%7B4, 24, 30, 14%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_hiwat%22, %5B%5D_C_int%7B4, 24, 30, 16%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_lowat%22, %5B%5D_C_int%7B4, 24, 30, 17%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_debug%22, %5B%5D_C_int%7B4, 24, 30, 18%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_delay%22, %5B%5D_C_int%7B4, 24, 30, 8%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_maxnudhint%22, %5B%5D_C_int%7B4, 24, 30, 15%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_mmaxtries%22, %5B%5D_C_int%7B4, 24, 30, 10%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_umaxtries%22, %5B%5D_C_int%7B4, 24, 30, 9%7D%7D,%0A%09%7B%22net.inet6.icmp6.redirtimeout%22, %5B%5D_C_int%7B4, 24, 30, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.auto_flowlabel%22, %5B%5D_C_int%7B4, 24, 17, 17%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_count%22, %5B%5D_C_int%7B4, 24, 17, 16%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_pending%22, %5B%5D_C_int%7B4, 24, 17, 49%7D%7D,%0A%09%7B%22net.inet6.ip6.defmcasthlim%22, %5B%5D_C_int%7B4, 24, 17, 18%7D%7D,%0A%09%7B%22net.inet6.ip6.forwarding%22, %5B%5D_C_int%7B4, 24, 17, 1%7D%7D,%0A%09%7B%22net.inet6.ip6.forwsrcrt%22, %5B%5D_C_int%7B4, 24, 17, 5%7D%7D,%0A%09%7B%22net.inet6.ip6.hdrnestlimit%22, %5B%5D_C_int%7B4, 24, 17, 15%7D%7D,%0A%09%7B%22net.inet6.ip6.hlim%22, %5B%5D_C_int%7B4, 24, 17, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.log_interval%22, %5B%5D_C_int%7B4, 24, 17, 14%7D%7D,%0A%09%7B%22net.inet6.ip6.maxdynroutes%22, %5B%5D_C_int%7B4, 24, 17, 48%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfragpackets%22, %5B%5D_C_int%7B4, 24, 17, 9%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfrags%22, %5B%5D_C_int%7B4, 24, 17, 41%7D%7D,%0A%09%7B%22net.inet6.ip6.mforwarding%22, %5B%5D_C_int%7B4, 24, 17, 42%7D%7D,%0A%09%7B%22net.inet6.ip6.mrtmfc%22, %5B%5D_C_int%7B4, 24, 17, 53%7D%7D,%0A%09%7B%22net.inet6.ip6.mrtmif%22, %5B%5D_C_int%7B4, 24, 17, 52%7D%7D,%0A%09%7B%22net.inet6.ip6.mrtproto%22, %5B%5D_C_int%7B4, 24, 17, 8%7D%7D,%0A%09%7B%22net.inet6.ip6.mtudisctimeout%22, %5B%5D_C_int%7B4, 24, 17, 50%7D%7D,%0A%09%7B%22net.inet6.ip6.multicast_mtudisc%22, %5B%5D_C_int%7B4, 24, 17, 44%7D%7D,%0A%09%7B%22net.inet6.ip6.multipath%22, %5B%5D_C_int%7B4, 24, 17, 43%7D%7D,%0A%09%7B%22net.inet6.ip6.neighborgcthresh%22, %5B%5D_C_int%7B4, 24, 17, 45%7D%7D,%0A%09%7B%22net.inet6.ip6.redirect%22, %5B%5D_C_int%7B4, 24, 17, 2%7D%7D,%0A%09%7B%22net.inet6.ip6.soiikey%22, %5B%5D_C_int%7B4, 24, 17, 54%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck%22, %5B%5D_C_int%7B4, 24, 17, 10%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck_logint%22, %5B%5D_C_int%7B4, 24, 17, 11%7D%7D,%0A%09%7B%22net.inet6.ip6.use_deprecated%22, %5B%5D_C_int%7B4, 24, 17, 21%7D%7D,%0A%09%7B%22net.key.sadb_dump%22, %5B%5D_C_int%7B4, 30, 1%7D%7D,%0A%09%7B%22net.key.spd_dump%22, %5B%5D_C_int%7B4, 30, 2%7D%7D,%0A%09%7B%22net.mpls.ifq.congestion%22, %5B%5D_C_int%7B4, 33, 3, 4%7D%7D,%0A%09%7B%22net.mpls.ifq.drops%22, %5B%5D_C_int%7B4, 33, 3, 3%7D%7D,%0A%09%7B%22net.mpls.ifq.len%22, %5B%5D_C_int%7B4, 33, 3, 1%7D%7D,%0A%09%7B%22net.mpls.ifq.maxlen%22, %5B%5D_C_int%7B4, 33, 3, 2%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip%22, %5B%5D_C_int%7B4, 33, 5%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip6%22, %5B%5D_C_int%7B4, 33, 6%7D%7D,%0A%09%7B%22net.mpls.maxloop_inkernel%22, %5B%5D_C_int%7B4, 33, 4%7D%7D,%0A%09%7B%22net.mpls.ttl%22, %5B%5D_C_int%7B4, 33, 2%7D%7D,%0A%09%7B%22net.pflow.stats%22, %5B%5D_C_int%7B4, 34, 1%7D%7D,%0A%09%7B%22net.pipex.enable%22, %5B%5D_C_int%7B4, 35, 1%7D%7D,%0A%7D%0A
- f 0a6e625c26f26c12e9034772b7c75c0706159c437c6b8294f18006f5a302bfcf vendor/golang.org/x/sys/unix/zsysctl_openbsd_arm.go
+ f a9c5f81c8053ae7b474a23f0472078d97ab0a10f376809defeb6eebb85a64104 vendor/golang.org/x/sys/unix/zsysctl_openbsd_arm.go
dmppatch 3
@@ -83,8 +83,11902 @@
 ge unix%0A
+%0Atype mibentry struct %7B%0A%09ctlname string%0A%09ctloid  %5B%5D_C_int%0A%7D%0A%0Avar sysctlMib = %5B%5Dmibentry%7B%0A%09%7B%22ddb.console%22, %5B%5D_C_int%7B9, 6%7D%7D,%0A%09%7B%22ddb.log%22, %5B%5D_C_int%7B9, 7%7D%7D,%0A%09%7B%22ddb.max_line%22, %5B%5D_C_int%7B9, 3%7D%7D,%0A%09%7B%22ddb.max_width%22, %5B%5D_C_int%7B9, 2%7D%7D,%0A%09%7B%22ddb.panic%22, %5B%5D_C_int%7B9, 5%7D%7D,%0A%09%7B%22ddb.radix%22, %5B%5D_C_int%7B9, 1%7D%7D,%0A%09%7B%22ddb.tab_stop_width%22, %5B%5D_C_int%7B9, 4%7D%7D,%0A%09%7B%22ddb.trigger%22, %5B%5D_C_int%7B9, 8%7D%7D,%0A%09%7B%22fs.posix.setuid%22, %5B%5D_C_int%7B3, 1, 1%7D%7D,%0A%09%7B%22hw.allowpowerdown%22, %5B%5D_C_int%7B6, 22%7D%7D,%0A%09%7B%22hw.byteorder%22, %5B%5D_C_int%7B6, 4%7D%7D,%0A%09%7B%22hw.cpuspeed%22, %5B%5D_C_int%7B6, 12%7D%7D,%0A%09%7B%22hw.diskcount%22, %5B%5D_C_int%7B6, 10%7D%7D,%0A%09%7B%22hw.disknames%22, %5B%5D_C_int%7B6, 8%7D%7D,%0A%09%7B%22hw.diskstats%22, %5B%5D_C_int%7B6, 9%7D%7D,%0A%09%7B%22hw.machine%22, %5B%5D_C_int%7B6, 1%7D%7D,%0A%09%7B%22hw.model%22, %5B%5D_C_int%7B6, 2%7D%7D,%0A%09%7B%22hw.ncpu%22, %5B%5D_C_int%7B6, 3%7D%7D,%0A%09%7B%22hw.ncpufound%22, %5B%5D_C_int%7B6, 21%7D%7D,%0A%09%7B%22hw.pagesize%22, %5B%5D_C_int%7B6, 7%7D%7D,%0A%09%7B%22hw.physmem%22, %5B%5D_C_int%7B6, 19%7D%7D,%0A%09%7B%22hw.product%22, %5B%5D_C_int%7B6, 15%7D%7D,%0A%09%7B%22hw.serialno%22, %5B%5D_C_int%7B6, 17%7D%7D,%0A%09%7B%22hw.setperf%22, %5B%5D_C_int%7B6, 13%7D%7D,%0A%09%7B%22hw.usermem%22, %5B%5D_C_int%7B6, 20%7D%7D,%0A%09%7B%22hw.uuid%22, %5B%5D_C_int%7B6, 18%7D%7D,%0A%09%7B%22hw.vendor%22, %5B%5D_C_int%7B6, 14%7D%7D,%0A%09%7B%22hw.version%22, %5B%5D_C_int%7B6, 16%7D%7D,%0A%09%7B%22kern.arandom%22, %5B%5D_C_int%7B1, 37%7D%7D,%0A%09%7B%22kern.argmax%22, %5B%5D_C_int%7B1, 8%7D%7D,%0A%09%7B%22kern.boottime%22, %5B%5D_C_int%7B1, 21%7D%7D,%0A%09%7B%22kern.bufcachepercent%22, %5B%5D_C_int%7B1, 72%7D%7D,%0A%09%7B%22kern.ccpu%22, %5B%5D_C_int%7B1, 45%7D%7D,%0A%09%7B%22kern.clockrate%22, %5B%5D_C_int%7B1, 12%7D%7D,%0A%09%7B%22kern.consdev%22, %5B%5D_C_int%7B1, 75%7D%7D,%0A%09%7B%22kern.cp_time%22, %5B%5D_C_int%7B1, 40%7D%7D,%0A%09%7B%22kern.cp_time2%22, %5B%5D_C_int%7B1, 71%7D%7D,%0A%09%7B%22kern.cryptodevallowsoft%22, %5B%5D_C_int%7B1, 53%7D%7D,%0A%09%7B%22kern.domainname%22, %5B%5D_C_int%7B1, 22%7D%7D,%0A%09%7B%22kern.file%22, %5B%5D_C_int%7B1, 73%7D%7D,%0A%09%7B%22kern.forkstat%22, %5B%5D_C_int%7B1, 42%7D%7D,%0A%09%7B%22kern.fscale%22, %5B%5D_C_int%7B1, 46%7D%7D,%0A%09%7B%22kern.fsync%22, %5B%5D_C_int%7B1, 33%7D%7D,%0A%09%7B%22kern.hostid%22, %5B%5D_C_int%7B1, 11%7D%7D,%0A%09%7B%22kern.hostname%22, %5B%5D_C_int%7B1, 10%7D%7D,%0A%09%7B%22kern.intrcnt.nintrcnt%22, %5B%5D_C_int%7B1, 63, 1%7D%7D,%0A%09%7B%22kern.job_control%22, %5B%5D_C_int%7B1, 19%7D%7D,%0A%09%7B%22kern.malloc.buckets%22, %5B%5D_C_int%7B1, 39, 1%7D%7D,%0A%09%7B%22kern.malloc.kmemnames%22, %5B%5D_C_int%7B1, 39, 3%7D%7D,%0A%09%7B%22kern.maxclusters%22, %5B%5D_C_int%7B1, 67%7D%7D,%0A%09%7B%22kern.maxfiles%22, %5B%5D_C_int%7B1, 7%7D%7D,%0A%09%7B%22kern.maxlocksperuid%22, %5B%5D_C_int%7B1, 70%7D%7D,%0A%09%7B%22kern.maxpartitions%22, %5B%5D_C_int%7B1, 23%7D%7D,%0A%09%7B%22kern.maxproc%22, %5B%5D_C_int%7B1, 6%7D%7D,%0A%09%7B%22kern.maxthread%22, %5B%5D_C_int%7B1, 25%7D%7D,%0A%09%7B%22kern.maxvnodes%22, %5B%5D_C_int%7B1, 5%7D%7D,%0A%09%7B%22kern.mbstat%22, %5B%5D_C_int%7B1, 59%7D%7D,%0A%09%7B%22kern.msgbuf%22, %5B%5D_C_int%7B1, 48%7D%7D,%0A%09%7B%22kern.msgbufsize%22, %5B%5D_C_int%7B1, 38%7D%7D,%0A%09%7B%22kern.nchstats%22, %5B%5D_C_int%7B1, 41%7D%7D,%0A%09%7B%22kern.netlivelocks%22, %5B%5D_C_int%7B1, 76%7D%7D,%0A%09%7B%22kern.nfiles%22, %5B%5D_C_int%7B1, 56%7D%7D,%0A%09%7B%22kern.ngroups%22, %5B%5D_C_int%7B1, 18%7D%7D,%0A%09%7B%22kern.nosuidcoredump%22, %5B%5D_C_int%7B1, 32%7D%7D,%0A%09%7B%22kern.nprocs%22, %5B%5D_C_int%7B1, 47%7D%7D,%0A%09%7B%22kern.nselcoll%22, %5B%5D_C_int%7B1, 43%7D%7D,%0A%09%7B%22kern.nthreads%22, %5B%5D_C_int%7B1, 26%7D%7D,%0A%09%7B%22kern.numvnodes%22, %5B%5D_C_int%7B1, 58%7D%7D,%0A%09%7B%22kern.osrelease%22, %5B%5D_C_int%7B1, 2%7D%7D,%0A%09%7B%22kern.osrevision%22, %5B%5D_C_int%7B1, 3%7D%7D,%0A%09%7B%22kern.ostype%22, %5B%5D_C_int%7B1, 1%7D%7D,%0A%09%7B%22kern.osversion%22, %5B%5D_C_int%7B1, 27%7D%7D,%0A%09%7B%22kern.pool_debug%22, %5B%5D_C_int%7B1, 77%7D%7D,%0A%09%7B%22kern.posix1version%22, %5B%5D_C_int%7B1, 17%7D%7D,%0A%09%7B%22kern.proc%22, %5B%5D_C_int%7B1, 66%7D%7D,%0A%09%7B%22kern.random%22, %5B%5D_C_int%7B1, 31%7D%7D,%0A%09%7B%22kern.rawpartition%22, %5B%5D_C_int%7B1, 24%7D%7D,%0A%09%7B%22kern.saved_ids%22, %5B%5D_C_int%7B1, 20%7D%7D,%0A%09%7B%22kern.securelevel%22, %5B%5D_C_int%7B1, 9%7D%7D,%0A%09%7B%22kern.seminfo%22, %5B%5D_C_int%7B1, 61%7D%7D,%0A%09%7B%22kern.shminfo%22, %5B%5D_C_int%7B1, 62%7D%7D,%0A%09%7B%22kern.somaxconn%22, %5B%5D_C_int%7B1, 28%7D%7D,%0A%09%7B%22kern.sominconn%22, %5B%5D_C_int%7B1, 29%7D%7D,%0A%09%7B%22kern.splassert%22, %5B%5D_C_int%7B1, 54%7D%7D,%0A%09%7B%22kern.stackgap_random%22, %5B%5D_C_int%7B1, 50%7D%7D,%0A%09%7B%22kern.sysvipc_info%22, %5B%5D_C_int%7B1, 51%7D%7D,%0A%09%7B%22kern.sysvmsg%22, %5B%5D_C_int%7B1, 34%7D%7D,%0A%09%7B%22kern.sysvsem%22, %5B%5D_C_int%7B1, 35%7D%7D,%0A%09%7B%22kern.sysvshm%22, %5B%5D_C_int%7B1, 36%7D%7D,%0A%09%7B%22kern.timecounter.choice%22, %5B%5D_C_int%7B1, 69, 4%7D%7D,%0A%09%7B%22kern.timecounter.hardware%22, %5B%5D_C_int%7B1, 69, 3%7D%7D,%0A%09%7B%22kern.timecounter.tick%22, %5B%5D_C_int%7B1, 69, 1%7D%7D,%0A%09%7B%22kern.timecounter.timestepwarnings%22, %5B%5D_C_int%7B1, 69, 2%7D%7D,%0A%09%7B%22kern.tty.maxptys%22, %5B%5D_C_int%7B1, 44, 6%7D%7D,%0A%09%7B%22kern.tty.nptys%22, %5B%5D_C_int%7B1, 44, 7%7D%7D,%0A%09%7B%22kern.tty.tk_cancc%22, %5B%5D_C_int%7B1, 44, 4%7D%7D,%0A%09%7B%22kern.tty.tk_nin%22, %5B%5D_C_int%7B1, 44, 1%7D%7D,%0A%09%7B%22kern.tty.tk_nout%22, %5B%5D_C_int%7B1, 44, 2%7D%7D,%0A%09%7B%22kern.tty.tk_rawcc%22, %5B%5D_C_int%7B1, 44, 3%7D%7D,%0A%09%7B%22kern.tty.ttyinfo%22, %5B%5D_C_int%7B1, 44, 5%7D%7D,%0A%09%7B%22kern.ttycount%22, %5B%5D_C_int%7B1, 57%7D%7D,%0A%09%7B%22kern.userasymcrypto%22, %5B%5D_C_int%7B1, 60%7D%7D,%0A%09%7B%22kern.usercrypto%22, %5B%5D_C_int%7B1, 52%7D%7D,%0A%09%7B%22kern.usermount%22, %5B%5D_C_int%7B1, 30%7D%7D,%0A%09%7B%22kern.version%22, %5B%5D_C_int%7B1, 4%7D%7D,%0A%09%7B%22kern.vnode%22, %5B%5D_C_int%7B1, 13%7D%7D,%0A%09%7B%22kern.watchdog.auto%22, %5B%5D_C_int%7B1, 64, 2%7D%7D,%0A%09%7B%22kern.watchdog.period%22, %5B%5D_C_int%7B1, 64, 1%7D%7D,%0A%09%7B%22net.bpf.bufsize%22, %5B%5D_C_int%7B4, 31, 1%7D%7D,%0A%09%7B%22net.bpf.maxbufsize%22, %5B%5D_C_int%7B4, 31, 2%7D%7D,%0A%09%7B%22net.inet.ah.enable%22, %5B%5D_C_int%7B4, 2, 51, 1%7D%7D,%0A%09%7B%22net.inet.ah.stats%22, %5B%5D_C_int%7B4, 2, 51, 2%7D%7D,%0A%09%7B%22net.inet.carp.allow%22, %5B%5D_C_int%7B4, 2, 112, 1%7D%7D,%0A%09%7B%22net.inet.carp.log%22, %5B%5D_C_int%7B4, 2, 112, 3%7D%7D,%0A%09%7B%22net.inet.carp.preempt%22, %5B%5D_C_int%7B4, 2, 112, 2%7D%7D,%0A%09%7B%22net.inet.carp.stats%22, %5B%5D_C_int%7B4, 2, 112, 4%7D%7D,%0A%09%7B%22net.inet.divert.recvspace%22, %5B%5D_C_int%7B4, 2, 258, 1%7D%7D,%0A%09%7B%22net.inet.divert.sendspace%22, %5B%5D_C_int%7B4, 2, 258, 2%7D%7D,%0A%09%7B%22net.inet.divert.stats%22, %5B%5D_C_int%7B4, 2, 258, 3%7D%7D,%0A%09%7B%22net.inet.esp.enable%22, %5B%5D_C_int%7B4, 2, 50, 1%7D%7D,%0A%09%7B%22net.inet.esp.stats%22, %5B%5D_C_int%7B4, 2, 50, 4%7D%7D,%0A%09%7B%22net.inet.esp.udpencap%22, %5B%5D_C_int%7B4, 2, 50, 2%7D%7D,%0A%09%7B%22net.inet.esp.udpencap_port%22, %5B%5D_C_int%7B4, 2, 50, 3%7D%7D,%0A%09%7B%22net.inet.etherip.allow%22, %5B%5D_C_int%7B4, 2, 97, 1%7D%7D,%0A%09%7B%22net.inet.etherip.stats%22, %5B%5D_C_int%7B4, 2, 97, 2%7D%7D,%0A%09%7B%22net.inet.gre.allow%22, %5B%5D_C_int%7B4, 2, 47, 1%7D%7D,%0A%09%7B%22net.inet.gre.wccp%22, %5B%5D_C_int%7B4, 2, 47, 2%7D%7D,%0A%09%7B%22net.inet.icmp.bmcastecho%22, %5B%5D_C_int%7B4, 2, 1, 2%7D%7D,%0A%09%7B%22net.inet.icmp.errppslimit%22, %5B%5D_C_int%7B4, 2, 1, 3%7D%7D,%0A%09%7B%22net.inet.icmp.maskrepl%22, %5B%5D_C_int%7B4, 2, 1, 1%7D%7D,%0A%09%7B%22net.inet.icmp.rediraccept%22, %5B%5D_C_int%7B4, 2, 1, 4%7D%7D,%0A%09%7B%22net.inet.icmp.redirtimeout%22, %5B%5D_C_int%7B4, 2, 1, 5%7D%7D,%0A%09%7B%22net.inet.icmp.stats%22, %5B%5D_C_int%7B4, 2, 1, 7%7D%7D,%0A%09%7B%22net.inet.icmp.tstamprepl%22, %5B%5D_C_int%7B4, 2, 1, 6%7D%7D,%0A%09%7B%22net.inet.igmp.stats%22, %5B%5D_C_int%7B4, 2, 2, 1%7D%7D,%0A%09%7B%22net.inet.ip.arpqueued%22, %5B%5D_C_int%7B4, 2, 0, 36%7D%7D,%0A%09%7B%22net.inet.ip.encdebug%22, %5B%5D_C_int%7B4, 2, 0, 12%7D%7D,%0A%09%7B%22net.inet.ip.forwarding%22, %5B%5D_C_int%7B4, 2, 0, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.congestion%22, %5B%5D_C_int%7B4, 2, 0, 30, 4%7D%7D,%0A%09%7B%22net.inet.ip.ifq.drops%22, %5B%5D_C_int%7B4, 2, 0, 30, 3%7D%7D,%0A%09%7B%22net.inet.ip.ifq.len%22, %5B%5D_C_int%7B4, 2, 0, 30, 1%7D%7D,%0A%09%7B%22net.inet.ip.ifq.maxlen%22, %5B%5D_C_int%7B4, 2, 0, 30, 2%7D%7D,%0A%09%7B%22net.inet.ip.maxqueue%22, %5B%5D_C_int%7B4, 2, 0, 11%7D%7D,%0A%09%7B%22net.inet.ip.mforwarding%22, %5B%5D_C_int%7B4, 2, 0, 31%7D%7D,%0A%09%7B%22net.inet.ip.mrtproto%22, %5B%5D_C_int%7B4, 2, 0, 34%7D%7D,%0A%09%7B%22net.inet.ip.mrtstats%22, %5B%5D_C_int%7B4, 2, 0, 35%7D%7D,%0A%09%7B%22net.inet.ip.mtu%22, %5B%5D_C_int%7B4, 2, 0, 4%7D%7D,%0A%09%7B%22net.inet.ip.mtudisc%22, %5B%5D_C_int%7B4, 2, 0, 27%7D%7D,%0A%09%7B%22net.inet.ip.mtudisctimeout%22, %5B%5D_C_int%7B4, 2, 0, 28%7D%7D,%0A%09%7B%22net.inet.ip.multipath%22, %5B%5D_C_int%7B4, 2, 0, 32%7D%7D,%0A%09%7B%22net.inet.ip.portfirst%22, %5B%5D_C_int%7B4, 2, 0, 7%7D%7D,%0A%09%7B%22net.inet.ip.porthifirst%22, %5B%5D_C_int%7B4, 2, 0, 9%7D%7D,%0A%09%7B%22net.inet.ip.porthilast%22, %5B%5D_C_int%7B4, 2, 0, 10%7D%7D,%0A%09%7B%22net.inet.ip.portlast%22, %5B%5D_C_int%7B4, 2, 0, 8%7D%7D,%0A%09%7B%22net.inet.ip.redirect%22, %5B%5D_C_int%7B4, 2, 0, 2%7D%7D,%0A%09%7B%22net.inet.ip.sourceroute%22, %5B%5D_C_int%7B4, 2, 0, 5%7D%7D,%0A%09%7B%22net.inet.ip.stats%22, %5B%5D_C_int%7B4, 2, 0, 33%7D%7D,%0A%09%7B%22net.inet.ip.ttl%22, %5B%5D_C_int%7B4, 2, 0, 3%7D%7D,%0A%09%7B%22net.inet.ipcomp.enable%22, %5B%5D_C_int%7B4, 2, 108, 1%7D%7D,%0A%09%7B%22net.inet.ipcomp.stats%22, %5B%5D_C_int%7B4, 2, 108, 2%7D%7D,%0A%09%7B%22net.inet.ipip.allow%22, %5B%5D_C_int%7B4, 2, 4, 1%7D%7D,%0A%09%7B%22net.inet.ipip.stats%22, %5B%5D_C_int%7B4, 2, 4, 2%7D%7D,%0A%09%7B%22net.inet.mobileip.allow%22, %5B%5D_C_int%7B4, 2, 55, 1%7D%7D,%0A%09%7B%22net.inet.pfsync.stats%22, %5B%5D_C_int%7B4, 2, 240, 1%7D%7D,%0A%09%7B%22net.inet.pim.stats%22, %5B%5D_C_int%7B4, 2, 103, 1%7D%7D,%0A%09%7B%22net.inet.tcp.ackonpush%22, %5B%5D_C_int%7B4, 2, 6, 13%7D%7D,%0A%09%7B%22net.inet.tcp.always_keepalive%22, %5B%5D_C_int%7B4, 2, 6, 22%7D%7D,%0A%09%7B%22net.inet.tcp.baddynamic%22, %5B%5D_C_int%7B4, 2, 6, 6%7D%7D,%0A%09%7B%22net.inet.tcp.drop%22, %5B%5D_C_int%7B4, 2, 6, 19%7D%7D,%0A%09%7B%22net.inet.tcp.ecn%22, %5B%5D_C_int%7B4, 2, 6, 14%7D%7D,%0A%09%7B%22net.inet.tcp.ident%22, %5B%5D_C_int%7B4, 2, 6, 9%7D%7D,%0A%09%7B%22net.inet.tcp.keepidle%22, %5B%5D_C_int%7B4, 2, 6, 3%7D%7D,%0A%09%7B%22net.inet.tcp.keepinittime%22, %5B%5D_C_int%7B4, 2, 6, 2%7D%7D,%0A%09%7B%22net.inet.tcp.keepintvl%22, %5B%5D_C_int%7B4, 2, 6, 4%7D%7D,%0A%09%7B%22net.inet.tcp.mssdflt%22, %5B%5D_C_int%7B4, 2, 6, 11%7D%7D,%0A%09%7B%22net.inet.tcp.reasslimit%22, %5B%5D_C_int%7B4, 2, 6, 18%7D%7D,%0A%09%7B%22net.inet.tcp.rfc1323%22, %5B%5D_C_int%7B4, 2, 6, 1%7D%7D,%0A%09%7B%22net.inet.tcp.rfc3390%22, %5B%5D_C_int%7B4, 2, 6, 17%7D%7D,%0A%09%7B%22net.inet.tcp.rstppslimit%22, %5B%5D_C_int%7B4, 2, 6, 12%7D%7D,%0A%09%7B%22net.inet.tcp.sack%22, %5B%5D_C_int%7B4, 2, 6, 10%7D%7D,%0A%09%7B%22net.inet.tcp.sackholelimit%22, %5B%5D_C_int%7B4, 2, 6, 20%7D%7D,%0A%09%7B%22net.inet.tcp.slowhz%22, %5B%5D_C_int%7B4, 2, 6, 5%7D%7D,%0A%09%7B%22net.inet.tcp.stats%22, %5B%5D_C_int%7B4, 2, 6, 21%7D%7D,%0A%09%7B%22net.inet.tcp.synbucketlimit%22, %5B%5D_C_int%7B4, 2, 6, 16%7D%7D,%0A%09%7B%22net.inet.tcp.syncachelimit%22, %5B%5D_C_int%7B4, 2, 6, 15%7D%7D,%0A%09%7B%22net.inet.udp.baddynamic%22, %5B%5D_C_int%7B4, 2, 17, 2%7D%7D,%0A%09%7B%22net.inet.udp.checksum%22, %5B%5D_C_int%7B4, 2, 17, 1%7D%7D,%0A%09%7B%22net.inet.udp.recvspace%22, %5B%5D_C_int%7B4, 2, 17, 3%7D%7D,%0A%09%7B%22net.inet.udp.sendspace%22, %5B%5D_C_int%7B4, 2, 17, 4%7D%7D,%0A%09%7B%22net.inet.udp.stats%22, %5B%5D_C_int%7B4, 2, 17, 5%7D%7D,%0A%09%7B%22net.inet6.divert.recvspace%22, %5B%5D_C_int%7B4, 24, 86, 1%7D%7D,%0A%09%7B%22net.inet6.divert.sendspace%22, %5B%5D_C_int%7B4, 24, 86, 2%7D%7D,%0A%09%7B%22net.inet6.divert.stats%22, %5B%5D_C_int%7B4, 24, 86, 3%7D%7D,%0A%09%7B%22net.inet6.icmp6.errppslimit%22, %5B%5D_C_int%7B4, 24, 30, 14%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_hiwat%22, %5B%5D_C_int%7B4, 24, 30, 16%7D%7D,%0A%09%7B%22net.inet6.icmp6.mtudisc_lowat%22, %5B%5D_C_int%7B4, 24, 30, 17%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_debug%22, %5B%5D_C_int%7B4, 24, 30, 18%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_delay%22, %5B%5D_C_int%7B4, 24, 30, 8%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_maxnudhint%22, %5B%5D_C_int%7B4, 24, 30, 15%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_mmaxtries%22, %5B%5D_C_int%7B4, 24, 30, 10%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_prune%22, %5B%5D_C_int%7B4, 24, 30, 6%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_umaxtries%22, %5B%5D_C_int%7B4, 24, 30, 9%7D%7D,%0A%09%7B%22net.inet6.icmp6.nd6_useloopback%22, %5B%5D_C_int%7B4, 24, 30, 11%7D%7D,%0A%09%7B%22net.inet6.icmp6.nodeinfo%22, %5B%5D_C_int%7B4, 24, 30, 13%7D%7D,%0A%09%7B%22net.inet6.icmp6.rediraccept%22, %5B%5D_C_int%7B4, 24, 30, 2%7D%7D,%0A%09%7B%22net.inet6.icmp6.redirtimeout%22, %5B%5D_C_int%7B4, 24, 30, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.accept_rtadv%22, %5B%5D_C_int%7B4, 24, 17, 12%7D%7D,%0A%09%7B%22net.inet6.ip6.auto_flowlabel%22, %5B%5D_C_int%7B4, 24, 17, 17%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_count%22, %5B%5D_C_int%7B4, 24, 17, 16%7D%7D,%0A%09%7B%22net.inet6.ip6.dad_pending%22, %5B%5D_C_int%7B4, 24, 17, 49%7D%7D,%0A%09%7B%22net.inet6.ip6.defmcasthlim%22, %5B%5D_C_int%7B4, 24, 17, 18%7D%7D,%0A%09%7B%22net.inet6.ip6.forwarding%22, %5B%5D_C_int%7B4, 24, 17, 1%7D%7D,%0A%09%7B%22net.inet6.ip6.forwsrcrt%22, %5B%5D_C_int%7B4, 24, 17, 5%7D%7D,%0A%09%7B%22net.inet6.ip6.hdrnestlimit%22, %5B%5D_C_int%7B4, 24, 17, 15%7D%7D,%0A%09%7B%22net.inet6.ip6.hlim%22, %5B%5D_C_int%7B4, 24, 17, 3%7D%7D,%0A%09%7B%22net.inet6.ip6.log_interval%22, %5B%5D_C_int%7B4, 24, 17, 14%7D%7D,%0A%09%7B%22net.inet6.ip6.maxdynroutes%22, %5B%5D_C_int%7B4, 24, 17, 48%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfragpackets%22, %5B%5D_C_int%7B4, 24, 17, 9%7D%7D,%0A%09%7B%22net.inet6.ip6.maxfrags%22, %5B%5D_C_int%7B4, 24, 17, 41%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifdefrouters%22, %5B%5D_C_int%7B4, 24, 17, 47%7D%7D,%0A%09%7B%22net.inet6.ip6.maxifprefixes%22, %5B%5D_C_int%7B4, 24, 17, 46%7D%7D,%0A%09%7B%22net.inet6.ip6.mforwarding%22, %5B%5D_C_int%7B4, 24, 17, 42%7D%7D,%0A%09%7B%22net.inet6.ip6.mrtproto%22, %5B%5D_C_int%7B4, 24, 17, 8%7D%7D,%0A%09%7B%22net.inet6.ip6.mtudisctimeout%22, %5B%5D_C_int%7B4, 24, 17, 50%7D%7D,%0A%09%7B%22net.inet6.ip6.multicast_mtudisc%22, %5B%5D_C_int%7B4, 24, 17, 44%7D%7D,%0A%09%7B%22net.inet6.ip6.multipath%22, %5B%5D_C_int%7B4, 24, 17, 43%7D%7D,%0A%09%7B%22net.inet6.ip6.neighborgcthresh%22, %5B%5D_C_int%7B4, 24, 17, 45%7D%7D,%0A%09%7B%22net.inet6.ip6.redirect%22, %5B%5D_C_int%7B4, 24, 17, 2%7D%7D,%0A%09%7B%22net.inet6.ip6.rr_prune%22, %5B%5D_C_int%7B4, 24, 17, 22%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck%22, %5B%5D_C_int%7B4, 24, 17, 10%7D%7D,%0A%09%7B%22net.inet6.ip6.sourcecheck_logint%22, %5B%5D_C_int%7B4, 24, 17, 11%7D%7D,%0A%09%7B%22net.inet6.ip6.use_deprecated%22, %5B%5D_C_int%7B4, 24, 17, 21%7D%7D,%0A%09%7B%22net.inet6.ip6.v6only%22, %5B%5D_C_int%7B4, 24, 17, 24%7D%7D,%0A%09%7B%22net.key.sadb_dump%22, %5B%5D_C_int%7B4, 30, 1%7D%7D,%0A%09%7B%22net.key.spd_dump%22, %5B%5D_C_int%7B4, 30, 2%7D%7D,%0A%09%7B%22net.mpls.ifq.congestion%22, %5B%5D_C_int%7B4, 33, 3, 4%7D%7D,%0A%09%7B%22net.mpls.ifq.drops%22, %5B%5D_C_int%7B4, 33, 3, 3%7D%7D,%0A%09%7B%22net.mpls.ifq.len%22, %5B%5D_C_int%7B4, 33, 3, 1%7D%7D,%0A%09%7B%22net.mpls.ifq.maxlen%22, %5B%5D_C_int%7B4, 33, 3, 2%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip%22, %5B%5D_C_int%7B4, 33, 5%7D%7D,%0A%09%7B%22net.mpls.mapttl_ip6%22, %5B%5D_C_int%7B4, 33, 6%7D%7D,%0A%09%7B%22net.mpls.maxloop_inkernel%22, %5B%5D_C_int%7B4, 33, 4%7D%7D,%0A%09%7B%22net.mpls.ttl%22, %5B%5D_C_int%7B4, 33, 2%7D%7D,%0A%09%7B%22net.pflow.stats%22, %5B%5D_C_int%7B4, 34, 1%7D%7D,%0A%09%7B%22net.pipex.enable%22, %5B%5D_C_int%7B4, 35, 1%7D%7D,%0A%09%7B%22vm.anonmin%22, %5B%5D_C_int%7B2, 7%7D%7D,%0A%09%7B%22vm.loadavg%22, %5B%5D_C_int%7B2, 2%7D%7D,%0A%09%7B%22vm.maxslp%22, %5B%5D_C_int%7B2, 10%7D%7D,%0A%09%7B%22vm.nkmempages%22, %5B%5D_C_int%7B2, 6%7D%7D,%0A%09%7B%22vm.psstrings%22, %5B%5D_C_int%7B2, 3%7D%7D,%0A%09%7B%22vm.swapencrypt.enable%22, %5B%5D_C_int%7B2, 5, 0%7D%7D,%0A%09%7B%22vm.swapencrypt.keyscreated%22, %5B%5D_C_int%7B2, 5, 1%7D%7D,%0A%09%7B%22vm.swapencrypt.keysdeleted%22, %5B%5D_C_int%7B2, 5, 2%7D%7D,%0A%09%7B%22vm.uspace%22, %5B%5D_C_int%7B2, 11%7D%7D,%0A%09%7B%22vm.uvmexp%22, %5B%5D_C_int%7B2, 4%7D%7D,%0A%09%7B%22vm.vmmeter%22, %5B%5D_C_int%7B2, 1%7D%7D,%0A%09%7B%22vm.vnodemin%22, %5B%5D_C_int%7B2, 9%7D%7D,%0A%09%7B%22vm.vtextmin%22, %5B%5D_C_int%7B2, 8%7D%7D,%0A%7D%0A
- f b1100e5801bb79ba932b0971d8a7aef35f1da2bbb0a73f0ffaf47743a4c9828f vendor/golang.org/x/sys/unix/zsysnum_freebsd_386.go
+ f 2a7fa1f3db1df48a9f4b747e93075e7e445b1ea3f969c0fff87e9ebf037e673e vendor/golang.org/x/sys/unix/zsysnum_freebsd_386.go
dmppatch 5
@@ -201,25423 +201,30051 @@
 int%0A
-%09SYS_EXIT                   = 1   // %7B void sys_exit(int rval); %7D exit %5C%0A%09SYS_FORK                   = 2   // %7B int fork(void); %7D%0A%09SYS_READ                   = 3   // %7B ssize_t read(int fd, void *buf, %5C%0A%09SYS_WRITE                  = 4   // %7B ssize_t write(int fd, const void *buf, %5C%0A%09SYS_OPEN                   = 5   // %7B int open(char *path, int flags, int mode); %7D%0A%09SYS_CLOSE                  = 6   // %7B int close(int fd); %7D%0A%09SYS_WAIT4                  = 7   // %7B int wait4(int pid, int *status, %5C%0A%09SYS_LINK                   = 9   // %7B int link(char *path, char *link); %7D%0A%09SYS_UNLINK                 = 10  // %7B int unlink(char *path); %7D%0A%09SYS_CHDIR                  = 12  // %7B int chdir(char *path); %7D%0A%09SYS_FCHDIR                 = 13  // %7B int fchdir(int fd); %7D%0A%09SYS_MKNOD                  = 14  // %7B int mknod(char *path, int mode, int dev); %7D%0A%09SYS_CHMOD                  = 15  // %7B int chmod(char *path, int mode); %7D%0A%09SYS_CHOWN                  = 16  // %7B int chown(char *path, int uid, int gid); %7D%0A%09SYS_OBREAK                 = 17  // %7B int obreak(char *nsize); %7D break %5C%0A%09SYS_GETPID                 = 20  // %7B pid_t getpid(void); %7D%0A%09SYS_MOUNT                  = 21  // %7B int mount(char *type, char *path, %5C%0A%09SYS_UNMOUNT                = 22  // %7B int unmount(char *path, int flags); %7D%0A%09SYS_SETUID                 = 23  // %7B int setuid(uid_t uid); %7D%0A%09SYS_GETUID                 = 24  // %7B uid_t getuid(void); %7D%0A%09SYS_GETEUID                = 25  // %7B uid_t geteuid(void); %7D%0A%09SYS_PTRACE                 = 26  // %7B int ptrace(int req, pid_t pid, %5C%0A%09SYS_RECVMSG                = 27  // %7B int recvmsg(int s, struct msghdr *msg, %5C%0A%09SYS_SENDMSG                = 28  // %7B int sendmsg(int s, struct msghdr *msg, %5C%0A%09SYS_RECVFROM               = 29  // %7B int recvfrom(int s, caddr_t buf, %5C%0A%09SYS_ACCEPT                 = 30  // %7B int accept(int s, %5C%0A%09SYS_GETPEERNAME            = 31  // %7B int getpeername(int fdes, %5C%0A%09SYS_GETSOCKNAME            = 32  // %7B int getsockname(int fdes, %5C%0A%09SYS_ACCESS                 = 33  // %7B int access(char *path, int amode); %7D%0A%09SYS_CHFLAGS                = 34  // %7B int chflags(const char *path, u_long flags); %7D%0A%09SYS_FCHFLAGS               = 35  // %7B int fchflags(int fd, u_long flags); %7D%0A%09SYS_SYNC                   = 36  // %7B int sync(void); %7D%0A%09SYS_KILL                   = 37  // %7B int kill(int pid, int signum); %7D%0A%09SYS_GETPPID                = 39  // %7B pid_t getppid(void); %7D%0A%09SYS_DUP                    = 41  // %7B int dup(u_int fd); %7D%0A%09SYS_PIPE                   = 42  // %7B int pipe(void); %7D%0A%09SYS_GETEGID                = 43  // %7B gid_t getegid(void); %7D%0A%09SYS_PROFIL                 = 44  // %7B int profil(caddr_t samples, size_t size, %5C%0A%09SYS_KTRACE                 = 45  // %7B int ktrace(const char *fname, int ops, %5C%0A%09SYS_GETGID                 = 47  // %7B gid_t getgid(void); %7D%0A%09SYS_GETLOGIN               = 49  // %7B int getlogin(char *namebuf, u_int %5C%0A%09SYS_SETLOGIN               = 50  // %7B int setlogin(char *namebuf); %7D%0A%09SYS_ACCT                   = 51  // %7B int acct(char *path); %7D%0A%09SYS_SIGALTSTACK            = 53  // %7B int sigaltstack(stack_t *ss, %5C%0A%09SYS_IOCTL                  = 54  // %7B int ioctl(int fd, u_long com, %5C%0A%09SYS_REBOOT                 = 55  // %7B int reboot(int opt); %7D%0A%09SYS_REVOKE                 = 56  // %7B int revoke(char *path); %7D%0A%09SYS_SYMLINK                = 57  // %7B int symlink(char *path, char *link); %7D%0A%09SYS_READLINK               = 58  // %7B ssize_t readlink(char *path, char *buf, %5C%0A%09SYS_EXECVE                 = 59  // %7B int execve(char *fname, char **argv, %5C%0A%09SYS_UMASK                  = 60  // %7B int umask(int newmask); %7D umask umask_args %5C%0A%09SYS_CHROOT                 = 61  // %7B int chroot(char *path); %7D%0A%09SYS_MSYNC                  = 65  // %7B int msync(void *addr, size_t len, %5C%0A%09SYS_VFORK                  = 66  // %7B int vfork(void); %7D%0A%09SYS_SBRK                   = 69  // %7B int sbrk(int incr); %7D%0A%09SYS_SSTK                   = 70  // %7B int sstk(int incr); %7D%0A%09SYS_OVADVISE               = 72  // %7B int ovadvise(int anom); %7D vadvise %5C%0A%09SYS_MUNMAP                 = 73  // %7B int munmap(void *addr, size_t len); %7D%0A%09SYS_MPROTECT               = 74  // %7B int mprotect(const void *addr, size_t len, %5C%0A%09SYS_MADVISE                = 75  // %7B int madvise(void *addr, size_t len, %5C%0A%09SYS_MINCORE                = 78  // %7B int mincore(const void *addr, size_t len, %5C%0A%09SYS_GETGROUPS              = 79  // %7B int getgroups(u_int gidsetsize, %5C%0A%09SYS_SETGROUPS              = 80  // %7B int setgroups(u_int gidsetsize, %5C%0A%09SYS_GETPGRP                = 81  // %7B int getpgrp(void); %7D%0A%09SYS_SETPGID                = 82  // %7B int setpgid(int pid, int pgid); %7D%0A%09SYS_SETITIMER              = 83  // %7B int setitimer(u_int which, struct %5C%0A%09SYS_SWAPON                 = 85  // %7B int swapon(char *name); %7D%0A%09SYS_GETITIMER              = 86  // %7B int getitimer(u_int which, %5C%0A%09SYS_GETDTABLESIZE          = 89  // %7B int getdtablesize(void); %7D%0A%09SYS_DUP2                   = 90  // %7B int dup2(u_int from, u_int to); %7D%0A%09SYS_FCNTL                  = 92  // %7B int fcntl(int fd, int cmd, long arg); %7D%0A%09SYS_SELECT                 = 93  // %7B int select(int nd, fd_set *in, fd_set *ou, %5C%0A%09SYS_FSYNC                  = 95  // %7B int fsync(int fd); %7D%0A%09SYS_SETPRIORITY            = 96  // %7B int setpriority(int which, int who, %5C%0A%09SYS_SOCKET                 = 97  // %7B int socket(int domain, int type, %5C%0A%09SYS_CONNECT                = 98  // %7B int connect(int s, caddr_t name, %5C%0A%09SYS_GETPRIORITY            = 100 // %7B int getpriority(int which, int who); %7D%0A%09SYS_BIND                   = 104 // %7B int bind(int s, caddr_t name, %5C%0A%09SYS_SETSOCKOPT             = 105 // %7B int setsockopt(int s, int level, int name, %5C%0A%09SYS_LISTEN                 = 106 // %7B int listen(int s, int backlog); %7D%0A%09SYS_GETTIMEOFDAY           = 116 // %7B int gettimeofday(struct timeval *tp, %5C%0A%09SYS_GETRUSAGE              = 117 // %7B int getrusage(int who, %5C%0A%09SYS_GETSOCKOPT             = 118 // %7B int getsockopt(int s, int level, int name, %5C%0A%09SYS_READV                  = 120 // %7B int readv(int fd, struct iovec *iovp, %5C%0A%09SYS_WRITEV                 = 121 // %7B int writev(int fd, struct iovec *iovp, %5C%0A%09SYS_SETTIMEOFDAY           = 122 // %7B int settimeofday(struct timeval *tv, %5C%0A%09SYS_FCHOWN                 = 123 // %7B int fchown(int fd, int uid, int gid); %7D%0A%09SYS_FCHMOD                 = 124 // %7B int fchmod(int fd, int mode); %7D%0A%09SYS_SETREUID               = 126 // %7B int setreuid(int ruid, int euid); %7D%0A%09SYS_SETREGID               = 127 // %7B int setregid(int rgid, int egid); %7D%0A%09SYS_RENAME                 = 128 // %7B int rename(char *from, char *to); %7D%0A%09SYS_FLOCK                  = 131 // %7B int flock(int fd, int how); %7D%0A%09SYS_MKFIFO                 = 132 // %7B int mkfifo(char *path, int mode); %7D%0A%09SYS_SENDTO                 = 133 // %7B int sendto(int s, caddr_t buf, size_t len, %5C%0A%09SYS_SHUTDOWN               = 134 // %7B int shutdown(int s, int how); %7D%0A%09SYS_SOCKETPAIR             = 135 // %7B int socketpair(int domain, int type, %5C%0A%09SYS_MKDIR                  = 136 // %7B int mkdir(char *path, int mode); %7D%0A%09SYS_RMDIR                  = 137 // %7B int rmdir(char *path); %7D%0A%09SYS_UTIMES                 = 138 // %7B int utimes(char *path, %5C%0A%09SYS_ADJTIME                = 140 // %7B int adjtime(struct timeval *delta, %5C%0A%09SYS_SETSID                 = 147 // %7B int setsid(void); %7D%0A%09SYS_QUOTACTL               = 148 // %7B int quotactl(char *path, int cmd, int uid, %5C%0A%09SYS_LGETFH                 = 160 // %7B int lgetfh(char *fname, %5C%0A%09SYS_GETFH                  = 161 // %7B int getfh(char *fname, %5C%0A%09SYS_SYSARCH                = 165 // %7B int sysarch(int op, char *parms); %7D%0A%09SYS_RTPRIO                 = 166 // %7B int rtprio(int function, pid_t pid, %5C%0A%09SYS_FREEBSD6_PREAD         = 173 // %7B ssize_t freebsd6_pread(int fd, void *buf, %5C%0A%09SYS_FREEBSD6_PWRITE        = 174 // %7B ssize_t freebsd6_pwrite(int fd, %5C%0A%09SYS_SETFIB                 = 175 // %7B int setfib(int fibnum); %7D%0A%09SYS_NTP_ADJTIME            = 176 // %7B int ntp_adjtime(struct timex *tp); %7D%0A%09SYS_SETGID                 = 181 // %7B int setgid(gid_t gid); %7D%0A%09SYS_SETEGID                = 182 // %7B int setegid(gid_t egid); %7D%0A%09SYS_SETEUID                = 183 // %7B int seteuid(uid_t euid); %7D%0A%09SYS_STAT                   = 188 // %7B int stat(char *path, struct stat *ub); %7D%0A%09SYS_FSTAT                  = 189 // %7B int fstat(int fd, struct stat *sb); %7D%0A%09SYS_LSTAT                  = 190 // %7B int lstat(char *path, struct stat *ub); %7D%0A%09SYS_PATHCONF               = 191 // %7B int pathconf(char *path, int name); %7D%0A%09SYS_FPATHCONF              = 192 // %7B int fpathconf(int fd, int name); %7D%0A%09SYS_GETRLIMIT              = 194 // %7B int getrlimit(u_int which, %5C%0A%09SYS_SETRLIMIT              = 195 // %7B int setrlimit(u_int which, %5C%0A%09SYS_GETDIRENTRIES          = 196 // %7B int getdirentries(int fd, char *buf, %5C%0A%09SYS_FREEBSD6_MMAP          = 197 // %7B caddr_t freebsd6_mmap(caddr_t addr, %5C%0A%09SYS_FREEBSD6_LSEEK         = 199 // %7B off_t freebsd6_lseek(int fd, int pad, %5C%0A%09SYS_FREEBSD6_TRUNCATE      = 200 // %7B int freebsd6_truncate(char *path, int pad, %5C%0A%09SYS_FREEBSD6_FTRUNCATE     = 201 // %7B int freebsd6_ftruncate(int fd, int pad, %5C%0A%09SYS___SYSCTL               = 202 // %7B int __sysctl(int *name, u_int namelen, %5C%0A%09SYS_MLOCK                  = 203 // %7B int mlock(const void *addr, size_t len); %7D%0A%09SYS_MUNLOCK                = 204 // %7B int munlock(const void *addr, size_t len); %7D%0A%09SYS_UNDELETE               = 205 // %7B int undelete(char *path); %7D%0A%09SYS_FUTIMES                = 206 // %7B int futimes(int fd, struct timeval *tptr); %7D%0A%09SYS_GETPGID                = 207 // %7B int getpgid(pid_t pid); %7D%0A%09SYS_POLL                   = 209 // %7B int poll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_CLOCK_GETTIME          = 232 // %7B int clock_gettime(clockid_t clock_id, %5C%0A%09SYS_CLOCK_SETTIME          = 233 // %7B int clock_settime( %5C%0A%09SYS_CLOCK_GETRES           = 234 // %7B int clock_getres(clockid_t clock_id, %5C%0A%09SYS_KTIMER_CREATE          = 235 // %7B int ktimer_create(clockid_t clock_id, %5C%0A%09SYS_KTIMER_DELETE          = 236 // %7B int ktimer_delete(int timerid); %7D%0A%09SYS_KTIMER_SETTIME         = 237 // %7B int ktimer_settime(int timerid, int flags, %5C%0A%09SYS_KTIMER_GETTIME         = 238 // %7B int ktimer_gettime(int timerid, struct %5C%0A%09SYS_KTIMER_GETOVERRUN      = 239 // %7B int ktimer_getoverrun(int timerid); %7D%0A%09SYS_NANOSLEEP              = 240 // %7B int nanosleep(const struct timespec *rqtp, %5C%0A%09SYS_FFCLOCK_GETCOUNTER     = 241 // %7B int ffclock_getcounter(ffcounter *ffcount); %7D%0A%09SYS_FFCLOCK_SETESTIMATE    = 242 // %7B int ffclock_setestimate( %5C%0A%09SYS_FFCLOCK_GETESTIMATE    = 243 // %7B int ffclock_getestimate( %5C%0A%09SYS_CLOCK_GETCPUCLOCKID2   = 247 // %7B int clock_getcpuclockid2(id_t id,%5C%0A%09SYS_NTP_GETTIME            = 248 // %7B int ntp_gettime(struct ntptimeval *ntvp); %7D%0A%09SYS_MINHERIT               = 250 // %7B int minherit(void *addr, size_t len, %5C%0A%09SYS_RFORK                  = 251 // %7B int rfork(int flags); %7D%0A%09SYS_OPENBSD_POLL           = 252 // %7B int openbsd_poll(struct pollfd *fds, %5C%0A%09SYS_ISSETUGID              = 253 // %7B int issetugid(void); %7D%0A%09SYS_LCHOWN                 = 254 // %7B int lchown(char *path, int uid, int gid); %7D%0A%09SYS_GETDENTS               = 272 // %7B int getdents(int fd, char *buf, %5C%0A%09SYS_LCHMOD                 = 274 // %7B int lchmod(char *path, mode_t mode); %7D%0A%09SYS_LUTIMES                = 276 // %7B int lutimes(char *path, %5C%0A%09SYS_NSTAT                  = 278 // %7B int nstat(char *path, struct nstat *ub); %7D%0A%09SYS_NFSTAT                 = 279 // %7B int nfstat(int fd, struct nstat *sb); %7D%0A%09SYS_NLSTAT                 = 280 // %7B int nlstat(char *path, struct nstat *ub); %7D%0A%09SYS_PREADV                 = 289 // %7B ssize_t preadv(int fd, struct iovec *iovp, %5C%0A%09SYS_PWRITEV                = 290 // %7B ssize_t pwritev(int fd, struct iovec *iovp, %5C%0A%09SYS_FHOPEN                 = 298 // %7B int fhopen(const struct fhandle *u_fhp, %5C%0A%09SYS_FHSTAT                 = 299 // %7B int fhstat(const struct fhandle *u_fhp, %5C%0A%09SYS_MODNEXT                = 300 // %7B int modnext(int modid); %7D%0A%09SYS_MODSTAT                = 301 // %7B int modstat(int modid, %5C%0A%09SYS_MODFNEXT               = 302 // %7B int modfnext(int modid); %7D%0A%09SYS_MODFIND                = 303 // %7B int modfind(const char *name); %7D%0A%09SYS_KLDLOAD                = 304 // %7B int kldload(const char *file); %7D%0A%09SYS_KLDUNLOAD              = 305 // %7B int kldunload(int fileid); %7D%0A%09SYS_KLDFIND                = 306 // %7B int kldfind(const char *file); %7D%0A%09SYS_KLDNEXT                = 307 // %7B int kldnext(int fileid); %7D%0A%09SYS_KLDSTAT                = 308 // %7B int kldstat(int fileid, struct %5C%0A%09SYS_KLDFIRSTMOD            = 309 // %7B int kldfirstmod(int fileid); %7D%0A%09SYS_GETSID                 = 310 // %7B int getsid(pid_t pid); %7D%0A%09SYS_SETRESUID              = 311 // %7B int setresuid(uid_t ruid, uid_t euid, %5C%0A%09SYS_SETRESGID              = 312 // %7B int setresgid(gid_t rgid, gid_t egid, %5C%0A%09SYS_YIELD                  = 321 // %7B int yield(void); %7D%0A%09SYS_MLOCKALL               = 324 // %7B int mlockall(int how); %7D%0A%09SYS_MUNLOCKALL             = 325 // %7B int munlockall(void); %7D%0A%09SYS___GETCWD               = 326 // %7B int __getcwd(char *buf, u_int buflen); %7D%0A%09SYS_SCHED_SETPARAM         = 327 // %7B int sched_setparam (pid_t pid, %5C%0A%09SYS_SCHED_GETPARAM         = 328 // %7B int sched_getparam (pid_t pid, struct %5C%0A%09SYS_SCHED_SETSCHEDULER     = 329 // %7B int sched_setscheduler (pid_t pid, int %5C%0A%09SYS_SCHED_GETSCHEDULER     = 330 // %7B int sched_getscheduler (pid_t pid); %7D%0A%09SYS_SCHED_YIELD            = 331 // %7B int sched_yield (void); %7D%0A%09SYS_SCHED_GET_PRIORITY_MAX = 332 // %7B int sched_get_priority_max (int policy); %7D%0A%09SYS_SCHED_GET_PRIORITY_MIN = 333 // %7B int sched_get_priority_min (int policy); %7D%0A%09SYS_SCHED_RR_GET_INTERVAL  = 334 // %7B int sched_rr_get_interval (pid_t pid, %5C%0A%09SYS_UTRACE                 = 335 // %7B int utrace(const void *addr, size_t len); %7D%0A%09SYS_KLDSYM                 = 337 // %7B int kldsym(int fileid, int cmd, %5C%0A%09SYS_JAIL                   = 338 // %7B int jail(struct jail *jail); %7D%0A%09SYS_SIGPROCMASK            = 340 // %7B int sigprocmask(int how, %5C%0A%09SYS_SIGSUSPEND             = 341 // %7B int sigsuspend(const sigset_t *sigmask); %7D%0A%09SYS_SIGPENDING             = 343 // %7B int sigpending(sigset_t *set); %7D%0A%09SYS_SIGTIMEDWAIT           = 345 // %7B int sigtimedwait(const sigset_t *set, %5C%0A%09SYS_SIGWAITINFO            = 346 // %7B int sigwaitinfo(const sigset_t *set, %5C%0A%09SYS___ACL_GET_FILE         = 347 // %7B int __acl_get_file(const char *path, %5C%0A%09SYS___ACL_SET_FILE         = 348 // %7B int __acl_set_file(const char *path, %5C%0A%09SYS___ACL_GET_FD           = 349 // %7B int __acl_get_fd(int filedes, %5C%0A%09SYS___ACL_SET_FD           = 350 // %7B int __acl_set_fd(int filedes, %5C%0A%09SYS___ACL_DELETE_FILE      = 351 // %7B int __acl_delete_file(const char *path, %5C%0A%09SYS___ACL_DELETE_FD        = 352 // %7B int __acl_delete_fd(int filedes, %5C%0A%09SYS___ACL_ACLCHECK_FILE    = 353 // %7B int __acl_aclcheck_file(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_FD      = 354 // %7B int __acl_aclcheck_fd(int filedes, %5C%0A%09SYS_EXTATTRCTL             = 355 // %7B int extattrctl(const char *path, int cmd, %5C%0A%09SYS_EXTATTR_SET_FILE       = 356 // %7B ssize_t extattr_set_file( %5C%0A%09SYS_EXTATTR_GET_FILE       = 357 // %7B ssize_t extattr_get_file( %5C%0A%09SYS_EXTATTR_DELETE_FILE    = 358 // %7B int extattr_delete_file(const char *path, %5C%0A%09SYS_GETRESUID              = 360 // %7B int getresuid(uid_t *ruid, uid_t *euid, %5C%0A%09SYS_GETRESGID              = 361 // %7B int getresgid(gid_t *rgid, gid_t *egid, %5C%0A%09SYS_KQUEUE                 = 362 // %7B int kqueue(void); %7D%0A%09SYS_KEVENT                 = 363 // %7B int kevent(int fd, %5C%0A%09SYS_EXTATTR_SET_FD         = 371 // %7B ssize_t extattr_set_fd(int fd, %5C%0A%09SYS_EXTATTR_GET_FD         = 372 // %7B ssize_t extattr_get_fd(int fd, %5C%0A%09SYS_EXTATTR_DELETE_FD      = 373 // %7B int extattr_delete_fd(int fd, %5C%0A%09SYS___SETUGID              = 374 // %7B int __setugid(int flag); %7D%0A%09SYS_EACCESS                = 376 // %7B int eaccess(char *path, int amode); %7D%0A%09SYS_NMOUNT                 = 378 // %7B int nmount(struct iovec *iovp, %5C%0A%09SYS___MAC_GET_PROC         = 384 // %7B int __mac_get_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_SET_PROC         = 385 // %7B int __mac_set_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_GET_FD           = 386 // %7B int __mac_get_fd(int fd, %5C%0A%09SYS___MAC_GET_FILE         = 387 // %7B int __mac_get_file(const char *path_p, %5C%0A%09SYS___MAC_SET_FD           = 388 // %7B int __mac_set_fd(int fd, %5C%0A%09SYS___MAC_SET_FILE         = 389 // %7B int __mac_set_file(const char *path_p, %5C%0A%09SYS_KENV                   = 390 // %7B int kenv(int what, const char *name, %5C%0A%09SYS_LCHFLAGS               = 391 // %7B int lchflags(const char *path, %5C%0A%09SYS_UUIDGEN                = 392 // %7B int uuidgen(struct uuid *store, %5C%0A%09SYS_SENDFILE               = 393 // %7B int sendfile(int fd, int s, off_t offset, %5C%0A%09SYS_MAC_SYSCALL            = 394 // %7B int mac_syscall(const char *policy, %5C%0A%09SYS_GETFSSTAT              = 395 // %7B int getfsstat(struct statfs *buf, %5C%0A%09SYS_STATFS                 = 396 // %7B int statfs(char *path, %5C%0A%09SYS_FSTATFS                = 397 // %7B int fstatfs(int fd, struct statfs *buf); %7D%0A%09SYS_FHSTATFS               = 398 // %7B int fhstatfs(const struct fhandle *u_fhp, %5C%0A%09SYS___MAC_GET_PID          = 409 // %7B int __mac_get_pid(pid_t pid, %5C%0A%09SYS___MAC_GET_LINK         = 410 // %7B int __mac_get_link(const char *path_p, %5C%0A%09SYS___MAC_SET_LINK         = 411 // %7B int __mac_set_link(const char *path_p, %5C%0A%09SYS_EXTATTR_SET_LINK       = 412 // %7B ssize_t extattr_set_link( %5C%0A%09SYS_EXTATTR_GET_LINK       = 413 // %7B ssize_t extattr_get_link( %5C%0A%09SYS_EXTATTR_DELETE_LINK    = 414 // %7B int extattr_delete_link( %5C%0A%09SYS___MAC_EXECVE           = 415 // %7B int __mac_execve(char *fname, char **argv, %5C%0A%09SYS_SIGACTION              = 416 // %7B int sigaction(int sig, %5C%0A%09SYS_SIGRETURN              = 417 // %7B int sigreturn( %5C%0A%09SYS_GETCONTEXT             = 421 // %7B int getcontext(struct __ucontext *ucp); %7D%0A%09SYS_SETCONTEXT             = 422 // %7B int setcontext( %5C%0A%09SYS_SWAPCONTEXT            = 423 // %7B int swapcontext(struct __ucontext *oucp, %5C%0A%09SYS_SWAPOFF                = 424 // %7B int swapoff(const char *name); %7D%0A%09SYS___ACL_GET_LINK         = 425 // %7B int __acl_get_link(const char *path, %5C%0A%09SYS___ACL_SET_LINK         = 426 // %7B int __acl_set_link(const char *path, %5C%0A%09SYS___ACL_DELETE_LINK      = 427 // %7B int __acl_delete_link(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_LINK    = 428 // %7B int __acl_aclcheck_link(const char *path, %5C%0A%09SYS_SIGWAIT                = 429 // %7B int sigwait(const sigset_t *set, %5C%0A%09SYS_THR_CREATE             = 430 // %7B int thr_create(ucontext_t *ctx, long *id, %5C%0A%09SYS_THR_EXIT               = 431 // %7B void thr_exit(long *state); %7D%0A%09SYS_THR_SELF               = 432 // %7B int thr_self(long *id); %7D%0A%09SYS_THR_KILL               = 433 // %7B int thr_kill(long id, int sig); %7D%0A%09SYS__UMTX_LOCK             = 434 // %7B int _umtx_lock(struct umtx *umtx); %7D%0A%09SYS__UMTX_UNLOCK           = 435 // %7B int _umtx_unlock(struct umtx *umtx); %7D%0A%09SYS_JAIL_ATTACH            = 436 // %7B int jail_attach(int jid); %7D%0A%09SYS_EXTATTR_LIST_FD        = 437 // %7B ssize_t extattr_list_fd(int fd, %5C%0A%09SYS_EXTATTR_LIST_FILE      = 438 // %7B ssize_t extattr_list_file( %5C%0A%09SYS_EXTATTR_LIST_LINK      = 439 // %7B ssize_t extattr_list_link( %5C%0A%09SYS_THR_SUSPEND            = 442 // %7B int thr_suspend( %5C%0A%09SYS_THR_WAKE               = 443 // %7B int thr_wake(long id); %7D%0A%09SYS_KLDUNLOADF             = 444 // %7B int kldunloadf(int fileid, int flags); %7D%0A%09SYS_AUDIT                  = 445 // %7B int audit(const void *record, %5C%0A%09SYS_AUDITON                = 446 // %7B int auditon(int cmd, void *data, %5C%0A%09SYS_GETAUID                = 447 // %7B int getauid(uid_t *auid); %7D%0A%09SYS_SETAUID                = 448 // %7B int setauid(uid_t *auid); %7D%0A%09SYS_GETAUDIT               = 449 // %7B int getaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_SETAUDIT               = 450 // %7B int setaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_GETAUDIT_ADDR          = 451 // %7B int getaudit_addr( %5C%0A%09SYS_SETAUDIT_ADDR          = 452 // %7B int setaudit_addr( %5C%0A%09SYS_AUDITCTL               = 453 // %7B int auditctl(char *path); %7D%0A%09SYS__UMTX_OP               = 454 // %7B int _umtx_op(void *obj, int op, %5C%0A%09SYS_THR_NEW                = 455 // %7B int thr_new(struct thr_param *param, %5C%0A%09SYS_SIGQUEUE               = 456 // %7B int sigqueue(pid_t pid, int signum, void *value); %7D%0A%09SYS_ABORT2                 = 463 // %7B int abort2(const char *why, int nargs, void **args); %7D%0A%09SYS_THR_SET_NAME           = 464 // %7B int thr_set_name(long id, const char *name); %7D%0A%09SYS_RTPRIO_THREAD          = 466 // %7B int rtprio_thread(int function, %5C%0A%09SYS_PREAD                  = 475 // %7B ssize_t pread(int fd, void *buf, %5C%0A%09SYS_PWRITE                 = 476 // %7B ssize_t pwrite(int fd, const void *buf, %5C%0A%09SYS_MMAP                   = 477 // %7B caddr_t mmap(caddr_t addr, size_t len, %5C%0A%09SYS_LSEEK                  = 478 // %7B off_t lseek(int fd, off_t offset, %5C%0A%09SYS_TRUNCATE               = 479 // %7B int truncate(char *path, off_t length); %7D%0A%09SYS_FTRUNCATE              = 480 // %7B int ftruncate(int fd, off_t length); %7D%0A%09SYS_THR_KILL2              = 481 // %7B int thr_kill2(pid_t pid, long id, int sig); %7D%0A%09SYS_SHM_OPEN               = 482 // %7B int shm_open(const char *path, int flags, %5C%0A%09SYS_SHM_UNLINK             = 483 // %7B int shm_unlink(const char *path); %7D%0A%09SYS_CPUSET                 = 484 // %7B int cpuset(cpusetid_t *setid); %7D%0A%09SYS_CPUSET_SETID           = 485 // %7B int cpuset_setid(cpuwhich_t which, id_t id, %5C%0A%09SYS_CPUSET_GETID           = 486 // %7B int cpuset_getid(cpulevel_t level, %5C%0A%09SYS_CPUSET_GETAFFINITY     = 487 // %7B int cpuset_getaffinity(cpulevel_t level, %5C%0A%09SYS_CPUSET_SETAFFINITY     = 488 // %7B int cpuset_setaffinity(cpulevel_t level, %5C%0A%09SYS_FACCESSAT              = 489 // %7B int faccessat(int fd, char *path, int amode, %5C%0A%09SYS_FCHMODAT               = 490 // %7B int fchmodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_FCHOWNAT               = 491 // %7B int fchownat(int fd, char *path, uid_t uid, %5C%0A%09SYS_FEXECVE                = 492 // %7B int fexecve(int fd, char **argv, %5C%0A%09SYS_FSTATAT                = 493 // %7B int fstatat(int fd, char *path, %5C%0A%09SYS_FUTIMESAT              = 494 // %7B int futimesat(int fd, char *path, %5C%0A%09SYS_LINKAT                 = 495 // %7B int linkat(int fd1, char *path1, int fd2, %5C%0A%09SYS_MKDIRAT                = 496 // %7B int mkdirat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKFIFOAT               = 497 // %7B int mkfifoat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKNODAT                = 498 // %7B int mknodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_OPENAT                 = 499 // %7B int openat(int fd, char *path, int flag, %5C%0A%09SYS_READLINKAT             = 500 // %7B int readlinkat(int fd, char *path, char *buf, %5C%0A%09SYS_RENAMEAT               = 501 // %7B int renameat(int oldfd, char *old, int newfd, %5C%0A%09SYS_SYMLINKAT              = 502 // %7B int symlinkat(char *path1, int fd, %5C%0A%09SYS_UNLINKAT               = 503 // %7B int unlinkat(int fd, char *path, int flag); %7D%0A%09SYS_POSIX_OPENPT           = 504 // %7B int posix_openpt(int flags); %7D%0A%09SYS_JAIL_GET               = 506 // %7B int jail_get(struct iovec *iovp, %5C%0A%09SYS_JAIL_SET               = 507 // %7B int jail_set(struct iovec *iovp, %5C%0A%09SYS_JAIL_REMOVE            = 508 // %7B int jail_remove(int jid); %7D%0A%09SYS_CLOSEFROM              = 509 // %7B int closefrom(int lowfd); %7D%0A%09SYS_LPATHCONF              = 513 // %7B int lpathconf(char *path, int name); %7D%0A%09SYS___CAP_RIGHTS_GET       = 515 // %7B int __cap_rights_get(int version, %5C%0A%09SYS_CAP_ENTER              = 516 // %7B int cap_enter(void); %7D%0A%09SYS_CAP_GETMODE            = 517 // %7B int cap_getmode(u_int *modep); %7D%0A%09SYS_PDFORK                 = 518 // %7B int pdfork(int *fdp, int flags); %7D%0A%09SYS_PDKILL                 = 519 // %7B int pdkill(int fd, int signum); %7D%0A%09SYS_PDGETPID               = 520 // %7B int pdgetpid(int fd, pid_t *pidp); %7D%0A%09SYS_PSELECT                = 522 // %7B int pselect(int nd, fd_set *in, %5C%0A%09SYS_GETLOGINCLASS          = 523 // %7B int getloginclass(char *namebuf, %5C%0A%09SYS_SETLOGINCLASS          = 524 // %7B int setloginclass(const char *namebuf); %7D%0A%09SYS_RCTL_GET_RACCT         = 525 // %7B int rctl_get_racct(const void *inbufp, %5C%0A%09SYS_RCTL_GET_RULES         = 526 // %7B int rctl_get_rules(const void *inbufp, %5C%0A%09SYS_RCTL_GET_LIMITS        = 527 // %7B int rctl_get_limits(const void *inbufp, %5C%0A%09SYS_RCTL_ADD_RULE          = 528 // %7B int rctl_add_rule(const void *inbufp, %5C%0A%09SYS_RCTL_REMOVE_RULE       = 529 // %7B int rctl_remove_rule(const void *inbufp, %5C%0A%09SYS_POSIX_FALLOCATE        = 530 // %7B int posix_fallocate(int fd, %5C%0A%09SYS_POSIX_FADVISE          = 531 // %7B int posix_fadvise(int fd, off_t offset, %5C%0A%09SYS_WAIT6                  = 532 // %7B int wait6(idtype_t idtype, id_t id, %5C%0A%09SYS_CAP_RIGHTS_LIMIT       = 533 // %7B int cap_rights_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_LIMIT       = 534 // %7B int cap_ioctls_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_GET         = 535 // %7B ssize_t cap_ioctls_get(int fd, %5C%0A%09SYS_CAP_FCNTLS_LIMIT       = 536 // %7B int cap_fcntls_limit(int fd, %5C%0A%09SYS_CAP_FCNTLS_GET         = 537 // %7B int cap_fcntls_get(int fd, %5C%0A%09SYS_BINDAT                 = 538 // %7B int bindat(int fd, int s, caddr_t name, %5C%0A%09SYS_CONNECTAT              = 539 // %7B int connectat(int fd, int s, caddr_t name, %5C%0A%09SYS_CHFLAGSAT              = 540 // %7B int chflagsat(int fd, const char *path, %5C%0A%09SYS_ACCEPT4                = 541 // %7B int accept4(int s, %5C%0A%09SYS_PIPE2                  = 542 // %7B int pipe2(int *fildes, int flags); %7D%0A%09SYS_PROCCTL                = 544 // %7B int procctl(idtype_t idtype, id_t id, %5C%0A%09SYS_PPOLL                  = 545 // %7B int ppoll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_FUTIMENS               = 546 // %7B int futimens(int fd, %5C%0A%09SYS_UTIMENSAT              = 547 // %7B int utimensat(int fd, %5C%0A
+%09SYS_EXIT                     = 1   // %7B void sys_exit(int rval); %7D exit %5C%0A%09SYS_FORK                     = 2   // %7B int fork(void); %7D%0A%09SYS_READ                     = 3   // %7B ssize_t read(int fd, void *buf, %5C%0A%09SYS_WRITE                    = 4   // %7B ssize_t write(int fd, const void *buf, %5C%0A%09SYS_OPEN                     = 5   // %7B int open(char *path, int flags, int mode); %7D%0A%09SYS_CLOSE                    = 6   // %7B int close(int fd); %7D%0A%09SYS_WAIT4                    = 7   // %7B int wait4(int pid, int *status, %5C%0A%09SYS_LINK                     = 9   // %7B int link(char *path, char *link); %7D%0A%09SYS_UNLINK                   = 10  // %7B int unlink(char *path); %7D%0A%09SYS_CHDIR                    = 12  // %7B int chdir(char *path); %7D%0A%09SYS_FCHDIR                   = 13  // %7B int fchdir(int fd); %7D%0A%09SYS_MKNOD                    = 14  // %7B int mknod(char *path, int mode, int dev); %7D%0A%09SYS_CHMOD                    = 15  // %7B int chmod(char *path, int mode); %7D%0A%09SYS_CHOWN                    = 16  // %7B int chown(char *path, int uid, int gid); %7D%0A%09SYS_OBREAK                   = 17  // %7B int obreak(char *nsize); %7D break %5C%0A%09SYS_GETPID                   = 20  // %7B pid_t getpid(void); %7D%0A%09SYS_MOUNT                    = 21  // %7B int mount(char *type, char *path, %5C%0A%09SYS_UNMOUNT                  = 22  // %7B int unmount(char *path, int flags); %7D%0A%09SYS_SETUID                   = 23  // %7B int setuid(uid_t uid); %7D%0A%09SYS_GETUID                   = 24  // %7B uid_t getuid(void); %7D%0A%09SYS_GETEUID                  = 25  // %7B uid_t geteuid(void); %7D%0A%09SYS_PTRACE                   = 26  // %7B int ptrace(int req, pid_t pid, %5C%0A%09SYS_RECVMSG                  = 27  // %7B int recvmsg(int s, struct msghdr *msg, %5C%0A%09SYS_SENDMSG                  = 28  // %7B int sendmsg(int s, struct msghdr *msg, %5C%0A%09SYS_RECVFROM                 = 29  // %7B int recvfrom(int s, caddr_t buf, %5C%0A%09SYS_ACCEPT                   = 30  // %7B int accept(int s, %5C%0A%09SYS_GETPEERNAME              = 31  // %7B int getpeername(int fdes, %5C%0A%09SYS_GETSOCKNAME              = 32  // %7B int getsockname(int fdes, %5C%0A%09SYS_ACCESS                   = 33  // %7B int access(char *path, int amode); %7D%0A%09SYS_CHFLAGS                  = 34  // %7B int chflags(const char *path, u_long flags); %7D%0A%09SYS_FCHFLAGS                 = 35  // %7B int fchflags(int fd, u_long flags); %7D%0A%09SYS_SYNC                     = 36  // %7B int sync(void); %7D%0A%09SYS_KILL                     = 37  // %7B int kill(int pid, int signum); %7D%0A%09SYS_GETPPID                  = 39  // %7B pid_t getppid(void); %7D%0A%09SYS_DUP                      = 41  // %7B int dup(u_int fd); %7D%0A%09SYS_PIPE                     = 42  // %7B int pipe(void); %7D%0A%09SYS_GETEGID                  = 43  // %7B gid_t getegid(void); %7D%0A%09SYS_PROFIL                   = 44  // %7B int profil(caddr_t samples, size_t size, %5C%0A%09SYS_KTRACE                   = 45  // %7B int ktrace(const char *fname, int ops, %5C%0A%09SYS_GETGID                   = 47  // %7B gid_t getgid(void); %7D%0A%09SYS_GETLOGIN                 = 49  // %7B int getlogin(char *namebuf, u_int %5C%0A%09SYS_SETLOGIN                 = 50  // %7B int setlogin(char *namebuf); %7D%0A%09SYS_ACCT                     = 51  // %7B int acct(char *path); %7D%0A%09SYS_SIGALTSTACK              = 53  // %7B int sigaltstack(stack_t *ss, %5C%0A%09SYS_IOCTL                    = 54  // %7B int ioctl(int fd, u_long com, %5C%0A%09SYS_REBOOT                   = 55  // %7B int reboot(int opt); %7D%0A%09SYS_REVOKE                   = 56  // %7B int revoke(char *path); %7D%0A%09SYS_SYMLINK                  = 57  // %7B int symlink(char *path, char *link); %7D%0A%09SYS_READLINK                 = 58  // %7B ssize_t readlink(char *path, char *buf, %5C%0A%09SYS_EXECVE                   = 59  // %7B int execve(char *fname, char **argv, %5C%0A%09SYS_UMASK                    = 60  // %7B int umask(int newmask); %7D umask umask_args %5C%0A%09SYS_CHROOT                   = 61  // %7B int chroot(char *path); %7D%0A%09SYS_MSYNC                    = 65  // %7B int msync(void *addr, size_t len, %5C%0A%09SYS_VFORK                    = 66  // %7B int vfork(void); %7D%0A%09SYS_SBRK                     = 69  // %7B int sbrk(int incr); %7D%0A%09SYS_SSTK                     = 70  // %7B int sstk(int incr); %7D%0A%09SYS_OVADVISE                 = 72  // %7B int ovadvise(int anom); %7D vadvise %5C%0A%09SYS_MUNMAP                   = 73  // %7B int munmap(void *addr, size_t len); %7D%0A%09SYS_MPROTECT                 = 74  // %7B int mprotect(const void *addr, size_t len, %5C%0A%09SYS_MADVISE                  = 75  // %7B int madvise(void *addr, size_t len, %5C%0A%09SYS_MINCORE                  = 78  // %7B int mincore(const void *addr, size_t len, %5C%0A%09SYS_GETGROUPS                = 79  // %7B int getgroups(u_int gidsetsize, %5C%0A%09SYS_SETGROUPS                = 80  // %7B int setgroups(u_int gidsetsize, %5C%0A%09SYS_GETPGRP                  = 81  // %7B int getpgrp(void); %7D%0A%09SYS_SETPGID                  = 82  // %7B int setpgid(int pid, int pgid); %7D%0A%09SYS_SETITIMER                = 83  // %7B int setitimer(u_int which, struct %5C%0A%09SYS_SWAPON                   = 85  // %7B int swapon(char *name); %7D%0A%09SYS_GETITIMER                = 86  // %7B int getitimer(u_int which, %5C%0A%09SYS_GETDTABLESIZE            = 89  // %7B int getdtablesize(void); %7D%0A%09SYS_DUP2                     = 90  // %7B int dup2(u_int from, u_int to); %7D%0A%09SYS_FCNTL                    = 92  // %7B int fcntl(int fd, int cmd, long arg); %7D%0A%09SYS_SELECT                   = 93  // %7B int select(int nd, fd_set *in, fd_set *ou, %5C%0A%09SYS_FSYNC                    = 95  // %7B int fsync(int fd); %7D%0A%09SYS_SETPRIORITY              = 96  // %7B int setpriority(int which, int who, %5C%0A%09SYS_SOCKET                   = 97  // %7B int socket(int domain, int type, %5C%0A%09SYS_CONNECT                  = 98  // %7B int connect(int s, caddr_t name, %5C%0A%09SYS_GETPRIORITY              = 100 // %7B int getpriority(int which, int who); %7D%0A%09SYS_BIND                     = 104 // %7B int bind(int s, caddr_t name, %5C%0A%09SYS_SETSOCKOPT               = 105 // %7B int setsockopt(int s, int level, int name, %5C%0A%09SYS_LISTEN                   = 106 // %7B int listen(int s, int backlog); %7D%0A%09SYS_GETTIMEOFDAY             = 116 // %7B int gettimeofday(struct timeval *tp, %5C%0A%09SYS_GETRUSAGE                = 117 // %7B int getrusage(int who, %5C%0A%09SYS_GETSOCKOPT               = 118 // %7B int getsockopt(int s, int level, int name, %5C%0A%09SYS_READV                    = 120 // %7B int readv(int fd, struct iovec *iovp, %5C%0A%09SYS_WRITEV                   = 121 // %7B int writev(int fd, struct iovec *iovp, %5C%0A%09SYS_SETTIMEOFDAY             = 122 // %7B int settimeofday(struct timeval *tv, %5C%0A%09SYS_FCHOWN                   = 123 // %7B int fchown(int fd, int uid, int gid); %7D%0A%09SYS_FCHMOD                   = 124 // %7B int fchmod(int fd, int mode); %7D%0A%09SYS_SETREUID                 = 126 // %7B int setreuid(int ruid, int euid); %7D%0A%09SYS_SETREGID                 = 127 // %7B int setregid(int rgid, int egid); %7D%0A%09SYS_RENAME                   = 128 // %7B int rename(char *from, char *to); %7D%0A%09SYS_FLOCK                    = 131 // %7B int flock(int fd, int how); %7D%0A%09SYS_MKFIFO                   = 132 // %7B int mkfifo(char *path, int mode); %7D%0A%09SYS_SENDTO                   = 133 // %7B int sendto(int s, caddr_t buf, size_t len, %5C%0A%09SYS_SHUTDOWN                 = 134 // %7B int shutdown(int s, int how); %7D%0A%09SYS_SOCKETPAIR               = 135 // %7B int socketpair(int domain, int type, %5C%0A%09SYS_MKDIR                    = 136 // %7B int mkdir(char *path, int mode); %7D%0A%09SYS_RMDIR                    = 137 // %7B int rmdir(char *path); %7D%0A%09SYS_UTIMES                   = 138 // %7B int utimes(char *path, %5C%0A%09SYS_ADJTIME                  = 140 // %7B int adjtime(struct timeval *delta, %5C%0A%09SYS_SETSID                   = 147 // %7B int setsid(void); %7D%0A%09SYS_QUOTACTL                 = 148 // %7B int quotactl(char *path, int cmd, int uid, %5C%0A%09SYS_NLM_SYSCALL              = 154 // %7B int nlm_syscall(int debug_level, int grace_period, int addr_count, char **addrs); %7D%0A%09SYS_NFSSVC                   = 155 // %7B int nfssvc(int flag, caddr_t argp); %7D%0A%09SYS_LGETFH                   = 160 // %7B int lgetfh(char *fname, %5C%0A%09SYS_GETFH                    = 161 // %7B int getfh(char *fname, %5C%0A%09SYS_SYSARCH                  = 165 // %7B int sysarch(int op, char *parms); %7D%0A%09SYS_RTPRIO                   = 166 // %7B int rtprio(int function, pid_t pid, %5C%0A%09SYS_SEMSYS                   = 169 // %7B int semsys(int which, int a2, int a3, %5C%0A%09SYS_MSGSYS                   = 170 // %7B int msgsys(int which, int a2, int a3, %5C%0A%09SYS_SHMSYS                   = 171 // %7B int shmsys(int which, int a2, int a3, %5C%0A%09SYS_FREEBSD6_PREAD           = 173 // %7B ssize_t freebsd6_pread(int fd, void *buf, %5C%0A%09SYS_FREEBSD6_PWRITE          = 174 // %7B ssize_t freebsd6_pwrite(int fd, %5C%0A%09SYS_SETFIB                   = 175 // %7B int setfib(int fibnum); %7D%0A%09SYS_NTP_ADJTIME              = 176 // %7B int ntp_adjtime(struct timex *tp); %7D%0A%09SYS_SETGID                   = 181 // %7B int setgid(gid_t gid); %7D%0A%09SYS_SETEGID                  = 182 // %7B int setegid(gid_t egid); %7D%0A%09SYS_SETEUID                  = 183 // %7B int seteuid(uid_t euid); %7D%0A%09SYS_STAT                     = 188 // %7B int stat(char *path, struct stat *ub); %7D%0A%09SYS_FSTAT                    = 189 // %7B int fstat(int fd, struct stat *sb); %7D%0A%09SYS_LSTAT                    = 190 // %7B int lstat(char *path, struct stat *ub); %7D%0A%09SYS_PATHCONF                 = 191 // %7B int pathconf(char *path, int name); %7D%0A%09SYS_FPATHCONF                = 192 // %7B int fpathconf(int fd, int name); %7D%0A%09SYS_GETRLIMIT                = 194 // %7B int getrlimit(u_int which, %5C%0A%09SYS_SETRLIMIT                = 195 // %7B int setrlimit(u_int which, %5C%0A%09SYS_GETDIRENTRIES            = 196 // %7B int getdirentries(int fd, char *buf, %5C%0A%09SYS_FREEBSD6_MMAP            = 197 // %7B caddr_t freebsd6_mmap(caddr_t addr, %5C%0A%09SYS_FREEBSD6_LSEEK           = 199 // %7B off_t freebsd6_lseek(int fd, int pad, %5C%0A%09SYS_FREEBSD6_TRUNCATE        = 200 // %7B int freebsd6_truncate(char *path, int pad, %5C%0A%09SYS_FREEBSD6_FTRUNCATE       = 201 // %7B int freebsd6_ftruncate(int fd, int pad, %5C%0A%09SYS___SYSCTL                 = 202 // %7B int __sysctl(int *name, u_int namelen, %5C%0A%09SYS_MLOCK                    = 203 // %7B int mlock(const void *addr, size_t len); %7D%0A%09SYS_MUNLOCK                  = 204 // %7B int munlock(const void *addr, size_t len); %7D%0A%09SYS_UNDELETE                 = 205 // %7B int undelete(char *path); %7D%0A%09SYS_FUTIMES                  = 206 // %7B int futimes(int fd, struct timeval *tptr); %7D%0A%09SYS_GETPGID                  = 207 // %7B int getpgid(pid_t pid); %7D%0A%09SYS_POLL                     = 209 // %7B int poll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_SEMGET                   = 221 // %7B int semget(key_t key, int nsems, %5C%0A%09SYS_SEMOP                    = 222 // %7B int semop(int semid, struct sembuf *sops, %5C%0A%09SYS_MSGGET                   = 225 // %7B int msgget(key_t key, int msgflg); %7D%0A%09SYS_MSGSND                   = 226 // %7B int msgsnd(int msqid, const void *msgp, %5C%0A%09SYS_MSGRCV                   = 227 // %7B int msgrcv(int msqid, void *msgp, %5C%0A%09SYS_SHMAT                    = 228 // %7B int shmat(int shmid, const void *shmaddr, %5C%0A%09SYS_SHMDT                    = 230 // %7B int shmdt(const void *shmaddr); %7D%0A%09SYS_SHMGET                   = 231 // %7B int shmget(key_t key, size_t size, %5C%0A%09SYS_CLOCK_GETTIME            = 232 // %7B int clock_gettime(clockid_t clock_id, %5C%0A%09SYS_CLOCK_SETTIME            = 233 // %7B int clock_settime( %5C%0A%09SYS_CLOCK_GETRES             = 234 // %7B int clock_getres(clockid_t clock_id, %5C%0A%09SYS_KTIMER_CREATE            = 235 // %7B int ktimer_create(clockid_t clock_id, %5C%0A%09SYS_KTIMER_DELETE            = 236 // %7B int ktimer_delete(int timerid); %7D%0A%09SYS_KTIMER_SETTIME           = 237 // %7B int ktimer_settime(int timerid, int flags, %5C%0A%09SYS_KTIMER_GETTIME           = 238 // %7B int ktimer_gettime(int timerid, struct %5C%0A%09SYS_KTIMER_GETOVERRUN        = 239 // %7B int ktimer_getoverrun(int timerid); %7D%0A%09SYS_NANOSLEEP                = 240 // %7B int nanosleep(const struct timespec *rqtp, %5C%0A%09SYS_FFCLOCK_GETCOUNTER       = 241 // %7B int ffclock_getcounter(ffcounter *ffcount); %7D%0A%09SYS_FFCLOCK_SETESTIMATE      = 242 // %7B int ffclock_setestimate( %5C%0A%09SYS_FFCLOCK_GETESTIMATE      = 243 // %7B int ffclock_getestimate( %5C%0A%09SYS_CLOCK_GETCPUCLOCKID2     = 247 // %7B int clock_getcpuclockid2(id_t id,%5C%0A%09SYS_NTP_GETTIME              = 248 // %7B int ntp_gettime(struct ntptimeval *ntvp); %7D%0A%09SYS_MINHERIT                 = 250 // %7B int minherit(void *addr, size_t len, %5C%0A%09SYS_RFORK                    = 251 // %7B int rfork(int flags); %7D%0A%09SYS_OPENBSD_POLL             = 252 // %7B int openbsd_poll(struct pollfd *fds, %5C%0A%09SYS_ISSETUGID                = 253 // %7B int issetugid(void); %7D%0A%09SYS_LCHOWN                   = 254 // %7B int lchown(char *path, int uid, int gid); %7D%0A%09SYS_AIO_READ                 = 255 // %7B int aio_read(struct aiocb *aiocbp); %7D%0A%09SYS_AIO_WRITE                = 256 // %7B int aio_write(struct aiocb *aiocbp); %7D%0A%09SYS_LIO_LISTIO               = 257 // %7B int lio_listio(int mode, %5C%0A%09SYS_GETDENTS                 = 272 // %7B int getdents(int fd, char *buf, %5C%0A%09SYS_LCHMOD                   = 274 // %7B int lchmod(char *path, mode_t mode); %7D%0A%09SYS_LUTIMES                  = 276 // %7B int lutimes(char *path, %5C%0A%09SYS_NSTAT                    = 278 // %7B int nstat(char *path, struct nstat *ub); %7D%0A%09SYS_NFSTAT                   = 279 // %7B int nfstat(int fd, struct nstat *sb); %7D%0A%09SYS_NLSTAT                   = 280 // %7B int nlstat(char *path, struct nstat *ub); %7D%0A%09SYS_PREADV                   = 289 // %7B ssize_t preadv(int fd, struct iovec *iovp, %5C%0A%09SYS_PWRITEV                  = 290 // %7B ssize_t pwritev(int fd, struct iovec *iovp, %5C%0A%09SYS_FHOPEN                   = 298 // %7B int fhopen(const struct fhandle *u_fhp, %5C%0A%09SYS_FHSTAT                   = 299 // %7B int fhstat(const struct fhandle *u_fhp, %5C%0A%09SYS_MODNEXT                  = 300 // %7B int modnext(int modid); %7D%0A%09SYS_MODSTAT                  = 301 // %7B int modstat(int modid, %5C%0A%09SYS_MODFNEXT                 = 302 // %7B int modfnext(int modid); %7D%0A%09SYS_MODFIND                  = 303 // %7B int modfind(const char *name); %7D%0A%09SYS_KLDLOAD                  = 304 // %7B int kldload(const char *file); %7D%0A%09SYS_KLDUNLOAD                = 305 // %7B int kldunload(int fileid); %7D%0A%09SYS_KLDFIND                  = 306 // %7B int kldfind(const char *file); %7D%0A%09SYS_KLDNEXT                  = 307 // %7B int kldnext(int fileid); %7D%0A%09SYS_KLDSTAT                  = 308 // %7B int kldstat(int fileid, struct %5C%0A%09SYS_KLDFIRSTMOD              = 309 // %7B int kldfirstmod(int fileid); %7D%0A%09SYS_GETSID                   = 310 // %7B int getsid(pid_t pid); %7D%0A%09SYS_SETRESUID                = 311 // %7B int setresuid(uid_t ruid, uid_t euid, %5C%0A%09SYS_SETRESGID                = 312 // %7B int setresgid(gid_t rgid, gid_t egid, %5C%0A%09SYS_AIO_RETURN               = 314 // %7B int aio_return(struct aiocb *aiocbp); %7D%0A%09SYS_AIO_SUSPEND              = 315 // %7B int aio_suspend( %5C%0A%09SYS_AIO_CANCEL               = 316 // %7B int aio_cancel(int fd, %5C%0A%09SYS_AIO_ERROR                = 317 // %7B int aio_error(struct aiocb *aiocbp); %7D%0A%09SYS_OAIO_READ                = 318 // %7B int oaio_read(struct oaiocb *aiocbp); %7D%0A%09SYS_OAIO_WRITE               = 319 // %7B int oaio_write(struct oaiocb *aiocbp); %7D%0A%09SYS_OLIO_LISTIO              = 320 // %7B int olio_listio(int mode, %5C%0A%09SYS_YIELD                    = 321 // %7B int yield(void); %7D%0A%09SYS_MLOCKALL                 = 324 // %7B int mlockall(int how); %7D%0A%09SYS_MUNLOCKALL               = 325 // %7B int munlockall(void); %7D%0A%09SYS___GETCWD                 = 326 // %7B int __getcwd(char *buf, u_int buflen); %7D%0A%09SYS_SCHED_SETPARAM           = 327 // %7B int sched_setparam (pid_t pid, %5C%0A%09SYS_SCHED_GETPARAM           = 328 // %7B int sched_getparam (pid_t pid, struct %5C%0A%09SYS_SCHED_SETSCHEDULER       = 329 // %7B int sched_setscheduler (pid_t pid, int %5C%0A%09SYS_SCHED_GETSCHEDULER       = 330 // %7B int sched_getscheduler (pid_t pid); %7D%0A%09SYS_SCHED_YIELD              = 331 // %7B int sched_yield (void); %7D%0A%09SYS_SCHED_GET_PRIORITY_MAX   = 332 // %7B int sched_get_priority_max (int policy); %7D%0A%09SYS_SCHED_GET_PRIORITY_MIN   = 333 // %7B int sched_get_priority_min (int policy); %7D%0A%09SYS_SCHED_RR_GET_INTERVAL    = 334 // %7B int sched_rr_get_interval (pid_t pid, %5C%0A%09SYS_UTRACE                   = 335 // %7B int utrace(const void *addr, size_t len); %7D%0A%09SYS_KLDSYM                   = 337 // %7B int kldsym(int fileid, int cmd, %5C%0A%09SYS_JAIL                     = 338 // %7B int jail(struct jail *jail); %7D%0A%09SYS_SIGPROCMASK              = 340 // %7B int sigprocmask(int how, %5C%0A%09SYS_SIGSUSPEND               = 341 // %7B int sigsuspend(const sigset_t *sigmask); %7D%0A%09SYS_SIGPENDING               = 343 // %7B int sigpending(sigset_t *set); %7D%0A%09SYS_SIGTIMEDWAIT             = 345 // %7B int sigtimedwait(const sigset_t *set, %5C%0A%09SYS_SIGWAITINFO              = 346 // %7B int sigwaitinfo(const sigset_t *set, %5C%0A%09SYS___ACL_GET_FILE           = 347 // %7B int __acl_get_file(const char *path, %5C%0A%09SYS___ACL_SET_FILE           = 348 // %7B int __acl_set_file(const char *path, %5C%0A%09SYS___ACL_GET_FD             = 349 // %7B int __acl_get_fd(int filedes, %5C%0A%09SYS___ACL_SET_FD             = 350 // %7B int __acl_set_fd(int filedes, %5C%0A%09SYS___ACL_DELETE_FILE        = 351 // %7B int __acl_delete_file(const char *path, %5C%0A%09SYS___ACL_DELETE_FD          = 352 // %7B int __acl_delete_fd(int filedes, %5C%0A%09SYS___ACL_ACLCHECK_FILE      = 353 // %7B int __acl_aclcheck_file(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_FD        = 354 // %7B int __acl_aclcheck_fd(int filedes, %5C%0A%09SYS_EXTATTRCTL               = 355 // %7B int extattrctl(const char *path, int cmd, %5C%0A%09SYS_EXTATTR_SET_FILE         = 356 // %7B ssize_t extattr_set_file( %5C%0A%09SYS_EXTATTR_GET_FILE         = 357 // %7B ssize_t extattr_get_file( %5C%0A%09SYS_EXTATTR_DELETE_FILE      = 358 // %7B int extattr_delete_file(const char *path, %5C%0A%09SYS_AIO_WAITCOMPLETE         = 359 // %7B int aio_waitcomplete( %5C%0A%09SYS_GETRESUID                = 360 // %7B int getresuid(uid_t *ruid, uid_t *euid, %5C%0A%09SYS_GETRESGID                = 361 // %7B int getresgid(gid_t *rgid, gid_t *egid, %5C%0A%09SYS_KQUEUE                   = 362 // %7B int kqueue(void); %7D%0A%09SYS_KEVENT                   = 363 // %7B int kevent(int fd, %5C%0A%09SYS_EXTATTR_SET_FD           = 371 // %7B ssize_t extattr_set_fd(int fd, %5C%0A%09SYS_EXTATTR_GET_FD           = 372 // %7B ssize_t extattr_get_fd(int fd, %5C%0A%09SYS_EXTATTR_DELETE_FD        = 373 // %7B int extattr_delete_fd(int fd, %5C%0A%09SYS___SETUGID                = 374 // %7B int __setugid(int flag); %7D%0A%09SYS_EACCESS                  = 376 // %7B int eaccess(char *path, int amode); %7D%0A%09SYS_NMOUNT                   = 378 // %7B int nmount(struct iovec *iovp, %5C%0A%09SYS___MAC_GET_PROC           = 384 // %7B int __mac_get_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_SET_PROC           = 385 // %7B int __mac_set_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_GET_FD             = 386 // %7B int __mac_get_fd(int fd, %5C%0A%09SYS___MAC_GET_FILE           = 387 // %7B int __mac_get_file(const char *path_p, %5C%0A%09SYS___MAC_SET_FD             = 388 // %7B int __mac_set_fd(int fd, %5C%0A%09SYS___MAC_SET_FILE           = 389 // %7B int __mac_set_file(const char *path_p, %5C%0A%09SYS_KENV                     = 390 // %7B int kenv(int what, const char *name, %5C%0A%09SYS_LCHFLAGS                 = 391 // %7B int lchflags(const char *path, %5C%0A%09SYS_UUIDGEN                  = 392 // %7B int uuidgen(struct uuid *store, %5C%0A%09SYS_SENDFILE                 = 393 // %7B int sendfile(int fd, int s, off_t offset, %5C%0A%09SYS_MAC_SYSCALL              = 394 // %7B int mac_syscall(const char *policy, %5C%0A%09SYS_GETFSSTAT                = 395 // %7B int getfsstat(struct statfs *buf, %5C%0A%09SYS_STATFS                   = 396 // %7B int statfs(char *path, %5C%0A%09SYS_FSTATFS                  = 397 // %7B int fstatfs(int fd, struct statfs *buf); %7D%0A%09SYS_FHSTATFS                 = 398 // %7B int fhstatfs(const struct fhandle *u_fhp, %5C%0A%09SYS_KSEM_CLOSE               = 400 // %7B int ksem_close(semid_t id); %7D%0A%09SYS_KSEM_POST                = 401 // %7B int ksem_post(semid_t id); %7D%0A%09SYS_KSEM_WAIT                = 402 // %7B int ksem_wait(semid_t id); %7D%0A%09SYS_KSEM_TRYWAIT             = 403 // %7B int ksem_trywait(semid_t id); %7D%0A%09SYS_KSEM_INIT                = 404 // %7B int ksem_init(semid_t *idp, %5C%0A%09SYS_KSEM_OPEN                = 405 // %7B int ksem_open(semid_t *idp, %5C%0A%09SYS_KSEM_UNLINK              = 406 // %7B int ksem_unlink(const char *name); %7D%0A%09SYS_KSEM_GETVALUE            = 407 // %7B int ksem_getvalue(semid_t id, int *val); %7D%0A%09SYS_KSEM_DESTROY             = 408 // %7B int ksem_destroy(semid_t id); %7D%0A%09SYS___MAC_GET_PID            = 409 // %7B int __mac_get_pid(pid_t pid, %5C%0A%09SYS___MAC_GET_LINK           = 410 // %7B int __mac_get_link(const char *path_p, %5C%0A%09SYS___MAC_SET_LINK           = 411 // %7B int __mac_set_link(const char *path_p, %5C%0A%09SYS_EXTATTR_SET_LINK         = 412 // %7B ssize_t extattr_set_link( %5C%0A%09SYS_EXTATTR_GET_LINK         = 413 // %7B ssize_t extattr_get_link( %5C%0A%09SYS_EXTATTR_DELETE_LINK      = 414 // %7B int extattr_delete_link( %5C%0A%09SYS___MAC_EXECVE             = 415 // %7B int __mac_execve(char *fname, char **argv, %5C%0A%09SYS_SIGACTION                = 416 // %7B int sigaction(int sig, %5C%0A%09SYS_SIGRETURN                = 417 // %7B int sigreturn( %5C%0A%09SYS_GETCONTEXT               = 421 // %7B int getcontext(struct __ucontext *ucp); %7D%0A%09SYS_SETCONTEXT               = 422 // %7B int setcontext( %5C%0A%09SYS_SWAPCONTEXT              = 423 // %7B int swapcontext(struct __ucontext *oucp, %5C%0A%09SYS_SWAPOFF                  = 424 // %7B int swapoff(const char *name); %7D%0A%09SYS___ACL_GET_LINK           = 425 // %7B int __acl_get_link(const char *path, %5C%0A%09SYS___ACL_SET_LINK           = 426 // %7B int __acl_set_link(const char *path, %5C%0A%09SYS___ACL_DELETE_LINK        = 427 // %7B int __acl_delete_link(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_LINK      = 428 // %7B int __acl_aclcheck_link(const char *path, %5C%0A%09SYS_SIGWAIT                  = 429 // %7B int sigwait(const sigset_t *set, %5C%0A%09SYS_THR_CREATE               = 430 // %7B int thr_create(ucontext_t *ctx, long *id, %5C%0A%09SYS_THR_EXIT                 = 431 // %7B void thr_exit(long *state); %7D%0A%09SYS_THR_SELF                 = 432 // %7B int thr_self(long *id); %7D%0A%09SYS_THR_KILL                 = 433 // %7B int thr_kill(long id, int sig); %7D%0A%09SYS__UMTX_LOCK               = 434 // %7B int _umtx_lock(struct umtx *umtx); %7D%0A%09SYS__UMTX_UNLOCK             = 435 // %7B int _umtx_unlock(struct umtx *umtx); %7D%0A%09SYS_JAIL_ATTACH              = 436 // %7B int jail_attach(int jid); %7D%0A%09SYS_EXTATTR_LIST_FD          = 437 // %7B ssize_t extattr_list_fd(int fd, %5C%0A%09SYS_EXTATTR_LIST_FILE        = 438 // %7B ssize_t extattr_list_file( %5C%0A%09SYS_EXTATTR_LIST_LINK        = 439 // %7B ssize_t extattr_list_link( %5C%0A%09SYS_KSEM_TIMEDWAIT           = 441 // %7B int ksem_timedwait(semid_t id, %5C%0A%09SYS_THR_SUSPEND              = 442 // %7B int thr_suspend( %5C%0A%09SYS_THR_WAKE                 = 443 // %7B int thr_wake(long id); %7D%0A%09SYS_KLDUNLOADF               = 444 // %7B int kldunloadf(int fileid, int flags); %7D%0A%09SYS_AUDIT                    = 445 // %7B int audit(const void *record, %5C%0A%09SYS_AUDITON                  = 446 // %7B int auditon(int cmd, void *data, %5C%0A%09SYS_GETAUID                  = 447 // %7B int getauid(uid_t *auid); %7D%0A%09SYS_SETAUID                  = 448 // %7B int setauid(uid_t *auid); %7D%0A%09SYS_GETAUDIT                 = 449 // %7B int getaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_SETAUDIT                 = 450 // %7B int setaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_GETAUDIT_ADDR            = 451 // %7B int getaudit_addr( %5C%0A%09SYS_SETAUDIT_ADDR            = 452 // %7B int setaudit_addr( %5C%0A%09SYS_AUDITCTL                 = 453 // %7B int auditctl(char *path); %7D%0A%09SYS__UMTX_OP                 = 454 // %7B int _umtx_op(void *obj, int op, %5C%0A%09SYS_THR_NEW                  = 455 // %7B int thr_new(struct thr_param *param, %5C%0A%09SYS_SIGQUEUE                 = 456 // %7B int sigqueue(pid_t pid, int signum, void *value); %7D%0A%09SYS_KMQ_OPEN                 = 457 // %7B int kmq_open(const char *path, int flags, %5C%0A%09SYS_KMQ_SETATTR              = 458 // %7B int kmq_setattr(int mqd,%09%09%5C%0A%09SYS_KMQ_TIMEDRECEIVE         = 459 // %7B int kmq_timedreceive(int mqd,%09%5C%0A%09SYS_KMQ_TIMEDSEND            = 460 // %7B int kmq_timedsend(int mqd,%09%09%5C%0A%09SYS_KMQ_NOTIFY               = 461 // %7B int kmq_notify(int mqd,%09%09%5C%0A%09SYS_KMQ_UNLINK               = 462 // %7B int kmq_unlink(const char *path); %7D%0A%09SYS_ABORT2                   = 463 // %7B int abort2(const char *why, int nargs, void **args); %7D%0A%09SYS_THR_SET_NAME             = 464 // %7B int thr_set_name(long id, const char *name); %7D%0A%09SYS_AIO_FSYNC                = 465 // %7B int aio_fsync(int op, struct aiocb *aiocbp); %7D%0A%09SYS_RTPRIO_THREAD            = 466 // %7B int rtprio_thread(int function, %5C%0A%09SYS_SCTP_PEELOFF             = 471 // %7B int sctp_peeloff(int sd, uint32_t name); %7D%0A%09SYS_SCTP_GENERIC_SENDMSG     = 472 // %7B int sctp_generic_sendmsg(int sd, caddr_t msg, int mlen, %5C%0A%09SYS_SCTP_GENERIC_SENDMSG_IOV = 473 // %7B int sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, %5C%0A%09SYS_SCTP_GENERIC_RECVMSG     = 474 // %7B int sctp_generic_recvmsg(int sd, struct iovec *iov, int iovlen, %5C%0A%09SYS_PREAD                    = 475 // %7B ssize_t pread(int fd, void *buf, %5C%0A%09SYS_PWRITE                   = 476 // %7B ssize_t pwrite(int fd, const void *buf, %5C%0A%09SYS_MMAP                     = 477 // %7B caddr_t mmap(caddr_t addr, size_t len, %5C%0A%09SYS_LSEEK                    = 478 // %7B off_t lseek(int fd, off_t offset, %5C%0A%09SYS_TRUNCATE                 = 479 // %7B int truncate(char *path, off_t length); %7D%0A%09SYS_FTRUNCATE                = 480 // %7B int ftruncate(int fd, off_t length); %7D%0A%09SYS_THR_KILL2                = 481 // %7B int thr_kill2(pid_t pid, long id, int sig); %7D%0A%09SYS_SHM_OPEN                 = 482 // %7B int shm_open(const char *path, int flags, %5C%0A%09SYS_SHM_UNLINK               = 483 // %7B int shm_unlink(const char *path); %7D%0A%09SYS_CPUSET                   = 484 // %7B int cpuset(cpusetid_t *setid); %7D%0A%09SYS_CPUSET_SETID             = 485 // %7B int cpuset_setid(cpuwhich_t which, id_t id, %5C%0A%09SYS_CPUSET_GETID             = 486 // %7B int cpuset_getid(cpulevel_t level, %5C%0A%09SYS_CPUSET_GETAFFINITY       = 487 // %7B int cpuset_getaffinity(cpulevel_t level, %5C%0A%09SYS_CPUSET_SETAFFINITY       = 488 // %7B int cpuset_setaffinity(cpulevel_t level, %5C%0A%09SYS_FACCESSAT                = 489 // %7B int faccessat(int fd, char *path, int amode, %5C%0A%09SYS_FCHMODAT                 = 490 // %7B int fchmodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_FCHOWNAT                 = 491 // %7B int fchownat(int fd, char *path, uid_t uid, %5C%0A%09SYS_FEXECVE                  = 492 // %7B int fexecve(int fd, char **argv, %5C%0A%09SYS_FSTATAT                  = 493 // %7B int fstatat(int fd, char *path, %5C%0A%09SYS_FUTIMESAT                = 494 // %7B int futimesat(int fd, char *path, %5C%0A%09SYS_LINKAT                   = 495 // %7B int linkat(int fd1, char *path1, int fd2, %5C%0A%09SYS_MKDIRAT                  = 496 // %7B int mkdirat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKFIFOAT                 = 497 // %7B int mkfifoat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKNODAT                  = 498 // %7B int mknodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_OPENAT                   = 499 // %7B int openat(int fd, char *path, int flag, %5C%0A%09SYS_READLINKAT               = 500 // %7B int readlinkat(int fd, char *path, char *buf, %5C%0A%09SYS_RENAMEAT                 = 501 // %7B int renameat(int oldfd, char *old, int newfd, %5C%0A%09SYS_SYMLINKAT                = 502 // %7B int symlinkat(char *path1, int fd, %5C%0A%09SYS_UNLINKAT                 = 503 // %7B int unlinkat(int fd, char *path, int flag); %7D%0A%09SYS_POSIX_OPENPT             = 504 // %7B int posix_openpt(int flags); %7D%0A%09SYS_GSSD_SYSCALL             = 505 // %7B int gssd_syscall(char *path); %7D%0A%09SYS_JAIL_GET                 = 506 // %7B int jail_get(struct iovec *iovp, %5C%0A%09SYS_JAIL_SET                 = 507 // %7B int jail_set(struct iovec *iovp, %5C%0A%09SYS_JAIL_REMOVE              = 508 // %7B int jail_remove(int jid); %7D%0A%09SYS_CLOSEFROM                = 509 // %7B int closefrom(int lowfd); %7D%0A%09SYS___SEMCTL                 = 510 // %7B int __semctl(int semid, int semnum, %5C%0A%09SYS_MSGCTL                   = 511 // %7B int msgctl(int msqid, int cmd, %5C%0A%09SYS_SHMCTL                   = 512 // %7B int shmctl(int shmid, int cmd, %5C%0A%09SYS_LPATHCONF                = 513 // %7B int lpathconf(char *path, int name); %7D%0A%09SYS___CAP_RIGHTS_GET         = 515 // %7B int __cap_rights_get(int version, %5C%0A%09SYS_CAP_ENTER                = 516 // %7B int cap_enter(void); %7D%0A%09SYS_CAP_GETMODE              = 517 // %7B int cap_getmode(u_int *modep); %7D%0A%09SYS_PDFORK                   = 518 // %7B int pdfork(int *fdp, int flags); %7D%0A%09SYS_PDKILL                   = 519 // %7B int pdkill(int fd, int signum); %7D%0A%09SYS_PDGETPID                 = 520 // %7B int pdgetpid(int fd, pid_t *pidp); %7D%0A%09SYS_PSELECT                  = 522 // %7B int pselect(int nd, fd_set *in, %5C%0A%09SYS_GETLOGINCLASS            = 523 // %7B int getloginclass(char *namebuf, %5C%0A%09SYS_SETLOGINCLASS            = 524 // %7B int setloginclass(const char *namebuf); %7D%0A%09SYS_RCTL_GET_RACCT           = 525 // %7B int rctl_get_racct(const void *inbufp, %5C%0A%09SYS_RCTL_GET_RULES           = 526 // %7B int rctl_get_rules(const void *inbufp, %5C%0A%09SYS_RCTL_GET_LIMITS          = 527 // %7B int rctl_get_limits(const void *inbufp, %5C%0A%09SYS_RCTL_ADD_RULE            = 528 // %7B int rctl_add_rule(const void *inbufp, %5C%0A%09SYS_RCTL_REMOVE_RULE         = 529 // %7B int rctl_remove_rule(const void *inbufp, %5C%0A%09SYS_POSIX_FALLOCATE          = 530 // %7B int posix_fallocate(int fd, %5C%0A%09SYS_POSIX_FADVISE            = 531 // %7B int posix_fadvise(int fd, off_t offset, %5C%0A%09SYS_WAIT6                    = 532 // %7B int wait6(idtype_t idtype, id_t id, %5C%0A%09SYS_CAP_RIGHTS_LIMIT         = 533 // %7B int cap_rights_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_LIMIT         = 534 // %7B int cap_ioctls_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_GET           = 535 // %7B ssize_t cap_ioctls_get(int fd, %5C%0A%09SYS_CAP_FCNTLS_LIMIT         = 536 // %7B int cap_fcntls_limit(int fd, %5C%0A%09SYS_CAP_FCNTLS_GET           = 537 // %7B int cap_fcntls_get(int fd, %5C%0A%09SYS_BINDAT                   = 538 // %7B int bindat(int fd, int s, caddr_t name, %5C%0A%09SYS_CONNECTAT                = 539 // %7B int connectat(int fd, int s, caddr_t name, %5C%0A%09SYS_CHFLAGSAT                = 540 // %7B int chflagsat(int fd, const char *path, %5C%0A%09SYS_ACCEPT4                  = 541 // %7B int accept4(int s, %5C%0A%09SYS_PIPE2                    = 542 // %7B int pipe2(int *fildes, int flags); %7D%0A%09SYS_AIO_MLOCK                = 543 // %7B int aio_mlock(struct aiocb *aiocbp); %7D%0A%09SYS_PROCCTL                  = 544 // %7B int procctl(idtype_t idtype, id_t id, %5C%0A%09SYS_PPOLL                    = 545 // %7B int ppoll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_FUTIMENS                 = 546 // %7B int futimens(int fd, %5C%0A%09SYS_UTIMENSAT                = 547 // %7B int utimensat(int fd, %5C%0A
 )%0A
- f 34107082c63665813eb53f5de42806c5c14f2d31f7c78c77702ce6e7407ce948 vendor/golang.org/x/sys/unix/zsysnum_freebsd_amd64.go
+ f f2f4e6bc87589ff70593f3dd9345ff4de2f7caa98392fc54947e8a052704177e vendor/golang.org/x/sys/unix/zsysnum_freebsd_amd64.go
dmppatch 5
@@ -203,25423 +203,30051 @@
 int%0A
-%09SYS_EXIT                   = 1   // %7B void sys_exit(int rval); %7D exit %5C%0A%09SYS_FORK                   = 2   // %7B int fork(void); %7D%0A%09SYS_READ                   = 3   // %7B ssize_t read(int fd, void *buf, %5C%0A%09SYS_WRITE                  = 4   // %7B ssize_t write(int fd, const void *buf, %5C%0A%09SYS_OPEN                   = 5   // %7B int open(char *path, int flags, int mode); %7D%0A%09SYS_CLOSE                  = 6   // %7B int close(int fd); %7D%0A%09SYS_WAIT4                  = 7   // %7B int wait4(int pid, int *status, %5C%0A%09SYS_LINK                   = 9   // %7B int link(char *path, char *link); %7D%0A%09SYS_UNLINK                 = 10  // %7B int unlink(char *path); %7D%0A%09SYS_CHDIR                  = 12  // %7B int chdir(char *path); %7D%0A%09SYS_FCHDIR                 = 13  // %7B int fchdir(int fd); %7D%0A%09SYS_MKNOD                  = 14  // %7B int mknod(char *path, int mode, int dev); %7D%0A%09SYS_CHMOD                  = 15  // %7B int chmod(char *path, int mode); %7D%0A%09SYS_CHOWN                  = 16  // %7B int chown(char *path, int uid, int gid); %7D%0A%09SYS_OBREAK                 = 17  // %7B int obreak(char *nsize); %7D break %5C%0A%09SYS_GETPID                 = 20  // %7B pid_t getpid(void); %7D%0A%09SYS_MOUNT                  = 21  // %7B int mount(char *type, char *path, %5C%0A%09SYS_UNMOUNT                = 22  // %7B int unmount(char *path, int flags); %7D%0A%09SYS_SETUID                 = 23  // %7B int setuid(uid_t uid); %7D%0A%09SYS_GETUID                 = 24  // %7B uid_t getuid(void); %7D%0A%09SYS_GETEUID                = 25  // %7B uid_t geteuid(void); %7D%0A%09SYS_PTRACE                 = 26  // %7B int ptrace(int req, pid_t pid, %5C%0A%09SYS_RECVMSG                = 27  // %7B int recvmsg(int s, struct msghdr *msg, %5C%0A%09SYS_SENDMSG                = 28  // %7B int sendmsg(int s, struct msghdr *msg, %5C%0A%09SYS_RECVFROM               = 29  // %7B int recvfrom(int s, caddr_t buf, %5C%0A%09SYS_ACCEPT                 = 30  // %7B int accept(int s, %5C%0A%09SYS_GETPEERNAME            = 31  // %7B int getpeername(int fdes, %5C%0A%09SYS_GETSOCKNAME            = 32  // %7B int getsockname(int fdes, %5C%0A%09SYS_ACCESS                 = 33  // %7B int access(char *path, int amode); %7D%0A%09SYS_CHFLAGS                = 34  // %7B int chflags(const char *path, u_long flags); %7D%0A%09SYS_FCHFLAGS               = 35  // %7B int fchflags(int fd, u_long flags); %7D%0A%09SYS_SYNC                   = 36  // %7B int sync(void); %7D%0A%09SYS_KILL                   = 37  // %7B int kill(int pid, int signum); %7D%0A%09SYS_GETPPID                = 39  // %7B pid_t getppid(void); %7D%0A%09SYS_DUP                    = 41  // %7B int dup(u_int fd); %7D%0A%09SYS_PIPE                   = 42  // %7B int pipe(void); %7D%0A%09SYS_GETEGID                = 43  // %7B gid_t getegid(void); %7D%0A%09SYS_PROFIL                 = 44  // %7B int profil(caddr_t samples, size_t size, %5C%0A%09SYS_KTRACE                 = 45  // %7B int ktrace(const char *fname, int ops, %5C%0A%09SYS_GETGID                 = 47  // %7B gid_t getgid(void); %7D%0A%09SYS_GETLOGIN               = 49  // %7B int getlogin(char *namebuf, u_int %5C%0A%09SYS_SETLOGIN               = 50  // %7B int setlogin(char *namebuf); %7D%0A%09SYS_ACCT                   = 51  // %7B int acct(char *path); %7D%0A%09SYS_SIGALTSTACK            = 53  // %7B int sigaltstack(stack_t *ss, %5C%0A%09SYS_IOCTL                  = 54  // %7B int ioctl(int fd, u_long com, %5C%0A%09SYS_REBOOT                 = 55  // %7B int reboot(int opt); %7D%0A%09SYS_REVOKE                 = 56  // %7B int revoke(char *path); %7D%0A%09SYS_SYMLINK                = 57  // %7B int symlink(char *path, char *link); %7D%0A%09SYS_READLINK               = 58  // %7B ssize_t readlink(char *path, char *buf, %5C%0A%09SYS_EXECVE                 = 59  // %7B int execve(char *fname, char **argv, %5C%0A%09SYS_UMASK                  = 60  // %7B int umask(int newmask); %7D umask umask_args %5C%0A%09SYS_CHROOT                 = 61  // %7B int chroot(char *path); %7D%0A%09SYS_MSYNC                  = 65  // %7B int msync(void *addr, size_t len, %5C%0A%09SYS_VFORK                  = 66  // %7B int vfork(void); %7D%0A%09SYS_SBRK                   = 69  // %7B int sbrk(int incr); %7D%0A%09SYS_SSTK                   = 70  // %7B int sstk(int incr); %7D%0A%09SYS_OVADVISE               = 72  // %7B int ovadvise(int anom); %7D vadvise %5C%0A%09SYS_MUNMAP                 = 73  // %7B int munmap(void *addr, size_t len); %7D%0A%09SYS_MPROTECT               = 74  // %7B int mprotect(const void *addr, size_t len, %5C%0A%09SYS_MADVISE                = 75  // %7B int madvise(void *addr, size_t len, %5C%0A%09SYS_MINCORE                = 78  // %7B int mincore(const void *addr, size_t len, %5C%0A%09SYS_GETGROUPS              = 79  // %7B int getgroups(u_int gidsetsize, %5C%0A%09SYS_SETGROUPS              = 80  // %7B int setgroups(u_int gidsetsize, %5C%0A%09SYS_GETPGRP                = 81  // %7B int getpgrp(void); %7D%0A%09SYS_SETPGID                = 82  // %7B int setpgid(int pid, int pgid); %7D%0A%09SYS_SETITIMER              = 83  // %7B int setitimer(u_int which, struct %5C%0A%09SYS_SWAPON                 = 85  // %7B int swapon(char *name); %7D%0A%09SYS_GETITIMER              = 86  // %7B int getitimer(u_int which, %5C%0A%09SYS_GETDTABLESIZE          = 89  // %7B int getdtablesize(void); %7D%0A%09SYS_DUP2                   = 90  // %7B int dup2(u_int from, u_int to); %7D%0A%09SYS_FCNTL                  = 92  // %7B int fcntl(int fd, int cmd, long arg); %7D%0A%09SYS_SELECT                 = 93  // %7B int select(int nd, fd_set *in, fd_set *ou, %5C%0A%09SYS_FSYNC                  = 95  // %7B int fsync(int fd); %7D%0A%09SYS_SETPRIORITY            = 96  // %7B int setpriority(int which, int who, %5C%0A%09SYS_SOCKET                 = 97  // %7B int socket(int domain, int type, %5C%0A%09SYS_CONNECT                = 98  // %7B int connect(int s, caddr_t name, %5C%0A%09SYS_GETPRIORITY            = 100 // %7B int getpriority(int which, int who); %7D%0A%09SYS_BIND                   = 104 // %7B int bind(int s, caddr_t name, %5C%0A%09SYS_SETSOCKOPT             = 105 // %7B int setsockopt(int s, int level, int name, %5C%0A%09SYS_LISTEN                 = 106 // %7B int listen(int s, int backlog); %7D%0A%09SYS_GETTIMEOFDAY           = 116 // %7B int gettimeofday(struct timeval *tp, %5C%0A%09SYS_GETRUSAGE              = 117 // %7B int getrusage(int who, %5C%0A%09SYS_GETSOCKOPT             = 118 // %7B int getsockopt(int s, int level, int name, %5C%0A%09SYS_READV                  = 120 // %7B int readv(int fd, struct iovec *iovp, %5C%0A%09SYS_WRITEV                 = 121 // %7B int writev(int fd, struct iovec *iovp, %5C%0A%09SYS_SETTIMEOFDAY           = 122 // %7B int settimeofday(struct timeval *tv, %5C%0A%09SYS_FCHOWN                 = 123 // %7B int fchown(int fd, int uid, int gid); %7D%0A%09SYS_FCHMOD                 = 124 // %7B int fchmod(int fd, int mode); %7D%0A%09SYS_SETREUID               = 126 // %7B int setreuid(int ruid, int euid); %7D%0A%09SYS_SETREGID               = 127 // %7B int setregid(int rgid, int egid); %7D%0A%09SYS_RENAME                 = 128 // %7B int rename(char *from, char *to); %7D%0A%09SYS_FLOCK                  = 131 // %7B int flock(int fd, int how); %7D%0A%09SYS_MKFIFO                 = 132 // %7B int mkfifo(char *path, int mode); %7D%0A%09SYS_SENDTO                 = 133 // %7B int sendto(int s, caddr_t buf, size_t len, %5C%0A%09SYS_SHUTDOWN               = 134 // %7B int shutdown(int s, int how); %7D%0A%09SYS_SOCKETPAIR             = 135 // %7B int socketpair(int domain, int type, %5C%0A%09SYS_MKDIR                  = 136 // %7B int mkdir(char *path, int mode); %7D%0A%09SYS_RMDIR                  = 137 // %7B int rmdir(char *path); %7D%0A%09SYS_UTIMES                 = 138 // %7B int utimes(char *path, %5C%0A%09SYS_ADJTIME                = 140 // %7B int adjtime(struct timeval *delta, %5C%0A%09SYS_SETSID                 = 147 // %7B int setsid(void); %7D%0A%09SYS_QUOTACTL               = 148 // %7B int quotactl(char *path, int cmd, int uid, %5C%0A%09SYS_LGETFH                 = 160 // %7B int lgetfh(char *fname, %5C%0A%09SYS_GETFH                  = 161 // %7B int getfh(char *fname, %5C%0A%09SYS_SYSARCH                = 165 // %7B int sysarch(int op, char *parms); %7D%0A%09SYS_RTPRIO                 = 166 // %7B int rtprio(int function, pid_t pid, %5C%0A%09SYS_FREEBSD6_PREAD         = 173 // %7B ssize_t freebsd6_pread(int fd, void *buf, %5C%0A%09SYS_FREEBSD6_PWRITE        = 174 // %7B ssize_t freebsd6_pwrite(int fd, %5C%0A%09SYS_SETFIB                 = 175 // %7B int setfib(int fibnum); %7D%0A%09SYS_NTP_ADJTIME            = 176 // %7B int ntp_adjtime(struct timex *tp); %7D%0A%09SYS_SETGID                 = 181 // %7B int setgid(gid_t gid); %7D%0A%09SYS_SETEGID                = 182 // %7B int setegid(gid_t egid); %7D%0A%09SYS_SETEUID                = 183 // %7B int seteuid(uid_t euid); %7D%0A%09SYS_STAT                   = 188 // %7B int stat(char *path, struct stat *ub); %7D%0A%09SYS_FSTAT                  = 189 // %7B int fstat(int fd, struct stat *sb); %7D%0A%09SYS_LSTAT                  = 190 // %7B int lstat(char *path, struct stat *ub); %7D%0A%09SYS_PATHCONF               = 191 // %7B int pathconf(char *path, int name); %7D%0A%09SYS_FPATHCONF              = 192 // %7B int fpathconf(int fd, int name); %7D%0A%09SYS_GETRLIMIT              = 194 // %7B int getrlimit(u_int which, %5C%0A%09SYS_SETRLIMIT              = 195 // %7B int setrlimit(u_int which, %5C%0A%09SYS_GETDIRENTRIES          = 196 // %7B int getdirentries(int fd, char *buf, %5C%0A%09SYS_FREEBSD6_MMAP          = 197 // %7B caddr_t freebsd6_mmap(caddr_t addr, %5C%0A%09SYS_FREEBSD6_LSEEK         = 199 // %7B off_t freebsd6_lseek(int fd, int pad, %5C%0A%09SYS_FREEBSD6_TRUNCATE      = 200 // %7B int freebsd6_truncate(char *path, int pad, %5C%0A%09SYS_FREEBSD6_FTRUNCATE     = 201 // %7B int freebsd6_ftruncate(int fd, int pad, %5C%0A%09SYS___SYSCTL               = 202 // %7B int __sysctl(int *name, u_int namelen, %5C%0A%09SYS_MLOCK                  = 203 // %7B int mlock(const void *addr, size_t len); %7D%0A%09SYS_MUNLOCK                = 204 // %7B int munlock(const void *addr, size_t len); %7D%0A%09SYS_UNDELETE               = 205 // %7B int undelete(char *path); %7D%0A%09SYS_FUTIMES                = 206 // %7B int futimes(int fd, struct timeval *tptr); %7D%0A%09SYS_GETPGID                = 207 // %7B int getpgid(pid_t pid); %7D%0A%09SYS_POLL                   = 209 // %7B int poll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_CLOCK_GETTIME          = 232 // %7B int clock_gettime(clockid_t clock_id, %5C%0A%09SYS_CLOCK_SETTIME          = 233 // %7B int clock_settime( %5C%0A%09SYS_CLOCK_GETRES           = 234 // %7B int clock_getres(clockid_t clock_id, %5C%0A%09SYS_KTIMER_CREATE          = 235 // %7B int ktimer_create(clockid_t clock_id, %5C%0A%09SYS_KTIMER_DELETE          = 236 // %7B int ktimer_delete(int timerid); %7D%0A%09SYS_KTIMER_SETTIME         = 237 // %7B int ktimer_settime(int timerid, int flags, %5C%0A%09SYS_KTIMER_GETTIME         = 238 // %7B int ktimer_gettime(int timerid, struct %5C%0A%09SYS_KTIMER_GETOVERRUN      = 239 // %7B int ktimer_getoverrun(int timerid); %7D%0A%09SYS_NANOSLEEP              = 240 // %7B int nanosleep(const struct timespec *rqtp, %5C%0A%09SYS_FFCLOCK_GETCOUNTER     = 241 // %7B int ffclock_getcounter(ffcounter *ffcount); %7D%0A%09SYS_FFCLOCK_SETESTIMATE    = 242 // %7B int ffclock_setestimate( %5C%0A%09SYS_FFCLOCK_GETESTIMATE    = 243 // %7B int ffclock_getestimate( %5C%0A%09SYS_CLOCK_GETCPUCLOCKID2   = 247 // %7B int clock_getcpuclockid2(id_t id,%5C%0A%09SYS_NTP_GETTIME            = 248 // %7B int ntp_gettime(struct ntptimeval *ntvp); %7D%0A%09SYS_MINHERIT               = 250 // %7B int minherit(void *addr, size_t len, %5C%0A%09SYS_RFORK                  = 251 // %7B int rfork(int flags); %7D%0A%09SYS_OPENBSD_POLL           = 252 // %7B int openbsd_poll(struct pollfd *fds, %5C%0A%09SYS_ISSETUGID              = 253 // %7B int issetugid(void); %7D%0A%09SYS_LCHOWN                 = 254 // %7B int lchown(char *path, int uid, int gid); %7D%0A%09SYS_GETDENTS               = 272 // %7B int getdents(int fd, char *buf, %5C%0A%09SYS_LCHMOD                 = 274 // %7B int lchmod(char *path, mode_t mode); %7D%0A%09SYS_LUTIMES                = 276 // %7B int lutimes(char *path, %5C%0A%09SYS_NSTAT                  = 278 // %7B int nstat(char *path, struct nstat *ub); %7D%0A%09SYS_NFSTAT                 = 279 // %7B int nfstat(int fd, struct nstat *sb); %7D%0A%09SYS_NLSTAT                 = 280 // %7B int nlstat(char *path, struct nstat *ub); %7D%0A%09SYS_PREADV                 = 289 // %7B ssize_t preadv(int fd, struct iovec *iovp, %5C%0A%09SYS_PWRITEV                = 290 // %7B ssize_t pwritev(int fd, struct iovec *iovp, %5C%0A%09SYS_FHOPEN                 = 298 // %7B int fhopen(const struct fhandle *u_fhp, %5C%0A%09SYS_FHSTAT                 = 299 // %7B int fhstat(const struct fhandle *u_fhp, %5C%0A%09SYS_MODNEXT                = 300 // %7B int modnext(int modid); %7D%0A%09SYS_MODSTAT                = 301 // %7B int modstat(int modid, %5C%0A%09SYS_MODFNEXT               = 302 // %7B int modfnext(int modid); %7D%0A%09SYS_MODFIND                = 303 // %7B int modfind(const char *name); %7D%0A%09SYS_KLDLOAD                = 304 // %7B int kldload(const char *file); %7D%0A%09SYS_KLDUNLOAD              = 305 // %7B int kldunload(int fileid); %7D%0A%09SYS_KLDFIND                = 306 // %7B int kldfind(const char *file); %7D%0A%09SYS_KLDNEXT                = 307 // %7B int kldnext(int fileid); %7D%0A%09SYS_KLDSTAT                = 308 // %7B int kldstat(int fileid, struct %5C%0A%09SYS_KLDFIRSTMOD            = 309 // %7B int kldfirstmod(int fileid); %7D%0A%09SYS_GETSID                 = 310 // %7B int getsid(pid_t pid); %7D%0A%09SYS_SETRESUID              = 311 // %7B int setresuid(uid_t ruid, uid_t euid, %5C%0A%09SYS_SETRESGID              = 312 // %7B int setresgid(gid_t rgid, gid_t egid, %5C%0A%09SYS_YIELD                  = 321 // %7B int yield(void); %7D%0A%09SYS_MLOCKALL               = 324 // %7B int mlockall(int how); %7D%0A%09SYS_MUNLOCKALL             = 325 // %7B int munlockall(void); %7D%0A%09SYS___GETCWD               = 326 // %7B int __getcwd(char *buf, u_int buflen); %7D%0A%09SYS_SCHED_SETPARAM         = 327 // %7B int sched_setparam (pid_t pid, %5C%0A%09SYS_SCHED_GETPARAM         = 328 // %7B int sched_getparam (pid_t pid, struct %5C%0A%09SYS_SCHED_SETSCHEDULER     = 329 // %7B int sched_setscheduler (pid_t pid, int %5C%0A%09SYS_SCHED_GETSCHEDULER     = 330 // %7B int sched_getscheduler (pid_t pid); %7D%0A%09SYS_SCHED_YIELD            = 331 // %7B int sched_yield (void); %7D%0A%09SYS_SCHED_GET_PRIORITY_MAX = 332 // %7B int sched_get_priority_max (int policy); %7D%0A%09SYS_SCHED_GET_PRIORITY_MIN = 333 // %7B int sched_get_priority_min (int policy); %7D%0A%09SYS_SCHED_RR_GET_INTERVAL  = 334 // %7B int sched_rr_get_interval (pid_t pid, %5C%0A%09SYS_UTRACE                 = 335 // %7B int utrace(const void *addr, size_t len); %7D%0A%09SYS_KLDSYM                 = 337 // %7B int kldsym(int fileid, int cmd, %5C%0A%09SYS_JAIL                   = 338 // %7B int jail(struct jail *jail); %7D%0A%09SYS_SIGPROCMASK            = 340 // %7B int sigprocmask(int how, %5C%0A%09SYS_SIGSUSPEND             = 341 // %7B int sigsuspend(const sigset_t *sigmask); %7D%0A%09SYS_SIGPENDING             = 343 // %7B int sigpending(sigset_t *set); %7D%0A%09SYS_SIGTIMEDWAIT           = 345 // %7B int sigtimedwait(const sigset_t *set, %5C%0A%09SYS_SIGWAITINFO            = 346 // %7B int sigwaitinfo(const sigset_t *set, %5C%0A%09SYS___ACL_GET_FILE         = 347 // %7B int __acl_get_file(const char *path, %5C%0A%09SYS___ACL_SET_FILE         = 348 // %7B int __acl_set_file(const char *path, %5C%0A%09SYS___ACL_GET_FD           = 349 // %7B int __acl_get_fd(int filedes, %5C%0A%09SYS___ACL_SET_FD           = 350 // %7B int __acl_set_fd(int filedes, %5C%0A%09SYS___ACL_DELETE_FILE      = 351 // %7B int __acl_delete_file(const char *path, %5C%0A%09SYS___ACL_DELETE_FD        = 352 // %7B int __acl_delete_fd(int filedes, %5C%0A%09SYS___ACL_ACLCHECK_FILE    = 353 // %7B int __acl_aclcheck_file(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_FD      = 354 // %7B int __acl_aclcheck_fd(int filedes, %5C%0A%09SYS_EXTATTRCTL             = 355 // %7B int extattrctl(const char *path, int cmd, %5C%0A%09SYS_EXTATTR_SET_FILE       = 356 // %7B ssize_t extattr_set_file( %5C%0A%09SYS_EXTATTR_GET_FILE       = 357 // %7B ssize_t extattr_get_file( %5C%0A%09SYS_EXTATTR_DELETE_FILE    = 358 // %7B int extattr_delete_file(const char *path, %5C%0A%09SYS_GETRESUID              = 360 // %7B int getresuid(uid_t *ruid, uid_t *euid, %5C%0A%09SYS_GETRESGID              = 361 // %7B int getresgid(gid_t *rgid, gid_t *egid, %5C%0A%09SYS_KQUEUE                 = 362 // %7B int kqueue(void); %7D%0A%09SYS_KEVENT                 = 363 // %7B int kevent(int fd, %5C%0A%09SYS_EXTATTR_SET_FD         = 371 // %7B ssize_t extattr_set_fd(int fd, %5C%0A%09SYS_EXTATTR_GET_FD         = 372 // %7B ssize_t extattr_get_fd(int fd, %5C%0A%09SYS_EXTATTR_DELETE_FD      = 373 // %7B int extattr_delete_fd(int fd, %5C%0A%09SYS___SETUGID              = 374 // %7B int __setugid(int flag); %7D%0A%09SYS_EACCESS                = 376 // %7B int eaccess(char *path, int amode); %7D%0A%09SYS_NMOUNT                 = 378 // %7B int nmount(struct iovec *iovp, %5C%0A%09SYS___MAC_GET_PROC         = 384 // %7B int __mac_get_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_SET_PROC         = 385 // %7B int __mac_set_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_GET_FD           = 386 // %7B int __mac_get_fd(int fd, %5C%0A%09SYS___MAC_GET_FILE         = 387 // %7B int __mac_get_file(const char *path_p, %5C%0A%09SYS___MAC_SET_FD           = 388 // %7B int __mac_set_fd(int fd, %5C%0A%09SYS___MAC_SET_FILE         = 389 // %7B int __mac_set_file(const char *path_p, %5C%0A%09SYS_KENV                   = 390 // %7B int kenv(int what, const char *name, %5C%0A%09SYS_LCHFLAGS               = 391 // %7B int lchflags(const char *path, %5C%0A%09SYS_UUIDGEN                = 392 // %7B int uuidgen(struct uuid *store, %5C%0A%09SYS_SENDFILE               = 393 // %7B int sendfile(int fd, int s, off_t offset, %5C%0A%09SYS_MAC_SYSCALL            = 394 // %7B int mac_syscall(const char *policy, %5C%0A%09SYS_GETFSSTAT              = 395 // %7B int getfsstat(struct statfs *buf, %5C%0A%09SYS_STATFS                 = 396 // %7B int statfs(char *path, %5C%0A%09SYS_FSTATFS                = 397 // %7B int fstatfs(int fd, struct statfs *buf); %7D%0A%09SYS_FHSTATFS               = 398 // %7B int fhstatfs(const struct fhandle *u_fhp, %5C%0A%09SYS___MAC_GET_PID          = 409 // %7B int __mac_get_pid(pid_t pid, %5C%0A%09SYS___MAC_GET_LINK         = 410 // %7B int __mac_get_link(const char *path_p, %5C%0A%09SYS___MAC_SET_LINK         = 411 // %7B int __mac_set_link(const char *path_p, %5C%0A%09SYS_EXTATTR_SET_LINK       = 412 // %7B ssize_t extattr_set_link( %5C%0A%09SYS_EXTATTR_GET_LINK       = 413 // %7B ssize_t extattr_get_link( %5C%0A%09SYS_EXTATTR_DELETE_LINK    = 414 // %7B int extattr_delete_link( %5C%0A%09SYS___MAC_EXECVE           = 415 // %7B int __mac_execve(char *fname, char **argv, %5C%0A%09SYS_SIGACTION              = 416 // %7B int sigaction(int sig, %5C%0A%09SYS_SIGRETURN              = 417 // %7B int sigreturn( %5C%0A%09SYS_GETCONTEXT             = 421 // %7B int getcontext(struct __ucontext *ucp); %7D%0A%09SYS_SETCONTEXT             = 422 // %7B int setcontext( %5C%0A%09SYS_SWAPCONTEXT            = 423 // %7B int swapcontext(struct __ucontext *oucp, %5C%0A%09SYS_SWAPOFF                = 424 // %7B int swapoff(const char *name); %7D%0A%09SYS___ACL_GET_LINK         = 425 // %7B int __acl_get_link(const char *path, %5C%0A%09SYS___ACL_SET_LINK         = 426 // %7B int __acl_set_link(const char *path, %5C%0A%09SYS___ACL_DELETE_LINK      = 427 // %7B int __acl_delete_link(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_LINK    = 428 // %7B int __acl_aclcheck_link(const char *path, %5C%0A%09SYS_SIGWAIT                = 429 // %7B int sigwait(const sigset_t *set, %5C%0A%09SYS_THR_CREATE             = 430 // %7B int thr_create(ucontext_t *ctx, long *id, %5C%0A%09SYS_THR_EXIT               = 431 // %7B void thr_exit(long *state); %7D%0A%09SYS_THR_SELF               = 432 // %7B int thr_self(long *id); %7D%0A%09SYS_THR_KILL               = 433 // %7B int thr_kill(long id, int sig); %7D%0A%09SYS__UMTX_LOCK             = 434 // %7B int _umtx_lock(struct umtx *umtx); %7D%0A%09SYS__UMTX_UNLOCK           = 435 // %7B int _umtx_unlock(struct umtx *umtx); %7D%0A%09SYS_JAIL_ATTACH            = 436 // %7B int jail_attach(int jid); %7D%0A%09SYS_EXTATTR_LIST_FD        = 437 // %7B ssize_t extattr_list_fd(int fd, %5C%0A%09SYS_EXTATTR_LIST_FILE      = 438 // %7B ssize_t extattr_list_file( %5C%0A%09SYS_EXTATTR_LIST_LINK      = 439 // %7B ssize_t extattr_list_link( %5C%0A%09SYS_THR_SUSPEND            = 442 // %7B int thr_suspend( %5C%0A%09SYS_THR_WAKE               = 443 // %7B int thr_wake(long id); %7D%0A%09SYS_KLDUNLOADF             = 444 // %7B int kldunloadf(int fileid, int flags); %7D%0A%09SYS_AUDIT                  = 445 // %7B int audit(const void *record, %5C%0A%09SYS_AUDITON                = 446 // %7B int auditon(int cmd, void *data, %5C%0A%09SYS_GETAUID                = 447 // %7B int getauid(uid_t *auid); %7D%0A%09SYS_SETAUID                = 448 // %7B int setauid(uid_t *auid); %7D%0A%09SYS_GETAUDIT               = 449 // %7B int getaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_SETAUDIT               = 450 // %7B int setaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_GETAUDIT_ADDR          = 451 // %7B int getaudit_addr( %5C%0A%09SYS_SETAUDIT_ADDR          = 452 // %7B int setaudit_addr( %5C%0A%09SYS_AUDITCTL               = 453 // %7B int auditctl(char *path); %7D%0A%09SYS__UMTX_OP               = 454 // %7B int _umtx_op(void *obj, int op, %5C%0A%09SYS_THR_NEW                = 455 // %7B int thr_new(struct thr_param *param, %5C%0A%09SYS_SIGQUEUE               = 456 // %7B int sigqueue(pid_t pid, int signum, void *value); %7D%0A%09SYS_ABORT2                 = 463 // %7B int abort2(const char *why, int nargs, void **args); %7D%0A%09SYS_THR_SET_NAME           = 464 // %7B int thr_set_name(long id, const char *name); %7D%0A%09SYS_RTPRIO_THREAD          = 466 // %7B int rtprio_thread(int function, %5C%0A%09SYS_PREAD                  = 475 // %7B ssize_t pread(int fd, void *buf, %5C%0A%09SYS_PWRITE                 = 476 // %7B ssize_t pwrite(int fd, const void *buf, %5C%0A%09SYS_MMAP                   = 477 // %7B caddr_t mmap(caddr_t addr, size_t len, %5C%0A%09SYS_LSEEK                  = 478 // %7B off_t lseek(int fd, off_t offset, %5C%0A%09SYS_TRUNCATE               = 479 // %7B int truncate(char *path, off_t length); %7D%0A%09SYS_FTRUNCATE              = 480 // %7B int ftruncate(int fd, off_t length); %7D%0A%09SYS_THR_KILL2              = 481 // %7B int thr_kill2(pid_t pid, long id, int sig); %7D%0A%09SYS_SHM_OPEN               = 482 // %7B int shm_open(const char *path, int flags, %5C%0A%09SYS_SHM_UNLINK             = 483 // %7B int shm_unlink(const char *path); %7D%0A%09SYS_CPUSET                 = 484 // %7B int cpuset(cpusetid_t *setid); %7D%0A%09SYS_CPUSET_SETID           = 485 // %7B int cpuset_setid(cpuwhich_t which, id_t id, %5C%0A%09SYS_CPUSET_GETID           = 486 // %7B int cpuset_getid(cpulevel_t level, %5C%0A%09SYS_CPUSET_GETAFFINITY     = 487 // %7B int cpuset_getaffinity(cpulevel_t level, %5C%0A%09SYS_CPUSET_SETAFFINITY     = 488 // %7B int cpuset_setaffinity(cpulevel_t level, %5C%0A%09SYS_FACCESSAT              = 489 // %7B int faccessat(int fd, char *path, int amode, %5C%0A%09SYS_FCHMODAT               = 490 // %7B int fchmodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_FCHOWNAT               = 491 // %7B int fchownat(int fd, char *path, uid_t uid, %5C%0A%09SYS_FEXECVE                = 492 // %7B int fexecve(int fd, char **argv, %5C%0A%09SYS_FSTATAT                = 493 // %7B int fstatat(int fd, char *path, %5C%0A%09SYS_FUTIMESAT              = 494 // %7B int futimesat(int fd, char *path, %5C%0A%09SYS_LINKAT                 = 495 // %7B int linkat(int fd1, char *path1, int fd2, %5C%0A%09SYS_MKDIRAT                = 496 // %7B int mkdirat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKFIFOAT               = 497 // %7B int mkfifoat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKNODAT                = 498 // %7B int mknodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_OPENAT                 = 499 // %7B int openat(int fd, char *path, int flag, %5C%0A%09SYS_READLINKAT             = 500 // %7B int readlinkat(int fd, char *path, char *buf, %5C%0A%09SYS_RENAMEAT               = 501 // %7B int renameat(int oldfd, char *old, int newfd, %5C%0A%09SYS_SYMLINKAT              = 502 // %7B int symlinkat(char *path1, int fd, %5C%0A%09SYS_UNLINKAT               = 503 // %7B int unlinkat(int fd, char *path, int flag); %7D%0A%09SYS_POSIX_OPENPT           = 504 // %7B int posix_openpt(int flags); %7D%0A%09SYS_JAIL_GET               = 506 // %7B int jail_get(struct iovec *iovp, %5C%0A%09SYS_JAIL_SET               = 507 // %7B int jail_set(struct iovec *iovp, %5C%0A%09SYS_JAIL_REMOVE            = 508 // %7B int jail_remove(int jid); %7D%0A%09SYS_CLOSEFROM              = 509 // %7B int closefrom(int lowfd); %7D%0A%09SYS_LPATHCONF              = 513 // %7B int lpathconf(char *path, int name); %7D%0A%09SYS___CAP_RIGHTS_GET       = 515 // %7B int __cap_rights_get(int version, %5C%0A%09SYS_CAP_ENTER              = 516 // %7B int cap_enter(void); %7D%0A%09SYS_CAP_GETMODE            = 517 // %7B int cap_getmode(u_int *modep); %7D%0A%09SYS_PDFORK                 = 518 // %7B int pdfork(int *fdp, int flags); %7D%0A%09SYS_PDKILL                 = 519 // %7B int pdkill(int fd, int signum); %7D%0A%09SYS_PDGETPID               = 520 // %7B int pdgetpid(int fd, pid_t *pidp); %7D%0A%09SYS_PSELECT                = 522 // %7B int pselect(int nd, fd_set *in, %5C%0A%09SYS_GETLOGINCLASS          = 523 // %7B int getloginclass(char *namebuf, %5C%0A%09SYS_SETLOGINCLASS          = 524 // %7B int setloginclass(const char *namebuf); %7D%0A%09SYS_RCTL_GET_RACCT         = 525 // %7B int rctl_get_racct(const void *inbufp, %5C%0A%09SYS_RCTL_GET_RULES         = 526 // %7B int rctl_get_rules(const void *inbufp, %5C%0A%09SYS_RCTL_GET_LIMITS        = 527 // %7B int rctl_get_limits(const void *inbufp, %5C%0A%09SYS_RCTL_ADD_RULE          = 528 // %7B int rctl_add_rule(const void *inbufp, %5C%0A%09SYS_RCTL_REMOVE_RULE       = 529 // %7B int rctl_remove_rule(const void *inbufp, %5C%0A%09SYS_POSIX_FALLOCATE        = 530 // %7B int posix_fallocate(int fd, %5C%0A%09SYS_POSIX_FADVISE          = 531 // %7B int posix_fadvise(int fd, off_t offset, %5C%0A%09SYS_WAIT6                  = 532 // %7B int wait6(idtype_t idtype, id_t id, %5C%0A%09SYS_CAP_RIGHTS_LIMIT       = 533 // %7B int cap_rights_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_LIMIT       = 534 // %7B int cap_ioctls_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_GET         = 535 // %7B ssize_t cap_ioctls_get(int fd, %5C%0A%09SYS_CAP_FCNTLS_LIMIT       = 536 // %7B int cap_fcntls_limit(int fd, %5C%0A%09SYS_CAP_FCNTLS_GET         = 537 // %7B int cap_fcntls_get(int fd, %5C%0A%09SYS_BINDAT                 = 538 // %7B int bindat(int fd, int s, caddr_t name, %5C%0A%09SYS_CONNECTAT              = 539 // %7B int connectat(int fd, int s, caddr_t name, %5C%0A%09SYS_CHFLAGSAT              = 540 // %7B int chflagsat(int fd, const char *path, %5C%0A%09SYS_ACCEPT4                = 541 // %7B int accept4(int s, %5C%0A%09SYS_PIPE2                  = 542 // %7B int pipe2(int *fildes, int flags); %7D%0A%09SYS_PROCCTL                = 544 // %7B int procctl(idtype_t idtype, id_t id, %5C%0A%09SYS_PPOLL                  = 545 // %7B int ppoll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_FUTIMENS               = 546 // %7B int futimens(int fd, %5C%0A%09SYS_UTIMENSAT              = 547 // %7B int utimensat(int fd, %5C%0A
+%09SYS_EXIT                     = 1   // %7B void sys_exit(int rval); %7D exit %5C%0A%09SYS_FORK                     = 2   // %7B int fork(void); %7D%0A%09SYS_READ                     = 3   // %7B ssize_t read(int fd, void *buf, %5C%0A%09SYS_WRITE                    = 4   // %7B ssize_t write(int fd, const void *buf, %5C%0A%09SYS_OPEN                     = 5   // %7B int open(char *path, int flags, int mode); %7D%0A%09SYS_CLOSE                    = 6   // %7B int close(int fd); %7D%0A%09SYS_WAIT4                    = 7   // %7B int wait4(int pid, int *status, %5C%0A%09SYS_LINK                     = 9   // %7B int link(char *path, char *link); %7D%0A%09SYS_UNLINK                   = 10  // %7B int unlink(char *path); %7D%0A%09SYS_CHDIR                    = 12  // %7B int chdir(char *path); %7D%0A%09SYS_FCHDIR                   = 13  // %7B int fchdir(int fd); %7D%0A%09SYS_MKNOD                    = 14  // %7B int mknod(char *path, int mode, int dev); %7D%0A%09SYS_CHMOD                    = 15  // %7B int chmod(char *path, int mode); %7D%0A%09SYS_CHOWN                    = 16  // %7B int chown(char *path, int uid, int gid); %7D%0A%09SYS_OBREAK                   = 17  // %7B int obreak(char *nsize); %7D break %5C%0A%09SYS_GETPID                   = 20  // %7B pid_t getpid(void); %7D%0A%09SYS_MOUNT                    = 21  // %7B int mount(char *type, char *path, %5C%0A%09SYS_UNMOUNT                  = 22  // %7B int unmount(char *path, int flags); %7D%0A%09SYS_SETUID                   = 23  // %7B int setuid(uid_t uid); %7D%0A%09SYS_GETUID                   = 24  // %7B uid_t getuid(void); %7D%0A%09SYS_GETEUID                  = 25  // %7B uid_t geteuid(void); %7D%0A%09SYS_PTRACE                   = 26  // %7B int ptrace(int req, pid_t pid, %5C%0A%09SYS_RECVMSG                  = 27  // %7B int recvmsg(int s, struct msghdr *msg, %5C%0A%09SYS_SENDMSG                  = 28  // %7B int sendmsg(int s, struct msghdr *msg, %5C%0A%09SYS_RECVFROM                 = 29  // %7B int recvfrom(int s, caddr_t buf, %5C%0A%09SYS_ACCEPT                   = 30  // %7B int accept(int s, %5C%0A%09SYS_GETPEERNAME              = 31  // %7B int getpeername(int fdes, %5C%0A%09SYS_GETSOCKNAME              = 32  // %7B int getsockname(int fdes, %5C%0A%09SYS_ACCESS                   = 33  // %7B int access(char *path, int amode); %7D%0A%09SYS_CHFLAGS                  = 34  // %7B int chflags(const char *path, u_long flags); %7D%0A%09SYS_FCHFLAGS                 = 35  // %7B int fchflags(int fd, u_long flags); %7D%0A%09SYS_SYNC                     = 36  // %7B int sync(void); %7D%0A%09SYS_KILL                     = 37  // %7B int kill(int pid, int signum); %7D%0A%09SYS_GETPPID                  = 39  // %7B pid_t getppid(void); %7D%0A%09SYS_DUP                      = 41  // %7B int dup(u_int fd); %7D%0A%09SYS_PIPE                     = 42  // %7B int pipe(void); %7D%0A%09SYS_GETEGID                  = 43  // %7B gid_t getegid(void); %7D%0A%09SYS_PROFIL                   = 44  // %7B int profil(caddr_t samples, size_t size, %5C%0A%09SYS_KTRACE                   = 45  // %7B int ktrace(const char *fname, int ops, %5C%0A%09SYS_GETGID                   = 47  // %7B gid_t getgid(void); %7D%0A%09SYS_GETLOGIN                 = 49  // %7B int getlogin(char *namebuf, u_int %5C%0A%09SYS_SETLOGIN                 = 50  // %7B int setlogin(char *namebuf); %7D%0A%09SYS_ACCT                     = 51  // %7B int acct(char *path); %7D%0A%09SYS_SIGALTSTACK              = 53  // %7B int sigaltstack(stack_t *ss, %5C%0A%09SYS_IOCTL                    = 54  // %7B int ioctl(int fd, u_long com, %5C%0A%09SYS_REBOOT                   = 55  // %7B int reboot(int opt); %7D%0A%09SYS_REVOKE                   = 56  // %7B int revoke(char *path); %7D%0A%09SYS_SYMLINK                  = 57  // %7B int symlink(char *path, char *link); %7D%0A%09SYS_READLINK                 = 58  // %7B ssize_t readlink(char *path, char *buf, %5C%0A%09SYS_EXECVE                   = 59  // %7B int execve(char *fname, char **argv, %5C%0A%09SYS_UMASK                    = 60  // %7B int umask(int newmask); %7D umask umask_args %5C%0A%09SYS_CHROOT                   = 61  // %7B int chroot(char *path); %7D%0A%09SYS_MSYNC                    = 65  // %7B int msync(void *addr, size_t len, %5C%0A%09SYS_VFORK                    = 66  // %7B int vfork(void); %7D%0A%09SYS_SBRK                     = 69  // %7B int sbrk(int incr); %7D%0A%09SYS_SSTK                     = 70  // %7B int sstk(int incr); %7D%0A%09SYS_OVADVISE                 = 72  // %7B int ovadvise(int anom); %7D vadvise %5C%0A%09SYS_MUNMAP                   = 73  // %7B int munmap(void *addr, size_t len); %7D%0A%09SYS_MPROTECT                 = 74  // %7B int mprotect(const void *addr, size_t len, %5C%0A%09SYS_MADVISE                  = 75  // %7B int madvise(void *addr, size_t len, %5C%0A%09SYS_MINCORE                  = 78  // %7B int mincore(const void *addr, size_t len, %5C%0A%09SYS_GETGROUPS                = 79  // %7B int getgroups(u_int gidsetsize, %5C%0A%09SYS_SETGROUPS                = 80  // %7B int setgroups(u_int gidsetsize, %5C%0A%09SYS_GETPGRP                  = 81  // %7B int getpgrp(void); %7D%0A%09SYS_SETPGID                  = 82  // %7B int setpgid(int pid, int pgid); %7D%0A%09SYS_SETITIMER                = 83  // %7B int setitimer(u_int which, struct %5C%0A%09SYS_SWAPON                   = 85  // %7B int swapon(char *name); %7D%0A%09SYS_GETITIMER                = 86  // %7B int getitimer(u_int which, %5C%0A%09SYS_GETDTABLESIZE            = 89  // %7B int getdtablesize(void); %7D%0A%09SYS_DUP2                     = 90  // %7B int dup2(u_int from, u_int to); %7D%0A%09SYS_FCNTL                    = 92  // %7B int fcntl(int fd, int cmd, long arg); %7D%0A%09SYS_SELECT                   = 93  // %7B int select(int nd, fd_set *in, fd_set *ou, %5C%0A%09SYS_FSYNC                    = 95  // %7B int fsync(int fd); %7D%0A%09SYS_SETPRIORITY              = 96  // %7B int setpriority(int which, int who, %5C%0A%09SYS_SOCKET                   = 97  // %7B int socket(int domain, int type, %5C%0A%09SYS_CONNECT                  = 98  // %7B int connect(int s, caddr_t name, %5C%0A%09SYS_GETPRIORITY              = 100 // %7B int getpriority(int which, int who); %7D%0A%09SYS_BIND                     = 104 // %7B int bind(int s, caddr_t name, %5C%0A%09SYS_SETSOCKOPT               = 105 // %7B int setsockopt(int s, int level, int name, %5C%0A%09SYS_LISTEN                   = 106 // %7B int listen(int s, int backlog); %7D%0A%09SYS_GETTIMEOFDAY             = 116 // %7B int gettimeofday(struct timeval *tp, %5C%0A%09SYS_GETRUSAGE                = 117 // %7B int getrusage(int who, %5C%0A%09SYS_GETSOCKOPT               = 118 // %7B int getsockopt(int s, int level, int name, %5C%0A%09SYS_READV                    = 120 // %7B int readv(int fd, struct iovec *iovp, %5C%0A%09SYS_WRITEV                   = 121 // %7B int writev(int fd, struct iovec *iovp, %5C%0A%09SYS_SETTIMEOFDAY             = 122 // %7B int settimeofday(struct timeval *tv, %5C%0A%09SYS_FCHOWN                   = 123 // %7B int fchown(int fd, int uid, int gid); %7D%0A%09SYS_FCHMOD                   = 124 // %7B int fchmod(int fd, int mode); %7D%0A%09SYS_SETREUID                 = 126 // %7B int setreuid(int ruid, int euid); %7D%0A%09SYS_SETREGID                 = 127 // %7B int setregid(int rgid, int egid); %7D%0A%09SYS_RENAME                   = 128 // %7B int rename(char *from, char *to); %7D%0A%09SYS_FLOCK                    = 131 // %7B int flock(int fd, int how); %7D%0A%09SYS_MKFIFO                   = 132 // %7B int mkfifo(char *path, int mode); %7D%0A%09SYS_SENDTO                   = 133 // %7B int sendto(int s, caddr_t buf, size_t len, %5C%0A%09SYS_SHUTDOWN                 = 134 // %7B int shutdown(int s, int how); %7D%0A%09SYS_SOCKETPAIR               = 135 // %7B int socketpair(int domain, int type, %5C%0A%09SYS_MKDIR                    = 136 // %7B int mkdir(char *path, int mode); %7D%0A%09SYS_RMDIR                    = 137 // %7B int rmdir(char *path); %7D%0A%09SYS_UTIMES                   = 138 // %7B int utimes(char *path, %5C%0A%09SYS_ADJTIME                  = 140 // %7B int adjtime(struct timeval *delta, %5C%0A%09SYS_SETSID                   = 147 // %7B int setsid(void); %7D%0A%09SYS_QUOTACTL                 = 148 // %7B int quotactl(char *path, int cmd, int uid, %5C%0A%09SYS_NLM_SYSCALL              = 154 // %7B int nlm_syscall(int debug_level, int grace_period, int addr_count, char **addrs); %7D%0A%09SYS_NFSSVC                   = 155 // %7B int nfssvc(int flag, caddr_t argp); %7D%0A%09SYS_LGETFH                   = 160 // %7B int lgetfh(char *fname, %5C%0A%09SYS_GETFH                    = 161 // %7B int getfh(char *fname, %5C%0A%09SYS_SYSARCH                  = 165 // %7B int sysarch(int op, char *parms); %7D%0A%09SYS_RTPRIO                   = 166 // %7B int rtprio(int function, pid_t pid, %5C%0A%09SYS_SEMSYS                   = 169 // %7B int semsys(int which, int a2, int a3, %5C%0A%09SYS_MSGSYS                   = 170 // %7B int msgsys(int which, int a2, int a3, %5C%0A%09SYS_SHMSYS                   = 171 // %7B int shmsys(int which, int a2, int a3, %5C%0A%09SYS_FREEBSD6_PREAD           = 173 // %7B ssize_t freebsd6_pread(int fd, void *buf, %5C%0A%09SYS_FREEBSD6_PWRITE          = 174 // %7B ssize_t freebsd6_pwrite(int fd, %5C%0A%09SYS_SETFIB                   = 175 // %7B int setfib(int fibnum); %7D%0A%09SYS_NTP_ADJTIME              = 176 // %7B int ntp_adjtime(struct timex *tp); %7D%0A%09SYS_SETGID                   = 181 // %7B int setgid(gid_t gid); %7D%0A%09SYS_SETEGID                  = 182 // %7B int setegid(gid_t egid); %7D%0A%09SYS_SETEUID                  = 183 // %7B int seteuid(uid_t euid); %7D%0A%09SYS_STAT                     = 188 // %7B int stat(char *path, struct stat *ub); %7D%0A%09SYS_FSTAT                    = 189 // %7B int fstat(int fd, struct stat *sb); %7D%0A%09SYS_LSTAT                    = 190 // %7B int lstat(char *path, struct stat *ub); %7D%0A%09SYS_PATHCONF                 = 191 // %7B int pathconf(char *path, int name); %7D%0A%09SYS_FPATHCONF                = 192 // %7B int fpathconf(int fd, int name); %7D%0A%09SYS_GETRLIMIT                = 194 // %7B int getrlimit(u_int which, %5C%0A%09SYS_SETRLIMIT                = 195 // %7B int setrlimit(u_int which, %5C%0A%09SYS_GETDIRENTRIES            = 196 // %7B int getdirentries(int fd, char *buf, %5C%0A%09SYS_FREEBSD6_MMAP            = 197 // %7B caddr_t freebsd6_mmap(caddr_t addr, %5C%0A%09SYS_FREEBSD6_LSEEK           = 199 // %7B off_t freebsd6_lseek(int fd, int pad, %5C%0A%09SYS_FREEBSD6_TRUNCATE        = 200 // %7B int freebsd6_truncate(char *path, int pad, %5C%0A%09SYS_FREEBSD6_FTRUNCATE       = 201 // %7B int freebsd6_ftruncate(int fd, int pad, %5C%0A%09SYS___SYSCTL                 = 202 // %7B int __sysctl(int *name, u_int namelen, %5C%0A%09SYS_MLOCK                    = 203 // %7B int mlock(const void *addr, size_t len); %7D%0A%09SYS_MUNLOCK                  = 204 // %7B int munlock(const void *addr, size_t len); %7D%0A%09SYS_UNDELETE                 = 205 // %7B int undelete(char *path); %7D%0A%09SYS_FUTIMES                  = 206 // %7B int futimes(int fd, struct timeval *tptr); %7D%0A%09SYS_GETPGID                  = 207 // %7B int getpgid(pid_t pid); %7D%0A%09SYS_POLL                     = 209 // %7B int poll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_SEMGET                   = 221 // %7B int semget(key_t key, int nsems, %5C%0A%09SYS_SEMOP                    = 222 // %7B int semop(int semid, struct sembuf *sops, %5C%0A%09SYS_MSGGET                   = 225 // %7B int msgget(key_t key, int msgflg); %7D%0A%09SYS_MSGSND                   = 226 // %7B int msgsnd(int msqid, const void *msgp, %5C%0A%09SYS_MSGRCV                   = 227 // %7B int msgrcv(int msqid, void *msgp, %5C%0A%09SYS_SHMAT                    = 228 // %7B int shmat(int shmid, const void *shmaddr, %5C%0A%09SYS_SHMDT                    = 230 // %7B int shmdt(const void *shmaddr); %7D%0A%09SYS_SHMGET                   = 231 // %7B int shmget(key_t key, size_t size, %5C%0A%09SYS_CLOCK_GETTIME            = 232 // %7B int clock_gettime(clockid_t clock_id, %5C%0A%09SYS_CLOCK_SETTIME            = 233 // %7B int clock_settime( %5C%0A%09SYS_CLOCK_GETRES             = 234 // %7B int clock_getres(clockid_t clock_id, %5C%0A%09SYS_KTIMER_CREATE            = 235 // %7B int ktimer_create(clockid_t clock_id, %5C%0A%09SYS_KTIMER_DELETE            = 236 // %7B int ktimer_delete(int timerid); %7D%0A%09SYS_KTIMER_SETTIME           = 237 // %7B int ktimer_settime(int timerid, int flags, %5C%0A%09SYS_KTIMER_GETTIME           = 238 // %7B int ktimer_gettime(int timerid, struct %5C%0A%09SYS_KTIMER_GETOVERRUN        = 239 // %7B int ktimer_getoverrun(int timerid); %7D%0A%09SYS_NANOSLEEP                = 240 // %7B int nanosleep(const struct timespec *rqtp, %5C%0A%09SYS_FFCLOCK_GETCOUNTER       = 241 // %7B int ffclock_getcounter(ffcounter *ffcount); %7D%0A%09SYS_FFCLOCK_SETESTIMATE      = 242 // %7B int ffclock_setestimate( %5C%0A%09SYS_FFCLOCK_GETESTIMATE      = 243 // %7B int ffclock_getestimate( %5C%0A%09SYS_CLOCK_GETCPUCLOCKID2     = 247 // %7B int clock_getcpuclockid2(id_t id,%5C%0A%09SYS_NTP_GETTIME              = 248 // %7B int ntp_gettime(struct ntptimeval *ntvp); %7D%0A%09SYS_MINHERIT                 = 250 // %7B int minherit(void *addr, size_t len, %5C%0A%09SYS_RFORK                    = 251 // %7B int rfork(int flags); %7D%0A%09SYS_OPENBSD_POLL             = 252 // %7B int openbsd_poll(struct pollfd *fds, %5C%0A%09SYS_ISSETUGID                = 253 // %7B int issetugid(void); %7D%0A%09SYS_LCHOWN                   = 254 // %7B int lchown(char *path, int uid, int gid); %7D%0A%09SYS_AIO_READ                 = 255 // %7B int aio_read(struct aiocb *aiocbp); %7D%0A%09SYS_AIO_WRITE                = 256 // %7B int aio_write(struct aiocb *aiocbp); %7D%0A%09SYS_LIO_LISTIO               = 257 // %7B int lio_listio(int mode, %5C%0A%09SYS_GETDENTS                 = 272 // %7B int getdents(int fd, char *buf, %5C%0A%09SYS_LCHMOD                   = 274 // %7B int lchmod(char *path, mode_t mode); %7D%0A%09SYS_LUTIMES                  = 276 // %7B int lutimes(char *path, %5C%0A%09SYS_NSTAT                    = 278 // %7B int nstat(char *path, struct nstat *ub); %7D%0A%09SYS_NFSTAT                   = 279 // %7B int nfstat(int fd, struct nstat *sb); %7D%0A%09SYS_NLSTAT                   = 280 // %7B int nlstat(char *path, struct nstat *ub); %7D%0A%09SYS_PREADV                   = 289 // %7B ssize_t preadv(int fd, struct iovec *iovp, %5C%0A%09SYS_PWRITEV                  = 290 // %7B ssize_t pwritev(int fd, struct iovec *iovp, %5C%0A%09SYS_FHOPEN                   = 298 // %7B int fhopen(const struct fhandle *u_fhp, %5C%0A%09SYS_FHSTAT                   = 299 // %7B int fhstat(const struct fhandle *u_fhp, %5C%0A%09SYS_MODNEXT                  = 300 // %7B int modnext(int modid); %7D%0A%09SYS_MODSTAT                  = 301 // %7B int modstat(int modid, %5C%0A%09SYS_MODFNEXT                 = 302 // %7B int modfnext(int modid); %7D%0A%09SYS_MODFIND                  = 303 // %7B int modfind(const char *name); %7D%0A%09SYS_KLDLOAD                  = 304 // %7B int kldload(const char *file); %7D%0A%09SYS_KLDUNLOAD                = 305 // %7B int kldunload(int fileid); %7D%0A%09SYS_KLDFIND                  = 306 // %7B int kldfind(const char *file); %7D%0A%09SYS_KLDNEXT                  = 307 // %7B int kldnext(int fileid); %7D%0A%09SYS_KLDSTAT                  = 308 // %7B int kldstat(int fileid, struct %5C%0A%09SYS_KLDFIRSTMOD              = 309 // %7B int kldfirstmod(int fileid); %7D%0A%09SYS_GETSID                   = 310 // %7B int getsid(pid_t pid); %7D%0A%09SYS_SETRESUID                = 311 // %7B int setresuid(uid_t ruid, uid_t euid, %5C%0A%09SYS_SETRESGID                = 312 // %7B int setresgid(gid_t rgid, gid_t egid, %5C%0A%09SYS_AIO_RETURN               = 314 // %7B int aio_return(struct aiocb *aiocbp); %7D%0A%09SYS_AIO_SUSPEND              = 315 // %7B int aio_suspend( %5C%0A%09SYS_AIO_CANCEL               = 316 // %7B int aio_cancel(int fd, %5C%0A%09SYS_AIO_ERROR                = 317 // %7B int aio_error(struct aiocb *aiocbp); %7D%0A%09SYS_OAIO_READ                = 318 // %7B int oaio_read(struct oaiocb *aiocbp); %7D%0A%09SYS_OAIO_WRITE               = 319 // %7B int oaio_write(struct oaiocb *aiocbp); %7D%0A%09SYS_OLIO_LISTIO              = 320 // %7B int olio_listio(int mode, %5C%0A%09SYS_YIELD                    = 321 // %7B int yield(void); %7D%0A%09SYS_MLOCKALL                 = 324 // %7B int mlockall(int how); %7D%0A%09SYS_MUNLOCKALL               = 325 // %7B int munlockall(void); %7D%0A%09SYS___GETCWD                 = 326 // %7B int __getcwd(char *buf, u_int buflen); %7D%0A%09SYS_SCHED_SETPARAM           = 327 // %7B int sched_setparam (pid_t pid, %5C%0A%09SYS_SCHED_GETPARAM           = 328 // %7B int sched_getparam (pid_t pid, struct %5C%0A%09SYS_SCHED_SETSCHEDULER       = 329 // %7B int sched_setscheduler (pid_t pid, int %5C%0A%09SYS_SCHED_GETSCHEDULER       = 330 // %7B int sched_getscheduler (pid_t pid); %7D%0A%09SYS_SCHED_YIELD              = 331 // %7B int sched_yield (void); %7D%0A%09SYS_SCHED_GET_PRIORITY_MAX   = 332 // %7B int sched_get_priority_max (int policy); %7D%0A%09SYS_SCHED_GET_PRIORITY_MIN   = 333 // %7B int sched_get_priority_min (int policy); %7D%0A%09SYS_SCHED_RR_GET_INTERVAL    = 334 // %7B int sched_rr_get_interval (pid_t pid, %5C%0A%09SYS_UTRACE                   = 335 // %7B int utrace(const void *addr, size_t len); %7D%0A%09SYS_KLDSYM                   = 337 // %7B int kldsym(int fileid, int cmd, %5C%0A%09SYS_JAIL                     = 338 // %7B int jail(struct jail *jail); %7D%0A%09SYS_SIGPROCMASK              = 340 // %7B int sigprocmask(int how, %5C%0A%09SYS_SIGSUSPEND               = 341 // %7B int sigsuspend(const sigset_t *sigmask); %7D%0A%09SYS_SIGPENDING               = 343 // %7B int sigpending(sigset_t *set); %7D%0A%09SYS_SIGTIMEDWAIT             = 345 // %7B int sigtimedwait(const sigset_t *set, %5C%0A%09SYS_SIGWAITINFO              = 346 // %7B int sigwaitinfo(const sigset_t *set, %5C%0A%09SYS___ACL_GET_FILE           = 347 // %7B int __acl_get_file(const char *path, %5C%0A%09SYS___ACL_SET_FILE           = 348 // %7B int __acl_set_file(const char *path, %5C%0A%09SYS___ACL_GET_FD             = 349 // %7B int __acl_get_fd(int filedes, %5C%0A%09SYS___ACL_SET_FD             = 350 // %7B int __acl_set_fd(int filedes, %5C%0A%09SYS___ACL_DELETE_FILE        = 351 // %7B int __acl_delete_file(const char *path, %5C%0A%09SYS___ACL_DELETE_FD          = 352 // %7B int __acl_delete_fd(int filedes, %5C%0A%09SYS___ACL_ACLCHECK_FILE      = 353 // %7B int __acl_aclcheck_file(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_FD        = 354 // %7B int __acl_aclcheck_fd(int filedes, %5C%0A%09SYS_EXTATTRCTL               = 355 // %7B int extattrctl(const char *path, int cmd, %5C%0A%09SYS_EXTATTR_SET_FILE         = 356 // %7B ssize_t extattr_set_file( %5C%0A%09SYS_EXTATTR_GET_FILE         = 357 // %7B ssize_t extattr_get_file( %5C%0A%09SYS_EXTATTR_DELETE_FILE      = 358 // %7B int extattr_delete_file(const char *path, %5C%0A%09SYS_AIO_WAITCOMPLETE         = 359 // %7B int aio_waitcomplete( %5C%0A%09SYS_GETRESUID                = 360 // %7B int getresuid(uid_t *ruid, uid_t *euid, %5C%0A%09SYS_GETRESGID                = 361 // %7B int getresgid(gid_t *rgid, gid_t *egid, %5C%0A%09SYS_KQUEUE                   = 362 // %7B int kqueue(void); %7D%0A%09SYS_KEVENT                   = 363 // %7B int kevent(int fd, %5C%0A%09SYS_EXTATTR_SET_FD           = 371 // %7B ssize_t extattr_set_fd(int fd, %5C%0A%09SYS_EXTATTR_GET_FD           = 372 // %7B ssize_t extattr_get_fd(int fd, %5C%0A%09SYS_EXTATTR_DELETE_FD        = 373 // %7B int extattr_delete_fd(int fd, %5C%0A%09SYS___SETUGID                = 374 // %7B int __setugid(int flag); %7D%0A%09SYS_EACCESS                  = 376 // %7B int eaccess(char *path, int amode); %7D%0A%09SYS_NMOUNT                   = 378 // %7B int nmount(struct iovec *iovp, %5C%0A%09SYS___MAC_GET_PROC           = 384 // %7B int __mac_get_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_SET_PROC           = 385 // %7B int __mac_set_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_GET_FD             = 386 // %7B int __mac_get_fd(int fd, %5C%0A%09SYS___MAC_GET_FILE           = 387 // %7B int __mac_get_file(const char *path_p, %5C%0A%09SYS___MAC_SET_FD             = 388 // %7B int __mac_set_fd(int fd, %5C%0A%09SYS___MAC_SET_FILE           = 389 // %7B int __mac_set_file(const char *path_p, %5C%0A%09SYS_KENV                     = 390 // %7B int kenv(int what, const char *name, %5C%0A%09SYS_LCHFLAGS                 = 391 // %7B int lchflags(const char *path, %5C%0A%09SYS_UUIDGEN                  = 392 // %7B int uuidgen(struct uuid *store, %5C%0A%09SYS_SENDFILE                 = 393 // %7B int sendfile(int fd, int s, off_t offset, %5C%0A%09SYS_MAC_SYSCALL              = 394 // %7B int mac_syscall(const char *policy, %5C%0A%09SYS_GETFSSTAT                = 395 // %7B int getfsstat(struct statfs *buf, %5C%0A%09SYS_STATFS                   = 396 // %7B int statfs(char *path, %5C%0A%09SYS_FSTATFS                  = 397 // %7B int fstatfs(int fd, struct statfs *buf); %7D%0A%09SYS_FHSTATFS                 = 398 // %7B int fhstatfs(const struct fhandle *u_fhp, %5C%0A%09SYS_KSEM_CLOSE               = 400 // %7B int ksem_close(semid_t id); %7D%0A%09SYS_KSEM_POST                = 401 // %7B int ksem_post(semid_t id); %7D%0A%09SYS_KSEM_WAIT                = 402 // %7B int ksem_wait(semid_t id); %7D%0A%09SYS_KSEM_TRYWAIT             = 403 // %7B int ksem_trywait(semid_t id); %7D%0A%09SYS_KSEM_INIT                = 404 // %7B int ksem_init(semid_t *idp, %5C%0A%09SYS_KSEM_OPEN                = 405 // %7B int ksem_open(semid_t *idp, %5C%0A%09SYS_KSEM_UNLINK              = 406 // %7B int ksem_unlink(const char *name); %7D%0A%09SYS_KSEM_GETVALUE            = 407 // %7B int ksem_getvalue(semid_t id, int *val); %7D%0A%09SYS_KSEM_DESTROY             = 408 // %7B int ksem_destroy(semid_t id); %7D%0A%09SYS___MAC_GET_PID            = 409 // %7B int __mac_get_pid(pid_t pid, %5C%0A%09SYS___MAC_GET_LINK           = 410 // %7B int __mac_get_link(const char *path_p, %5C%0A%09SYS___MAC_SET_LINK           = 411 // %7B int __mac_set_link(const char *path_p, %5C%0A%09SYS_EXTATTR_SET_LINK         = 412 // %7B ssize_t extattr_set_link( %5C%0A%09SYS_EXTATTR_GET_LINK         = 413 // %7B ssize_t extattr_get_link( %5C%0A%09SYS_EXTATTR_DELETE_LINK      = 414 // %7B int extattr_delete_link( %5C%0A%09SYS___MAC_EXECVE             = 415 // %7B int __mac_execve(char *fname, char **argv, %5C%0A%09SYS_SIGACTION                = 416 // %7B int sigaction(int sig, %5C%0A%09SYS_SIGRETURN                = 417 // %7B int sigreturn( %5C%0A%09SYS_GETCONTEXT               = 421 // %7B int getcontext(struct __ucontext *ucp); %7D%0A%09SYS_SETCONTEXT               = 422 // %7B int setcontext( %5C%0A%09SYS_SWAPCONTEXT              = 423 // %7B int swapcontext(struct __ucontext *oucp, %5C%0A%09SYS_SWAPOFF                  = 424 // %7B int swapoff(const char *name); %7D%0A%09SYS___ACL_GET_LINK           = 425 // %7B int __acl_get_link(const char *path, %5C%0A%09SYS___ACL_SET_LINK           = 426 // %7B int __acl_set_link(const char *path, %5C%0A%09SYS___ACL_DELETE_LINK        = 427 // %7B int __acl_delete_link(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_LINK      = 428 // %7B int __acl_aclcheck_link(const char *path, %5C%0A%09SYS_SIGWAIT                  = 429 // %7B int sigwait(const sigset_t *set, %5C%0A%09SYS_THR_CREATE               = 430 // %7B int thr_create(ucontext_t *ctx, long *id, %5C%0A%09SYS_THR_EXIT                 = 431 // %7B void thr_exit(long *state); %7D%0A%09SYS_THR_SELF                 = 432 // %7B int thr_self(long *id); %7D%0A%09SYS_THR_KILL                 = 433 // %7B int thr_kill(long id, int sig); %7D%0A%09SYS__UMTX_LOCK               = 434 // %7B int _umtx_lock(struct umtx *umtx); %7D%0A%09SYS__UMTX_UNLOCK             = 435 // %7B int _umtx_unlock(struct umtx *umtx); %7D%0A%09SYS_JAIL_ATTACH              = 436 // %7B int jail_attach(int jid); %7D%0A%09SYS_EXTATTR_LIST_FD          = 437 // %7B ssize_t extattr_list_fd(int fd, %5C%0A%09SYS_EXTATTR_LIST_FILE        = 438 // %7B ssize_t extattr_list_file( %5C%0A%09SYS_EXTATTR_LIST_LINK        = 439 // %7B ssize_t extattr_list_link( %5C%0A%09SYS_KSEM_TIMEDWAIT           = 441 // %7B int ksem_timedwait(semid_t id, %5C%0A%09SYS_THR_SUSPEND              = 442 // %7B int thr_suspend( %5C%0A%09SYS_THR_WAKE                 = 443 // %7B int thr_wake(long id); %7D%0A%09SYS_KLDUNLOADF               = 444 // %7B int kldunloadf(int fileid, int flags); %7D%0A%09SYS_AUDIT                    = 445 // %7B int audit(const void *record, %5C%0A%09SYS_AUDITON                  = 446 // %7B int auditon(int cmd, void *data, %5C%0A%09SYS_GETAUID                  = 447 // %7B int getauid(uid_t *auid); %7D%0A%09SYS_SETAUID                  = 448 // %7B int setauid(uid_t *auid); %7D%0A%09SYS_GETAUDIT                 = 449 // %7B int getaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_SETAUDIT                 = 450 // %7B int setaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_GETAUDIT_ADDR            = 451 // %7B int getaudit_addr( %5C%0A%09SYS_SETAUDIT_ADDR            = 452 // %7B int setaudit_addr( %5C%0A%09SYS_AUDITCTL                 = 453 // %7B int auditctl(char *path); %7D%0A%09SYS__UMTX_OP                 = 454 // %7B int _umtx_op(void *obj, int op, %5C%0A%09SYS_THR_NEW                  = 455 // %7B int thr_new(struct thr_param *param, %5C%0A%09SYS_SIGQUEUE                 = 456 // %7B int sigqueue(pid_t pid, int signum, void *value); %7D%0A%09SYS_KMQ_OPEN                 = 457 // %7B int kmq_open(const char *path, int flags, %5C%0A%09SYS_KMQ_SETATTR              = 458 // %7B int kmq_setattr(int mqd,%09%09%5C%0A%09SYS_KMQ_TIMEDRECEIVE         = 459 // %7B int kmq_timedreceive(int mqd,%09%5C%0A%09SYS_KMQ_TIMEDSEND            = 460 // %7B int kmq_timedsend(int mqd,%09%09%5C%0A%09SYS_KMQ_NOTIFY               = 461 // %7B int kmq_notify(int mqd,%09%09%5C%0A%09SYS_KMQ_UNLINK               = 462 // %7B int kmq_unlink(const char *path); %7D%0A%09SYS_ABORT2                   = 463 // %7B int abort2(const char *why, int nargs, void **args); %7D%0A%09SYS_THR_SET_NAME             = 464 // %7B int thr_set_name(long id, const char *name); %7D%0A%09SYS_AIO_FSYNC                = 465 // %7B int aio_fsync(int op, struct aiocb *aiocbp); %7D%0A%09SYS_RTPRIO_THREAD            = 466 // %7B int rtprio_thread(int function, %5C%0A%09SYS_SCTP_PEELOFF             = 471 // %7B int sctp_peeloff(int sd, uint32_t name); %7D%0A%09SYS_SCTP_GENERIC_SENDMSG     = 472 // %7B int sctp_generic_sendmsg(int sd, caddr_t msg, int mlen, %5C%0A%09SYS_SCTP_GENERIC_SENDMSG_IOV = 473 // %7B int sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, %5C%0A%09SYS_SCTP_GENERIC_RECVMSG     = 474 // %7B int sctp_generic_recvmsg(int sd, struct iovec *iov, int iovlen, %5C%0A%09SYS_PREAD                    = 475 // %7B ssize_t pread(int fd, void *buf, %5C%0A%09SYS_PWRITE                   = 476 // %7B ssize_t pwrite(int fd, const void *buf, %5C%0A%09SYS_MMAP                     = 477 // %7B caddr_t mmap(caddr_t addr, size_t len, %5C%0A%09SYS_LSEEK                    = 478 // %7B off_t lseek(int fd, off_t offset, %5C%0A%09SYS_TRUNCATE                 = 479 // %7B int truncate(char *path, off_t length); %7D%0A%09SYS_FTRUNCATE                = 480 // %7B int ftruncate(int fd, off_t length); %7D%0A%09SYS_THR_KILL2                = 481 // %7B int thr_kill2(pid_t pid, long id, int sig); %7D%0A%09SYS_SHM_OPEN                 = 482 // %7B int shm_open(const char *path, int flags, %5C%0A%09SYS_SHM_UNLINK               = 483 // %7B int shm_unlink(const char *path); %7D%0A%09SYS_CPUSET                   = 484 // %7B int cpuset(cpusetid_t *setid); %7D%0A%09SYS_CPUSET_SETID             = 485 // %7B int cpuset_setid(cpuwhich_t which, id_t id, %5C%0A%09SYS_CPUSET_GETID             = 486 // %7B int cpuset_getid(cpulevel_t level, %5C%0A%09SYS_CPUSET_GETAFFINITY       = 487 // %7B int cpuset_getaffinity(cpulevel_t level, %5C%0A%09SYS_CPUSET_SETAFFINITY       = 488 // %7B int cpuset_setaffinity(cpulevel_t level, %5C%0A%09SYS_FACCESSAT                = 489 // %7B int faccessat(int fd, char *path, int amode, %5C%0A%09SYS_FCHMODAT                 = 490 // %7B int fchmodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_FCHOWNAT                 = 491 // %7B int fchownat(int fd, char *path, uid_t uid, %5C%0A%09SYS_FEXECVE                  = 492 // %7B int fexecve(int fd, char **argv, %5C%0A%09SYS_FSTATAT                  = 493 // %7B int fstatat(int fd, char *path, %5C%0A%09SYS_FUTIMESAT                = 494 // %7B int futimesat(int fd, char *path, %5C%0A%09SYS_LINKAT                   = 495 // %7B int linkat(int fd1, char *path1, int fd2, %5C%0A%09SYS_MKDIRAT                  = 496 // %7B int mkdirat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKFIFOAT                 = 497 // %7B int mkfifoat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKNODAT                  = 498 // %7B int mknodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_OPENAT                   = 499 // %7B int openat(int fd, char *path, int flag, %5C%0A%09SYS_READLINKAT               = 500 // %7B int readlinkat(int fd, char *path, char *buf, %5C%0A%09SYS_RENAMEAT                 = 501 // %7B int renameat(int oldfd, char *old, int newfd, %5C%0A%09SYS_SYMLINKAT                = 502 // %7B int symlinkat(char *path1, int fd, %5C%0A%09SYS_UNLINKAT                 = 503 // %7B int unlinkat(int fd, char *path, int flag); %7D%0A%09SYS_POSIX_OPENPT             = 504 // %7B int posix_openpt(int flags); %7D%0A%09SYS_GSSD_SYSCALL             = 505 // %7B int gssd_syscall(char *path); %7D%0A%09SYS_JAIL_GET                 = 506 // %7B int jail_get(struct iovec *iovp, %5C%0A%09SYS_JAIL_SET                 = 507 // %7B int jail_set(struct iovec *iovp, %5C%0A%09SYS_JAIL_REMOVE              = 508 // %7B int jail_remove(int jid); %7D%0A%09SYS_CLOSEFROM                = 509 // %7B int closefrom(int lowfd); %7D%0A%09SYS___SEMCTL                 = 510 // %7B int __semctl(int semid, int semnum, %5C%0A%09SYS_MSGCTL                   = 511 // %7B int msgctl(int msqid, int cmd, %5C%0A%09SYS_SHMCTL                   = 512 // %7B int shmctl(int shmid, int cmd, %5C%0A%09SYS_LPATHCONF                = 513 // %7B int lpathconf(char *path, int name); %7D%0A%09SYS___CAP_RIGHTS_GET         = 515 // %7B int __cap_rights_get(int version, %5C%0A%09SYS_CAP_ENTER                = 516 // %7B int cap_enter(void); %7D%0A%09SYS_CAP_GETMODE              = 517 // %7B int cap_getmode(u_int *modep); %7D%0A%09SYS_PDFORK                   = 518 // %7B int pdfork(int *fdp, int flags); %7D%0A%09SYS_PDKILL                   = 519 // %7B int pdkill(int fd, int signum); %7D%0A%09SYS_PDGETPID                 = 520 // %7B int pdgetpid(int fd, pid_t *pidp); %7D%0A%09SYS_PSELECT                  = 522 // %7B int pselect(int nd, fd_set *in, %5C%0A%09SYS_GETLOGINCLASS            = 523 // %7B int getloginclass(char *namebuf, %5C%0A%09SYS_SETLOGINCLASS            = 524 // %7B int setloginclass(const char *namebuf); %7D%0A%09SYS_RCTL_GET_RACCT           = 525 // %7B int rctl_get_racct(const void *inbufp, %5C%0A%09SYS_RCTL_GET_RULES           = 526 // %7B int rctl_get_rules(const void *inbufp, %5C%0A%09SYS_RCTL_GET_LIMITS          = 527 // %7B int rctl_get_limits(const void *inbufp, %5C%0A%09SYS_RCTL_ADD_RULE            = 528 // %7B int rctl_add_rule(const void *inbufp, %5C%0A%09SYS_RCTL_REMOVE_RULE         = 529 // %7B int rctl_remove_rule(const void *inbufp, %5C%0A%09SYS_POSIX_FALLOCATE          = 530 // %7B int posix_fallocate(int fd, %5C%0A%09SYS_POSIX_FADVISE            = 531 // %7B int posix_fadvise(int fd, off_t offset, %5C%0A%09SYS_WAIT6                    = 532 // %7B int wait6(idtype_t idtype, id_t id, %5C%0A%09SYS_CAP_RIGHTS_LIMIT         = 533 // %7B int cap_rights_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_LIMIT         = 534 // %7B int cap_ioctls_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_GET           = 535 // %7B ssize_t cap_ioctls_get(int fd, %5C%0A%09SYS_CAP_FCNTLS_LIMIT         = 536 // %7B int cap_fcntls_limit(int fd, %5C%0A%09SYS_CAP_FCNTLS_GET           = 537 // %7B int cap_fcntls_get(int fd, %5C%0A%09SYS_BINDAT                   = 538 // %7B int bindat(int fd, int s, caddr_t name, %5C%0A%09SYS_CONNECTAT                = 539 // %7B int connectat(int fd, int s, caddr_t name, %5C%0A%09SYS_CHFLAGSAT                = 540 // %7B int chflagsat(int fd, const char *path, %5C%0A%09SYS_ACCEPT4                  = 541 // %7B int accept4(int s, %5C%0A%09SYS_PIPE2                    = 542 // %7B int pipe2(int *fildes, int flags); %7D%0A%09SYS_AIO_MLOCK                = 543 // %7B int aio_mlock(struct aiocb *aiocbp); %7D%0A%09SYS_PROCCTL                  = 544 // %7B int procctl(idtype_t idtype, id_t id, %5C%0A%09SYS_PPOLL                    = 545 // %7B int ppoll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_FUTIMENS                 = 546 // %7B int futimens(int fd, %5C%0A%09SYS_UTIMENSAT                = 547 // %7B int utimensat(int fd, %5C%0A
 )%0A
- f 1b4a735672ba062884ff20fe4e20b8dc2bbcba7f66c0b8dfee5f10e8d29d4cf8 vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm.go
+ f 666e8807f8e4b0139d52e14fe0a1d620c2877953500ead601a405f370a410c0a vendor/golang.org/x/sys/unix/zsysnum_freebsd_arm.go
dmppatch 5
@@ -201,25423 +201,30051 @@
 int%0A
-%09SYS_EXIT                   = 1   // %7B void sys_exit(int rval); %7D exit %5C%0A%09SYS_FORK                   = 2   // %7B int fork(void); %7D%0A%09SYS_READ                   = 3   // %7B ssize_t read(int fd, void *buf, %5C%0A%09SYS_WRITE                  = 4   // %7B ssize_t write(int fd, const void *buf, %5C%0A%09SYS_OPEN                   = 5   // %7B int open(char *path, int flags, int mode); %7D%0A%09SYS_CLOSE                  = 6   // %7B int close(int fd); %7D%0A%09SYS_WAIT4                  = 7   // %7B int wait4(int pid, int *status, %5C%0A%09SYS_LINK                   = 9   // %7B int link(char *path, char *link); %7D%0A%09SYS_UNLINK                 = 10  // %7B int unlink(char *path); %7D%0A%09SYS_CHDIR                  = 12  // %7B int chdir(char *path); %7D%0A%09SYS_FCHDIR                 = 13  // %7B int fchdir(int fd); %7D%0A%09SYS_MKNOD                  = 14  // %7B int mknod(char *path, int mode, int dev); %7D%0A%09SYS_CHMOD                  = 15  // %7B int chmod(char *path, int mode); %7D%0A%09SYS_CHOWN                  = 16  // %7B int chown(char *path, int uid, int gid); %7D%0A%09SYS_OBREAK                 = 17  // %7B int obreak(char *nsize); %7D break %5C%0A%09SYS_GETPID                 = 20  // %7B pid_t getpid(void); %7D%0A%09SYS_MOUNT                  = 21  // %7B int mount(char *type, char *path, %5C%0A%09SYS_UNMOUNT                = 22  // %7B int unmount(char *path, int flags); %7D%0A%09SYS_SETUID                 = 23  // %7B int setuid(uid_t uid); %7D%0A%09SYS_GETUID                 = 24  // %7B uid_t getuid(void); %7D%0A%09SYS_GETEUID                = 25  // %7B uid_t geteuid(void); %7D%0A%09SYS_PTRACE                 = 26  // %7B int ptrace(int req, pid_t pid, %5C%0A%09SYS_RECVMSG                = 27  // %7B int recvmsg(int s, struct msghdr *msg, %5C%0A%09SYS_SENDMSG                = 28  // %7B int sendmsg(int s, struct msghdr *msg, %5C%0A%09SYS_RECVFROM               = 29  // %7B int recvfrom(int s, caddr_t buf, %5C%0A%09SYS_ACCEPT                 = 30  // %7B int accept(int s, %5C%0A%09SYS_GETPEERNAME            = 31  // %7B int getpeername(int fdes, %5C%0A%09SYS_GETSOCKNAME            = 32  // %7B int getsockname(int fdes, %5C%0A%09SYS_ACCESS                 = 33  // %7B int access(char *path, int amode); %7D%0A%09SYS_CHFLAGS                = 34  // %7B int chflags(const char *path, u_long flags); %7D%0A%09SYS_FCHFLAGS               = 35  // %7B int fchflags(int fd, u_long flags); %7D%0A%09SYS_SYNC                   = 36  // %7B int sync(void); %7D%0A%09SYS_KILL                   = 37  // %7B int kill(int pid, int signum); %7D%0A%09SYS_GETPPID                = 39  // %7B pid_t getppid(void); %7D%0A%09SYS_DUP                    = 41  // %7B int dup(u_int fd); %7D%0A%09SYS_PIPE                   = 42  // %7B int pipe(void); %7D%0A%09SYS_GETEGID                = 43  // %7B gid_t getegid(void); %7D%0A%09SYS_PROFIL                 = 44  // %7B int profil(caddr_t samples, size_t size, %5C%0A%09SYS_KTRACE                 = 45  // %7B int ktrace(const char *fname, int ops, %5C%0A%09SYS_GETGID                 = 47  // %7B gid_t getgid(void); %7D%0A%09SYS_GETLOGIN               = 49  // %7B int getlogin(char *namebuf, u_int %5C%0A%09SYS_SETLOGIN               = 50  // %7B int setlogin(char *namebuf); %7D%0A%09SYS_ACCT                   = 51  // %7B int acct(char *path); %7D%0A%09SYS_SIGALTSTACK            = 53  // %7B int sigaltstack(stack_t *ss, %5C%0A%09SYS_IOCTL                  = 54  // %7B int ioctl(int fd, u_long com, %5C%0A%09SYS_REBOOT                 = 55  // %7B int reboot(int opt); %7D%0A%09SYS_REVOKE                 = 56  // %7B int revoke(char *path); %7D%0A%09SYS_SYMLINK                = 57  // %7B int symlink(char *path, char *link); %7D%0A%09SYS_READLINK               = 58  // %7B ssize_t readlink(char *path, char *buf, %5C%0A%09SYS_EXECVE                 = 59  // %7B int execve(char *fname, char **argv, %5C%0A%09SYS_UMASK                  = 60  // %7B int umask(int newmask); %7D umask umask_args %5C%0A%09SYS_CHROOT                 = 61  // %7B int chroot(char *path); %7D%0A%09SYS_MSYNC                  = 65  // %7B int msync(void *addr, size_t len, %5C%0A%09SYS_VFORK                  = 66  // %7B int vfork(void); %7D%0A%09SYS_SBRK                   = 69  // %7B int sbrk(int incr); %7D%0A%09SYS_SSTK                   = 70  // %7B int sstk(int incr); %7D%0A%09SYS_OVADVISE               = 72  // %7B int ovadvise(int anom); %7D vadvise %5C%0A%09SYS_MUNMAP                 = 73  // %7B int munmap(void *addr, size_t len); %7D%0A%09SYS_MPROTECT               = 74  // %7B int mprotect(const void *addr, size_t len, %5C%0A%09SYS_MADVISE                = 75  // %7B int madvise(void *addr, size_t len, %5C%0A%09SYS_MINCORE                = 78  // %7B int mincore(const void *addr, size_t len, %5C%0A%09SYS_GETGROUPS              = 79  // %7B int getgroups(u_int gidsetsize, %5C%0A%09SYS_SETGROUPS              = 80  // %7B int setgroups(u_int gidsetsize, %5C%0A%09SYS_GETPGRP                = 81  // %7B int getpgrp(void); %7D%0A%09SYS_SETPGID                = 82  // %7B int setpgid(int pid, int pgid); %7D%0A%09SYS_SETITIMER              = 83  // %7B int setitimer(u_int which, struct %5C%0A%09SYS_SWAPON                 = 85  // %7B int swapon(char *name); %7D%0A%09SYS_GETITIMER              = 86  // %7B int getitimer(u_int which, %5C%0A%09SYS_GETDTABLESIZE          = 89  // %7B int getdtablesize(void); %7D%0A%09SYS_DUP2                   = 90  // %7B int dup2(u_int from, u_int to); %7D%0A%09SYS_FCNTL                  = 92  // %7B int fcntl(int fd, int cmd, long arg); %7D%0A%09SYS_SELECT                 = 93  // %7B int select(int nd, fd_set *in, fd_set *ou, %5C%0A%09SYS_FSYNC                  = 95  // %7B int fsync(int fd); %7D%0A%09SYS_SETPRIORITY            = 96  // %7B int setpriority(int which, int who, %5C%0A%09SYS_SOCKET                 = 97  // %7B int socket(int domain, int type, %5C%0A%09SYS_CONNECT                = 98  // %7B int connect(int s, caddr_t name, %5C%0A%09SYS_GETPRIORITY            = 100 // %7B int getpriority(int which, int who); %7D%0A%09SYS_BIND                   = 104 // %7B int bind(int s, caddr_t name, %5C%0A%09SYS_SETSOCKOPT             = 105 // %7B int setsockopt(int s, int level, int name, %5C%0A%09SYS_LISTEN                 = 106 // %7B int listen(int s, int backlog); %7D%0A%09SYS_GETTIMEOFDAY           = 116 // %7B int gettimeofday(struct timeval *tp, %5C%0A%09SYS_GETRUSAGE              = 117 // %7B int getrusage(int who, %5C%0A%09SYS_GETSOCKOPT             = 118 // %7B int getsockopt(int s, int level, int name, %5C%0A%09SYS_READV                  = 120 // %7B int readv(int fd, struct iovec *iovp, %5C%0A%09SYS_WRITEV                 = 121 // %7B int writev(int fd, struct iovec *iovp, %5C%0A%09SYS_SETTIMEOFDAY           = 122 // %7B int settimeofday(struct timeval *tv, %5C%0A%09SYS_FCHOWN                 = 123 // %7B int fchown(int fd, int uid, int gid); %7D%0A%09SYS_FCHMOD                 = 124 // %7B int fchmod(int fd, int mode); %7D%0A%09SYS_SETREUID               = 126 // %7B int setreuid(int ruid, int euid); %7D%0A%09SYS_SETREGID               = 127 // %7B int setregid(int rgid, int egid); %7D%0A%09SYS_RENAME                 = 128 // %7B int rename(char *from, char *to); %7D%0A%09SYS_FLOCK                  = 131 // %7B int flock(int fd, int how); %7D%0A%09SYS_MKFIFO                 = 132 // %7B int mkfifo(char *path, int mode); %7D%0A%09SYS_SENDTO                 = 133 // %7B int sendto(int s, caddr_t buf, size_t len, %5C%0A%09SYS_SHUTDOWN               = 134 // %7B int shutdown(int s, int how); %7D%0A%09SYS_SOCKETPAIR             = 135 // %7B int socketpair(int domain, int type, %5C%0A%09SYS_MKDIR                  = 136 // %7B int mkdir(char *path, int mode); %7D%0A%09SYS_RMDIR                  = 137 // %7B int rmdir(char *path); %7D%0A%09SYS_UTIMES                 = 138 // %7B int utimes(char *path, %5C%0A%09SYS_ADJTIME                = 140 // %7B int adjtime(struct timeval *delta, %5C%0A%09SYS_SETSID                 = 147 // %7B int setsid(void); %7D%0A%09SYS_QUOTACTL               = 148 // %7B int quotactl(char *path, int cmd, int uid, %5C%0A%09SYS_LGETFH                 = 160 // %7B int lgetfh(char *fname, %5C%0A%09SYS_GETFH                  = 161 // %7B int getfh(char *fname, %5C%0A%09SYS_SYSARCH                = 165 // %7B int sysarch(int op, char *parms); %7D%0A%09SYS_RTPRIO                 = 166 // %7B int rtprio(int function, pid_t pid, %5C%0A%09SYS_FREEBSD6_PREAD         = 173 // %7B ssize_t freebsd6_pread(int fd, void *buf, %5C%0A%09SYS_FREEBSD6_PWRITE        = 174 // %7B ssize_t freebsd6_pwrite(int fd, %5C%0A%09SYS_SETFIB                 = 175 // %7B int setfib(int fibnum); %7D%0A%09SYS_NTP_ADJTIME            = 176 // %7B int ntp_adjtime(struct timex *tp); %7D%0A%09SYS_SETGID                 = 181 // %7B int setgid(gid_t gid); %7D%0A%09SYS_SETEGID                = 182 // %7B int setegid(gid_t egid); %7D%0A%09SYS_SETEUID                = 183 // %7B int seteuid(uid_t euid); %7D%0A%09SYS_STAT                   = 188 // %7B int stat(char *path, struct stat *ub); %7D%0A%09SYS_FSTAT                  = 189 // %7B int fstat(int fd, struct stat *sb); %7D%0A%09SYS_LSTAT                  = 190 // %7B int lstat(char *path, struct stat *ub); %7D%0A%09SYS_PATHCONF               = 191 // %7B int pathconf(char *path, int name); %7D%0A%09SYS_FPATHCONF              = 192 // %7B int fpathconf(int fd, int name); %7D%0A%09SYS_GETRLIMIT              = 194 // %7B int getrlimit(u_int which, %5C%0A%09SYS_SETRLIMIT              = 195 // %7B int setrlimit(u_int which, %5C%0A%09SYS_GETDIRENTRIES          = 196 // %7B int getdirentries(int fd, char *buf, %5C%0A%09SYS_FREEBSD6_MMAP          = 197 // %7B caddr_t freebsd6_mmap(caddr_t addr, %5C%0A%09SYS_FREEBSD6_LSEEK         = 199 // %7B off_t freebsd6_lseek(int fd, int pad, %5C%0A%09SYS_FREEBSD6_TRUNCATE      = 200 // %7B int freebsd6_truncate(char *path, int pad, %5C%0A%09SYS_FREEBSD6_FTRUNCATE     = 201 // %7B int freebsd6_ftruncate(int fd, int pad, %5C%0A%09SYS___SYSCTL               = 202 // %7B int __sysctl(int *name, u_int namelen, %5C%0A%09SYS_MLOCK                  = 203 // %7B int mlock(const void *addr, size_t len); %7D%0A%09SYS_MUNLOCK                = 204 // %7B int munlock(const void *addr, size_t len); %7D%0A%09SYS_UNDELETE               = 205 // %7B int undelete(char *path); %7D%0A%09SYS_FUTIMES                = 206 // %7B int futimes(int fd, struct timeval *tptr); %7D%0A%09SYS_GETPGID                = 207 // %7B int getpgid(pid_t pid); %7D%0A%09SYS_POLL                   = 209 // %7B int poll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_CLOCK_GETTIME          = 232 // %7B int clock_gettime(clockid_t clock_id, %5C%0A%09SYS_CLOCK_SETTIME          = 233 // %7B int clock_settime( %5C%0A%09SYS_CLOCK_GETRES           = 234 // %7B int clock_getres(clockid_t clock_id, %5C%0A%09SYS_KTIMER_CREATE          = 235 // %7B int ktimer_create(clockid_t clock_id, %5C%0A%09SYS_KTIMER_DELETE          = 236 // %7B int ktimer_delete(int timerid); %7D%0A%09SYS_KTIMER_SETTIME         = 237 // %7B int ktimer_settime(int timerid, int flags, %5C%0A%09SYS_KTIMER_GETTIME         = 238 // %7B int ktimer_gettime(int timerid, struct %5C%0A%09SYS_KTIMER_GETOVERRUN      = 239 // %7B int ktimer_getoverrun(int timerid); %7D%0A%09SYS_NANOSLEEP              = 240 // %7B int nanosleep(const struct timespec *rqtp, %5C%0A%09SYS_FFCLOCK_GETCOUNTER     = 241 // %7B int ffclock_getcounter(ffcounter *ffcount); %7D%0A%09SYS_FFCLOCK_SETESTIMATE    = 242 // %7B int ffclock_setestimate( %5C%0A%09SYS_FFCLOCK_GETESTIMATE    = 243 // %7B int ffclock_getestimate( %5C%0A%09SYS_CLOCK_GETCPUCLOCKID2   = 247 // %7B int clock_getcpuclockid2(id_t id,%5C%0A%09SYS_NTP_GETTIME            = 248 // %7B int ntp_gettime(struct ntptimeval *ntvp); %7D%0A%09SYS_MINHERIT               = 250 // %7B int minherit(void *addr, size_t len, %5C%0A%09SYS_RFORK                  = 251 // %7B int rfork(int flags); %7D%0A%09SYS_OPENBSD_POLL           = 252 // %7B int openbsd_poll(struct pollfd *fds, %5C%0A%09SYS_ISSETUGID              = 253 // %7B int issetugid(void); %7D%0A%09SYS_LCHOWN                 = 254 // %7B int lchown(char *path, int uid, int gid); %7D%0A%09SYS_GETDENTS               = 272 // %7B int getdents(int fd, char *buf, %5C%0A%09SYS_LCHMOD                 = 274 // %7B int lchmod(char *path, mode_t mode); %7D%0A%09SYS_LUTIMES                = 276 // %7B int lutimes(char *path, %5C%0A%09SYS_NSTAT                  = 278 // %7B int nstat(char *path, struct nstat *ub); %7D%0A%09SYS_NFSTAT                 = 279 // %7B int nfstat(int fd, struct nstat *sb); %7D%0A%09SYS_NLSTAT                 = 280 // %7B int nlstat(char *path, struct nstat *ub); %7D%0A%09SYS_PREADV                 = 289 // %7B ssize_t preadv(int fd, struct iovec *iovp, %5C%0A%09SYS_PWRITEV                = 290 // %7B ssize_t pwritev(int fd, struct iovec *iovp, %5C%0A%09SYS_FHOPEN                 = 298 // %7B int fhopen(const struct fhandle *u_fhp, %5C%0A%09SYS_FHSTAT                 = 299 // %7B int fhstat(const struct fhandle *u_fhp, %5C%0A%09SYS_MODNEXT                = 300 // %7B int modnext(int modid); %7D%0A%09SYS_MODSTAT                = 301 // %7B int modstat(int modid, %5C%0A%09SYS_MODFNEXT               = 302 // %7B int modfnext(int modid); %7D%0A%09SYS_MODFIND                = 303 // %7B int modfind(const char *name); %7D%0A%09SYS_KLDLOAD                = 304 // %7B int kldload(const char *file); %7D%0A%09SYS_KLDUNLOAD              = 305 // %7B int kldunload(int fileid); %7D%0A%09SYS_KLDFIND                = 306 // %7B int kldfind(const char *file); %7D%0A%09SYS_KLDNEXT                = 307 // %7B int kldnext(int fileid); %7D%0A%09SYS_KLDSTAT                = 308 // %7B int kldstat(int fileid, struct %5C%0A%09SYS_KLDFIRSTMOD            = 309 // %7B int kldfirstmod(int fileid); %7D%0A%09SYS_GETSID                 = 310 // %7B int getsid(pid_t pid); %7D%0A%09SYS_SETRESUID              = 311 // %7B int setresuid(uid_t ruid, uid_t euid, %5C%0A%09SYS_SETRESGID              = 312 // %7B int setresgid(gid_t rgid, gid_t egid, %5C%0A%09SYS_YIELD                  = 321 // %7B int yield(void); %7D%0A%09SYS_MLOCKALL               = 324 // %7B int mlockall(int how); %7D%0A%09SYS_MUNLOCKALL             = 325 // %7B int munlockall(void); %7D%0A%09SYS___GETCWD               = 326 // %7B int __getcwd(char *buf, u_int buflen); %7D%0A%09SYS_SCHED_SETPARAM         = 327 // %7B int sched_setparam (pid_t pid, %5C%0A%09SYS_SCHED_GETPARAM         = 328 // %7B int sched_getparam (pid_t pid, struct %5C%0A%09SYS_SCHED_SETSCHEDULER     = 329 // %7B int sched_setscheduler (pid_t pid, int %5C%0A%09SYS_SCHED_GETSCHEDULER     = 330 // %7B int sched_getscheduler (pid_t pid); %7D%0A%09SYS_SCHED_YIELD            = 331 // %7B int sched_yield (void); %7D%0A%09SYS_SCHED_GET_PRIORITY_MAX = 332 // %7B int sched_get_priority_max (int policy); %7D%0A%09SYS_SCHED_GET_PRIORITY_MIN = 333 // %7B int sched_get_priority_min (int policy); %7D%0A%09SYS_SCHED_RR_GET_INTERVAL  = 334 // %7B int sched_rr_get_interval (pid_t pid, %5C%0A%09SYS_UTRACE                 = 335 // %7B int utrace(const void *addr, size_t len); %7D%0A%09SYS_KLDSYM                 = 337 // %7B int kldsym(int fileid, int cmd, %5C%0A%09SYS_JAIL                   = 338 // %7B int jail(struct jail *jail); %7D%0A%09SYS_SIGPROCMASK            = 340 // %7B int sigprocmask(int how, %5C%0A%09SYS_SIGSUSPEND             = 341 // %7B int sigsuspend(const sigset_t *sigmask); %7D%0A%09SYS_SIGPENDING             = 343 // %7B int sigpending(sigset_t *set); %7D%0A%09SYS_SIGTIMEDWAIT           = 345 // %7B int sigtimedwait(const sigset_t *set, %5C%0A%09SYS_SIGWAITINFO            = 346 // %7B int sigwaitinfo(const sigset_t *set, %5C%0A%09SYS___ACL_GET_FILE         = 347 // %7B int __acl_get_file(const char *path, %5C%0A%09SYS___ACL_SET_FILE         = 348 // %7B int __acl_set_file(const char *path, %5C%0A%09SYS___ACL_GET_FD           = 349 // %7B int __acl_get_fd(int filedes, %5C%0A%09SYS___ACL_SET_FD           = 350 // %7B int __acl_set_fd(int filedes, %5C%0A%09SYS___ACL_DELETE_FILE      = 351 // %7B int __acl_delete_file(const char *path, %5C%0A%09SYS___ACL_DELETE_FD        = 352 // %7B int __acl_delete_fd(int filedes, %5C%0A%09SYS___ACL_ACLCHECK_FILE    = 353 // %7B int __acl_aclcheck_file(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_FD      = 354 // %7B int __acl_aclcheck_fd(int filedes, %5C%0A%09SYS_EXTATTRCTL             = 355 // %7B int extattrctl(const char *path, int cmd, %5C%0A%09SYS_EXTATTR_SET_FILE       = 356 // %7B ssize_t extattr_set_file( %5C%0A%09SYS_EXTATTR_GET_FILE       = 357 // %7B ssize_t extattr_get_file( %5C%0A%09SYS_EXTATTR_DELETE_FILE    = 358 // %7B int extattr_delete_file(const char *path, %5C%0A%09SYS_GETRESUID              = 360 // %7B int getresuid(uid_t *ruid, uid_t *euid, %5C%0A%09SYS_GETRESGID              = 361 // %7B int getresgid(gid_t *rgid, gid_t *egid, %5C%0A%09SYS_KQUEUE                 = 362 // %7B int kqueue(void); %7D%0A%09SYS_KEVENT                 = 363 // %7B int kevent(int fd, %5C%0A%09SYS_EXTATTR_SET_FD         = 371 // %7B ssize_t extattr_set_fd(int fd, %5C%0A%09SYS_EXTATTR_GET_FD         = 372 // %7B ssize_t extattr_get_fd(int fd, %5C%0A%09SYS_EXTATTR_DELETE_FD      = 373 // %7B int extattr_delete_fd(int fd, %5C%0A%09SYS___SETUGID              = 374 // %7B int __setugid(int flag); %7D%0A%09SYS_EACCESS                = 376 // %7B int eaccess(char *path, int amode); %7D%0A%09SYS_NMOUNT                 = 378 // %7B int nmount(struct iovec *iovp, %5C%0A%09SYS___MAC_GET_PROC         = 384 // %7B int __mac_get_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_SET_PROC         = 385 // %7B int __mac_set_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_GET_FD           = 386 // %7B int __mac_get_fd(int fd, %5C%0A%09SYS___MAC_GET_FILE         = 387 // %7B int __mac_get_file(const char *path_p, %5C%0A%09SYS___MAC_SET_FD           = 388 // %7B int __mac_set_fd(int fd, %5C%0A%09SYS___MAC_SET_FILE         = 389 // %7B int __mac_set_file(const char *path_p, %5C%0A%09SYS_KENV                   = 390 // %7B int kenv(int what, const char *name, %5C%0A%09SYS_LCHFLAGS               = 391 // %7B int lchflags(const char *path, %5C%0A%09SYS_UUIDGEN                = 392 // %7B int uuidgen(struct uuid *store, %5C%0A%09SYS_SENDFILE               = 393 // %7B int sendfile(int fd, int s, off_t offset, %5C%0A%09SYS_MAC_SYSCALL            = 394 // %7B int mac_syscall(const char *policy, %5C%0A%09SYS_GETFSSTAT              = 395 // %7B int getfsstat(struct statfs *buf, %5C%0A%09SYS_STATFS                 = 396 // %7B int statfs(char *path, %5C%0A%09SYS_FSTATFS                = 397 // %7B int fstatfs(int fd, struct statfs *buf); %7D%0A%09SYS_FHSTATFS               = 398 // %7B int fhstatfs(const struct fhandle *u_fhp, %5C%0A%09SYS___MAC_GET_PID          = 409 // %7B int __mac_get_pid(pid_t pid, %5C%0A%09SYS___MAC_GET_LINK         = 410 // %7B int __mac_get_link(const char *path_p, %5C%0A%09SYS___MAC_SET_LINK         = 411 // %7B int __mac_set_link(const char *path_p, %5C%0A%09SYS_EXTATTR_SET_LINK       = 412 // %7B ssize_t extattr_set_link( %5C%0A%09SYS_EXTATTR_GET_LINK       = 413 // %7B ssize_t extattr_get_link( %5C%0A%09SYS_EXTATTR_DELETE_LINK    = 414 // %7B int extattr_delete_link( %5C%0A%09SYS___MAC_EXECVE           = 415 // %7B int __mac_execve(char *fname, char **argv, %5C%0A%09SYS_SIGACTION              = 416 // %7B int sigaction(int sig, %5C%0A%09SYS_SIGRETURN              = 417 // %7B int sigreturn( %5C%0A%09SYS_GETCONTEXT             = 421 // %7B int getcontext(struct __ucontext *ucp); %7D%0A%09SYS_SETCONTEXT             = 422 // %7B int setcontext( %5C%0A%09SYS_SWAPCONTEXT            = 423 // %7B int swapcontext(struct __ucontext *oucp, %5C%0A%09SYS_SWAPOFF                = 424 // %7B int swapoff(const char *name); %7D%0A%09SYS___ACL_GET_LINK         = 425 // %7B int __acl_get_link(const char *path, %5C%0A%09SYS___ACL_SET_LINK         = 426 // %7B int __acl_set_link(const char *path, %5C%0A%09SYS___ACL_DELETE_LINK      = 427 // %7B int __acl_delete_link(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_LINK    = 428 // %7B int __acl_aclcheck_link(const char *path, %5C%0A%09SYS_SIGWAIT                = 429 // %7B int sigwait(const sigset_t *set, %5C%0A%09SYS_THR_CREATE             = 430 // %7B int thr_create(ucontext_t *ctx, long *id, %5C%0A%09SYS_THR_EXIT               = 431 // %7B void thr_exit(long *state); %7D%0A%09SYS_THR_SELF               = 432 // %7B int thr_self(long *id); %7D%0A%09SYS_THR_KILL               = 433 // %7B int thr_kill(long id, int sig); %7D%0A%09SYS__UMTX_LOCK             = 434 // %7B int _umtx_lock(struct umtx *umtx); %7D%0A%09SYS__UMTX_UNLOCK           = 435 // %7B int _umtx_unlock(struct umtx *umtx); %7D%0A%09SYS_JAIL_ATTACH            = 436 // %7B int jail_attach(int jid); %7D%0A%09SYS_EXTATTR_LIST_FD        = 437 // %7B ssize_t extattr_list_fd(int fd, %5C%0A%09SYS_EXTATTR_LIST_FILE      = 438 // %7B ssize_t extattr_list_file( %5C%0A%09SYS_EXTATTR_LIST_LINK      = 439 // %7B ssize_t extattr_list_link( %5C%0A%09SYS_THR_SUSPEND            = 442 // %7B int thr_suspend( %5C%0A%09SYS_THR_WAKE               = 443 // %7B int thr_wake(long id); %7D%0A%09SYS_KLDUNLOADF             = 444 // %7B int kldunloadf(int fileid, int flags); %7D%0A%09SYS_AUDIT                  = 445 // %7B int audit(const void *record, %5C%0A%09SYS_AUDITON                = 446 // %7B int auditon(int cmd, void *data, %5C%0A%09SYS_GETAUID                = 447 // %7B int getauid(uid_t *auid); %7D%0A%09SYS_SETAUID                = 448 // %7B int setauid(uid_t *auid); %7D%0A%09SYS_GETAUDIT               = 449 // %7B int getaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_SETAUDIT               = 450 // %7B int setaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_GETAUDIT_ADDR          = 451 // %7B int getaudit_addr( %5C%0A%09SYS_SETAUDIT_ADDR          = 452 // %7B int setaudit_addr( %5C%0A%09SYS_AUDITCTL               = 453 // %7B int auditctl(char *path); %7D%0A%09SYS__UMTX_OP               = 454 // %7B int _umtx_op(void *obj, int op, %5C%0A%09SYS_THR_NEW                = 455 // %7B int thr_new(struct thr_param *param, %5C%0A%09SYS_SIGQUEUE               = 456 // %7B int sigqueue(pid_t pid, int signum, void *value); %7D%0A%09SYS_ABORT2                 = 463 // %7B int abort2(const char *why, int nargs, void **args); %7D%0A%09SYS_THR_SET_NAME           = 464 // %7B int thr_set_name(long id, const char *name); %7D%0A%09SYS_RTPRIO_THREAD          = 466 // %7B int rtprio_thread(int function, %5C%0A%09SYS_PREAD                  = 475 // %7B ssize_t pread(int fd, void *buf, %5C%0A%09SYS_PWRITE                 = 476 // %7B ssize_t pwrite(int fd, const void *buf, %5C%0A%09SYS_MMAP                   = 477 // %7B caddr_t mmap(caddr_t addr, size_t len, %5C%0A%09SYS_LSEEK                  = 478 // %7B off_t lseek(int fd, off_t offset, %5C%0A%09SYS_TRUNCATE               = 479 // %7B int truncate(char *path, off_t length); %7D%0A%09SYS_FTRUNCATE              = 480 // %7B int ftruncate(int fd, off_t length); %7D%0A%09SYS_THR_KILL2              = 481 // %7B int thr_kill2(pid_t pid, long id, int sig); %7D%0A%09SYS_SHM_OPEN               = 482 // %7B int shm_open(const char *path, int flags, %5C%0A%09SYS_SHM_UNLINK             = 483 // %7B int shm_unlink(const char *path); %7D%0A%09SYS_CPUSET                 = 484 // %7B int cpuset(cpusetid_t *setid); %7D%0A%09SYS_CPUSET_SETID           = 485 // %7B int cpuset_setid(cpuwhich_t which, id_t id, %5C%0A%09SYS_CPUSET_GETID           = 486 // %7B int cpuset_getid(cpulevel_t level, %5C%0A%09SYS_CPUSET_GETAFFINITY     = 487 // %7B int cpuset_getaffinity(cpulevel_t level, %5C%0A%09SYS_CPUSET_SETAFFINITY     = 488 // %7B int cpuset_setaffinity(cpulevel_t level, %5C%0A%09SYS_FACCESSAT              = 489 // %7B int faccessat(int fd, char *path, int amode, %5C%0A%09SYS_FCHMODAT               = 490 // %7B int fchmodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_FCHOWNAT               = 491 // %7B int fchownat(int fd, char *path, uid_t uid, %5C%0A%09SYS_FEXECVE                = 492 // %7B int fexecve(int fd, char **argv, %5C%0A%09SYS_FSTATAT                = 493 // %7B int fstatat(int fd, char *path, %5C%0A%09SYS_FUTIMESAT              = 494 // %7B int futimesat(int fd, char *path, %5C%0A%09SYS_LINKAT                 = 495 // %7B int linkat(int fd1, char *path1, int fd2, %5C%0A%09SYS_MKDIRAT                = 496 // %7B int mkdirat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKFIFOAT               = 497 // %7B int mkfifoat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKNODAT                = 498 // %7B int mknodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_OPENAT                 = 499 // %7B int openat(int fd, char *path, int flag, %5C%0A%09SYS_READLINKAT             = 500 // %7B int readlinkat(int fd, char *path, char *buf, %5C%0A%09SYS_RENAMEAT               = 501 // %7B int renameat(int oldfd, char *old, int newfd, %5C%0A%09SYS_SYMLINKAT              = 502 // %7B int symlinkat(char *path1, int fd, %5C%0A%09SYS_UNLINKAT               = 503 // %7B int unlinkat(int fd, char *path, int flag); %7D%0A%09SYS_POSIX_OPENPT           = 504 // %7B int posix_openpt(int flags); %7D%0A%09SYS_JAIL_GET               = 506 // %7B int jail_get(struct iovec *iovp, %5C%0A%09SYS_JAIL_SET               = 507 // %7B int jail_set(struct iovec *iovp, %5C%0A%09SYS_JAIL_REMOVE            = 508 // %7B int jail_remove(int jid); %7D%0A%09SYS_CLOSEFROM              = 509 // %7B int closefrom(int lowfd); %7D%0A%09SYS_LPATHCONF              = 513 // %7B int lpathconf(char *path, int name); %7D%0A%09SYS___CAP_RIGHTS_GET       = 515 // %7B int __cap_rights_get(int version, %5C%0A%09SYS_CAP_ENTER              = 516 // %7B int cap_enter(void); %7D%0A%09SYS_CAP_GETMODE            = 517 // %7B int cap_getmode(u_int *modep); %7D%0A%09SYS_PDFORK                 = 518 // %7B int pdfork(int *fdp, int flags); %7D%0A%09SYS_PDKILL                 = 519 // %7B int pdkill(int fd, int signum); %7D%0A%09SYS_PDGETPID               = 520 // %7B int pdgetpid(int fd, pid_t *pidp); %7D%0A%09SYS_PSELECT                = 522 // %7B int pselect(int nd, fd_set *in, %5C%0A%09SYS_GETLOGINCLASS          = 523 // %7B int getloginclass(char *namebuf, %5C%0A%09SYS_SETLOGINCLASS          = 524 // %7B int setloginclass(const char *namebuf); %7D%0A%09SYS_RCTL_GET_RACCT         = 525 // %7B int rctl_get_racct(const void *inbufp, %5C%0A%09SYS_RCTL_GET_RULES         = 526 // %7B int rctl_get_rules(const void *inbufp, %5C%0A%09SYS_RCTL_GET_LIMITS        = 527 // %7B int rctl_get_limits(const void *inbufp, %5C%0A%09SYS_RCTL_ADD_RULE          = 528 // %7B int rctl_add_rule(const void *inbufp, %5C%0A%09SYS_RCTL_REMOVE_RULE       = 529 // %7B int rctl_remove_rule(const void *inbufp, %5C%0A%09SYS_POSIX_FALLOCATE        = 530 // %7B int posix_fallocate(int fd, %5C%0A%09SYS_POSIX_FADVISE          = 531 // %7B int posix_fadvise(int fd, off_t offset, %5C%0A%09SYS_WAIT6                  = 532 // %7B int wait6(idtype_t idtype, id_t id, %5C%0A%09SYS_CAP_RIGHTS_LIMIT       = 533 // %7B int cap_rights_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_LIMIT       = 534 // %7B int cap_ioctls_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_GET         = 535 // %7B ssize_t cap_ioctls_get(int fd, %5C%0A%09SYS_CAP_FCNTLS_LIMIT       = 536 // %7B int cap_fcntls_limit(int fd, %5C%0A%09SYS_CAP_FCNTLS_GET         = 537 // %7B int cap_fcntls_get(int fd, %5C%0A%09SYS_BINDAT                 = 538 // %7B int bindat(int fd, int s, caddr_t name, %5C%0A%09SYS_CONNECTAT              = 539 // %7B int connectat(int fd, int s, caddr_t name, %5C%0A%09SYS_CHFLAGSAT              = 540 // %7B int chflagsat(int fd, const char *path, %5C%0A%09SYS_ACCEPT4                = 541 // %7B int accept4(int s, %5C%0A%09SYS_PIPE2                  = 542 // %7B int pipe2(int *fildes, int flags); %7D%0A%09SYS_PROCCTL                = 544 // %7B int procctl(idtype_t idtype, id_t id, %5C%0A%09SYS_PPOLL                  = 545 // %7B int ppoll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_FUTIMENS               = 546 // %7B int futimens(int fd, %5C%0A%09SYS_UTIMENSAT              = 547 // %7B int utimensat(int fd, %5C%0A
+%09SYS_EXIT                     = 1   // %7B void sys_exit(int rval); %7D exit %5C%0A%09SYS_FORK                     = 2   // %7B int fork(void); %7D%0A%09SYS_READ                     = 3   // %7B ssize_t read(int fd, void *buf, %5C%0A%09SYS_WRITE                    = 4   // %7B ssize_t write(int fd, const void *buf, %5C%0A%09SYS_OPEN                     = 5   // %7B int open(char *path, int flags, int mode); %7D%0A%09SYS_CLOSE                    = 6   // %7B int close(int fd); %7D%0A%09SYS_WAIT4                    = 7   // %7B int wait4(int pid, int *status, %5C%0A%09SYS_LINK                     = 9   // %7B int link(char *path, char *link); %7D%0A%09SYS_UNLINK                   = 10  // %7B int unlink(char *path); %7D%0A%09SYS_CHDIR                    = 12  // %7B int chdir(char *path); %7D%0A%09SYS_FCHDIR                   = 13  // %7B int fchdir(int fd); %7D%0A%09SYS_MKNOD                    = 14  // %7B int mknod(char *path, int mode, int dev); %7D%0A%09SYS_CHMOD                    = 15  // %7B int chmod(char *path, int mode); %7D%0A%09SYS_CHOWN                    = 16  // %7B int chown(char *path, int uid, int gid); %7D%0A%09SYS_OBREAK                   = 17  // %7B int obreak(char *nsize); %7D break %5C%0A%09SYS_GETPID                   = 20  // %7B pid_t getpid(void); %7D%0A%09SYS_MOUNT                    = 21  // %7B int mount(char *type, char *path, %5C%0A%09SYS_UNMOUNT                  = 22  // %7B int unmount(char *path, int flags); %7D%0A%09SYS_SETUID                   = 23  // %7B int setuid(uid_t uid); %7D%0A%09SYS_GETUID                   = 24  // %7B uid_t getuid(void); %7D%0A%09SYS_GETEUID                  = 25  // %7B uid_t geteuid(void); %7D%0A%09SYS_PTRACE                   = 26  // %7B int ptrace(int req, pid_t pid, %5C%0A%09SYS_RECVMSG                  = 27  // %7B int recvmsg(int s, struct msghdr *msg, %5C%0A%09SYS_SENDMSG                  = 28  // %7B int sendmsg(int s, struct msghdr *msg, %5C%0A%09SYS_RECVFROM                 = 29  // %7B int recvfrom(int s, caddr_t buf, %5C%0A%09SYS_ACCEPT                   = 30  // %7B int accept(int s, %5C%0A%09SYS_GETPEERNAME              = 31  // %7B int getpeername(int fdes, %5C%0A%09SYS_GETSOCKNAME              = 32  // %7B int getsockname(int fdes, %5C%0A%09SYS_ACCESS                   = 33  // %7B int access(char *path, int amode); %7D%0A%09SYS_CHFLAGS                  = 34  // %7B int chflags(const char *path, u_long flags); %7D%0A%09SYS_FCHFLAGS                 = 35  // %7B int fchflags(int fd, u_long flags); %7D%0A%09SYS_SYNC                     = 36  // %7B int sync(void); %7D%0A%09SYS_KILL                     = 37  // %7B int kill(int pid, int signum); %7D%0A%09SYS_GETPPID                  = 39  // %7B pid_t getppid(void); %7D%0A%09SYS_DUP                      = 41  // %7B int dup(u_int fd); %7D%0A%09SYS_PIPE                     = 42  // %7B int pipe(void); %7D%0A%09SYS_GETEGID                  = 43  // %7B gid_t getegid(void); %7D%0A%09SYS_PROFIL                   = 44  // %7B int profil(caddr_t samples, size_t size, %5C%0A%09SYS_KTRACE                   = 45  // %7B int ktrace(const char *fname, int ops, %5C%0A%09SYS_GETGID                   = 47  // %7B gid_t getgid(void); %7D%0A%09SYS_GETLOGIN                 = 49  // %7B int getlogin(char *namebuf, u_int %5C%0A%09SYS_SETLOGIN                 = 50  // %7B int setlogin(char *namebuf); %7D%0A%09SYS_ACCT                     = 51  // %7B int acct(char *path); %7D%0A%09SYS_SIGALTSTACK              = 53  // %7B int sigaltstack(stack_t *ss, %5C%0A%09SYS_IOCTL                    = 54  // %7B int ioctl(int fd, u_long com, %5C%0A%09SYS_REBOOT                   = 55  // %7B int reboot(int opt); %7D%0A%09SYS_REVOKE                   = 56  // %7B int revoke(char *path); %7D%0A%09SYS_SYMLINK                  = 57  // %7B int symlink(char *path, char *link); %7D%0A%09SYS_READLINK                 = 58  // %7B ssize_t readlink(char *path, char *buf, %5C%0A%09SYS_EXECVE                   = 59  // %7B int execve(char *fname, char **argv, %5C%0A%09SYS_UMASK                    = 60  // %7B int umask(int newmask); %7D umask umask_args %5C%0A%09SYS_CHROOT                   = 61  // %7B int chroot(char *path); %7D%0A%09SYS_MSYNC                    = 65  // %7B int msync(void *addr, size_t len, %5C%0A%09SYS_VFORK                    = 66  // %7B int vfork(void); %7D%0A%09SYS_SBRK                     = 69  // %7B int sbrk(int incr); %7D%0A%09SYS_SSTK                     = 70  // %7B int sstk(int incr); %7D%0A%09SYS_OVADVISE                 = 72  // %7B int ovadvise(int anom); %7D vadvise %5C%0A%09SYS_MUNMAP                   = 73  // %7B int munmap(void *addr, size_t len); %7D%0A%09SYS_MPROTECT                 = 74  // %7B int mprotect(const void *addr, size_t len, %5C%0A%09SYS_MADVISE                  = 75  // %7B int madvise(void *addr, size_t len, %5C%0A%09SYS_MINCORE                  = 78  // %7B int mincore(const void *addr, size_t len, %5C%0A%09SYS_GETGROUPS                = 79  // %7B int getgroups(u_int gidsetsize, %5C%0A%09SYS_SETGROUPS                = 80  // %7B int setgroups(u_int gidsetsize, %5C%0A%09SYS_GETPGRP                  = 81  // %7B int getpgrp(void); %7D%0A%09SYS_SETPGID                  = 82  // %7B int setpgid(int pid, int pgid); %7D%0A%09SYS_SETITIMER                = 83  // %7B int setitimer(u_int which, struct %5C%0A%09SYS_SWAPON                   = 85  // %7B int swapon(char *name); %7D%0A%09SYS_GETITIMER                = 86  // %7B int getitimer(u_int which, %5C%0A%09SYS_GETDTABLESIZE            = 89  // %7B int getdtablesize(void); %7D%0A%09SYS_DUP2                     = 90  // %7B int dup2(u_int from, u_int to); %7D%0A%09SYS_FCNTL                    = 92  // %7B int fcntl(int fd, int cmd, long arg); %7D%0A%09SYS_SELECT                   = 93  // %7B int select(int nd, fd_set *in, fd_set *ou, %5C%0A%09SYS_FSYNC                    = 95  // %7B int fsync(int fd); %7D%0A%09SYS_SETPRIORITY              = 96  // %7B int setpriority(int which, int who, %5C%0A%09SYS_SOCKET                   = 97  // %7B int socket(int domain, int type, %5C%0A%09SYS_CONNECT                  = 98  // %7B int connect(int s, caddr_t name, %5C%0A%09SYS_GETPRIORITY              = 100 // %7B int getpriority(int which, int who); %7D%0A%09SYS_BIND                     = 104 // %7B int bind(int s, caddr_t name, %5C%0A%09SYS_SETSOCKOPT               = 105 // %7B int setsockopt(int s, int level, int name, %5C%0A%09SYS_LISTEN                   = 106 // %7B int listen(int s, int backlog); %7D%0A%09SYS_GETTIMEOFDAY             = 116 // %7B int gettimeofday(struct timeval *tp, %5C%0A%09SYS_GETRUSAGE                = 117 // %7B int getrusage(int who, %5C%0A%09SYS_GETSOCKOPT               = 118 // %7B int getsockopt(int s, int level, int name, %5C%0A%09SYS_READV                    = 120 // %7B int readv(int fd, struct iovec *iovp, %5C%0A%09SYS_WRITEV                   = 121 // %7B int writev(int fd, struct iovec *iovp, %5C%0A%09SYS_SETTIMEOFDAY             = 122 // %7B int settimeofday(struct timeval *tv, %5C%0A%09SYS_FCHOWN                   = 123 // %7B int fchown(int fd, int uid, int gid); %7D%0A%09SYS_FCHMOD                   = 124 // %7B int fchmod(int fd, int mode); %7D%0A%09SYS_SETREUID                 = 126 // %7B int setreuid(int ruid, int euid); %7D%0A%09SYS_SETREGID                 = 127 // %7B int setregid(int rgid, int egid); %7D%0A%09SYS_RENAME                   = 128 // %7B int rename(char *from, char *to); %7D%0A%09SYS_FLOCK                    = 131 // %7B int flock(int fd, int how); %7D%0A%09SYS_MKFIFO                   = 132 // %7B int mkfifo(char *path, int mode); %7D%0A%09SYS_SENDTO                   = 133 // %7B int sendto(int s, caddr_t buf, size_t len, %5C%0A%09SYS_SHUTDOWN                 = 134 // %7B int shutdown(int s, int how); %7D%0A%09SYS_SOCKETPAIR               = 135 // %7B int socketpair(int domain, int type, %5C%0A%09SYS_MKDIR                    = 136 // %7B int mkdir(char *path, int mode); %7D%0A%09SYS_RMDIR                    = 137 // %7B int rmdir(char *path); %7D%0A%09SYS_UTIMES                   = 138 // %7B int utimes(char *path, %5C%0A%09SYS_ADJTIME                  = 140 // %7B int adjtime(struct timeval *delta, %5C%0A%09SYS_SETSID                   = 147 // %7B int setsid(void); %7D%0A%09SYS_QUOTACTL                 = 148 // %7B int quotactl(char *path, int cmd, int uid, %5C%0A%09SYS_NLM_SYSCALL              = 154 // %7B int nlm_syscall(int debug_level, int grace_period, int addr_count, char **addrs); %7D%0A%09SYS_NFSSVC                   = 155 // %7B int nfssvc(int flag, caddr_t argp); %7D%0A%09SYS_LGETFH                   = 160 // %7B int lgetfh(char *fname, %5C%0A%09SYS_GETFH                    = 161 // %7B int getfh(char *fname, %5C%0A%09SYS_SYSARCH                  = 165 // %7B int sysarch(int op, char *parms); %7D%0A%09SYS_RTPRIO                   = 166 // %7B int rtprio(int function, pid_t pid, %5C%0A%09SYS_SEMSYS                   = 169 // %7B int semsys(int which, int a2, int a3, %5C%0A%09SYS_MSGSYS                   = 170 // %7B int msgsys(int which, int a2, int a3, %5C%0A%09SYS_SHMSYS                   = 171 // %7B int shmsys(int which, int a2, int a3, %5C%0A%09SYS_FREEBSD6_PREAD           = 173 // %7B ssize_t freebsd6_pread(int fd, void *buf, %5C%0A%09SYS_FREEBSD6_PWRITE          = 174 // %7B ssize_t freebsd6_pwrite(int fd, %5C%0A%09SYS_SETFIB                   = 175 // %7B int setfib(int fibnum); %7D%0A%09SYS_NTP_ADJTIME              = 176 // %7B int ntp_adjtime(struct timex *tp); %7D%0A%09SYS_SETGID                   = 181 // %7B int setgid(gid_t gid); %7D%0A%09SYS_SETEGID                  = 182 // %7B int setegid(gid_t egid); %7D%0A%09SYS_SETEUID                  = 183 // %7B int seteuid(uid_t euid); %7D%0A%09SYS_STAT                     = 188 // %7B int stat(char *path, struct stat *ub); %7D%0A%09SYS_FSTAT                    = 189 // %7B int fstat(int fd, struct stat *sb); %7D%0A%09SYS_LSTAT                    = 190 // %7B int lstat(char *path, struct stat *ub); %7D%0A%09SYS_PATHCONF                 = 191 // %7B int pathconf(char *path, int name); %7D%0A%09SYS_FPATHCONF                = 192 // %7B int fpathconf(int fd, int name); %7D%0A%09SYS_GETRLIMIT                = 194 // %7B int getrlimit(u_int which, %5C%0A%09SYS_SETRLIMIT                = 195 // %7B int setrlimit(u_int which, %5C%0A%09SYS_GETDIRENTRIES            = 196 // %7B int getdirentries(int fd, char *buf, %5C%0A%09SYS_FREEBSD6_MMAP            = 197 // %7B caddr_t freebsd6_mmap(caddr_t addr, %5C%0A%09SYS_FREEBSD6_LSEEK           = 199 // %7B off_t freebsd6_lseek(int fd, int pad, %5C%0A%09SYS_FREEBSD6_TRUNCATE        = 200 // %7B int freebsd6_truncate(char *path, int pad, %5C%0A%09SYS_FREEBSD6_FTRUNCATE       = 201 // %7B int freebsd6_ftruncate(int fd, int pad, %5C%0A%09SYS___SYSCTL                 = 202 // %7B int __sysctl(int *name, u_int namelen, %5C%0A%09SYS_MLOCK                    = 203 // %7B int mlock(const void *addr, size_t len); %7D%0A%09SYS_MUNLOCK                  = 204 // %7B int munlock(const void *addr, size_t len); %7D%0A%09SYS_UNDELETE                 = 205 // %7B int undelete(char *path); %7D%0A%09SYS_FUTIMES                  = 206 // %7B int futimes(int fd, struct timeval *tptr); %7D%0A%09SYS_GETPGID                  = 207 // %7B int getpgid(pid_t pid); %7D%0A%09SYS_POLL                     = 209 // %7B int poll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_SEMGET                   = 221 // %7B int semget(key_t key, int nsems, %5C%0A%09SYS_SEMOP                    = 222 // %7B int semop(int semid, struct sembuf *sops, %5C%0A%09SYS_MSGGET                   = 225 // %7B int msgget(key_t key, int msgflg); %7D%0A%09SYS_MSGSND                   = 226 // %7B int msgsnd(int msqid, const void *msgp, %5C%0A%09SYS_MSGRCV                   = 227 // %7B int msgrcv(int msqid, void *msgp, %5C%0A%09SYS_SHMAT                    = 228 // %7B int shmat(int shmid, const void *shmaddr, %5C%0A%09SYS_SHMDT                    = 230 // %7B int shmdt(const void *shmaddr); %7D%0A%09SYS_SHMGET                   = 231 // %7B int shmget(key_t key, size_t size, %5C%0A%09SYS_CLOCK_GETTIME            = 232 // %7B int clock_gettime(clockid_t clock_id, %5C%0A%09SYS_CLOCK_SETTIME            = 233 // %7B int clock_settime( %5C%0A%09SYS_CLOCK_GETRES             = 234 // %7B int clock_getres(clockid_t clock_id, %5C%0A%09SYS_KTIMER_CREATE            = 235 // %7B int ktimer_create(clockid_t clock_id, %5C%0A%09SYS_KTIMER_DELETE            = 236 // %7B int ktimer_delete(int timerid); %7D%0A%09SYS_KTIMER_SETTIME           = 237 // %7B int ktimer_settime(int timerid, int flags, %5C%0A%09SYS_KTIMER_GETTIME           = 238 // %7B int ktimer_gettime(int timerid, struct %5C%0A%09SYS_KTIMER_GETOVERRUN        = 239 // %7B int ktimer_getoverrun(int timerid); %7D%0A%09SYS_NANOSLEEP                = 240 // %7B int nanosleep(const struct timespec *rqtp, %5C%0A%09SYS_FFCLOCK_GETCOUNTER       = 241 // %7B int ffclock_getcounter(ffcounter *ffcount); %7D%0A%09SYS_FFCLOCK_SETESTIMATE      = 242 // %7B int ffclock_setestimate( %5C%0A%09SYS_FFCLOCK_GETESTIMATE      = 243 // %7B int ffclock_getestimate( %5C%0A%09SYS_CLOCK_GETCPUCLOCKID2     = 247 // %7B int clock_getcpuclockid2(id_t id,%5C%0A%09SYS_NTP_GETTIME              = 248 // %7B int ntp_gettime(struct ntptimeval *ntvp); %7D%0A%09SYS_MINHERIT                 = 250 // %7B int minherit(void *addr, size_t len, %5C%0A%09SYS_RFORK                    = 251 // %7B int rfork(int flags); %7D%0A%09SYS_OPENBSD_POLL             = 252 // %7B int openbsd_poll(struct pollfd *fds, %5C%0A%09SYS_ISSETUGID                = 253 // %7B int issetugid(void); %7D%0A%09SYS_LCHOWN                   = 254 // %7B int lchown(char *path, int uid, int gid); %7D%0A%09SYS_AIO_READ                 = 255 // %7B int aio_read(struct aiocb *aiocbp); %7D%0A%09SYS_AIO_WRITE                = 256 // %7B int aio_write(struct aiocb *aiocbp); %7D%0A%09SYS_LIO_LISTIO               = 257 // %7B int lio_listio(int mode, %5C%0A%09SYS_GETDENTS                 = 272 // %7B int getdents(int fd, char *buf, %5C%0A%09SYS_LCHMOD                   = 274 // %7B int lchmod(char *path, mode_t mode); %7D%0A%09SYS_LUTIMES                  = 276 // %7B int lutimes(char *path, %5C%0A%09SYS_NSTAT                    = 278 // %7B int nstat(char *path, struct nstat *ub); %7D%0A%09SYS_NFSTAT                   = 279 // %7B int nfstat(int fd, struct nstat *sb); %7D%0A%09SYS_NLSTAT                   = 280 // %7B int nlstat(char *path, struct nstat *ub); %7D%0A%09SYS_PREADV                   = 289 // %7B ssize_t preadv(int fd, struct iovec *iovp, %5C%0A%09SYS_PWRITEV                  = 290 // %7B ssize_t pwritev(int fd, struct iovec *iovp, %5C%0A%09SYS_FHOPEN                   = 298 // %7B int fhopen(const struct fhandle *u_fhp, %5C%0A%09SYS_FHSTAT                   = 299 // %7B int fhstat(const struct fhandle *u_fhp, %5C%0A%09SYS_MODNEXT                  = 300 // %7B int modnext(int modid); %7D%0A%09SYS_MODSTAT                  = 301 // %7B int modstat(int modid, %5C%0A%09SYS_MODFNEXT                 = 302 // %7B int modfnext(int modid); %7D%0A%09SYS_MODFIND                  = 303 // %7B int modfind(const char *name); %7D%0A%09SYS_KLDLOAD                  = 304 // %7B int kldload(const char *file); %7D%0A%09SYS_KLDUNLOAD                = 305 // %7B int kldunload(int fileid); %7D%0A%09SYS_KLDFIND                  = 306 // %7B int kldfind(const char *file); %7D%0A%09SYS_KLDNEXT                  = 307 // %7B int kldnext(int fileid); %7D%0A%09SYS_KLDSTAT                  = 308 // %7B int kldstat(int fileid, struct %5C%0A%09SYS_KLDFIRSTMOD              = 309 // %7B int kldfirstmod(int fileid); %7D%0A%09SYS_GETSID                   = 310 // %7B int getsid(pid_t pid); %7D%0A%09SYS_SETRESUID                = 311 // %7B int setresuid(uid_t ruid, uid_t euid, %5C%0A%09SYS_SETRESGID                = 312 // %7B int setresgid(gid_t rgid, gid_t egid, %5C%0A%09SYS_AIO_RETURN               = 314 // %7B int aio_return(struct aiocb *aiocbp); %7D%0A%09SYS_AIO_SUSPEND              = 315 // %7B int aio_suspend( %5C%0A%09SYS_AIO_CANCEL               = 316 // %7B int aio_cancel(int fd, %5C%0A%09SYS_AIO_ERROR                = 317 // %7B int aio_error(struct aiocb *aiocbp); %7D%0A%09SYS_OAIO_READ                = 318 // %7B int oaio_read(struct oaiocb *aiocbp); %7D%0A%09SYS_OAIO_WRITE               = 319 // %7B int oaio_write(struct oaiocb *aiocbp); %7D%0A%09SYS_OLIO_LISTIO              = 320 // %7B int olio_listio(int mode, %5C%0A%09SYS_YIELD                    = 321 // %7B int yield(void); %7D%0A%09SYS_MLOCKALL                 = 324 // %7B int mlockall(int how); %7D%0A%09SYS_MUNLOCKALL               = 325 // %7B int munlockall(void); %7D%0A%09SYS___GETCWD                 = 326 // %7B int __getcwd(char *buf, u_int buflen); %7D%0A%09SYS_SCHED_SETPARAM           = 327 // %7B int sched_setparam (pid_t pid, %5C%0A%09SYS_SCHED_GETPARAM           = 328 // %7B int sched_getparam (pid_t pid, struct %5C%0A%09SYS_SCHED_SETSCHEDULER       = 329 // %7B int sched_setscheduler (pid_t pid, int %5C%0A%09SYS_SCHED_GETSCHEDULER       = 330 // %7B int sched_getscheduler (pid_t pid); %7D%0A%09SYS_SCHED_YIELD              = 331 // %7B int sched_yield (void); %7D%0A%09SYS_SCHED_GET_PRIORITY_MAX   = 332 // %7B int sched_get_priority_max (int policy); %7D%0A%09SYS_SCHED_GET_PRIORITY_MIN   = 333 // %7B int sched_get_priority_min (int policy); %7D%0A%09SYS_SCHED_RR_GET_INTERVAL    = 334 // %7B int sched_rr_get_interval (pid_t pid, %5C%0A%09SYS_UTRACE                   = 335 // %7B int utrace(const void *addr, size_t len); %7D%0A%09SYS_KLDSYM                   = 337 // %7B int kldsym(int fileid, int cmd, %5C%0A%09SYS_JAIL                     = 338 // %7B int jail(struct jail *jail); %7D%0A%09SYS_SIGPROCMASK              = 340 // %7B int sigprocmask(int how, %5C%0A%09SYS_SIGSUSPEND               = 341 // %7B int sigsuspend(const sigset_t *sigmask); %7D%0A%09SYS_SIGPENDING               = 343 // %7B int sigpending(sigset_t *set); %7D%0A%09SYS_SIGTIMEDWAIT             = 345 // %7B int sigtimedwait(const sigset_t *set, %5C%0A%09SYS_SIGWAITINFO              = 346 // %7B int sigwaitinfo(const sigset_t *set, %5C%0A%09SYS___ACL_GET_FILE           = 347 // %7B int __acl_get_file(const char *path, %5C%0A%09SYS___ACL_SET_FILE           = 348 // %7B int __acl_set_file(const char *path, %5C%0A%09SYS___ACL_GET_FD             = 349 // %7B int __acl_get_fd(int filedes, %5C%0A%09SYS___ACL_SET_FD             = 350 // %7B int __acl_set_fd(int filedes, %5C%0A%09SYS___ACL_DELETE_FILE        = 351 // %7B int __acl_delete_file(const char *path, %5C%0A%09SYS___ACL_DELETE_FD          = 352 // %7B int __acl_delete_fd(int filedes, %5C%0A%09SYS___ACL_ACLCHECK_FILE      = 353 // %7B int __acl_aclcheck_file(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_FD        = 354 // %7B int __acl_aclcheck_fd(int filedes, %5C%0A%09SYS_EXTATTRCTL               = 355 // %7B int extattrctl(const char *path, int cmd, %5C%0A%09SYS_EXTATTR_SET_FILE         = 356 // %7B ssize_t extattr_set_file( %5C%0A%09SYS_EXTATTR_GET_FILE         = 357 // %7B ssize_t extattr_get_file( %5C%0A%09SYS_EXTATTR_DELETE_FILE      = 358 // %7B int extattr_delete_file(const char *path, %5C%0A%09SYS_AIO_WAITCOMPLETE         = 359 // %7B int aio_waitcomplete( %5C%0A%09SYS_GETRESUID                = 360 // %7B int getresuid(uid_t *ruid, uid_t *euid, %5C%0A%09SYS_GETRESGID                = 361 // %7B int getresgid(gid_t *rgid, gid_t *egid, %5C%0A%09SYS_KQUEUE                   = 362 // %7B int kqueue(void); %7D%0A%09SYS_KEVENT                   = 363 // %7B int kevent(int fd, %5C%0A%09SYS_EXTATTR_SET_FD           = 371 // %7B ssize_t extattr_set_fd(int fd, %5C%0A%09SYS_EXTATTR_GET_FD           = 372 // %7B ssize_t extattr_get_fd(int fd, %5C%0A%09SYS_EXTATTR_DELETE_FD        = 373 // %7B int extattr_delete_fd(int fd, %5C%0A%09SYS___SETUGID                = 374 // %7B int __setugid(int flag); %7D%0A%09SYS_EACCESS                  = 376 // %7B int eaccess(char *path, int amode); %7D%0A%09SYS_NMOUNT                   = 378 // %7B int nmount(struct iovec *iovp, %5C%0A%09SYS___MAC_GET_PROC           = 384 // %7B int __mac_get_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_SET_PROC           = 385 // %7B int __mac_set_proc(struct mac *mac_p); %7D%0A%09SYS___MAC_GET_FD             = 386 // %7B int __mac_get_fd(int fd, %5C%0A%09SYS___MAC_GET_FILE           = 387 // %7B int __mac_get_file(const char *path_p, %5C%0A%09SYS___MAC_SET_FD             = 388 // %7B int __mac_set_fd(int fd, %5C%0A%09SYS___MAC_SET_FILE           = 389 // %7B int __mac_set_file(const char *path_p, %5C%0A%09SYS_KENV                     = 390 // %7B int kenv(int what, const char *name, %5C%0A%09SYS_LCHFLAGS                 = 391 // %7B int lchflags(const char *path, %5C%0A%09SYS_UUIDGEN                  = 392 // %7B int uuidgen(struct uuid *store, %5C%0A%09SYS_SENDFILE                 = 393 // %7B int sendfile(int fd, int s, off_t offset, %5C%0A%09SYS_MAC_SYSCALL              = 394 // %7B int mac_syscall(const char *policy, %5C%0A%09SYS_GETFSSTAT                = 395 // %7B int getfsstat(struct statfs *buf, %5C%0A%09SYS_STATFS                   = 396 // %7B int statfs(char *path, %5C%0A%09SYS_FSTATFS                  = 397 // %7B int fstatfs(int fd, struct statfs *buf); %7D%0A%09SYS_FHSTATFS                 = 398 // %7B int fhstatfs(const struct fhandle *u_fhp, %5C%0A%09SYS_KSEM_CLOSE               = 400 // %7B int ksem_close(semid_t id); %7D%0A%09SYS_KSEM_POST                = 401 // %7B int ksem_post(semid_t id); %7D%0A%09SYS_KSEM_WAIT                = 402 // %7B int ksem_wait(semid_t id); %7D%0A%09SYS_KSEM_TRYWAIT             = 403 // %7B int ksem_trywait(semid_t id); %7D%0A%09SYS_KSEM_INIT                = 404 // %7B int ksem_init(semid_t *idp, %5C%0A%09SYS_KSEM_OPEN                = 405 // %7B int ksem_open(semid_t *idp, %5C%0A%09SYS_KSEM_UNLINK              = 406 // %7B int ksem_unlink(const char *name); %7D%0A%09SYS_KSEM_GETVALUE            = 407 // %7B int ksem_getvalue(semid_t id, int *val); %7D%0A%09SYS_KSEM_DESTROY             = 408 // %7B int ksem_destroy(semid_t id); %7D%0A%09SYS___MAC_GET_PID            = 409 // %7B int __mac_get_pid(pid_t pid, %5C%0A%09SYS___MAC_GET_LINK           = 410 // %7B int __mac_get_link(const char *path_p, %5C%0A%09SYS___MAC_SET_LINK           = 411 // %7B int __mac_set_link(const char *path_p, %5C%0A%09SYS_EXTATTR_SET_LINK         = 412 // %7B ssize_t extattr_set_link( %5C%0A%09SYS_EXTATTR_GET_LINK         = 413 // %7B ssize_t extattr_get_link( %5C%0A%09SYS_EXTATTR_DELETE_LINK      = 414 // %7B int extattr_delete_link( %5C%0A%09SYS___MAC_EXECVE             = 415 // %7B int __mac_execve(char *fname, char **argv, %5C%0A%09SYS_SIGACTION                = 416 // %7B int sigaction(int sig, %5C%0A%09SYS_SIGRETURN                = 417 // %7B int sigreturn( %5C%0A%09SYS_GETCONTEXT               = 421 // %7B int getcontext(struct __ucontext *ucp); %7D%0A%09SYS_SETCONTEXT               = 422 // %7B int setcontext( %5C%0A%09SYS_SWAPCONTEXT              = 423 // %7B int swapcontext(struct __ucontext *oucp, %5C%0A%09SYS_SWAPOFF                  = 424 // %7B int swapoff(const char *name); %7D%0A%09SYS___ACL_GET_LINK           = 425 // %7B int __acl_get_link(const char *path, %5C%0A%09SYS___ACL_SET_LINK           = 426 // %7B int __acl_set_link(const char *path, %5C%0A%09SYS___ACL_DELETE_LINK        = 427 // %7B int __acl_delete_link(const char *path, %5C%0A%09SYS___ACL_ACLCHECK_LINK      = 428 // %7B int __acl_aclcheck_link(const char *path, %5C%0A%09SYS_SIGWAIT                  = 429 // %7B int sigwait(const sigset_t *set, %5C%0A%09SYS_THR_CREATE               = 430 // %7B int thr_create(ucontext_t *ctx, long *id, %5C%0A%09SYS_THR_EXIT                 = 431 // %7B void thr_exit(long *state); %7D%0A%09SYS_THR_SELF                 = 432 // %7B int thr_self(long *id); %7D%0A%09SYS_THR_KILL                 = 433 // %7B int thr_kill(long id, int sig); %7D%0A%09SYS__UMTX_LOCK               = 434 // %7B int _umtx_lock(struct umtx *umtx); %7D%0A%09SYS__UMTX_UNLOCK             = 435 // %7B int _umtx_unlock(struct umtx *umtx); %7D%0A%09SYS_JAIL_ATTACH              = 436 // %7B int jail_attach(int jid); %7D%0A%09SYS_EXTATTR_LIST_FD          = 437 // %7B ssize_t extattr_list_fd(int fd, %5C%0A%09SYS_EXTATTR_LIST_FILE        = 438 // %7B ssize_t extattr_list_file( %5C%0A%09SYS_EXTATTR_LIST_LINK        = 439 // %7B ssize_t extattr_list_link( %5C%0A%09SYS_KSEM_TIMEDWAIT           = 441 // %7B int ksem_timedwait(semid_t id, %5C%0A%09SYS_THR_SUSPEND              = 442 // %7B int thr_suspend( %5C%0A%09SYS_THR_WAKE                 = 443 // %7B int thr_wake(long id); %7D%0A%09SYS_KLDUNLOADF               = 444 // %7B int kldunloadf(int fileid, int flags); %7D%0A%09SYS_AUDIT                    = 445 // %7B int audit(const void *record, %5C%0A%09SYS_AUDITON                  = 446 // %7B int auditon(int cmd, void *data, %5C%0A%09SYS_GETAUID                  = 447 // %7B int getauid(uid_t *auid); %7D%0A%09SYS_SETAUID                  = 448 // %7B int setauid(uid_t *auid); %7D%0A%09SYS_GETAUDIT                 = 449 // %7B int getaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_SETAUDIT                 = 450 // %7B int setaudit(struct auditinfo *auditinfo); %7D%0A%09SYS_GETAUDIT_ADDR            = 451 // %7B int getaudit_addr( %5C%0A%09SYS_SETAUDIT_ADDR            = 452 // %7B int setaudit_addr( %5C%0A%09SYS_AUDITCTL                 = 453 // %7B int auditctl(char *path); %7D%0A%09SYS__UMTX_OP                 = 454 // %7B int _umtx_op(void *obj, int op, %5C%0A%09SYS_THR_NEW                  = 455 // %7B int thr_new(struct thr_param *param, %5C%0A%09SYS_SIGQUEUE                 = 456 // %7B int sigqueue(pid_t pid, int signum, void *value); %7D%0A%09SYS_KMQ_OPEN                 = 457 // %7B int kmq_open(const char *path, int flags, %5C%0A%09SYS_KMQ_SETATTR              = 458 // %7B int kmq_setattr(int mqd,%09%09%5C%0A%09SYS_KMQ_TIMEDRECEIVE         = 459 // %7B int kmq_timedreceive(int mqd,%09%5C%0A%09SYS_KMQ_TIMEDSEND            = 460 // %7B int kmq_timedsend(int mqd,%09%09%5C%0A%09SYS_KMQ_NOTIFY               = 461 // %7B int kmq_notify(int mqd,%09%09%5C%0A%09SYS_KMQ_UNLINK               = 462 // %7B int kmq_unlink(const char *path); %7D%0A%09SYS_ABORT2                   = 463 // %7B int abort2(const char *why, int nargs, void **args); %7D%0A%09SYS_THR_SET_NAME             = 464 // %7B int thr_set_name(long id, const char *name); %7D%0A%09SYS_AIO_FSYNC                = 465 // %7B int aio_fsync(int op, struct aiocb *aiocbp); %7D%0A%09SYS_RTPRIO_THREAD            = 466 // %7B int rtprio_thread(int function, %5C%0A%09SYS_SCTP_PEELOFF             = 471 // %7B int sctp_peeloff(int sd, uint32_t name); %7D%0A%09SYS_SCTP_GENERIC_SENDMSG     = 472 // %7B int sctp_generic_sendmsg(int sd, caddr_t msg, int mlen, %5C%0A%09SYS_SCTP_GENERIC_SENDMSG_IOV = 473 // %7B int sctp_generic_sendmsg_iov(int sd, struct iovec *iov, int iovlen, %5C%0A%09SYS_SCTP_GENERIC_RECVMSG     = 474 // %7B int sctp_generic_recvmsg(int sd, struct iovec *iov, int iovlen, %5C%0A%09SYS_PREAD                    = 475 // %7B ssize_t pread(int fd, void *buf, %5C%0A%09SYS_PWRITE                   = 476 // %7B ssize_t pwrite(int fd, const void *buf, %5C%0A%09SYS_MMAP                     = 477 // %7B caddr_t mmap(caddr_t addr, size_t len, %5C%0A%09SYS_LSEEK                    = 478 // %7B off_t lseek(int fd, off_t offset, %5C%0A%09SYS_TRUNCATE                 = 479 // %7B int truncate(char *path, off_t length); %7D%0A%09SYS_FTRUNCATE                = 480 // %7B int ftruncate(int fd, off_t length); %7D%0A%09SYS_THR_KILL2                = 481 // %7B int thr_kill2(pid_t pid, long id, int sig); %7D%0A%09SYS_SHM_OPEN                 = 482 // %7B int shm_open(const char *path, int flags, %5C%0A%09SYS_SHM_UNLINK               = 483 // %7B int shm_unlink(const char *path); %7D%0A%09SYS_CPUSET                   = 484 // %7B int cpuset(cpusetid_t *setid); %7D%0A%09SYS_CPUSET_SETID             = 485 // %7B int cpuset_setid(cpuwhich_t which, id_t id, %5C%0A%09SYS_CPUSET_GETID             = 486 // %7B int cpuset_getid(cpulevel_t level, %5C%0A%09SYS_CPUSET_GETAFFINITY       = 487 // %7B int cpuset_getaffinity(cpulevel_t level, %5C%0A%09SYS_CPUSET_SETAFFINITY       = 488 // %7B int cpuset_setaffinity(cpulevel_t level, %5C%0A%09SYS_FACCESSAT                = 489 // %7B int faccessat(int fd, char *path, int amode, %5C%0A%09SYS_FCHMODAT                 = 490 // %7B int fchmodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_FCHOWNAT                 = 491 // %7B int fchownat(int fd, char *path, uid_t uid, %5C%0A%09SYS_FEXECVE                  = 492 // %7B int fexecve(int fd, char **argv, %5C%0A%09SYS_FSTATAT                  = 493 // %7B int fstatat(int fd, char *path, %5C%0A%09SYS_FUTIMESAT                = 494 // %7B int futimesat(int fd, char *path, %5C%0A%09SYS_LINKAT                   = 495 // %7B int linkat(int fd1, char *path1, int fd2, %5C%0A%09SYS_MKDIRAT                  = 496 // %7B int mkdirat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKFIFOAT                 = 497 // %7B int mkfifoat(int fd, char *path, mode_t mode); %7D%0A%09SYS_MKNODAT                  = 498 // %7B int mknodat(int fd, char *path, mode_t mode, %5C%0A%09SYS_OPENAT                   = 499 // %7B int openat(int fd, char *path, int flag, %5C%0A%09SYS_READLINKAT               = 500 // %7B int readlinkat(int fd, char *path, char *buf, %5C%0A%09SYS_RENAMEAT                 = 501 // %7B int renameat(int oldfd, char *old, int newfd, %5C%0A%09SYS_SYMLINKAT                = 502 // %7B int symlinkat(char *path1, int fd, %5C%0A%09SYS_UNLINKAT                 = 503 // %7B int unlinkat(int fd, char *path, int flag); %7D%0A%09SYS_POSIX_OPENPT             = 504 // %7B int posix_openpt(int flags); %7D%0A%09SYS_GSSD_SYSCALL             = 505 // %7B int gssd_syscall(char *path); %7D%0A%09SYS_JAIL_GET                 = 506 // %7B int jail_get(struct iovec *iovp, %5C%0A%09SYS_JAIL_SET                 = 507 // %7B int jail_set(struct iovec *iovp, %5C%0A%09SYS_JAIL_REMOVE              = 508 // %7B int jail_remove(int jid); %7D%0A%09SYS_CLOSEFROM                = 509 // %7B int closefrom(int lowfd); %7D%0A%09SYS___SEMCTL                 = 510 // %7B int __semctl(int semid, int semnum, %5C%0A%09SYS_MSGCTL                   = 511 // %7B int msgctl(int msqid, int cmd, %5C%0A%09SYS_SHMCTL                   = 512 // %7B int shmctl(int shmid, int cmd, %5C%0A%09SYS_LPATHCONF                = 513 // %7B int lpathconf(char *path, int name); %7D%0A%09SYS___CAP_RIGHTS_GET         = 515 // %7B int __cap_rights_get(int version, %5C%0A%09SYS_CAP_ENTER                = 516 // %7B int cap_enter(void); %7D%0A%09SYS_CAP_GETMODE              = 517 // %7B int cap_getmode(u_int *modep); %7D%0A%09SYS_PDFORK                   = 518 // %7B int pdfork(int *fdp, int flags); %7D%0A%09SYS_PDKILL                   = 519 // %7B int pdkill(int fd, int signum); %7D%0A%09SYS_PDGETPID                 = 520 // %7B int pdgetpid(int fd, pid_t *pidp); %7D%0A%09SYS_PSELECT                  = 522 // %7B int pselect(int nd, fd_set *in, %5C%0A%09SYS_GETLOGINCLASS            = 523 // %7B int getloginclass(char *namebuf, %5C%0A%09SYS_SETLOGINCLASS            = 524 // %7B int setloginclass(const char *namebuf); %7D%0A%09SYS_RCTL_GET_RACCT           = 525 // %7B int rctl_get_racct(const void *inbufp, %5C%0A%09SYS_RCTL_GET_RULES           = 526 // %7B int rctl_get_rules(const void *inbufp, %5C%0A%09SYS_RCTL_GET_LIMITS          = 527 // %7B int rctl_get_limits(const void *inbufp, %5C%0A%09SYS_RCTL_ADD_RULE            = 528 // %7B int rctl_add_rule(const void *inbufp, %5C%0A%09SYS_RCTL_REMOVE_RULE         = 529 // %7B int rctl_remove_rule(const void *inbufp, %5C%0A%09SYS_POSIX_FALLOCATE          = 530 // %7B int posix_fallocate(int fd, %5C%0A%09SYS_POSIX_FADVISE            = 531 // %7B int posix_fadvise(int fd, off_t offset, %5C%0A%09SYS_WAIT6                    = 532 // %7B int wait6(idtype_t idtype, id_t id, %5C%0A%09SYS_CAP_RIGHTS_LIMIT         = 533 // %7B int cap_rights_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_LIMIT         = 534 // %7B int cap_ioctls_limit(int fd, %5C%0A%09SYS_CAP_IOCTLS_GET           = 535 // %7B ssize_t cap_ioctls_get(int fd, %5C%0A%09SYS_CAP_FCNTLS_LIMIT         = 536 // %7B int cap_fcntls_limit(int fd, %5C%0A%09SYS_CAP_FCNTLS_GET           = 537 // %7B int cap_fcntls_get(int fd, %5C%0A%09SYS_BINDAT                   = 538 // %7B int bindat(int fd, int s, caddr_t name, %5C%0A%09SYS_CONNECTAT                = 539 // %7B int connectat(int fd, int s, caddr_t name, %5C%0A%09SYS_CHFLAGSAT                = 540 // %7B int chflagsat(int fd, const char *path, %5C%0A%09SYS_ACCEPT4                  = 541 // %7B int accept4(int s, %5C%0A%09SYS_PIPE2                    = 542 // %7B int pipe2(int *fildes, int flags); %7D%0A%09SYS_AIO_MLOCK                = 543 // %7B int aio_mlock(struct aiocb *aiocbp); %7D%0A%09SYS_PROCCTL                  = 544 // %7B int procctl(idtype_t idtype, id_t id, %5C%0A%09SYS_PPOLL                    = 545 // %7B int ppoll(struct pollfd *fds, u_int nfds, %5C%0A%09SYS_FUTIMENS                 = 546 // %7B int futimens(int fd, %5C%0A%09SYS_UTIMENSAT                = 547 // %7B int utimensat(int fd, %5C%0A
 )%0A
+ f 022ae23235165282acafd019d6b851c1e0680d555507d8a22595e0e5bd4d06f0 vendor/golang.org/x/sys/unix/zsysnum_linux_riscv64.go
dmppatch 2
@@ -0,0 +1,9511 @@
+// linux/mksysnum.pl -Wall -Werror -static -I/tmp/include /tmp/include/asm/unistd.h%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build riscv64,linux%0A%0Apackage unix%0A%0Aconst (%0A%09SYS_IO_SETUP               = 0%0A%09SYS_IO_DESTROY             = 1%0A%09SYS_IO_SUBMIT              = 2%0A%09SYS_IO_CANCEL              = 3%0A%09SYS_IO_GETEVENTS           = 4%0A%09SYS_SETXATTR               = 5%0A%09SYS_LSETXATTR              = 6%0A%09SYS_FSETXATTR              = 7%0A%09SYS_GETXATTR               = 8%0A%09SYS_LGETXATTR              = 9%0A%09SYS_FGETXATTR              = 10%0A%09SYS_LISTXATTR              = 11%0A%09SYS_LLISTXATTR             = 12%0A%09SYS_FLISTXATTR             = 13%0A%09SYS_REMOVEXATTR            = 14%0A%09SYS_LREMOVEXATTR           = 15%0A%09SYS_FREMOVEXATTR           = 16%0A%09SYS_GETCWD                 = 17%0A%09SYS_LOOKUP_DCOOKIE         = 18%0A%09SYS_EVENTFD2               = 19%0A%09SYS_EPOLL_CREATE1          = 20%0A%09SYS_EPOLL_CTL              = 21%0A%09SYS_EPOLL_PWAIT            = 22%0A%09SYS_DUP                    = 23%0A%09SYS_DUP3                   = 24%0A%09SYS_FCNTL                  = 25%0A%09SYS_INOTIFY_INIT1          = 26%0A%09SYS_INOTIFY_ADD_WATCH      = 27%0A%09SYS_INOTIFY_RM_WATCH       = 28%0A%09SYS_IOCTL                  = 29%0A%09SYS_IOPRIO_SET             = 30%0A%09SYS_IOPRIO_GET             = 31%0A%09SYS_FLOCK                  = 32%0A%09SYS_MKNODAT                = 33%0A%09SYS_MKDIRAT                = 34%0A%09SYS_UNLINKAT               = 35%0A%09SYS_SYMLINKAT              = 36%0A%09SYS_LINKAT                 = 37%0A%09SYS_UMOUNT2                = 39%0A%09SYS_MOUNT                  = 40%0A%09SYS_PIVOT_ROOT             = 41%0A%09SYS_NFSSERVCTL             = 42%0A%09SYS_STATFS                 = 43%0A%09SYS_FSTATFS                = 44%0A%09SYS_TRUNCATE               = 45%0A%09SYS_FTRUNCATE              = 46%0A%09SYS_FALLOCATE              = 47%0A%09SYS_FACCESSAT              = 48%0A%09SYS_CHDIR                  = 49%0A%09SYS_FCHDIR                 = 50%0A%09SYS_CHROOT                 = 51%0A%09SYS_FCHMOD                 = 52%0A%09SYS_FCHMODAT               = 53%0A%09SYS_FCHOWNAT               = 54%0A%09SYS_FCHOWN                 = 55%0A%09SYS_OPENAT                 = 56%0A%09SYS_CLOSE                  = 57%0A%09SYS_VHANGUP                = 58%0A%09SYS_PIPE2                  = 59%0A%09SYS_QUOTACTL               = 60%0A%09SYS_GETDENTS64             = 61%0A%09SYS_LSEEK                  = 62%0A%09SYS_READ                   = 63%0A%09SYS_WRITE                  = 64%0A%09SYS_READV                  = 65%0A%09SYS_WRITEV                 = 66%0A%09SYS_PREAD64                = 67%0A%09SYS_PWRITE64               = 68%0A%09SYS_PREADV                 = 69%0A%09SYS_PWRITEV                = 70%0A%09SYS_SENDFILE               = 71%0A%09SYS_PSELECT6               = 72%0A%09SYS_PPOLL                  = 73%0A%09SYS_SIGNALFD4              = 74%0A%09SYS_VMSPLICE               = 75%0A%09SYS_SPLICE                 = 76%0A%09SYS_TEE                    = 77%0A%09SYS_READLINKAT             = 78%0A%09SYS_FSTATAT                = 79%0A%09SYS_FSTAT                  = 80%0A%09SYS_SYNC                   = 81%0A%09SYS_FSYNC                  = 82%0A%09SYS_FDATASYNC              = 83%0A%09SYS_SYNC_FILE_RANGE        = 84%0A%09SYS_TIMERFD_CREATE         = 85%0A%09SYS_TIMERFD_SETTIME        = 86%0A%09SYS_TIMERFD_GETTIME        = 87%0A%09SYS_UTIMENSAT              = 88%0A%09SYS_ACCT                   = 89%0A%09SYS_CAPGET                 = 90%0A%09SYS_CAPSET                 = 91%0A%09SYS_PERSONALITY            = 92%0A%09SYS_EXIT                   = 93%0A%09SYS_EXIT_GROUP             = 94%0A%09SYS_WAITID                 = 95%0A%09SYS_SET_TID_ADDRESS        = 96%0A%09SYS_UNSHARE                = 97%0A%09SYS_FUTEX                  = 98%0A%09SYS_SET_ROBUST_LIST        = 99%0A%09SYS_GET_ROBUST_LIST        = 100%0A%09SYS_NANOSLEEP              = 101%0A%09SYS_GETITIMER              = 102%0A%09SYS_SETITIMER              = 103%0A%09SYS_KEXEC_LOAD             = 104%0A%09SYS_INIT_MODULE            = 105%0A%09SYS_DELETE_MODULE          = 106%0A%09SYS_TIMER_CREATE           = 107%0A%09SYS_TIMER_GETTIME          = 108%0A%09SYS_TIMER_GETOVERRUN       = 109%0A%09SYS_TIMER_SETTIME          = 110%0A%09SYS_TIMER_DELETE           = 111%0A%09SYS_CLOCK_SETTIME          = 112%0A%09SYS_CLOCK_GETTIME          = 113%0A%09SYS_CLOCK_GETRES           = 114%0A%09SYS_CLOCK_NANOSLEEP        = 115%0A%09SYS_SYSLOG                 = 116%0A%09SYS_PTRACE                 = 117%0A%09SYS_SCHED_SETPARAM         = 118%0A%09SYS_SCHED_SETSCHEDULER     = 119%0A%09SYS_SCHED_GETSCHEDULER     = 120%0A%09SYS_SCHED_GETPARAM         = 121%0A%09SYS_SCHED_SETAFFINITY      = 122%0A%09SYS_SCHED_GETAFFINITY      = 123%0A%09SYS_SCHED_YIELD            = 124%0A%09SYS_SCHED_GET_PRIORITY_MAX = 125%0A%09SYS_SCHED_GET_PRIORITY_MIN = 126%0A%09SYS_SCHED_RR_GET_INTERVAL  = 127%0A%09SYS_RESTART_SYSCALL        = 128%0A%09SYS_KILL                   = 129%0A%09SYS_TKILL                  = 130%0A%09SYS_TGKILL                 = 131%0A%09SYS_SIGALTSTACK            = 132%0A%09SYS_RT_SIGSUSPEND          = 133%0A%09SYS_RT_SIGACTION           = 134%0A%09SYS_RT_SIGPROCMASK         = 135%0A%09SYS_RT_SIGPENDING          = 136%0A%09SYS_RT_SIGTIMEDWAIT        = 137%0A%09SYS_RT_SIGQUEUEINFO        = 138%0A%09SYS_RT_SIGRETURN           = 139%0A%09SYS_SETPRIORITY            = 140%0A%09SYS_GETPRIORITY            = 141%0A%09SYS_REBOOT                 = 142%0A%09SYS_SETREGID               = 143%0A%09SYS_SETGID                 = 144%0A%09SYS_SETREUID               = 145%0A%09SYS_SETUID                 = 146%0A%09SYS_SETRESUID              = 147%0A%09SYS_GETRESUID              = 148%0A%09SYS_SETRESGID              = 149%0A%09SYS_GETRESGID              = 150%0A%09SYS_SETFSUID               = 151%0A%09SYS_SETFSGID               = 152%0A%09SYS_TIMES                  = 153%0A%09SYS_SETPGID                = 154%0A%09SYS_GETPGID                = 155%0A%09SYS_GETSID                 = 156%0A%09SYS_SETSID                 = 157%0A%09SYS_GETGROUPS              = 158%0A%09SYS_SETGROUPS              = 159%0A%09SYS_UNAME                  = 160%0A%09SYS_SETHOSTNAME            = 161%0A%09SYS_SETDOMAINNAME          = 162%0A%09SYS_GETRLIMIT              = 163%0A%09SYS_SETRLIMIT              = 164%0A%09SYS_GETRUSAGE              = 165%0A%09SYS_UMASK                  = 166%0A%09SYS_PRCTL                  = 167%0A%09SYS_GETCPU                 = 168%0A%09SYS_GETTIMEOFDAY           = 169%0A%09SYS_SETTIMEOFDAY           = 170%0A%09SYS_ADJTIMEX               = 171%0A%09SYS_GETPID                 = 172%0A%09SYS_GETPPID                = 173%0A%09SYS_GETUID                 = 174%0A%09SYS_GETEUID                = 175%0A%09SYS_GETGID                 = 176%0A%09SYS_GETEGID                = 177%0A%09SYS_GETTID                 = 178%0A%09SYS_SYSINFO                = 179%0A%09SYS_MQ_OPEN                = 180%0A%09SYS_MQ_UNLINK              = 181%0A%09SYS_MQ_TIMEDSEND           = 182%0A%09SYS_MQ_TIMEDRECEIVE        = 183%0A%09SYS_MQ_NOTIFY              = 184%0A%09SYS_MQ_GETSETATTR          = 185%0A%09SYS_MSGGET                 = 186%0A%09SYS_MSGCTL                 = 187%0A%09SYS_MSGRCV                 = 188%0A%09SYS_MSGSND                 = 189%0A%09SYS_SEMGET                 = 190%0A%09SYS_SEMCTL                 = 191%0A%09SYS_SEMTIMEDOP             = 192%0A%09SYS_SEMOP                  = 193%0A%09SYS_SHMGET                 = 194%0A%09SYS_SHMCTL                 = 195%0A%09SYS_SHMAT                  = 196%0A%09SYS_SHMDT                  = 197%0A%09SYS_SOCKET                 = 198%0A%09SYS_SOCKETPAIR             = 199%0A%09SYS_BIND                   = 200%0A%09SYS_LISTEN                 = 201%0A%09SYS_ACCEPT                 = 202%0A%09SYS_CONNECT                = 203%0A%09SYS_GETSOCKNAME            = 204%0A%09SYS_GETPEERNAME            = 205%0A%09SYS_SENDTO                 = 206%0A%09SYS_RECVFROM               = 207%0A%09SYS_SETSOCKOPT             = 208%0A%09SYS_GETSOCKOPT             = 209%0A%09SYS_SHUTDOWN               = 210%0A%09SYS_SENDMSG                = 211%0A%09SYS_RECVMSG                = 212%0A%09SYS_READAHEAD              = 213%0A%09SYS_BRK                    = 214%0A%09SYS_MUNMAP                 = 215%0A%09SYS_MREMAP                 = 216%0A%09SYS_ADD_KEY                = 217%0A%09SYS_REQUEST_KEY            = 218%0A%09SYS_KEYCTL                 = 219%0A%09SYS_CLONE                  = 220%0A%09SYS_EXECVE                 = 221%0A%09SYS_MMAP                   = 222%0A%09SYS_FADVISE64              = 223%0A%09SYS_SWAPON                 = 224%0A%09SYS_SWAPOFF                = 225%0A%09SYS_MPROTECT               = 226%0A%09SYS_MSYNC                  = 227%0A%09SYS_MLOCK                  = 228%0A%09SYS_MUNLOCK                = 229%0A%09SYS_MLOCKALL               = 230%0A%09SYS_MUNLOCKALL             = 231%0A%09SYS_MINCORE                = 232%0A%09SYS_MADVISE                = 233%0A%09SYS_REMAP_FILE_PAGES       = 234%0A%09SYS_MBIND                  = 235%0A%09SYS_GET_MEMPOLICY          = 236%0A%09SYS_SET_MEMPOLICY          = 237%0A%09SYS_MIGRATE_PAGES          = 238%0A%09SYS_MOVE_PAGES             = 239%0A%09SYS_RT_TGSIGQUEUEINFO      = 240%0A%09SYS_PERF_EVENT_OPEN        = 241%0A%09SYS_ACCEPT4                = 242%0A%09SYS_RECVMMSG               = 243%0A%09SYS_ARCH_SPECIFIC_SYSCALL  = 244%0A%09SYS_WAIT4                  = 260%0A%09SYS_PRLIMIT64              = 261%0A%09SYS_FANOTIFY_INIT          = 262%0A%09SYS_FANOTIFY_MARK          = 263%0A%09SYS_NAME_TO_HANDLE_AT      = 264%0A%09SYS_OPEN_BY_HANDLE_AT      = 265%0A%09SYS_CLOCK_ADJTIME          = 266%0A%09SYS_SYNCFS                 = 267%0A%09SYS_SETNS                  = 268%0A%09SYS_SENDMMSG               = 269%0A%09SYS_PROCESS_VM_READV       = 270%0A%09SYS_PROCESS_VM_WRITEV      = 271%0A%09SYS_KCMP                   = 272%0A%09SYS_FINIT_MODULE           = 273%0A%09SYS_SCHED_SETATTR          = 274%0A%09SYS_SCHED_GETATTR          = 275%0A%09SYS_RENAMEAT2              = 276%0A%09SYS_SECCOMP                = 277%0A%09SYS_GETRANDOM              = 278%0A%09SYS_MEMFD_CREATE           = 279%0A%09SYS_BPF                    = 280%0A%09SYS_EXECVEAT               = 281%0A%09SYS_USERFAULTFD            = 282%0A%09SYS_MEMBARRIER             = 283%0A%09SYS_MLOCK2                 = 284%0A%09SYS_COPY_FILE_RANGE        = 285%0A%09SYS_PREADV2                = 286%0A%09SYS_PWRITEV2               = 287%0A%09SYS_PKEY_MPROTECT          = 288%0A%09SYS_PKEY_ALLOC             = 289%0A%09SYS_PKEY_FREE              = 290%0A%09SYS_STATX                  = 291%0A%09SYS_IO_PGETEVENTS          = 292%0A)%0A
+ f 0e8cf24157dc058fa5b798a1eee53be03371b7637aeaa91b6c618fd1b54921fd vendor/golang.org/x/sys/unix/ztypes_aix_ppc.go
dmppatch 2
@@ -0,0 +1,4836 @@
+// cgo -godefs types_aix.go %7C go run mkpost.go%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build ppc,aix%0A%0Apackage unix%0A%0Aconst (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x3ff%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype off64 int64%0Atype off int32%0Atype Mode_t uint32%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype StTimespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timeval32 struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct%7B%7D%0A%0Atype Time_t int32%0A%0Atype Tms struct%7B%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int32%0A%09Modtime int32%0A%7D%0A%0Atype Timezone struct %7B%0A%09Minuteswest int32%0A%09Dsttime     int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype Pid_t int32%0A%0Atype _Gid_t uint32%0A%0Atype dev_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev      uint32%0A%09Ino      uint32%0A%09Mode     uint32%0A%09Nlink    int16%0A%09Flag     uint16%0A%09Uid      uint32%0A%09Gid      uint32%0A%09Rdev     uint32%0A%09Size     int32%0A%09Atim     StTimespec%0A%09Mtim     StTimespec%0A%09Ctim     StTimespec%0A%09Blksize  int32%0A%09Blocks   int32%0A%09Vfstype  int32%0A%09Vfs      uint32%0A%09Type     uint32%0A%09Gen      uint32%0A%09Reserved %5B9%5Duint32%0A%7D%0A%0Atype StatxTimestamp struct%7B%7D%0A%0Atype Statx_t struct%7B%7D%0A%0Atype Dirent struct %7B%0A%09Offset uint32%0A%09Ino    uint32%0A%09Reclen uint16%0A%09Namlen uint16%0A%09Name   %5B256%5Duint8%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B1023%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Duint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B1012%5Duint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4 = 0x10%0A%09SizeofSockaddrInet6 = 0x1c%0A%09SizeofSockaddrAny   = 0x404%0A%09SizeofSockaddrUnix  = 0x401%0A%09SizeofLinger        = 0x8%0A%09SizeofIPMreq        = 0x8%0A%09SizeofIPv6Mreq      = 0x14%0A%09SizeofIPv6MTUInfo   = 0x20%0A%09SizeofMsghdr        = 0x1c%0A%09SizeofCmsghdr       = 0xc%0A%09SizeofICMPv6Filter  = 0x20%0A)%0A%0Aconst (%0A%09SizeofIfMsghdr = 0x10%0A)%0A%0Atype IfMsgHdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09Addrlen uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B2048%5Dint32%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B32%5Dbyte%0A%09Nodename %5B32%5Dbyte%0A%09Release  %5B32%5Dbyte%0A%09Version  %5B32%5Dbyte%0A%09Machine  %5B32%5Dbyte%0A%7D%0A%0Atype Ustat_t struct%7B%7D%0A%0Atype Sigset_t struct %7B%0A%09Losigs uint32%0A%09Hisigs uint32%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x1%0A%09AT_SYMLINK_NOFOLLOW = 0x1%0A)%0A%0Atype Termios struct %7B%0A%09Iflag uint32%0A%09Oflag uint32%0A%09Cflag uint32%0A%09Lflag uint32%0A%09Cc    %5B16%5Duint8%0A%7D%0A%0Atype Termio struct %7B%0A%09Iflag uint16%0A%09Oflag uint16%0A%09Cflag uint16%0A%09Lflag uint16%0A%09Line  uint8%0A%09Cc    %5B8%5Duint8%0A%09_     %5B1%5Dbyte%0A%7D%0A%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  uint16%0A%09Revents uint16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x4000%0A%09POLLHUP    = 0x2000%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x8000%0A%09POLLOUT    = 0x2%0A%09POLLPRI    = 0x4%0A%09POLLRDBAND = 0x20%0A%09POLLRDNORM = 0x10%0A%09POLLWRBAND = 0x40%0A%09POLLWRNORM = 0x2%0A)%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09Sysid  uint32%0A%09Pid    int32%0A%09Vfs    int32%0A%09Start  int64%0A%09Len    int64%0A%7D%0A%0Atype Fsid_t struct %7B%0A%09Val %5B2%5Duint32%0A%7D%0Atype Fsid64_t struct %7B%0A%09Val %5B2%5Duint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Version   int32%0A%09Type      int32%0A%09Bsize     uint32%0A%09Blocks    uint32%0A%09Bfree     uint32%0A%09Bavail    uint32%0A%09Files     uint32%0A%09Ffree     uint32%0A%09Fsid      Fsid_t%0A%09Vfstype   int32%0A%09Fsize     uint32%0A%09Vfsnumber int32%0A%09Vfsoff    int32%0A%09Vfslen    int32%0A%09Vfsvers   int32%0A%09Fname     %5B32%5Duint8%0A%09Fpack     %5B32%5Duint8%0A%09Name_max  int32%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A
+ f 8c3012bfa2aba2670090c0eeb6e2ca2f359d147a693fa51cf8f8bfc8c0731ca3 vendor/golang.org/x/sys/unix/ztypes_aix_ppc64.go
dmppatch 2
@@ -0,0 +1,4998 @@
+// cgo -godefs types_aix.go %7C go run mkpost.go%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build ppc64,aix%0A%0Apackage unix%0A%0Aconst (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x3ff%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype off64 int64%0Atype off int64%0Atype Mode_t uint32%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype StTimespec struct %7B%0A%09Sec  int64%0A%09Nsec int32%0A%09_    %5B4%5Dbyte%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%09_    %5B4%5Dbyte%0A%7D%0A%0Atype Timeval32 struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct%7B%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct%7B%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Timezone struct %7B%0A%09Minuteswest int32%0A%09Dsttime     int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype Pid_t int32%0A%0Atype _Gid_t uint32%0A%0Atype dev_t uint64%0A%0Atype Stat_t struct %7B%0A%09Dev      uint64%0A%09Ino      uint64%0A%09Mode     uint32%0A%09Nlink    int16%0A%09Flag     uint16%0A%09Uid      uint32%0A%09Gid      uint32%0A%09Rdev     uint64%0A%09Ssize    int32%0A%09_        %5B4%5Dbyte%0A%09Atim     StTimespec%0A%09Mtim     StTimespec%0A%09Ctim     StTimespec%0A%09Blksize  int64%0A%09Blocks   int64%0A%09Vfstype  int32%0A%09Vfs      uint32%0A%09Type     uint32%0A%09Gen      uint32%0A%09Reserved %5B9%5Duint32%0A%09Padto_ll uint32%0A%09Size     int64%0A%7D%0A%0Atype StatxTimestamp struct%7B%7D%0A%0Atype Statx_t struct%7B%7D%0A%0Atype Dirent struct %7B%0A%09Offset uint64%0A%09Ino    uint64%0A%09Reclen uint16%0A%09Namlen uint16%0A%09Name   %5B256%5Duint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B1023%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Duint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B1012%5Duint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09_          %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4 = 0x10%0A%09SizeofSockaddrInet6 = 0x1c%0A%09SizeofSockaddrAny   = 0x404%0A%09SizeofSockaddrUnix  = 0x401%0A%09SizeofLinger        = 0x8%0A%09SizeofIPMreq        = 0x8%0A%09SizeofIPv6Mreq      = 0x14%0A%09SizeofIPv6MTUInfo   = 0x20%0A%09SizeofMsghdr        = 0x30%0A%09SizeofCmsghdr       = 0xc%0A%09SizeofICMPv6Filter  = 0x20%0A)%0A%0Aconst (%0A%09SizeofIfMsghdr = 0x10%0A)%0A%0Atype IfMsgHdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09Addrlen uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B1024%5Dint64%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B32%5Dbyte%0A%09Nodename %5B32%5Dbyte%0A%09Release  %5B32%5Dbyte%0A%09Version  %5B32%5Dbyte%0A%09Machine  %5B32%5Dbyte%0A%7D%0A%0Atype Ustat_t struct%7B%7D%0A%0Atype Sigset_t struct %7B%0A%09Set %5B4%5Duint64%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x1%0A%09AT_SYMLINK_NOFOLLOW = 0x1%0A)%0A%0Atype Termios struct %7B%0A%09Iflag uint32%0A%09Oflag uint32%0A%09Cflag uint32%0A%09Lflag uint32%0A%09Cc    %5B16%5Duint8%0A%7D%0A%0Atype Termio struct %7B%0A%09Iflag uint16%0A%09Oflag uint16%0A%09Cflag uint16%0A%09Lflag uint16%0A%09Line  uint8%0A%09Cc    %5B8%5Duint8%0A%09_     %5B1%5Dbyte%0A%7D%0A%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  uint16%0A%09Revents uint16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x4000%0A%09POLLHUP    = 0x2000%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x8000%0A%09POLLOUT    = 0x2%0A%09POLLPRI    = 0x4%0A%09POLLRDBAND = 0x20%0A%09POLLRDNORM = 0x10%0A%09POLLWRBAND = 0x40%0A%09POLLWRNORM = 0x2%0A)%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09Sysid  uint32%0A%09Pid    int32%0A%09Vfs    int32%0A%09Start  int64%0A%09Len    int64%0A%7D%0A%0Atype Fsid_t struct %7B%0A%09Val %5B2%5Duint32%0A%7D%0Atype Fsid64_t struct %7B%0A%09Val %5B2%5Duint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Version   int32%0A%09Type      int32%0A%09Bsize     uint64%0A%09Blocks    uint64%0A%09Bfree     uint64%0A%09Bavail    uint64%0A%09Files     uint64%0A%09Ffree     uint64%0A%09Fsid      Fsid64_t%0A%09Vfstype   int32%0A%09_         %5B4%5Dbyte%0A%09Fsize     uint64%0A%09Vfsnumber int32%0A%09Vfsoff    int32%0A%09Vfslen    int32%0A%09Vfsvers   int32%0A%09Fname     %5B32%5Duint8%0A%09Fpack     %5B32%5Duint8%0A%09Name_max  int32%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A
- f 66c5b6368e2491f2834b4f467bc5a42a23429014e01b1681e285a07c7bbb324f vendor/golang.org/x/sys/unix/ztypes_darwin_386.go
+ f 5e218c18904e344d116f5b9296021240f4835e7b5d9d9069f5281aff070cec8a vendor/golang.org/x/sys/unix/ztypes_darwin_386.go
dmppatch 7
@@ -148,16 +148,6505 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timeval32 struct%7B%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           int32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Ino           uint64%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          int32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Qspare        %5B2%5Dint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Bsize       uint32%0A%09Iosize      int32%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      uint64%0A%09Files       uint64%0A%09Ffree       uint64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        uint32%0A%09Flags       uint32%0A%09Fssubtype   uint32%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B1024%5Dint8%0A%09Mntfromname %5B1024%5Dint8%0A%09Reserved    %5B8%5Duint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Fstore_t struct %7B%0A%09Flags      uint32%0A%09Posmode    int32%0A%09Offset     int64%0A%09Length     int64%0A%09Bytesalloc int64%0A%7D%0A%0Atype Radvisory_t struct %7B%0A%09Offset int64%0A%09Count  int32%0A%7D%0A%0Atype Fbootstraptransfer_t struct %7B%0A%09Offset int64%0A%09Length uint32%0A%09Buffer *byte%0A%7D%0A%0Atype Log2phys_t struct %7B%0A%09Flags       uint32%0A%09Contigbytes int64%0A%09Devoffset   int64%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino     uint64%0A%09Seekoff uint64%0A%09Reclen  uint16%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Name    %5B1024%5Dint8%0A%09_       %5B3%5Dbyte%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet4Pktinfo     = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int32%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr    = 0x70%0A%09SizeofIfData      = 0x60%0A%09SizeofIfaMsghdr   = 0x14%0A%09SizeofIfmaMsghdr  = 0x10%0A%09SizeofIfmaMsghdr2 = 0x14%0A%09SizeofRtMsghdr    = 0x5c%0A%09SizeofRtMetrics   = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Typelen    uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09Unused1    uint8%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Recvtiming uint32%0A%09Xmittiming uint32%0A%09Lastchange Timeval%0A%09Unused2    uint32%0A%09Hwassist   uint32%0A%09Reserved1  uint32%0A%09Reserved2  uint32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfmaMsghdr2 struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Index    uint16%0A%09_        %5B2%5Dbyte%0A%09Refcount int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   int32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Filler   %5B4%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type Ter
@@ -6761,16 +6761,615 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x80%0A%09AT_SYMLINK_FOLLOW   = 0x40%0A%09AT_SYMLINK_NOFOLLOW = 0x20%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 0c049d1477747a54edeee042cd137a4caf47bb7496034e763abf3e24fdd2264a vendor/golang.org/x/sys/unix/ztypes_darwin_amd64.go
+ f 6483678e2d3a6ba3f5abcde6765e144a9a7eb55269398fcdbd652c68c8e7ec06 vendor/golang.org/x/sys/unix/ztypes_darwin_amd64.go
dmppatch 7
@@ -150,16 +150,6630 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%09_    %5B4%5Dbyte%0A%7D%0A%0Atype Timeval32 struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           int32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Ino           uint64%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          int32%0A%09_             %5B4%5Dbyte%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Qspare        %5B2%5Dint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Bsize       uint32%0A%09Iosize      int32%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      uint64%0A%09Files       uint64%0A%09Ffree       uint64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        uint32%0A%09Flags       uint32%0A%09Fssubtype   uint32%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B1024%5Dint8%0A%09Mntfromname %5B1024%5Dint8%0A%09Reserved    %5B8%5Duint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Fstore_t struct %7B%0A%09Flags      uint32%0A%09Posmode    int32%0A%09Offset     int64%0A%09Length     int64%0A%09Bytesalloc int64%0A%7D%0A%0Atype Radvisory_t struct %7B%0A%09Offset int64%0A%09Count  int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype Fbootstraptransfer_t struct %7B%0A%09Offset int64%0A%09Length uint64%0A%09Buffer *byte%0A%7D%0A%0Atype Log2phys_t struct %7B%0A%09Flags uint32%0A%09_     %5B8%5Dbyte%0A%09_     %5B8%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino     uint64%0A%09Seekoff uint64%0A%09Reclen  uint16%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Name    %5B1024%5Dint8%0A%09_       %5B3%5Dbyte%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09_          %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet4Pktinfo     = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr    = 0x70%0A%09SizeofIfData      = 0x60%0A%09SizeofIfaMsghdr   = 0x14%0A%09SizeofIfmaMsghdr  = 0x10%0A%09SizeofIfmaMsghdr2 = 0x14%0A%09SizeofRtMsghdr    = 0x5c%0A%09SizeofRtMetrics   = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Typelen    uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09Unused1    uint8%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Recvtiming uint32%0A%09Xmittiming uint32%0A%09Lastchange Timeval32%0A%09Unused2    uint32%0A%09Hwassist   uint32%0A%09Reserved1  uint32%0A%09Reserved2  uint32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfmaMsghdr2 struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Index    uint16%0A%09_        %5B2%5Dbyte%0A%09Refcount int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   int32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Filler   %5B4%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09_     %5B4%5Dbyte%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval32%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type Ter
@@ -6904,16 +6904,615 @@
 Ospeed uint64%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x80%0A%09AT_SYMLINK_FOLLOW   = 0x40%0A%09AT_SYMLINK_NOFOLLOW = 0x20%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 4d4e958875de6183262488a70912a2ce25455aec2279d46a87d70715fd2fc95d vendor/golang.org/x/sys/unix/ztypes_darwin_arm.go
+ f 468b0b07c951e3f809c05031f5a14906990f587e398752bc28b4056fe487c895 vendor/golang.org/x/sys/unix/ztypes_darwin_arm.go
dmppatch 7
@@ -167,16 +167,6504 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timeval32 %5B0%5Dbyte%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           int32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Ino           uint64%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          int32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Qspare        %5B2%5Dint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Bsize       uint32%0A%09Iosize      int32%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      uint64%0A%09Files       uint64%0A%09Ffree       uint64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        uint32%0A%09Flags       uint32%0A%09Fssubtype   uint32%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B1024%5Dint8%0A%09Mntfromname %5B1024%5Dint8%0A%09Reserved    %5B8%5Duint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Fstore_t struct %7B%0A%09Flags      uint32%0A%09Posmode    int32%0A%09Offset     int64%0A%09Length     int64%0A%09Bytesalloc int64%0A%7D%0A%0Atype Radvisory_t struct %7B%0A%09Offset int64%0A%09Count  int32%0A%7D%0A%0Atype Fbootstraptransfer_t struct %7B%0A%09Offset int64%0A%09Length uint32%0A%09Buffer *byte%0A%7D%0A%0Atype Log2phys_t struct %7B%0A%09Flags       uint32%0A%09Contigbytes int64%0A%09Devoffset   int64%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino     uint64%0A%09Seekoff uint64%0A%09Reclen  uint16%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Name    %5B1024%5Dint8%0A%09_       %5B3%5Dbyte%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet4Pktinfo     = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int32%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr    = 0x70%0A%09SizeofIfData      = 0x60%0A%09SizeofIfaMsghdr   = 0x14%0A%09SizeofIfmaMsghdr  = 0x10%0A%09SizeofIfmaMsghdr2 = 0x14%0A%09SizeofRtMsghdr    = 0x5c%0A%09SizeofRtMetrics   = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Typelen    uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09Unused1    uint8%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Recvtiming uint32%0A%09Xmittiming uint32%0A%09Lastchange Timeval%0A%09Unused2    uint32%0A%09Hwassist   uint32%0A%09Reserved1  uint32%0A%09Reserved2  uint32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfmaMsghdr2 struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Index    uint16%0A%09_        %5B2%5Dbyte%0A%09Refcount int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   int32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Filler   %5B4%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type Ter
@@ -6779,16 +6779,615 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x80%0A%09AT_SYMLINK_FOLLOW   = 0x40%0A%09AT_SYMLINK_NOFOLLOW = 0x20%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f fafabf2c64593962b255e0b9fe0bb9d1b14ec98d059b991b24de517fed4d4b19 vendor/golang.org/x/sys/unix/ztypes_darwin_arm64.go
+ f 261a92bf614f55dba2ce100be26e0315141ba4ef9f077bd8cd5b53521ff76ac2 vendor/golang.org/x/sys/unix/ztypes_darwin_arm64.go
dmppatch 7
@@ -150,16 +150,6630 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%09_    %5B4%5Dbyte%0A%7D%0A%0Atype Timeval32 struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           int32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Ino           uint64%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          int32%0A%09_             %5B4%5Dbyte%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Qspare        %5B2%5Dint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Bsize       uint32%0A%09Iosize      int32%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      uint64%0A%09Files       uint64%0A%09Ffree       uint64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        uint32%0A%09Flags       uint32%0A%09Fssubtype   uint32%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B1024%5Dint8%0A%09Mntfromname %5B1024%5Dint8%0A%09Reserved    %5B8%5Duint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Fstore_t struct %7B%0A%09Flags      uint32%0A%09Posmode    int32%0A%09Offset     int64%0A%09Length     int64%0A%09Bytesalloc int64%0A%7D%0A%0Atype Radvisory_t struct %7B%0A%09Offset int64%0A%09Count  int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype Fbootstraptransfer_t struct %7B%0A%09Offset int64%0A%09Length uint64%0A%09Buffer *byte%0A%7D%0A%0Atype Log2phys_t struct %7B%0A%09Flags uint32%0A%09_     %5B8%5Dbyte%0A%09_     %5B8%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino     uint64%0A%09Seekoff uint64%0A%09Reclen  uint16%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Name    %5B1024%5Dint8%0A%09_       %5B3%5Dbyte%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09_          %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  uint32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet4Pktinfo     = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr    = 0x70%0A%09SizeofIfData      = 0x60%0A%09SizeofIfaMsghdr   = 0x14%0A%09SizeofIfmaMsghdr  = 0x10%0A%09SizeofIfmaMsghdr2 = 0x14%0A%09SizeofRtMsghdr    = 0x5c%0A%09SizeofRtMetrics   = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Typelen    uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09Unused1    uint8%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Recvtiming uint32%0A%09Xmittiming uint32%0A%09Lastchange Timeval32%0A%09Unused2    uint32%0A%09Hwassist   uint32%0A%09Reserved1  uint32%0A%09Reserved2  uint32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfmaMsghdr2 struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Index    uint16%0A%09_        %5B2%5Dbyte%0A%09Refcount int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   int32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Filler   %5B4%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09_     %5B4%5Dbyte%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval32%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type Ter
@@ -6904,16 +6904,615 @@
 Ospeed uint64%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x2%0A%09AT_REMOVEDIR        = 0x80%0A%09AT_SYMLINK_FOLLOW   = 0x40%0A%09AT_SYMLINK_NOFOLLOW = 0x20%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 5d91ef2d147e6a8eba36b9961f9b0b1863d020abf4d7b44eb8ec68010eefb9ea vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go
+ f 7baad73fa07a897c21b84ad22bddab1b5671d8a81295b47f52dd76042a479181 vendor/golang.org/x/sys/unix/ztypes_dragonfly_amd64.go
dmppatch 7
@@ -156,16 +156,6193 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur int64%0A%09Max int64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Ino      uint64%0A%09Nlink    uint32%0A%09Dev      uint32%0A%09Mode     uint16%0A%09Padding1 uint16%0A%09Uid      uint32%0A%09Gid      uint32%0A%09Rdev     uint32%0A%09Atim     Timespec%0A%09Mtim     Timespec%0A%09Ctim     Timespec%0A%09Size     int64%0A%09Blocks   int64%0A%09Blksize  uint32%0A%09Flags    uint32%0A%09Gen      uint32%0A%09Lspare   int32%0A%09Qspare1  int64%0A%09Qspare2  int64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Spare2      int64%0A%09Bsize       int64%0A%09Iosize      int64%0A%09Blocks      int64%0A%09Bfree       int64%0A%09Bavail      int64%0A%09Files       int64%0A%09Ffree       int64%0A%09Fsid        Fsid%0A%09Owner       uint32%0A%09Type        int32%0A%09Flags       int32%0A%09_           %5B4%5Dbyte%0A%09Syncwrites  int64%0A%09Asyncwrites int64%0A%09Fstypename  %5B16%5Dint8%0A%09Mntonname   %5B80%5Dint8%0A%09Syncreads   int64%0A%09Asyncreads  int64%0A%09Spares1     int16%0A%09Mntfromname %5B80%5Dint8%0A%09Spares2     int16%0A%09_           %5B4%5Dbyte%0A%09Spare       %5B2%5Dint64%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno  uint64%0A%09Namlen  uint16%0A%09Type    uint8%0A%09Unused1 uint8%0A%09Unused2 uint32%0A%09Name    %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%09Rcf    uint16%0A%09Route  %5B16%5Duint16%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09_          %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x36%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Duint64%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0xb0%0A%09SizeofIfData           = 0xa0%0A%09SizeofIfaMsghdr        = 0x14%0A%09SizeofIfmaMsghdr       = 0x10%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x98%0A%09SizeofRtMetrics        = 0x70%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Physical   uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Recvquota  uint8%0A%09Xmitquota  uint8%0A%09_          %5B2%5Dbyte%0A%09Mtu        uint64%0A%09Metric     uint64%0A%09Link_state uint64%0A%09Baudrate   uint64%0A%09Ipackets   uint64%0A%09Ierrors    uint64%0A%09Opackets   uint64%0A%09Oerrors    uint64%0A%09Collisions uint64%0A%09Ibytes     uint64%0A%09Obytes     uint64%0A%09Imcasts    uint64%0A%09Omcasts    uint64%0A%09Iqdrops    uint64%0A%09Noproto    uint64%0A%09Hwassist   uint64%0A%09Oqdrops    uint64%0A%09Lastchange Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint64%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks     uint64%0A%09Mtu       uint64%0A%09Pksent    uint64%0A%09Expire    uint64%0A%09Sendpipe  uint64%0A%09Ssthresh  uint64%0A%09Rtt       uint64%0A%09Rttvar    uint64%0A%09Recvpipe  uint64%0A%09Hopcount  uint64%0A%09Mssopt    uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Msl       uint64%0A%09Iwmaxsegs uint64%0A%09Iwcapsegs uint64%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09_     %5B4%5Dbyte%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  Timeval%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B6%5Dbyte%0A%7D%0A%0A
 type Ter
@@ -6457,16 +6457,559 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = 0xfffafdcd%0A%09AT_SYMLINK_NOFOLLOW = 0x1%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B32%5Dbyte%0A%09Nodename %5B32%5Dbyte%0A%09Release  %5B32%5Dbyte%0A%09Version  %5B32%5Dbyte%0A%09Machine  %5B32%5Dbyte%0A%7D%0A
- f f420dd85139327c42867044c11d9d1ffbf96fcdedb1a573b7e58e78bbd0ddf65 vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
+ f 3b1e7fd614d435fe0b47bc9201c7572f4de150837a4d2e041905998245108fce vendor/golang.org/x/sys/unix/ztypes_freebsd_386.go
dmppatch 7
@@ -150,16 +150,7612 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur int64%0A%09Max int64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           uint32%0A%09Ino           uint32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          uint32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Birthtimespec Timespec%0A%09Pad_cgo_0     %5B8%5Dbyte%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Version     uint32%0A%09Type        uint32%0A%09Flags       uint64%0A%09Bsize       uint64%0A%09Iosize      uint64%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      int64%0A%09Files       uint64%0A%09Ffree       int64%0A%09Syncwrites  uint64%0A%09Asyncwrites uint64%0A%09Syncreads   uint64%0A%09Asyncreads  uint64%0A%09Spare       %5B10%5Duint64%0A%09Namemax     uint32%0A%09Owner       uint32%0A%09Fsid        Fsid%0A%09Charspare   %5B80%5Dint8%0A%09Fstypename  %5B16%5Dint8%0A%09Mntfromname %5B88%5Dint8%0A%09Mntonname   %5B88%5Dint8%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%09Sysid  int32%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno uint32%0A%09Reclen uint16%0A%09Type   uint8%0A%09Namlen uint8%0A%09Name   %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B46%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x36%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPMreqn          = 0xc%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int32%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09X__fds_bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09sizeofIfMsghdr         = 0xa8%0A%09SizeofIfMsghdr         = 0x60%0A%09sizeofIfData           = 0x98%0A%09SizeofIfData           = 0x50%0A%09SizeofIfaMsghdr        = 0x14%0A%09SizeofIfmaMsghdr       = 0x10%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x5c%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype ifMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      ifData%0A%7D%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype ifData struct %7B%0A%09Type              uint8%0A%09Physical          uint8%0A%09Addrlen           uint8%0A%09Hdrlen            uint8%0A%09Link_state        uint8%0A%09Vhid              uint8%0A%09Datalen           uint16%0A%09Mtu               uint32%0A%09Metric            uint32%0A%09Baudrate          uint64%0A%09Ipackets          uint64%0A%09Ierrors           uint64%0A%09Opackets          uint64%0A%09Oerrors           uint64%0A%09Collisions        uint64%0A%09Ibytes            uint64%0A%09Obytes            uint64%0A%09Imcasts           uint64%0A%09Omcasts           uint64%0A%09Iqdrops           uint64%0A%09Oqdrops           uint64%0A%09Noproto           uint64%0A%09Hwassist          uint64%0A%09X__ifi_epoch      %5B8%5Dbyte%0A%09X__ifi_lastchange %5B16%5Dbyte%0A%7D%0A%0Atype IfData struct %7B%0A%09Type        uint8%0A%09Physical    uint8%0A%09Addrlen     uint8%0A%09Hdrlen      uint8%0A%09Link_state  uint8%0A%09Spare_char1 uint8%0A%09Spare_char2 uint8%0A%09Datalen     uint8%0A%09Mtu         uint32%0A%09Metric      uint32%0A%09Baudrate    uint32%0A%09Ipackets    uint32%0A%09Ierrors     uint32%0A%09Opackets    uint32%0A%09Oerrors     uint32%0A%09Collisions  uint32%0A%09Ibytes      uint32%0A%09Obytes      uint32%0A%09Imcasts     uint32%0A%09Omcasts     uint32%0A%09Iqdrops     uint32%0A%09Noproto     uint32%0A%09Hwassist    uint32%0A%09Epoch       int32%0A%09Lastchange  Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Metric    int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Fmask     int32%0A%09Inits     uint32%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Weight   uint32%0A%09Filler   %5B3%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion    = 0x4%0A%09SizeofBpfStat       = 0x8%0A%09SizeofBpfZbuf       = 0xc%0A%09SizeofBpfProgram    = 0x8%0A%09SizeofBpfInsn       = 0x8%0A%09SizeofBpfHdr        = 0x14%0A%09SizeofBpfZbufHeader = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfZbuf struct %7B%0A%09Bufa   *byte%0A%09Bufb   *byte%0A%09Buflen uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    Timeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfZbufHeader struct %7B%0A%09Kernel_gen uint32%0A%09Kernel_len uint32%0A%09User_gen   uint32%0A%09X_bzh_pad  %5B5%5Duint32%0A%7D%0A%0A
 type Ter
@@ -7870,16 +7870,707 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_REMOVEDIR        = 0x800%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR      = 0x8%0A%09POLLHUP      = 0x10%0A%09POLLIN       = 0x1%0A%09POLLINIGNEOF = 0x2000%0A%09POLLNVAL     = 0x20%0A%09POLLOUT      = 0x4%0A%09POLLPRI      = 0x2%0A%09POLLRDBAND   = 0x80%0A%09POLLRDNORM   = 0x40%0A%09POLLWRBAND   = 0x100%0A%09POLLWRNORM   = 0x4%0A)%0A%0Atype CapRights struct %7B%0A%09Rights %5B2%5Duint64%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 58a0acc4efe257638d4ca7cecdb28e895c2e654cf94926711af23e2139b2b57d vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
+ f d399ae42d116a73252fda989dd8e1fd159151f348de43156867a8b5dd47c6159 vendor/golang.org/x/sys/unix/ztypes_freebsd_amd64.go
dmppatch 7
@@ -152,16 +152,7695 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur int64%0A%09Max int64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           uint32%0A%09Ino           uint32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          uint32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Birthtimespec Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Version     uint32%0A%09Type        uint32%0A%09Flags       uint64%0A%09Bsize       uint64%0A%09Iosize      uint64%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      int64%0A%09Files       uint64%0A%09Ffree       int64%0A%09Syncwrites  uint64%0A%09Asyncwrites uint64%0A%09Syncreads   uint64%0A%09Asyncreads  uint64%0A%09Spare       %5B10%5Duint64%0A%09Namemax     uint32%0A%09Owner       uint32%0A%09Fsid        Fsid%0A%09Charspare   %5B80%5Dint8%0A%09Fstypename  %5B16%5Dint8%0A%09Mntfromname %5B88%5Dint8%0A%09Mntonname   %5B88%5Dint8%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start     int64%0A%09Len       int64%0A%09Pid       int32%0A%09Type      int16%0A%09Whence    int16%0A%09Sysid     int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno uint32%0A%09Reclen uint16%0A%09Type   uint8%0A%09Namlen uint8%0A%09Name   %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B46%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Pad_cgo_0  %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Pad_cgo_1  %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x36%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPMreqn          = 0xc%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09X__fds_bits %5B16%5Duint64%0A%7D%0A%0Aconst (%0A%09sizeofIfMsghdr         = 0xa8%0A%09SizeofIfMsghdr         = 0xa8%0A%09sizeofIfData           = 0x98%0A%09SizeofIfData           = 0x98%0A%09SizeofIfaMsghdr        = 0x14%0A%09SizeofIfmaMsghdr       = 0x10%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x98%0A%09SizeofRtMetrics        = 0x70%0A)%0A%0Atype ifMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      ifData%0A%7D%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype ifData struct %7B%0A%09Type              uint8%0A%09Physical          uint8%0A%09Addrlen           uint8%0A%09Hdrlen            uint8%0A%09Link_state        uint8%0A%09Vhid              uint8%0A%09Datalen           uint16%0A%09Mtu               uint32%0A%09Metric            uint32%0A%09Baudrate          uint64%0A%09Ipackets          uint64%0A%09Ierrors           uint64%0A%09Opackets          uint64%0A%09Oerrors           uint64%0A%09Collisions        uint64%0A%09Ibytes            uint64%0A%09Obytes            uint64%0A%09Imcasts           uint64%0A%09Omcasts           uint64%0A%09Iqdrops           uint64%0A%09Oqdrops           uint64%0A%09Noproto           uint64%0A%09Hwassist          uint64%0A%09X__ifi_epoch      %5B8%5Dbyte%0A%09X__ifi_lastchange %5B16%5Dbyte%0A%7D%0A%0Atype IfData struct %7B%0A%09Type        uint8%0A%09Physical    uint8%0A%09Addrlen     uint8%0A%09Hdrlen      uint8%0A%09Link_state  uint8%0A%09Spare_char1 uint8%0A%09Spare_char2 uint8%0A%09Datalen     uint8%0A%09Mtu         uint64%0A%09Metric      uint64%0A%09Baudrate    uint64%0A%09Ipackets    uint64%0A%09Ierrors     uint64%0A%09Opackets    uint64%0A%09Oerrors     uint64%0A%09Collisions  uint64%0A%09Ibytes      uint64%0A%09Obytes      uint64%0A%09Imcasts     uint64%0A%09Omcasts     uint64%0A%09Iqdrops     uint64%0A%09Noproto     uint64%0A%09Hwassist    uint64%0A%09Epoch       int64%0A%09Lastchange  Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Metric    int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Fmask     int32%0A%09Inits     uint64%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint64%0A%09Mtu      uint64%0A%09Hopcount uint64%0A%09Expire   uint64%0A%09Recvpipe uint64%0A%09Sendpipe uint64%0A%09Ssthresh uint64%0A%09Rtt      uint64%0A%09Rttvar   uint64%0A%09Pksent   uint64%0A%09Weight   uint64%0A%09Filler   %5B3%5Duint64%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion    = 0x4%0A%09SizeofBpfStat       = 0x8%0A%09SizeofBpfZbuf       = 0x18%0A%09SizeofBpfProgram    = 0x10%0A%09SizeofBpfInsn       = 0x8%0A%09SizeofBpfHdr        = 0x20%0A%09SizeofBpfZbufHeader = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfZbuf struct %7B%0A%09Bufa   *byte%0A%09Bufb   *byte%0A%09Buflen uint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len       uint32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Insns     *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    Timeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype BpfZbufHeader struct %7B%0A%09Kernel_gen uint32%0A%09Kernel_len uint32%0A%09User_gen   uint32%0A%09X_bzh_pad  %5B5%5Duint32%0A%7D%0A%0A
 type Ter
@@ -7955,16 +7955,707 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_REMOVEDIR        = 0x800%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR      = 0x8%0A%09POLLHUP      = 0x10%0A%09POLLIN       = 0x1%0A%09POLLINIGNEOF = 0x2000%0A%09POLLNVAL     = 0x20%0A%09POLLOUT      = 0x4%0A%09POLLPRI      = 0x2%0A%09POLLRDBAND   = 0x80%0A%09POLLRDNORM   = 0x40%0A%09POLLWRBAND   = 0x100%0A%09POLLWRNORM   = 0x4%0A)%0A%0Atype CapRights struct %7B%0A%09Rights %5B2%5Duint64%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 095e31e7a1b6fd94d4bfd5c4e3a34aa8c06c6b7fa4f35ffc3f496afb5466f092 vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
+ f a636fec65795dc29c9770fbea3aa383dfe5b2cda6f2b043932f3d471abf45228 vendor/golang.org/x/sys/unix/ztypes_freebsd_arm.go
dmppatch 7
@@ -167,16 +167,7705 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec       int64%0A%09Nsec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec       int64%0A%09Usec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur int64%0A%09Max int64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           uint32%0A%09Ino           uint32%0A%09Mode          uint16%0A%09Nlink         uint16%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          uint32%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       int32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Lspare        int32%0A%09Birthtimespec Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Version     uint32%0A%09Type        uint32%0A%09Flags       uint64%0A%09Bsize       uint64%0A%09Iosize      uint64%0A%09Blocks      uint64%0A%09Bfree       uint64%0A%09Bavail      int64%0A%09Files       uint64%0A%09Ffree       int64%0A%09Syncwrites  uint64%0A%09Asyncwrites uint64%0A%09Syncreads   uint64%0A%09Asyncreads  uint64%0A%09Spare       %5B10%5Duint64%0A%09Namemax     uint32%0A%09Owner       uint32%0A%09Fsid        Fsid%0A%09Charspare   %5B80%5Dint8%0A%09Fstypename  %5B16%5Dint8%0A%09Mntfromname %5B88%5Dint8%0A%09Mntonname   %5B88%5Dint8%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start     int64%0A%09Len       int64%0A%09Pid       int32%0A%09Type      int16%0A%09Whence    int16%0A%09Sysid     int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno uint32%0A%09Reclen uint16%0A%09Type   uint8%0A%09Namlen uint8%0A%09Name   %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B46%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x36%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPMreqn          = 0xc%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int32%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09X__fds_bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09sizeofIfMsghdr         = 0xa8%0A%09SizeofIfMsghdr         = 0x70%0A%09sizeofIfData           = 0x98%0A%09SizeofIfData           = 0x60%0A%09SizeofIfaMsghdr        = 0x14%0A%09SizeofIfmaMsghdr       = 0x10%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x5c%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype ifMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      ifData%0A%7D%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype ifData struct %7B%0A%09Type              uint8%0A%09Physical          uint8%0A%09Addrlen           uint8%0A%09Hdrlen            uint8%0A%09Link_state        uint8%0A%09Vhid              uint8%0A%09Datalen           uint16%0A%09Mtu               uint32%0A%09Metric            uint32%0A%09Baudrate          uint64%0A%09Ipackets          uint64%0A%09Ierrors           uint64%0A%09Opackets          uint64%0A%09Oerrors           uint64%0A%09Collisions        uint64%0A%09Ibytes            uint64%0A%09Obytes            uint64%0A%09Imcasts           uint64%0A%09Omcasts           uint64%0A%09Iqdrops           uint64%0A%09Oqdrops           uint64%0A%09Noproto           uint64%0A%09Hwassist          uint64%0A%09X__ifi_epoch      %5B8%5Dbyte%0A%09X__ifi_lastchange %5B16%5Dbyte%0A%7D%0A%0Atype IfData struct %7B%0A%09Type        uint8%0A%09Physical    uint8%0A%09Addrlen     uint8%0A%09Hdrlen      uint8%0A%09Link_state  uint8%0A%09Spare_char1 uint8%0A%09Spare_char2 uint8%0A%09Datalen     uint8%0A%09Mtu         uint32%0A%09Metric      uint32%0A%09Baudrate    uint32%0A%09Ipackets    uint32%0A%09Ierrors     uint32%0A%09Opackets    uint32%0A%09Oerrors     uint32%0A%09Collisions  uint32%0A%09Ibytes      uint32%0A%09Obytes      uint32%0A%09Imcasts     uint32%0A%09Omcasts     uint32%0A%09Iqdrops     uint32%0A%09Noproto     uint32%0A%09Hwassist    uint32%0A%09Pad_cgo_0   %5B4%5Dbyte%0A%09Epoch       int64%0A%09Lastchange  Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Metric    int32%0A%7D%0A%0Atype IfmaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Fmask     int32%0A%09Inits     uint32%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%09Weight   uint32%0A%09Filler   %5B3%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion    = 0x4%0A%09SizeofBpfStat       = 0x8%0A%09SizeofBpfZbuf       = 0xc%0A%09SizeofBpfProgram    = 0x8%0A%09SizeofBpfInsn       = 0x8%0A%09SizeofBpfHdr        = 0x20%0A%09SizeofBpfZbufHeader = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfZbuf struct %7B%0A%09Bufa   *byte%0A%09Bufb   *byte%0A%09Buflen uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    Timeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype BpfZbufHeader struct %7B%0A%09Kernel_gen uint32%0A%09Kernel_len uint32%0A%09User_gen   uint32%0A%09X_bzh_pad  %5B5%5Duint32%0A%7D%0A%0A
 type Ter
@@ -7980,16 +7980,707 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_REMOVEDIR        = 0x800%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR      = 0x8%0A%09POLLHUP      = 0x10%0A%09POLLIN       = 0x1%0A%09POLLINIGNEOF = 0x2000%0A%09POLLNVAL     = 0x20%0A%09POLLOUT      = 0x4%0A%09POLLPRI      = 0x2%0A%09POLLRDBAND   = 0x80%0A%09POLLRDNORM   = 0x40%0A%09POLLWRBAND   = 0x100%0A%09POLLWRNORM   = 0x4%0A)%0A%0Atype CapRights struct %7B%0A%09Rights %5B2%5Duint64%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 7feeb508303d931abeccf65862134a797cbd60b0824736980c56e3a44a5be1c1 vendor/golang.org/x/sys/unix/ztypes_linux_386.go
+ f 125e0f346d13cbda63f4c6fe7c40be2380cb4ebc3767137e2f7569ea2fa6b3ba vendor/golang.org/x/sys/unix/ztypes_linux_386.go
dmppatch 7
@@ -191,16 +191,13519 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Offset    int32%0A%09Freq      int32%0A%09Maxerror  int32%0A%09Esterror  int32%0A%09Status    int32%0A%09Constant  int32%0A%09Precision int32%0A%09Tolerance int32%0A%09Time      Timeval%0A%09Tick      int32%0A%09Ppsfreq   int32%0A%09Jitter    int32%0A%09Shift     int32%0A%09Stabil    int32%0A%09Jitcnt    int32%0A%09Calcnt    int32%0A%09Errcnt    int32%0A%09Stbcnt    int32%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int32%0A%0Atype Tms struct %7B%0A%09Utime  int32%0A%09Stime  int32%0A%09Cutime int32%0A%09Cstime int32%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int32%0A%09Modtime int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09_       uint16%0A%09_       %5B2%5Dbyte%0A%09_       uint32%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint64%0A%09_       uint16%0A%09_       %5B2%5Dbyte%0A%09Size    int64%0A%09Blksize int32%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Ino     uint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B1%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x1c%0A%09SizeofCmsghdr           = 0xc%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x8%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B2%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Ebx      int32%0A%09Ecx      int32%0A%09Edx      int32%0A%09Esi      int32%0A%09Edi      int32%0A%09Ebp      int32%0A%09Eax      int32%0A%09Xds      int32%0A%09Xes      int32%0A%09Xfs      int32%0A%09Xgs      int32%0A%09Orig_eax int32%0A%09Eip      int32%0A%09Xcs      int32%0A%09Eflags   int32%0A%09Esp      int32%0A%09Xss      int32%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int32%0A%09Loads     %5B3%5Duint32%0A%09Totalram  uint32%0A%09Freeram   uint32%0A%09Sharedram uint32%0A%09Bufferram uint32%0A%09Totalswap uint32%0A%09Freeswap  uint32%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Totalhigh uint32%0A%09Freehigh  uint32%0A%09Unit      uint32%0A%09_         %5B8%5Dint8%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09Tinode uint32%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B32%5Duint32%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -13832,16 +13832,34886 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint32%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x20%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B122%5Dint8%0A%09_      uint32%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09Start     uint32%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int32%0A%09Bsize   int32%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int32%0A%09Frsize  int32%0A%09Flags   int32%0A%09Spare   %5B4%5Dint32%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint32%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x18%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int32%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x1269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f 9a7260bb083b7fcdbff2f85f5f10f6d9918b83907c4f5c692685e0dcbff925b6 vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go
+ f 90330c2b56f530a5dbf5287e570e415a5a5566538645d599bb195df75d37f2ea vendor/golang.org/x/sys/unix/ztypes_linux_amd64.go
dmppatch 7
@@ -193,16 +193,13859 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Nlink   uint64%0A%09Mode    uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09_       int32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Blksize int64%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09_       %5B3%5Dint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09R15      uint64%0A%09R14      uint64%0A%09R13      uint64%0A%09R12      uint64%0A%09Rbp      uint64%0A%09Rbx      uint64%0A%09R11      uint64%0A%09R10      uint64%0A%09R9       uint64%0A%09R8       uint64%0A%09Rax      uint64%0A%09Rcx      uint64%0A%09Rdx      uint64%0A%09Rsi      uint64%0A%09Rdi      uint64%0A%09Orig_rax uint64%0A%09Rip      uint64%0A%09Cs       uint64%0A%09Eflags   uint64%0A%09Rsp      uint64%0A%09Ss       uint64%0A%09Fs_base  uint64%0A%09Gs_base  uint64%0A%09Ds       uint64%0A%09Es       uint64%0A%09Fs       uint64%0A%09Gs       uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -14174,16 +14174,34956 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int64%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09_       %5B4%5Dbyte%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x1269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f abf6492c186d7836190890691d7c35098dd10ff2870d81f76eb08949fb29cc30 vendor/golang.org/x/sys/unix/ztypes_linux_arm.go
+ f 2c85147b681f27a3ad7ec8ab2846ecd335f7a3215fdd4d3ce8f78860cf648d19 vendor/golang.org/x/sys/unix/ztypes_linux_arm.go
dmppatch 7
@@ -186,16 +186,13334 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Offset    int32%0A%09Freq      int32%0A%09Maxerror  int32%0A%09Esterror  int32%0A%09Status    int32%0A%09Constant  int32%0A%09Precision int32%0A%09Tolerance int32%0A%09Time      Timeval%0A%09Tick      int32%0A%09Ppsfreq   int32%0A%09Jitter    int32%0A%09Shift     int32%0A%09Stabil    int32%0A%09Jitcnt    int32%0A%09Calcnt    int32%0A%09Errcnt    int32%0A%09Stbcnt    int32%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int32%0A%0Atype Tms struct %7B%0A%09Utime  int32%0A%09Stime  int32%0A%09Cutime int32%0A%09Cstime int32%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int32%0A%09Modtime int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09_       uint16%0A%09_       %5B2%5Dbyte%0A%09_       uint32%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint64%0A%09_       uint16%0A%09_       %5B6%5Dbyte%0A%09Size    int64%0A%09Blksize int32%0A%09_       %5B4%5Dbyte%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Ino     uint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Duint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Duint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Duint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x1c%0A%09SizeofCmsghdr           = 0xc%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x8%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B2%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Uregs %5B18%5Duint32%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int32%0A%09Loads     %5B3%5Duint32%0A%09Totalram  uint32%0A%09Freeram   uint32%0A%09Sharedram uint32%0A%09Bufferram uint32%0A%09Totalswap uint32%0A%09Freeswap  uint32%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Totalhigh uint32%0A%09Freehigh  uint32%0A%09Unit      uint32%0A%09_         %5B8%5Duint8%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09Tinode uint32%0A%09Fname  %5B6%5Duint8%0A%09Fpack  %5B6%5Duint8%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09PadFd  int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B32%5Duint32%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -13642,16 +13642,34922 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Duint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint32%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x20%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B122%5Duint8%0A%09_      uint32%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09Start     uint32%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int32%0A%09Bsize   int32%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int32%0A%09Frsize  int32%0A%09Flags   int32%0A%09Spare   %5B4%5Dint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint32%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x18%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int32%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x1269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f 3401b401c0e33be442471ddbac990bd9fff21f6cd40eb60bd128e446c5791712 vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go
+ f 38c1800af92e30c76ae8345f0374ae7330523787b2f518a6d85a6cc9853910ce vendor/golang.org/x/sys/unix/ztypes_linux_arm64.go
dmppatch 7
@@ -202,16 +202,13494 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint64%0A%09_       uint64%0A%09Size    int64%0A%09Blksize int32%0A%09_       int32%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09_       %5B2%5Dint32%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs   %5B31%5Duint64%0A%09Sp     uint64%0A%09Pc     uint64%0A%09Pstate uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09PadFd  int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -13818,16 +13818,34956 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int64%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09_       %5B4%5Dbyte%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x1269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f 687e4b021202955d0386780c15ca347011f760515090a8cee00030a2aa5beea7 vendor/golang.org/x/sys/unix/ztypes_linux_mips.go
+ f 9b08e3cd647e9b743246f04847783910a1c3d6d0608ebedc2a634811ab41cf64 vendor/golang.org/x/sys/unix/ztypes_linux_mips.go
dmppatch 7
@@ -187,16 +187,13404 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Offset    int32%0A%09Freq      int32%0A%09Maxerror  int32%0A%09Esterror  int32%0A%09Status    int32%0A%09Constant  int32%0A%09Precision int32%0A%09Tolerance int32%0A%09Time      Timeval%0A%09Tick      int32%0A%09Ppsfreq   int32%0A%09Jitter    int32%0A%09Shift     int32%0A%09Stabil    int32%0A%09Jitcnt    int32%0A%09Calcnt    int32%0A%09Errcnt    int32%0A%09Stbcnt    int32%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int32%0A%0Atype Tms struct %7B%0A%09Utime  int32%0A%09Stime  int32%0A%09Cutime int32%0A%09Cstime int32%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int32%0A%09Modtime int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint32%0A%09Pad1    %5B3%5Dint32%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint32%0A%09Pad2    %5B3%5Dint32%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize int32%0A%09Pad4    int32%0A%09Blocks  int64%0A%09Pad5    %5B14%5Dint32%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x1c%0A%09SizeofCmsghdr           = 0xc%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x8%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B2%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int32%0A%09Loads     %5B3%5Duint32%0A%09Totalram  uint32%0A%09Freeram   uint32%0A%09Sharedram uint32%0A%09Bufferram uint32%0A%09Totalswap uint32%0A%09Freeswap  uint32%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Totalhigh uint32%0A%09Freehigh  uint32%0A%09Unit      uint32%0A%09_         %5B8%5Dint8%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09Tinode uint32%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09PadFd  int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B32%5Duint32%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -13713,16 +13713,34941 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint32%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x20%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x8000000000000000%0A%09CBitFieldMaskBit1  = 0x4000000000000000%0A%09CBitFieldMaskBit2  = 0x2000000000000000%0A%09CBitFieldMaskBit3  = 0x1000000000000000%0A%09CBitFieldMaskBit4  = 0x800000000000000%0A%09CBitFieldMaskBit5  = 0x400000000000000%0A%09CBitFieldMaskBit6  = 0x200000000000000%0A%09CBitFieldMaskBit7  = 0x100000000000000%0A%09CBitFieldMaskBit8  = 0x80000000000000%0A%09CBitFieldMaskBit9  = 0x40000000000000%0A%09CBitFieldMaskBit10 = 0x20000000000000%0A%09CBitFieldMaskBit11 = 0x10000000000000%0A%09CBitFieldMaskBit12 = 0x8000000000000%0A%09CBitFieldMaskBit13 = 0x4000000000000%0A%09CBitFieldMaskBit14 = 0x2000000000000%0A%09CBitFieldMaskBit15 = 0x1000000000000%0A%09CBitFieldMaskBit16 = 0x800000000000%0A%09CBitFieldMaskBit17 = 0x400000000000%0A%09CBitFieldMaskBit18 = 0x200000000000%0A%09CBitFieldMaskBit19 = 0x100000000000%0A%09CBitFieldMaskBit20 = 0x80000000000%0A%09CBitFieldMaskBit21 = 0x40000000000%0A%09CBitFieldMaskBit22 = 0x20000000000%0A%09CBitFieldMaskBit23 = 0x10000000000%0A%09CBitFieldMaskBit24 = 0x8000000000%0A%09CBitFieldMaskBit25 = 0x4000000000%0A%09CBitFieldMaskBit26 = 0x2000000000%0A%09CBitFieldMaskBit27 = 0x1000000000%0A%09CBitFieldMaskBit28 = 0x800000000%0A%09CBitFieldMaskBit29 = 0x400000000%0A%09CBitFieldMaskBit30 = 0x200000000%0A%09CBitFieldMaskBit31 = 0x100000000%0A%09CBitFieldMaskBit32 = 0x80000000%0A%09CBitFieldMaskBit33 = 0x40000000%0A%09CBitFieldMaskBit34 = 0x20000000%0A%09CBitFieldMaskBit35 = 0x10000000%0A%09CBitFieldMaskBit36 = 0x8000000%0A%09CBitFieldMaskBit37 = 0x4000000%0A%09CBitFieldMaskBit38 = 0x2000000%0A%09CBitFieldMaskBit39 = 0x1000000%0A%09CBitFieldMaskBit40 = 0x800000%0A%09CBitFieldMaskBit41 = 0x400000%0A%09CBitFieldMaskBit42 = 0x200000%0A%09CBitFieldMaskBit43 = 0x100000%0A%09CBitFieldMaskBit44 = 0x80000%0A%09CBitFieldMaskBit45 = 0x40000%0A%09CBitFieldMaskBit46 = 0x20000%0A%09CBitFieldMaskBit47 = 0x10000%0A%09CBitFieldMaskBit48 = 0x8000%0A%09CBitFieldMaskBit49 = 0x4000%0A%09CBitFieldMaskBit50 = 0x2000%0A%09CBitFieldMaskBit51 = 0x1000%0A%09CBitFieldMaskBit52 = 0x800%0A%09CBitFieldMaskBit53 = 0x400%0A%09CBitFieldMaskBit54 = 0x200%0A%09CBitFieldMaskBit55 = 0x100%0A%09CBitFieldMaskBit56 = 0x80%0A%09CBitFieldMaskBit57 = 0x40%0A%09CBitFieldMaskBit58 = 0x20%0A%09CBitFieldMaskBit59 = 0x10%0A%09CBitFieldMaskBit60 = 0x8%0A%09CBitFieldMaskBit61 = 0x4%0A%09CBitFieldMaskBit62 = 0x2%0A%09CBitFieldMaskBit63 = 0x1%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B122%5Dint8%0A%09_      uint32%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09Start     uint32%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int32%0A%09Bsize   int32%0A%09Frsize  int32%0A%09_       %5B4%5Dbyte%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Bavail  uint64%0A%09Fsid    Fsid%0A%09Namelen int32%0A%09Flags   int32%0A%09Spare   %5B5%5Dint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint32%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x18%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int32%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x20001269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f eb86b5ba720c93e10ade7198ef366a42281f1bd04b17e65cd567e0802629a469 vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go
+ f 039f033381c3c83a4712a9884cdf687d2208a803929aa33b41a12b6995de9fdb vendor/golang.org/x/sys/unix/ztypes_linux_mips64.go
dmppatch 7
@@ -189,16 +189,13545 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint32%0A%09Pad1    %5B3%5Duint32%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint32%0A%09Pad2    %5B3%5Duint32%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize uint32%0A%09Pad4    uint32%0A%09Blocks  int64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -13856,16 +13856,34960 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x8000000000000000%0A%09CBitFieldMaskBit1  = 0x4000000000000000%0A%09CBitFieldMaskBit2  = 0x2000000000000000%0A%09CBitFieldMaskBit3  = 0x1000000000000000%0A%09CBitFieldMaskBit4  = 0x800000000000000%0A%09CBitFieldMaskBit5  = 0x400000000000000%0A%09CBitFieldMaskBit6  = 0x200000000000000%0A%09CBitFieldMaskBit7  = 0x100000000000000%0A%09CBitFieldMaskBit8  = 0x80000000000000%0A%09CBitFieldMaskBit9  = 0x40000000000000%0A%09CBitFieldMaskBit10 = 0x20000000000000%0A%09CBitFieldMaskBit11 = 0x10000000000000%0A%09CBitFieldMaskBit12 = 0x8000000000000%0A%09CBitFieldMaskBit13 = 0x4000000000000%0A%09CBitFieldMaskBit14 = 0x2000000000000%0A%09CBitFieldMaskBit15 = 0x1000000000000%0A%09CBitFieldMaskBit16 = 0x800000000000%0A%09CBitFieldMaskBit17 = 0x400000000000%0A%09CBitFieldMaskBit18 = 0x200000000000%0A%09CBitFieldMaskBit19 = 0x100000000000%0A%09CBitFieldMaskBit20 = 0x80000000000%0A%09CBitFieldMaskBit21 = 0x40000000000%0A%09CBitFieldMaskBit22 = 0x20000000000%0A%09CBitFieldMaskBit23 = 0x10000000000%0A%09CBitFieldMaskBit24 = 0x8000000000%0A%09CBitFieldMaskBit25 = 0x4000000000%0A%09CBitFieldMaskBit26 = 0x2000000000%0A%09CBitFieldMaskBit27 = 0x1000000000%0A%09CBitFieldMaskBit28 = 0x800000000%0A%09CBitFieldMaskBit29 = 0x400000000%0A%09CBitFieldMaskBit30 = 0x200000000%0A%09CBitFieldMaskBit31 = 0x100000000%0A%09CBitFieldMaskBit32 = 0x80000000%0A%09CBitFieldMaskBit33 = 0x40000000%0A%09CBitFieldMaskBit34 = 0x20000000%0A%09CBitFieldMaskBit35 = 0x10000000%0A%09CBitFieldMaskBit36 = 0x8000000%0A%09CBitFieldMaskBit37 = 0x4000000%0A%09CBitFieldMaskBit38 = 0x2000000%0A%09CBitFieldMaskBit39 = 0x1000000%0A%09CBitFieldMaskBit40 = 0x800000%0A%09CBitFieldMaskBit41 = 0x400000%0A%09CBitFieldMaskBit42 = 0x200000%0A%09CBitFieldMaskBit43 = 0x100000%0A%09CBitFieldMaskBit44 = 0x80000%0A%09CBitFieldMaskBit45 = 0x40000%0A%09CBitFieldMaskBit46 = 0x20000%0A%09CBitFieldMaskBit47 = 0x10000%0A%09CBitFieldMaskBit48 = 0x8000%0A%09CBitFieldMaskBit49 = 0x4000%0A%09CBitFieldMaskBit50 = 0x2000%0A%09CBitFieldMaskBit51 = 0x1000%0A%09CBitFieldMaskBit52 = 0x800%0A%09CBitFieldMaskBit53 = 0x400%0A%09CBitFieldMaskBit54 = 0x200%0A%09CBitFieldMaskBit55 = 0x100%0A%09CBitFieldMaskBit56 = 0x80%0A%09CBitFieldMaskBit57 = 0x40%0A%09CBitFieldMaskBit58 = 0x20%0A%09CBitFieldMaskBit59 = 0x10%0A%09CBitFieldMaskBit60 = 0x8%0A%09CBitFieldMaskBit61 = 0x4%0A%09CBitFieldMaskBit62 = 0x2%0A%09CBitFieldMaskBit63 = 0x1%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Frsize  int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Bavail  uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Flags   int64%0A%09Spare   %5B5%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int64%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09_       %5B4%5Dbyte%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x20001269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f 94f5c5e71dd8e01be25efa679ad977bd7ef7782d5dc59cd793c2041829f7dbf9 vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go
+ f 084b2ec1108736a19640f55655bfa58c901ad183ccd27c52d3ad1004a5c3561d vendor/golang.org/x/sys/unix/ztypes_linux_mips64le.go
dmppatch 7
@@ -191,16 +191,13545 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint32%0A%09Pad1    %5B3%5Duint32%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint32%0A%09Pad2    %5B3%5Duint32%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize uint32%0A%09Pad4    uint32%0A%09Blocks  int64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -13858,16 +13858,34960 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Frsize  int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Bavail  uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Flags   int64%0A%09Spare   %5B5%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int64%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09_       %5B4%5Dbyte%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x20001269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f e73653b005f7b60421641bffeb813aa4c346c3bfc77e588a61293a0b541cd4e8 vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go
+ f 8682e65c7ecf7a991cbf1b9b04700537a3a1bfcc33902c44a1da28409e7ab055 vendor/golang.org/x/sys/unix/ztypes_linux_mipsle.go
dmppatch 7
@@ -189,16 +189,13404 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int32%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Offset    int32%0A%09Freq      int32%0A%09Maxerror  int32%0A%09Esterror  int32%0A%09Status    int32%0A%09Constant  int32%0A%09Precision int32%0A%09Tolerance int32%0A%09Time      Timeval%0A%09Tick      int32%0A%09Ppsfreq   int32%0A%09Jitter    int32%0A%09Shift     int32%0A%09Stabil    int32%0A%09Jitcnt    int32%0A%09Calcnt    int32%0A%09Errcnt    int32%0A%09Stbcnt    int32%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int32%0A%0Atype Tms struct %7B%0A%09Utime  int32%0A%09Stime  int32%0A%09Cutime int32%0A%09Cstime int32%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int32%0A%09Modtime int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint32%0A%09Pad1    %5B3%5Dint32%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint32%0A%09Pad2    %5B3%5Dint32%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize int32%0A%09Pad4    int32%0A%09Blocks  int64%0A%09Pad5    %5B14%5Dint32%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x1c%0A%09SizeofCmsghdr           = 0xc%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x8%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B2%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs     %5B32%5Duint64%0A%09Lo       uint64%0A%09Hi       uint64%0A%09Epc      uint64%0A%09Badvaddr uint64%0A%09Status   uint64%0A%09Cause    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Dint32%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int32%0A%09Loads     %5B3%5Duint32%0A%09Totalram  uint32%0A%09Freeram   uint32%0A%09Sharedram uint32%0A%09Bufferram uint32%0A%09Totalswap uint32%0A%09Freeswap  uint32%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Totalhigh uint32%0A%09Freehigh  uint32%0A%09Unit      uint32%0A%09_         %5B8%5Dint8%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09Tinode uint32%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09PadFd  int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B32%5Duint32%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -13715,16 +13715,34941 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint32%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x20%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B122%5Dint8%0A%09_      uint32%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09Start     uint32%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int32%0A%09Bsize   int32%0A%09Frsize  int32%0A%09_       %5B4%5Dbyte%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Bavail  uint64%0A%09Fsid    Fsid%0A%09Namelen int32%0A%09Flags   int32%0A%09Spare   %5B5%5Dint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint32%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x18%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int32%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x20001269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f 5cc062acb2c6db686ab87978884e45ce778ef3bfe4bc35a17864d82b5b07fe21 vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go
+ f 8e3969b0dd112da1f0f82b5bc24807602b78e005d75982c179e7195ab683484f vendor/golang.org/x/sys/unix/ztypes_linux_ppc64.go
dmppatch 7
@@ -188,16 +188,13688 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Nlink   uint64%0A%09Mode    uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09_       int32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Blksize int64%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09_       uint64%0A%09_       uint64%0A%09_       uint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Duint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Duint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Duint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Gpr       %5B32%5Duint64%0A%09Nip       uint64%0A%09Msr       uint64%0A%09Orig_gpr3 uint64%0A%09Ctr       uint64%0A%09Link      uint64%0A%09Xer       uint64%0A%09Ccr       uint64%0A%09Softe     uint64%0A%09Trap      uint64%0A%09Dar       uint64%0A%09Dsisr     uint64%0A%09Result    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Duint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Duint8%0A%09Fpack  %5B6%5Duint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09_      int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -13998,16 +13998,34962 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Duint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x8000000000000000%0A%09CBitFieldMaskBit1  = 0x4000000000000000%0A%09CBitFieldMaskBit2  = 0x2000000000000000%0A%09CBitFieldMaskBit3  = 0x1000000000000000%0A%09CBitFieldMaskBit4  = 0x800000000000000%0A%09CBitFieldMaskBit5  = 0x400000000000000%0A%09CBitFieldMaskBit6  = 0x200000000000000%0A%09CBitFieldMaskBit7  = 0x100000000000000%0A%09CBitFieldMaskBit8  = 0x80000000000000%0A%09CBitFieldMaskBit9  = 0x40000000000000%0A%09CBitFieldMaskBit10 = 0x20000000000000%0A%09CBitFieldMaskBit11 = 0x10000000000000%0A%09CBitFieldMaskBit12 = 0x8000000000000%0A%09CBitFieldMaskBit13 = 0x4000000000000%0A%09CBitFieldMaskBit14 = 0x2000000000000%0A%09CBitFieldMaskBit15 = 0x1000000000000%0A%09CBitFieldMaskBit16 = 0x800000000000%0A%09CBitFieldMaskBit17 = 0x400000000000%0A%09CBitFieldMaskBit18 = 0x200000000000%0A%09CBitFieldMaskBit19 = 0x100000000000%0A%09CBitFieldMaskBit20 = 0x80000000000%0A%09CBitFieldMaskBit21 = 0x40000000000%0A%09CBitFieldMaskBit22 = 0x20000000000%0A%09CBitFieldMaskBit23 = 0x10000000000%0A%09CBitFieldMaskBit24 = 0x8000000000%0A%09CBitFieldMaskBit25 = 0x4000000000%0A%09CBitFieldMaskBit26 = 0x2000000000%0A%09CBitFieldMaskBit27 = 0x1000000000%0A%09CBitFieldMaskBit28 = 0x800000000%0A%09CBitFieldMaskBit29 = 0x400000000%0A%09CBitFieldMaskBit30 = 0x200000000%0A%09CBitFieldMaskBit31 = 0x100000000%0A%09CBitFieldMaskBit32 = 0x80000000%0A%09CBitFieldMaskBit33 = 0x40000000%0A%09CBitFieldMaskBit34 = 0x20000000%0A%09CBitFieldMaskBit35 = 0x10000000%0A%09CBitFieldMaskBit36 = 0x8000000%0A%09CBitFieldMaskBit37 = 0x4000000%0A%09CBitFieldMaskBit38 = 0x2000000%0A%09CBitFieldMaskBit39 = 0x1000000%0A%09CBitFieldMaskBit40 = 0x800000%0A%09CBitFieldMaskBit41 = 0x400000%0A%09CBitFieldMaskBit42 = 0x200000%0A%09CBitFieldMaskBit43 = 0x100000%0A%09CBitFieldMaskBit44 = 0x80000%0A%09CBitFieldMaskBit45 = 0x40000%0A%09CBitFieldMaskBit46 = 0x20000%0A%09CBitFieldMaskBit47 = 0x10000%0A%09CBitFieldMaskBit48 = 0x8000%0A%09CBitFieldMaskBit49 = 0x4000%0A%09CBitFieldMaskBit50 = 0x2000%0A%09CBitFieldMaskBit51 = 0x1000%0A%09CBitFieldMaskBit52 = 0x800%0A%09CBitFieldMaskBit53 = 0x400%0A%09CBitFieldMaskBit54 = 0x200%0A%09CBitFieldMaskBit55 = 0x100%0A%09CBitFieldMaskBit56 = 0x80%0A%09CBitFieldMaskBit57 = 0x40%0A%09CBitFieldMaskBit58 = 0x20%0A%09CBitFieldMaskBit59 = 0x10%0A%09CBitFieldMaskBit60 = 0x8%0A%09CBitFieldMaskBit61 = 0x4%0A%09CBitFieldMaskBit62 = 0x2%0A%09CBitFieldMaskBit63 = 0x1%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Duint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int64%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09_       %5B4%5Dbyte%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x20001269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f c0fe2bb880163c4d8c3d84a348df37293a96276aaca2a596cbe0985d7c3d7ae9 vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go
+ f 2db09cd28542b60c74ea867e98155c023322896bd3226de65b99f4366c866d21 vendor/golang.org/x/sys/unix/ztypes_linux_ppc64le.go
dmppatch 7
@@ -190,16 +190,13688 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Nlink   uint64%0A%09Mode    uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09_       int32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Blksize int64%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09_       uint64%0A%09_       uint64%0A%09_       uint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Duint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Duint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Duint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Gpr       %5B32%5Duint64%0A%09Nip       uint64%0A%09Msr       uint64%0A%09Orig_gpr3 uint64%0A%09Ctr       uint64%0A%09Link      uint64%0A%09Xer       uint64%0A%09Ccr       uint64%0A%09Softe     uint64%0A%09Trap      uint64%0A%09Dar       uint64%0A%09Dsisr     uint64%0A%09Result    uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Duint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Duint8%0A%09Fpack  %5B6%5Duint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09_      int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x40045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -14000,16 +14000,34962 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Duint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Duint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int64%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09_       %5B4%5Dbyte%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x20001269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
+ f bca2af24cf34d4fcee51bc29923b8d2dc320314776ef8f1fb4a0d93b62ff5158 vendor/golang.org/x/sys/unix/ztypes_linux_riscv64.go
dmppatch 2
@@ -0,0 +1,49076 @@
+// cgo -godefs -- -Wall -Werror -static -I/tmp/include linux/types.go %7C go run mkpost.go%0A// Code generated by the command above; see README.md. DO NOT EDIT.%0A%0A// +build riscv64,linux%0A%0Apackage unix%0A%0Aconst (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint64%0A%09_       uint64%0A%09Size    int64%0A%09Blksize int32%0A%09_       int32%0A%09Blocks  int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09_       %5B2%5Dint32%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Duint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Duint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Duint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Duint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Pc  uint64%0A%09Ra  uint64%0A%09Sp  uint64%0A%09Gp  uint64%0A%09Tp  uint64%0A%09T0  uint64%0A%09T1  uint64%0A%09T2  uint64%0A%09S0  uint64%0A%09S1  uint64%0A%09A0  uint64%0A%09A1  uint64%0A%09A2  uint64%0A%09A3  uint64%0A%09A4  uint64%0A%09A5  uint64%0A%09A6  uint64%0A%09A7  uint64%0A%09S2  uint64%0A%09S3  uint64%0A%09S4  uint64%0A%09S5  uint64%0A%09S6  uint64%0A%09S7  uint64%0A%09S8  uint64%0A%09S9  uint64%0A%09S10 uint64%0A%09S11 uint64%0A%09T3  uint64%0A%09T4  uint64%0A%09T5  uint64%0A%09T6  uint64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Duint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Duint8%0A%09Fpack  %5B6%5Duint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0Atype Termios struct %7B%0A%09Iflag  uint32%0A%09Oflag  uint32%0A%09Cflag  uint32%0A%09Lflag  uint32%0A%09Line   uint8%0A%09Cc     %5B19%5Duint8%0A%09Ispeed uint32%0A%09Ospeed uint32%0A%7D%0A%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Duint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x1%0A%09CBitFieldMaskBit1  = 0x2%0A%09CBitFieldMaskBit2  = 0x4%0A%09CBitFieldMaskBit3  = 0x8%0A%09CBitFieldMaskBit4  = 0x10%0A%09CBitFieldMaskBit5  = 0x20%0A%09CBitFieldMaskBit6  = 0x40%0A%09CBitFieldMaskBit7  = 0x80%0A%09CBitFieldMaskBit8  = 0x100%0A%09CBitFieldMaskBit9  = 0x200%0A%09CBitFieldMaskBit10 = 0x400%0A%09CBitFieldMaskBit11 = 0x800%0A%09CBitFieldMaskBit12 = 0x1000%0A%09CBitFieldMaskBit13 = 0x2000%0A%09CBitFieldMaskBit14 = 0x4000%0A%09CBitFieldMaskBit15 = 0x8000%0A%09CBitFieldMaskBit16 = 0x10000%0A%09CBitFieldMaskBit17 = 0x20000%0A%09CBitFieldMaskBit18 = 0x40000%0A%09CBitFieldMaskBit19 = 0x80000%0A%09CBitFieldMaskBit20 = 0x100000%0A%09CBitFieldMaskBit21 = 0x200000%0A%09CBitFieldMaskBit22 = 0x400000%0A%09CBitFieldMaskBit23 = 0x800000%0A%09CBitFieldMaskBit24 = 0x1000000%0A%09CBitFieldMaskBit25 = 0x2000000%0A%09CBitFieldMaskBit26 = 0x4000000%0A%09CBitFieldMaskBit27 = 0x8000000%0A%09CBitFieldMaskBit28 = 0x10000000%0A%09CBitFieldMaskBit29 = 0x20000000%0A%09CBitFieldMaskBit30 = 0x40000000%0A%09CBitFieldMaskBit31 = 0x80000000%0A%09CBitFieldMaskBit32 = 0x100000000%0A%09CBitFieldMaskBit33 = 0x200000000%0A%09CBitFieldMaskBit34 = 0x400000000%0A%09CBitFieldMaskBit35 = 0x800000000%0A%09CBitFieldMaskBit36 = 0x1000000000%0A%09CBitFieldMaskBit37 = 0x2000000000%0A%09CBitFieldMaskBit38 = 0x4000000000%0A%09CBitFieldMaskBit39 = 0x8000000000%0A%09CBitFieldMaskBit40 = 0x10000000000%0A%09CBitFieldMaskBit41 = 0x20000000000%0A%09CBitFieldMaskBit42 = 0x40000000000%0A%09CBitFieldMaskBit43 = 0x80000000000%0A%09CBitFieldMaskBit44 = 0x100000000000%0A%09CBitFieldMaskBit45 = 0x200000000000%0A%09CBitFieldMaskBit46 = 0x400000000000%0A%09CBitFieldMaskBit47 = 0x800000000000%0A%09CBitFieldMaskBit48 = 0x1000000000000%0A%09CBitFieldMaskBit49 = 0x2000000000000%0A%09CBitFieldMaskBit50 = 0x4000000000000%0A%09CBitFieldMaskBit51 = 0x8000000000000%0A%09CBitFieldMaskBit52 = 0x10000000000000%0A%09CBitFieldMaskBit53 = 0x20000000000000%0A%09CBitFieldMaskBit54 = 0x40000000000000%0A%09CBitFieldMaskBit55 = 0x80000000000000%0A%09CBitFieldMaskBit56 = 0x100000000000000%0A%09CBitFieldMaskBit57 = 0x200000000000000%0A%09CBitFieldMaskBit58 = 0x400000000000000%0A%09CBitFieldMaskBit59 = 0x800000000000000%0A%09CBitFieldMaskBit60 = 0x1000000000000000%0A%09CBitFieldMaskBit61 = 0x2000000000000000%0A%09CBitFieldMaskBit62 = 0x4000000000000000%0A%09CBitFieldMaskBit63 = 0x8000000000000000%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Duint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int64%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09_       %5B4%5Dbyte%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x1269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f 809925b423571275028925775c795f31d0f0cc32d41f29ac2ef8637dd5e680d0 vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go
+ f cb53cd52240e6ad7af48454ae3158330865f7079c608339166c74cb357cf794a vendor/golang.org/x/sys/unix/ztypes_linux_s390x.go
dmppatch 7
@@ -202,16 +202,14047 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09_         %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09_         %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09_         %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09_         %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Nlink   uint64%0A%09Mode    uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09_       int32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize int64%0A%09Blocks  int64%0A%09_       %5B3%5Dint64%0A%7D%0A%0Atype StatxTimestamp struct %7B%0A%09Sec  int64%0A%09Nsec uint32%0A%09_    int32%0A%7D%0A%0Atype Statx_t struct %7B%0A%09Mask            uint32%0A%09Blksize         uint32%0A%09Attributes      uint64%0A%09Nlink           uint32%0A%09Uid             uint32%0A%09Gid             uint32%0A%09Mode            uint16%0A%09_               %5B1%5Duint16%0A%09Ino             uint64%0A%09Size            uint64%0A%09Blocks          uint64%0A%09Attributes_mask uint64%0A%09Atime           StatxTimestamp%0A%09Btime           StatxTimestamp%0A%09Ctime           StatxTimestamp%0A%09Mtime           StatxTimestamp%0A%09Rdev_major      uint32%0A%09Rdev_minor      uint32%0A%09Dev_major       uint32%0A%09Dev_minor       uint32%0A%09_               %5B14%5Duint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Name   %5B256%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype FscryptPolicy struct %7B%0A%09Version                   uint8%0A%09Contents_encryption_mode  uint8%0A%09Filenames_encryption_mode uint8%0A%09Flags                     uint8%0A%09Master_key_descriptor     %5B8%5Duint8%0A%7D%0A%0Atype FscryptKey struct %7B%0A%09Mode uint32%0A%09Raw  %5B64%5Duint8%0A%09Size uint32%0A%7D%0A%0Atype KeyctlDHParams struct %7B%0A%09Private int32%0A%09Prime   int32%0A%09Base    int32%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x6%0A%09FADV_NOREUSE    = 0x7%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrL2 struct %7B%0A%09Family      uint16%0A%09Psm         uint16%0A%09Bdaddr      %5B6%5Duint8%0A%09Cid         uint16%0A%09Bdaddr_type uint8%0A%09_           %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrRFCOMM struct %7B%0A%09Family  uint16%0A%09Bdaddr  %5B6%5Duint8%0A%09Channel uint8%0A%09_       %5B1%5Dbyte%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family  uint16%0A%09_       %5B2%5Dbyte%0A%09Ifindex int32%0A%09Addr    %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddrXDP struct %7B%0A%09Family         uint16%0A%09Flags          uint16%0A%09Ifindex        uint32%0A%09Queue_id       uint32%0A%09Shared_umem_fd uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype PacketMreq struct %7B%0A%09Ifindex int32%0A%09Type    uint16%0A%09Alen    uint16%0A%09Address %5B8%5Duint8%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09_          %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09_              %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrL2        = 0xe%0A%09SizeofSockaddrRFCOMM    = 0xa%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofSockaddrXDP       = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIovec             = 0x10%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofPacketMreq        = 0x10%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_INFO_KIND       = 0x1%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x31%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTA_MARK             = 0x10%0A%09RTA_MFC_STATS        = 0x11%0A%09RTA_VIA              = 0x12%0A%09RTA_NEWDST           = 0x13%0A%09RTA_PREF             = 0x14%0A%09RTA_ENCAP_TYPE       = 0x15%0A%09RTA_ENCAP            = 0x16%0A%09RTA_EXPIRES          = 0x17%0A%09RTA_PAD              = 0x18%0A%09RTA_UID              = 0x19%0A%09RTA_TTL_PROPAGATE    = 0x1a%0A%09RTA_IP_PROTO         = 0x1b%0A%09RTA_SPORT            = 0x1c%0A%09RTA_DPORT            = 0x1d%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family uint8%0A%09_      uint8%0A%09Type   uint16%0A%09Index  int32%0A%09Flags  uint32%0A%09Change uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len    uint16%0A%09_      %5B6%5Dbyte%0A%09Filter *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Psw                      PtracePsw%0A%09Gprs                     %5B16%5Duint64%0A%09Acrs                     %5B16%5Duint32%0A%09Orig_gpr2                uint64%0A%09Fp_regs                  PtraceFpregs%0A%09Per_info                 PtracePer%0A%09Ieee_instruction_pointer uint64%0A%7D%0A%0Atype PtracePsw struct %7B%0A%09Mask uint64%0A%09Addr uint64%0A%7D%0A%0Atype PtraceFpregs struct %7B%0A%09Fpc  uint32%0A%09_    %5B4%5Dbyte%0A%09Fprs %5B16%5Dfloat64%0A%7D%0A%0Atype PtracePer struct %7B%0A%09_             %5B0%5Duint64%0A%09_             %5B24%5Dbyte%0A%09_             %5B8%5Dbyte%0A%09Starting_addr uint64%0A%09Ending_addr   uint64%0A%09Perc_atmid    uint16%0A%09_             %5B6%5Dbyte%0A%09Address       uint64%0A%09Access_id     uint8%0A%09_             %5B7%5Dbyte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09_         %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09_         %5B0%5Dint8%0A%09_         %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int32%0A%09_      %5B4%5Dbyte%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events uint32%0A%09_      int32%0A%09Fd     int32%0A%09Pad    int32%0A%7D%0A%0Aconst (%0A%09AT_EMPTY_PATH   = 0x1000%0A%09AT_FDCWD        = -0x64%0A%09AT_NO_AUTOMOUNT = 0x800%0A%09AT_REMOVEDIR    = 0x200%0A%0A%09AT_STATX_SYNC_AS_STAT = 0x0%0A%09AT_STATX_FORCE_SYNC   = 0x2000%0A%09AT_STATX_DONT_SYNC    = 0x4000%0A%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A%0A%09AT_EACCESS = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x2000%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09Val %5B16%5Duint64%0A%7D%0A%0Aconst RNDGETENTCNT = 0x80045200%0A%0Aconst PERF_IOC_FLAG_GROUP = 0x1%0A%0A
 type Ter
@@ -14371,16 +14371,34979 @@
 Ospeed uint32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype Taskstats struct %7B%0A%09Version                   uint16%0A%09_                         %5B2%5Dbyte%0A%09Ac_exitcode               uint32%0A%09Ac_flag                   uint8%0A%09Ac_nice                   uint8%0A%09_                         %5B6%5Dbyte%0A%09Cpu_count                 uint64%0A%09Cpu_delay_total           uint64%0A%09Blkio_count               uint64%0A%09Blkio_delay_total         uint64%0A%09Swapin_count              uint64%0A%09Swapin_delay_total        uint64%0A%09Cpu_run_real_total        uint64%0A%09Cpu_run_virtual_total     uint64%0A%09Ac_comm                   %5B32%5Dint8%0A%09Ac_sched                  uint8%0A%09Ac_pad                    %5B3%5Duint8%0A%09_                         %5B4%5Dbyte%0A%09Ac_uid                    uint32%0A%09Ac_gid                    uint32%0A%09Ac_pid                    uint32%0A%09Ac_ppid                   uint32%0A%09Ac_btime                  uint32%0A%09_                         %5B4%5Dbyte%0A%09Ac_etime                  uint64%0A%09Ac_utime                  uint64%0A%09Ac_stime                  uint64%0A%09Ac_minflt                 uint64%0A%09Ac_majflt                 uint64%0A%09Coremem                   uint64%0A%09Virtmem                   uint64%0A%09Hiwater_rss               uint64%0A%09Hiwater_vm                uint64%0A%09Read_char                 uint64%0A%09Write_char                uint64%0A%09Read_syscalls             uint64%0A%09Write_syscalls            uint64%0A%09Read_bytes                uint64%0A%09Write_bytes               uint64%0A%09Cancelled_write_bytes     uint64%0A%09Nvcsw                     uint64%0A%09Nivcsw                    uint64%0A%09Ac_utimescaled            uint64%0A%09Ac_stimescaled            uint64%0A%09Cpu_scaled_run_real_total uint64%0A%09Freepages_count           uint64%0A%09Freepages_delay_total     uint64%0A%7D%0A%0Aconst (%0A%09TASKSTATS_CMD_UNSPEC                  = 0x0%0A%09TASKSTATS_CMD_GET                     = 0x1%0A%09TASKSTATS_CMD_NEW                     = 0x2%0A%09TASKSTATS_TYPE_UNSPEC                 = 0x0%0A%09TASKSTATS_TYPE_PID                    = 0x1%0A%09TASKSTATS_TYPE_TGID                   = 0x2%0A%09TASKSTATS_TYPE_STATS                  = 0x3%0A%09TASKSTATS_TYPE_AGGR_PID               = 0x4%0A%09TASKSTATS_TYPE_AGGR_TGID              = 0x5%0A%09TASKSTATS_TYPE_NULL                   = 0x6%0A%09TASKSTATS_CMD_ATTR_UNSPEC             = 0x0%0A%09TASKSTATS_CMD_ATTR_PID                = 0x1%0A%09TASKSTATS_CMD_ATTR_TGID               = 0x2%0A%09TASKSTATS_CMD_ATTR_REGISTER_CPUMASK   = 0x3%0A%09TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK = 0x4%0A)%0A%0Atype CGroupStats struct %7B%0A%09Sleeping        uint64%0A%09Running         uint64%0A%09Stopped         uint64%0A%09Uninterruptible uint64%0A%09Io_wait         uint64%0A%7D%0A%0Aconst (%0A%09CGROUPSTATS_CMD_UNSPEC        = 0x3%0A%09CGROUPSTATS_CMD_GET           = 0x4%0A%09CGROUPSTATS_CMD_NEW           = 0x5%0A%09CGROUPSTATS_TYPE_UNSPEC       = 0x0%0A%09CGROUPSTATS_TYPE_CGROUP_STATS = 0x1%0A%09CGROUPSTATS_CMD_ATTR_UNSPEC   = 0x0%0A%09CGROUPSTATS_CMD_ATTR_FD       = 0x1%0A)%0A%0Atype Genlmsghdr struct %7B%0A%09Cmd      uint8%0A%09Version  uint8%0A%09Reserved uint16%0A%7D%0A%0Aconst (%0A%09CTRL_CMD_UNSPEC            = 0x0%0A%09CTRL_CMD_NEWFAMILY         = 0x1%0A%09CTRL_CMD_DELFAMILY         = 0x2%0A%09CTRL_CMD_GETFAMILY         = 0x3%0A%09CTRL_CMD_NEWOPS            = 0x4%0A%09CTRL_CMD_DELOPS            = 0x5%0A%09CTRL_CMD_GETOPS            = 0x6%0A%09CTRL_CMD_NEWMCAST_GRP      = 0x7%0A%09CTRL_CMD_DELMCAST_GRP      = 0x8%0A%09CTRL_CMD_GETMCAST_GRP      = 0x9%0A%09CTRL_ATTR_UNSPEC           = 0x0%0A%09CTRL_ATTR_FAMILY_ID        = 0x1%0A%09CTRL_ATTR_FAMILY_NAME      = 0x2%0A%09CTRL_ATTR_VERSION          = 0x3%0A%09CTRL_ATTR_HDRSIZE          = 0x4%0A%09CTRL_ATTR_MAXATTR          = 0x5%0A%09CTRL_ATTR_OPS              = 0x6%0A%09CTRL_ATTR_MCAST_GROUPS     = 0x7%0A%09CTRL_ATTR_OP_UNSPEC        = 0x0%0A%09CTRL_ATTR_OP_ID            = 0x1%0A%09CTRL_ATTR_OP_FLAGS         = 0x2%0A%09CTRL_ATTR_MCAST_GRP_UNSPEC = 0x0%0A%09CTRL_ATTR_MCAST_GRP_NAME   = 0x1%0A%09CTRL_ATTR_MCAST_GRP_ID     = 0x2%0A)%0A%0Atype cpuMask uint64%0A%0Aconst (%0A%09_CPU_SETSIZE = 0x400%0A%09_NCPUBITS    = 0x40%0A)%0A%0Aconst (%0A%09BDADDR_BREDR     = 0x0%0A%09BDADDR_LE_PUBLIC = 0x1%0A%09BDADDR_LE_RANDOM = 0x2%0A)%0A%0Atype PerfEventAttr struct %7B%0A%09Type               uint32%0A%09Size               uint32%0A%09Config             uint64%0A%09Sample             uint64%0A%09Sample_type        uint64%0A%09Read_format        uint64%0A%09Bits               uint64%0A%09Wakeup             uint32%0A%09Bp_type            uint32%0A%09Ext1               uint64%0A%09Ext2               uint64%0A%09Branch_sample_type uint64%0A%09Sample_regs_user   uint64%0A%09Sample_stack_user  uint32%0A%09Clockid            int32%0A%09Sample_regs_intr   uint64%0A%09Aux_watermark      uint32%0A%09_                  uint32%0A%7D%0A%0Atype PerfEventMmapPage struct %7B%0A%09Version        uint32%0A%09Compat_version uint32%0A%09Lock           uint32%0A%09Index          uint32%0A%09Offset         int64%0A%09Time_enabled   uint64%0A%09Time_running   uint64%0A%09Capabilities   uint64%0A%09Pmc_width      uint16%0A%09Time_shift     uint16%0A%09Time_mult      uint32%0A%09Time_offset    uint64%0A%09Time_zero      uint64%0A%09Size           uint32%0A%09_              %5B948%5Duint8%0A%09Data_head      uint64%0A%09Data_tail      uint64%0A%09Data_offset    uint64%0A%09Data_size      uint64%0A%09Aux_head       uint64%0A%09Aux_tail       uint64%0A%09Aux_offset     uint64%0A%09Aux_size       uint64%0A%7D%0A%0Aconst (%0A%09PerfBitDisabled               uint64 = CBitFieldMaskBit0%0A%09PerfBitInherit                       = CBitFieldMaskBit1%0A%09PerfBitPinned                        = CBitFieldMaskBit2%0A%09PerfBitExclusive                     = CBitFieldMaskBit3%0A%09PerfBitExcludeUser                   = CBitFieldMaskBit4%0A%09PerfBitExcludeKernel                 = CBitFieldMaskBit5%0A%09PerfBitExcludeHv                     = CBitFieldMaskBit6%0A%09PerfBitExcludeIdle                   = CBitFieldMaskBit7%0A%09PerfBitMmap                          = CBitFieldMaskBit8%0A%09PerfBitComm                          = CBitFieldMaskBit9%0A%09PerfBitFreq                          = CBitFieldMaskBit10%0A%09PerfBitInheritStat                   = CBitFieldMaskBit11%0A%09PerfBitEnableOnExec                  = CBitFieldMaskBit12%0A%09PerfBitTask                          = CBitFieldMaskBit13%0A%09PerfBitWatermark                     = CBitFieldMaskBit14%0A%09PerfBitPreciseIPBit1                 = CBitFieldMaskBit15%0A%09PerfBitPreciseIPBit2                 = CBitFieldMaskBit16%0A%09PerfBitMmapData                      = CBitFieldMaskBit17%0A%09PerfBitSampleIDAll                   = CBitFieldMaskBit18%0A%09PerfBitExcludeHost                   = CBitFieldMaskBit19%0A%09PerfBitExcludeGuest                  = CBitFieldMaskBit20%0A%09PerfBitExcludeCallchainKernel        = CBitFieldMaskBit21%0A%09PerfBitExcludeCallchainUser          = CBitFieldMaskBit22%0A%09PerfBitMmap2                         = CBitFieldMaskBit23%0A%09PerfBitCommExec                      = CBitFieldMaskBit24%0A%09PerfBitUseClockID                    = CBitFieldMaskBit25%0A%09PerfBitContextSwitch                 = CBitFieldMaskBit26%0A)%0A%0Aconst (%0A%09PERF_TYPE_HARDWARE   = 0x0%0A%09PERF_TYPE_SOFTWARE   = 0x1%0A%09PERF_TYPE_TRACEPOINT = 0x2%0A%09PERF_TYPE_HW_CACHE   = 0x3%0A%09PERF_TYPE_RAW        = 0x4%0A%09PERF_TYPE_BREAKPOINT = 0x5%0A%0A%09PERF_COUNT_HW_CPU_CYCLES              = 0x0%0A%09PERF_COUNT_HW_INSTRUCTIONS            = 0x1%0A%09PERF_COUNT_HW_CACHE_REFERENCES        = 0x2%0A%09PERF_COUNT_HW_CACHE_MISSES            = 0x3%0A%09PERF_COUNT_HW_BRANCH_INSTRUCTIONS     = 0x4%0A%09PERF_COUNT_HW_BRANCH_MISSES           = 0x5%0A%09PERF_COUNT_HW_BUS_CYCLES              = 0x6%0A%09PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 0x7%0A%09PERF_COUNT_HW_STALLED_CYCLES_BACKEND  = 0x8%0A%09PERF_COUNT_HW_REF_CPU_CYCLES          = 0x9%0A%0A%09PERF_COUNT_HW_CACHE_L1D  = 0x0%0A%09PERF_COUNT_HW_CACHE_L1I  = 0x1%0A%09PERF_COUNT_HW_CACHE_LL   = 0x2%0A%09PERF_COUNT_HW_CACHE_DTLB = 0x3%0A%09PERF_COUNT_HW_CACHE_ITLB = 0x4%0A%09PERF_COUNT_HW_CACHE_BPU  = 0x5%0A%09PERF_COUNT_HW_CACHE_NODE = 0x6%0A%0A%09PERF_COUNT_HW_CACHE_OP_READ     = 0x0%0A%09PERF_COUNT_HW_CACHE_OP_WRITE    = 0x1%0A%09PERF_COUNT_HW_CACHE_OP_PREFETCH = 0x2%0A%0A%09PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0x0%0A%09PERF_COUNT_HW_CACHE_RESULT_MISS   = 0x1%0A%0A%09PERF_COUNT_SW_CPU_CLOCK        = 0x0%0A%09PERF_COUNT_SW_TASK_CLOCK       = 0x1%0A%09PERF_COUNT_SW_PAGE_FAULTS      = 0x2%0A%09PERF_COUNT_SW_CONTEXT_SWITCHES = 0x3%0A%09PERF_COUNT_SW_CPU_MIGRATIONS   = 0x4%0A%09PERF_COUNT_SW_PAGE_FAULTS_MIN  = 0x5%0A%09PERF_COUNT_SW_PAGE_FAULTS_MAJ  = 0x6%0A%09PERF_COUNT_SW_ALIGNMENT_FAULTS = 0x7%0A%09PERF_COUNT_SW_EMULATION_FAULTS = 0x8%0A%09PERF_COUNT_SW_DUMMY            = 0x9%0A%0A%09PERF_SAMPLE_IP           = 0x1%0A%09PERF_SAMPLE_TID          = 0x2%0A%09PERF_SAMPLE_TIME         = 0x4%0A%09PERF_SAMPLE_ADDR         = 0x8%0A%09PERF_SAMPLE_READ         = 0x10%0A%09PERF_SAMPLE_CALLCHAIN    = 0x20%0A%09PERF_SAMPLE_ID           = 0x40%0A%09PERF_SAMPLE_CPU          = 0x80%0A%09PERF_SAMPLE_PERIOD       = 0x100%0A%09PERF_SAMPLE_STREAM_ID    = 0x200%0A%09PERF_SAMPLE_RAW          = 0x400%0A%09PERF_SAMPLE_BRANCH_STACK = 0x800%0A%0A%09PERF_SAMPLE_BRANCH_USER       = 0x1%0A%09PERF_SAMPLE_BRANCH_KERNEL     = 0x2%0A%09PERF_SAMPLE_BRANCH_HV         = 0x4%0A%09PERF_SAMPLE_BRANCH_ANY        = 0x8%0A%09PERF_SAMPLE_BRANCH_ANY_CALL   = 0x10%0A%09PERF_SAMPLE_BRANCH_ANY_RETURN = 0x20%0A%09PERF_SAMPLE_BRANCH_IND_CALL   = 0x40%0A%0A%09PERF_FORMAT_TOTAL_TIME_ENABLED = 0x1%0A%09PERF_FORMAT_TOTAL_TIME_RUNNING = 0x2%0A%09PERF_FORMAT_ID                 = 0x4%0A%09PERF_FORMAT_GROUP              = 0x8%0A%0A%09PERF_RECORD_MMAP       = 0x1%0A%09PERF_RECORD_LOST       = 0x2%0A%09PERF_RECORD_COMM       = 0x3%0A%09PERF_RECORD_EXIT       = 0x4%0A%09PERF_RECORD_THROTTLE   = 0x5%0A%09PERF_RECORD_UNTHROTTLE = 0x6%0A%09PERF_RECORD_FORK       = 0x7%0A%09PERF_RECORD_READ       = 0x8%0A%09PERF_RECORD_SAMPLE     = 0x9%0A%0A%09PERF_CONTEXT_HV     = -0x20%0A%09PERF_CONTEXT_KERNEL = -0x80%0A%09PERF_CONTEXT_USER   = -0x200%0A%0A%09PERF_CONTEXT_GUEST        = -0x800%0A%09PERF_CONTEXT_GUEST_KERNEL = -0x880%0A%09PERF_CONTEXT_GUEST_USER   = -0xa00%0A%0A%09PERF_FLAG_FD_NO_GROUP = 0x1%0A%09PERF_FLAG_FD_OUTPUT   = 0x2%0A%09PERF_FLAG_PID_CGROUP  = 0x4%0A)%0A%0Aconst (%0A%09CBitFieldMaskBit0  = 0x8000000000000000%0A%09CBitFieldMaskBit1  = 0x4000000000000000%0A%09CBitFieldMaskBit2  = 0x2000000000000000%0A%09CBitFieldMaskBit3  = 0x1000000000000000%0A%09CBitFieldMaskBit4  = 0x800000000000000%0A%09CBitFieldMaskBit5  = 0x400000000000000%0A%09CBitFieldMaskBit6  = 0x200000000000000%0A%09CBitFieldMaskBit7  = 0x100000000000000%0A%09CBitFieldMaskBit8  = 0x80000000000000%0A%09CBitFieldMaskBit9  = 0x40000000000000%0A%09CBitFieldMaskBit10 = 0x20000000000000%0A%09CBitFieldMaskBit11 = 0x10000000000000%0A%09CBitFieldMaskBit12 = 0x8000000000000%0A%09CBitFieldMaskBit13 = 0x4000000000000%0A%09CBitFieldMaskBit14 = 0x2000000000000%0A%09CBitFieldMaskBit15 = 0x1000000000000%0A%09CBitFieldMaskBit16 = 0x800000000000%0A%09CBitFieldMaskBit17 = 0x400000000000%0A%09CBitFieldMaskBit18 = 0x200000000000%0A%09CBitFieldMaskBit19 = 0x100000000000%0A%09CBitFieldMaskBit20 = 0x80000000000%0A%09CBitFieldMaskBit21 = 0x40000000000%0A%09CBitFieldMaskBit22 = 0x20000000000%0A%09CBitFieldMaskBit23 = 0x10000000000%0A%09CBitFieldMaskBit24 = 0x8000000000%0A%09CBitFieldMaskBit25 = 0x4000000000%0A%09CBitFieldMaskBit26 = 0x2000000000%0A%09CBitFieldMaskBit27 = 0x1000000000%0A%09CBitFieldMaskBit28 = 0x800000000%0A%09CBitFieldMaskBit29 = 0x400000000%0A%09CBitFieldMaskBit30 = 0x200000000%0A%09CBitFieldMaskBit31 = 0x100000000%0A%09CBitFieldMaskBit32 = 0x80000000%0A%09CBitFieldMaskBit33 = 0x40000000%0A%09CBitFieldMaskBit34 = 0x20000000%0A%09CBitFieldMaskBit35 = 0x10000000%0A%09CBitFieldMaskBit36 = 0x8000000%0A%09CBitFieldMaskBit37 = 0x4000000%0A%09CBitFieldMaskBit38 = 0x2000000%0A%09CBitFieldMaskBit39 = 0x1000000%0A%09CBitFieldMaskBit40 = 0x800000%0A%09CBitFieldMaskBit41 = 0x400000%0A%09CBitFieldMaskBit42 = 0x200000%0A%09CBitFieldMaskBit43 = 0x100000%0A%09CBitFieldMaskBit44 = 0x80000%0A%09CBitFieldMaskBit45 = 0x40000%0A%09CBitFieldMaskBit46 = 0x20000%0A%09CBitFieldMaskBit47 = 0x10000%0A%09CBitFieldMaskBit48 = 0x8000%0A%09CBitFieldMaskBit49 = 0x4000%0A%09CBitFieldMaskBit50 = 0x2000%0A%09CBitFieldMaskBit51 = 0x1000%0A%09CBitFieldMaskBit52 = 0x800%0A%09CBitFieldMaskBit53 = 0x400%0A%09CBitFieldMaskBit54 = 0x200%0A%09CBitFieldMaskBit55 = 0x100%0A%09CBitFieldMaskBit56 = 0x80%0A%09CBitFieldMaskBit57 = 0x40%0A%09CBitFieldMaskBit58 = 0x20%0A%09CBitFieldMaskBit59 = 0x10%0A%09CBitFieldMaskBit60 = 0x8%0A%09CBitFieldMaskBit61 = 0x4%0A%09CBitFieldMaskBit62 = 0x2%0A%09CBitFieldMaskBit63 = 0x1%0A)%0A%0Atype SockaddrStorage struct %7B%0A%09Family uint16%0A%09_      %5B118%5Dint8%0A%09_      uint64%0A%7D%0A%0Atype TCPMD5Sig struct %7B%0A%09Addr      SockaddrStorage%0A%09Flags     uint8%0A%09Prefixlen uint8%0A%09Keylen    uint16%0A%09_         uint32%0A%09Key       %5B80%5Duint8%0A%7D%0A%0Atype HDDriveCmdHdr struct %7B%0A%09Command uint8%0A%09Number  uint8%0A%09Feature uint8%0A%09Count   uint8%0A%7D%0A%0Atype HDGeometry struct %7B%0A%09Heads     uint8%0A%09Sectors   uint8%0A%09Cylinders uint16%0A%09_         %5B4%5Dbyte%0A%09Start     uint64%0A%7D%0A%0Atype HDDriveID struct %7B%0A%09Config         uint16%0A%09Cyls           uint16%0A%09Reserved2      uint16%0A%09Heads          uint16%0A%09Track_bytes    uint16%0A%09Sector_bytes   uint16%0A%09Sectors        uint16%0A%09Vendor0        uint16%0A%09Vendor1        uint16%0A%09Vendor2        uint16%0A%09Serial_no      %5B20%5Duint8%0A%09Buf_type       uint16%0A%09Buf_size       uint16%0A%09Ecc_bytes      uint16%0A%09Fw_rev         %5B8%5Duint8%0A%09Model          %5B40%5Duint8%0A%09Max_multsect   uint8%0A%09Vendor3        uint8%0A%09Dword_io       uint16%0A%09Vendor4        uint8%0A%09Capability     uint8%0A%09Reserved50     uint16%0A%09Vendor5        uint8%0A%09TPIO           uint8%0A%09Vendor6        uint8%0A%09TDMA           uint8%0A%09Field_valid    uint16%0A%09Cur_cyls       uint16%0A%09Cur_heads      uint16%0A%09Cur_sectors    uint16%0A%09Cur_capacity0  uint16%0A%09Cur_capacity1  uint16%0A%09Multsect       uint8%0A%09Multsect_valid uint8%0A%09Lba_capacity   uint32%0A%09Dma_1word      uint16%0A%09Dma_mword      uint16%0A%09Eide_pio_modes uint16%0A%09Eide_dma_min   uint16%0A%09Eide_dma_time  uint16%0A%09Eide_pio       uint16%0A%09Eide_pio_iordy uint16%0A%09Words69_70     %5B2%5Duint16%0A%09Words71_74     %5B4%5Duint16%0A%09Queue_depth    uint16%0A%09Words76_79     %5B4%5Duint16%0A%09Major_rev_num  uint16%0A%09Minor_rev_num  uint16%0A%09Command_set_1  uint16%0A%09Command_set_2  uint16%0A%09Cfsse          uint16%0A%09Cfs_enable_1   uint16%0A%09Cfs_enable_2   uint16%0A%09Csf_default    uint16%0A%09Dma_ultra      uint16%0A%09Trseuc         uint16%0A%09TrsEuc         uint16%0A%09CurAPMvalues   uint16%0A%09Mprc           uint16%0A%09Hw_config      uint16%0A%09Acoustic       uint16%0A%09Msrqs          uint16%0A%09Sxfert         uint16%0A%09Sal            uint16%0A%09Spg            uint32%0A%09Lba_capacity_2 uint64%0A%09Words104_125   %5B22%5Duint16%0A%09Last_lun       uint16%0A%09Word127        uint16%0A%09Dlf            uint16%0A%09Csfo           uint16%0A%09Words130_155   %5B26%5Duint16%0A%09Word156        uint16%0A%09Words157_159   %5B3%5Duint16%0A%09Cfa_power      uint16%0A%09Words161_175   %5B15%5Duint16%0A%09Words176_205   %5B30%5Duint16%0A%09Words206_254   %5B49%5Duint16%0A%09Integrity_word uint16%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    uint32%0A%09Bsize   uint32%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen uint32%0A%09Frsize  uint32%0A%09Flags   uint32%0A%09Spare   %5B4%5Duint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09ST_MANDLOCK    = 0x40%0A%09ST_NOATIME     = 0x400%0A%09ST_NODEV       = 0x4%0A%09ST_NODIRATIME  = 0x800%0A%09ST_NOEXEC      = 0x8%0A%09ST_NOSUID      = 0x2%0A%09ST_RDONLY      = 0x1%0A%09ST_RELATIME    = 0x1000%0A%09ST_SYNCHRONOUS = 0x10%0A)%0A%0Atype TpacketHdr struct %7B%0A%09Status  uint64%0A%09Len     uint32%0A%09Snaplen uint32%0A%09Mac     uint16%0A%09Net     uint16%0A%09Sec     uint32%0A%09Usec    uint32%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Atype Tpacket2Hdr struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Sec       uint32%0A%09Nsec      uint32%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%09_         %5B4%5Duint8%0A%7D%0A%0Atype Tpacket3Hdr struct %7B%0A%09Next_offset uint32%0A%09Sec         uint32%0A%09Nsec        uint32%0A%09Snaplen     uint32%0A%09Len         uint32%0A%09Status      uint32%0A%09Mac         uint16%0A%09Net         uint16%0A%09Hv1         TpacketHdrVariant1%0A%09_           %5B8%5Duint8%0A%7D%0A%0Atype TpacketHdrVariant1 struct %7B%0A%09Rxhash    uint32%0A%09Vlan_tci  uint32%0A%09Vlan_tpid uint16%0A%09_         uint16%0A%7D%0A%0Atype TpacketBlockDesc struct %7B%0A%09Version uint32%0A%09To_priv uint32%0A%09Hdr     %5B40%5Dbyte%0A%7D%0A%0Atype TpacketReq struct %7B%0A%09Block_size uint32%0A%09Block_nr   uint32%0A%09Frame_size uint32%0A%09Frame_nr   uint32%0A%7D%0A%0Atype TpacketReq3 struct %7B%0A%09Block_size       uint32%0A%09Block_nr         uint32%0A%09Frame_size       uint32%0A%09Frame_nr         uint32%0A%09Retire_blk_tov   uint32%0A%09Sizeof_priv      uint32%0A%09Feature_req_word uint32%0A%7D%0A%0Atype TpacketStats struct %7B%0A%09Packets uint32%0A%09Drops   uint32%0A%7D%0A%0Atype TpacketStatsV3 struct %7B%0A%09Packets      uint32%0A%09Drops        uint32%0A%09Freeze_q_cnt uint32%0A%7D%0A%0Atype TpacketAuxdata struct %7B%0A%09Status    uint32%0A%09Len       uint32%0A%09Snaplen   uint32%0A%09Mac       uint16%0A%09Net       uint16%0A%09Vlan_tci  uint16%0A%09Vlan_tpid uint16%0A%7D%0A%0Aconst (%0A%09TPACKET_V1 = 0x0%0A%09TPACKET_V2 = 0x1%0A%09TPACKET_V3 = 0x2%0A)%0A%0Aconst (%0A%09SizeofTpacketHdr  = 0x20%0A%09SizeofTpacket2Hdr = 0x20%0A%09SizeofTpacket3Hdr = 0x30%0A)%0A%0Aconst (%0A%09NF_INET_PRE_ROUTING  = 0x0%0A%09NF_INET_LOCAL_IN     = 0x1%0A%09NF_INET_FORWARD      = 0x2%0A%09NF_INET_LOCAL_OUT    = 0x3%0A%09NF_INET_POST_ROUTING = 0x4%0A%09NF_INET_NUMHOOKS     = 0x5%0A)%0A%0Aconst (%0A%09NF_NETDEV_INGRESS  = 0x0%0A%09NF_NETDEV_NUMHOOKS = 0x1%0A)%0A%0Aconst (%0A%09NFPROTO_UNSPEC   = 0x0%0A%09NFPROTO_INET     = 0x1%0A%09NFPROTO_IPV4     = 0x2%0A%09NFPROTO_ARP      = 0x3%0A%09NFPROTO_NETDEV   = 0x5%0A%09NFPROTO_BRIDGE   = 0x7%0A%09NFPROTO_IPV6     = 0xa%0A%09NFPROTO_DECNET   = 0xc%0A%09NFPROTO_NUMPROTO = 0xd%0A)%0A%0Atype Nfgenmsg struct %7B%0A%09Nfgen_family uint8%0A%09Version      uint8%0A%09Res_id       uint16%0A%7D%0A%0Aconst (%0A%09NFNL_BATCH_UNSPEC = 0x0%0A%09NFNL_BATCH_GENID  = 0x1%0A)%0A%0Aconst (%0A%09NFT_REG_VERDICT                   = 0x0%0A%09NFT_REG_1                         = 0x1%0A%09NFT_REG_2                         = 0x2%0A%09NFT_REG_3                         = 0x3%0A%09NFT_REG_4                         = 0x4%0A%09NFT_REG32_00                      = 0x8%0A%09NFT_REG32_01                      = 0x9%0A%09NFT_REG32_02                      = 0xa%0A%09NFT_REG32_03                      = 0xb%0A%09NFT_REG32_04                      = 0xc%0A%09NFT_REG32_05                      = 0xd%0A%09NFT_REG32_06                      = 0xe%0A%09NFT_REG32_07                      = 0xf%0A%09NFT_REG32_08                      = 0x10%0A%09NFT_REG32_09                      = 0x11%0A%09NFT_REG32_10                      = 0x12%0A%09NFT_REG32_11                      = 0x13%0A%09NFT_REG32_12                      = 0x14%0A%09NFT_REG32_13                      = 0x15%0A%09NFT_REG32_14                      = 0x16%0A%09NFT_REG32_15                      = 0x17%0A%09NFT_CONTINUE                      = -0x1%0A%09NFT_BREAK                         = -0x2%0A%09NFT_JUMP                          = -0x3%0A%09NFT_GOTO                          = -0x4%0A%09NFT_RETURN                        = -0x5%0A%09NFT_MSG_NEWTABLE                  = 0x0%0A%09NFT_MSG_GETTABLE                  = 0x1%0A%09NFT_MSG_DELTABLE                  = 0x2%0A%09NFT_MSG_NEWCHAIN                  = 0x3%0A%09NFT_MSG_GETCHAIN                  = 0x4%0A%09NFT_MSG_DELCHAIN                  = 0x5%0A%09NFT_MSG_NEWRULE                   = 0x6%0A%09NFT_MSG_GETRULE                   = 0x7%0A%09NFT_MSG_DELRULE                   = 0x8%0A%09NFT_MSG_NEWSET                    = 0x9%0A%09NFT_MSG_GETSET                    = 0xa%0A%09NFT_MSG_DELSET                    = 0xb%0A%09NFT_MSG_NEWSETELEM                = 0xc%0A%09NFT_MSG_GETSETELEM                = 0xd%0A%09NFT_MSG_DELSETELEM                = 0xe%0A%09NFT_MSG_NEWGEN                    = 0xf%0A%09NFT_MSG_GETGEN                    = 0x10%0A%09NFT_MSG_TRACE                     = 0x11%0A%09NFT_MSG_NEWOBJ                    = 0x12%0A%09NFT_MSG_GETOBJ                    = 0x13%0A%09NFT_MSG_DELOBJ                    = 0x14%0A%09NFT_MSG_GETOBJ_RESET              = 0x15%0A%09NFT_MSG_MAX                       = 0x19%0A%09NFTA_LIST_UNPEC                   = 0x0%0A%09NFTA_LIST_ELEM                    = 0x1%0A%09NFTA_HOOK_UNSPEC                  = 0x0%0A%09NFTA_HOOK_HOOKNUM                 = 0x1%0A%09NFTA_HOOK_PRIORITY                = 0x2%0A%09NFTA_HOOK_DEV                     = 0x3%0A%09NFT_TABLE_F_DORMANT               = 0x1%0A%09NFTA_TABLE_UNSPEC                 = 0x0%0A%09NFTA_TABLE_NAME                   = 0x1%0A%09NFTA_TABLE_FLAGS                  = 0x2%0A%09NFTA_TABLE_USE                    = 0x3%0A%09NFTA_CHAIN_UNSPEC                 = 0x0%0A%09NFTA_CHAIN_TABLE                  = 0x1%0A%09NFTA_CHAIN_HANDLE                 = 0x2%0A%09NFTA_CHAIN_NAME                   = 0x3%0A%09NFTA_CHAIN_HOOK                   = 0x4%0A%09NFTA_CHAIN_POLICY                 = 0x5%0A%09NFTA_CHAIN_USE                    = 0x6%0A%09NFTA_CHAIN_TYPE                   = 0x7%0A%09NFTA_CHAIN_COUNTERS               = 0x8%0A%09NFTA_CHAIN_PAD                    = 0x9%0A%09NFTA_RULE_UNSPEC                  = 0x0%0A%09NFTA_RULE_TABLE                   = 0x1%0A%09NFTA_RULE_CHAIN                   = 0x2%0A%09NFTA_RULE_HANDLE                  = 0x3%0A%09NFTA_RULE_EXPRESSIONS             = 0x4%0A%09NFTA_RULE_COMPAT                  = 0x5%0A%09NFTA_RULE_POSITION                = 0x6%0A%09NFTA_RULE_USERDATA                = 0x7%0A%09NFTA_RULE_PAD                     = 0x8%0A%09NFTA_RULE_ID                      = 0x9%0A%09NFT_RULE_COMPAT_F_INV             = 0x2%0A%09NFT_RULE_COMPAT_F_MASK            = 0x2%0A%09NFTA_RULE_COMPAT_UNSPEC           = 0x0%0A%09NFTA_RULE_COMPAT_PROTO            = 0x1%0A%09NFTA_RULE_COMPAT_FLAGS            = 0x2%0A%09NFT_SET_ANONYMOUS                 = 0x1%0A%09NFT_SET_CONSTANT                  = 0x2%0A%09NFT_SET_INTERVAL                  = 0x4%0A%09NFT_SET_MAP                       = 0x8%0A%09NFT_SET_TIMEOUT                   = 0x10%0A%09NFT_SET_EVAL                      = 0x20%0A%09NFT_SET_OBJECT                    = 0x40%0A%09NFT_SET_POL_PERFORMANCE           = 0x0%0A%09NFT_SET_POL_MEMORY                = 0x1%0A%09NFTA_SET_DESC_UNSPEC              = 0x0%0A%09NFTA_SET_DESC_SIZE                = 0x1%0A%09NFTA_SET_UNSPEC                   = 0x0%0A%09NFTA_SET_TABLE                    = 0x1%0A%09NFTA_SET_NAME                     = 0x2%0A%09NFTA_SET_FLAGS                    = 0x3%0A%09NFTA_SET_KEY_TYPE                 = 0x4%0A%09NFTA_SET_KEY_LEN                  = 0x5%0A%09NFTA_SET_DATA_TYPE                = 0x6%0A%09NFTA_SET_DATA_LEN                 = 0x7%0A%09NFTA_SET_POLICY                   = 0x8%0A%09NFTA_SET_DESC                     = 0x9%0A%09NFTA_SET_ID                       = 0xa%0A%09NFTA_SET_TIMEOUT                  = 0xb%0A%09NFTA_SET_GC_INTERVAL              = 0xc%0A%09NFTA_SET_USERDATA                 = 0xd%0A%09NFTA_SET_PAD                      = 0xe%0A%09NFTA_SET_OBJ_TYPE                 = 0xf%0A%09NFT_SET_ELEM_INTERVAL_END         = 0x1%0A%09NFTA_SET_ELEM_UNSPEC              = 0x0%0A%09NFTA_SET_ELEM_KEY                 = 0x1%0A%09NFTA_SET_ELEM_DATA                = 0x2%0A%09NFTA_SET_ELEM_FLAGS               = 0x3%0A%09NFTA_SET_ELEM_TIMEOUT             = 0x4%0A%09NFTA_SET_ELEM_EXPIRATION          = 0x5%0A%09NFTA_SET_ELEM_USERDATA            = 0x6%0A%09NFTA_SET_ELEM_EXPR                = 0x7%0A%09NFTA_SET_ELEM_PAD                 = 0x8%0A%09NFTA_SET_ELEM_OBJREF              = 0x9%0A%09NFTA_SET_ELEM_LIST_UNSPEC         = 0x0%0A%09NFTA_SET_ELEM_LIST_TABLE          = 0x1%0A%09NFTA_SET_ELEM_LIST_SET            = 0x2%0A%09NFTA_SET_ELEM_LIST_ELEMENTS       = 0x3%0A%09NFTA_SET_ELEM_LIST_SET_ID         = 0x4%0A%09NFT_DATA_VALUE                    = 0x0%0A%09NFT_DATA_VERDICT                  = 0xffffff00%0A%09NFTA_DATA_UNSPEC                  = 0x0%0A%09NFTA_DATA_VALUE                   = 0x1%0A%09NFTA_DATA_VERDICT                 = 0x2%0A%09NFTA_VERDICT_UNSPEC               = 0x0%0A%09NFTA_VERDICT_CODE                 = 0x1%0A%09NFTA_VERDICT_CHAIN                = 0x2%0A%09NFTA_EXPR_UNSPEC                  = 0x0%0A%09NFTA_EXPR_NAME                    = 0x1%0A%09NFTA_EXPR_DATA                    = 0x2%0A%09NFTA_IMMEDIATE_UNSPEC             = 0x0%0A%09NFTA_IMMEDIATE_DREG               = 0x1%0A%09NFTA_IMMEDIATE_DATA               = 0x2%0A%09NFTA_BITWISE_UNSPEC               = 0x0%0A%09NFTA_BITWISE_SREG                 = 0x1%0A%09NFTA_BITWISE_DREG                 = 0x2%0A%09NFTA_BITWISE_LEN                  = 0x3%0A%09NFTA_BITWISE_MASK                 = 0x4%0A%09NFTA_BITWISE_XOR                  = 0x5%0A%09NFT_BYTEORDER_NTOH                = 0x0%0A%09NFT_BYTEORDER_HTON                = 0x1%0A%09NFTA_BYTEORDER_UNSPEC             = 0x0%0A%09NFTA_BYTEORDER_SREG               = 0x1%0A%09NFTA_BYTEORDER_DREG               = 0x2%0A%09NFTA_BYTEORDER_OP                 = 0x3%0A%09NFTA_BYTEORDER_LEN                = 0x4%0A%09NFTA_BYTEORDER_SIZE               = 0x5%0A%09NFT_CMP_EQ                        = 0x0%0A%09NFT_CMP_NEQ                       = 0x1%0A%09NFT_CMP_LT                        = 0x2%0A%09NFT_CMP_LTE                       = 0x3%0A%09NFT_CMP_GT                        = 0x4%0A%09NFT_CMP_GTE                       = 0x5%0A%09NFTA_CMP_UNSPEC                   = 0x0%0A%09NFTA_CMP_SREG                     = 0x1%0A%09NFTA_CMP_OP                       = 0x2%0A%09NFTA_CMP_DATA                     = 0x3%0A%09NFT_RANGE_EQ                      = 0x0%0A%09NFT_RANGE_NEQ                     = 0x1%0A%09NFTA_RANGE_UNSPEC                 = 0x0%0A%09NFTA_RANGE_SREG                   = 0x1%0A%09NFTA_RANGE_OP                     = 0x2%0A%09NFTA_RANGE_FROM_DATA              = 0x3%0A%09NFTA_RANGE_TO_DATA                = 0x4%0A%09NFT_LOOKUP_F_INV                  = 0x1%0A%09NFTA_LOOKUP_UNSPEC                = 0x0%0A%09NFTA_LOOKUP_SET                   = 0x1%0A%09NFTA_LOOKUP_SREG                  = 0x2%0A%09NFTA_LOOKUP_DREG                  = 0x3%0A%09NFTA_LOOKUP_SET_ID                = 0x4%0A%09NFTA_LOOKUP_FLAGS                 = 0x5%0A%09NFT_DYNSET_OP_ADD                 = 0x0%0A%09NFT_DYNSET_OP_UPDATE              = 0x1%0A%09NFT_DYNSET_F_INV                  = 0x1%0A%09NFTA_DYNSET_UNSPEC                = 0x0%0A%09NFTA_DYNSET_SET_NAME              = 0x1%0A%09NFTA_DYNSET_SET_ID                = 0x2%0A%09NFTA_DYNSET_OP                    = 0x3%0A%09NFTA_DYNSET_SREG_KEY              = 0x4%0A%09NFTA_DYNSET_SREG_DATA             = 0x5%0A%09NFTA_DYNSET_TIMEOUT               = 0x6%0A%09NFTA_DYNSET_EXPR                  = 0x7%0A%09NFTA_DYNSET_PAD                   = 0x8%0A%09NFTA_DYNSET_FLAGS                 = 0x9%0A%09NFT_PAYLOAD_LL_HEADER             = 0x0%0A%09NFT_PAYLOAD_NETWORK_HEADER        = 0x1%0A%09NFT_PAYLOAD_TRANSPORT_HEADER      = 0x2%0A%09NFT_PAYLOAD_CSUM_NONE             = 0x0%0A%09NFT_PAYLOAD_CSUM_INET             = 0x1%0A%09NFT_PAYLOAD_L4CSUM_PSEUDOHDR      = 0x1%0A%09NFTA_PAYLOAD_UNSPEC               = 0x0%0A%09NFTA_PAYLOAD_DREG                 = 0x1%0A%09NFTA_PAYLOAD_BASE                 = 0x2%0A%09NFTA_PAYLOAD_OFFSET               = 0x3%0A%09NFTA_PAYLOAD_LEN                  = 0x4%0A%09NFTA_PAYLOAD_SREG                 = 0x5%0A%09NFTA_PAYLOAD_CSUM_TYPE            = 0x6%0A%09NFTA_PAYLOAD_CSUM_OFFSET          = 0x7%0A%09NFTA_PAYLOAD_CSUM_FLAGS           = 0x8%0A%09NFT_EXTHDR_F_PRESENT              = 0x1%0A%09NFT_EXTHDR_OP_IPV6                = 0x0%0A%09NFT_EXTHDR_OP_TCPOPT              = 0x1%0A%09NFTA_EXTHDR_UNSPEC                = 0x0%0A%09NFTA_EXTHDR_DREG                  = 0x1%0A%09NFTA_EXTHDR_TYPE                  = 0x2%0A%09NFTA_EXTHDR_OFFSET                = 0x3%0A%09NFTA_EXTHDR_LEN                   = 0x4%0A%09NFTA_EXTHDR_FLAGS                 = 0x5%0A%09NFTA_EXTHDR_OP                    = 0x6%0A%09NFTA_EXTHDR_SREG                  = 0x7%0A%09NFT_META_LEN                      = 0x0%0A%09NFT_META_PROTOCOL                 = 0x1%0A%09NFT_META_PRIORITY                 = 0x2%0A%09NFT_META_MARK                     = 0x3%0A%09NFT_META_IIF                      = 0x4%0A%09NFT_META_OIF                      = 0x5%0A%09NFT_META_IIFNAME                  = 0x6%0A%09NFT_META_OIFNAME                  = 0x7%0A%09NFT_META_IIFTYPE                  = 0x8%0A%09NFT_META_OIFTYPE                  = 0x9%0A%09NFT_META_SKUID                    = 0xa%0A%09NFT_META_SKGID                    = 0xb%0A%09NFT_META_NFTRACE                  = 0xc%0A%09NFT_META_RTCLASSID                = 0xd%0A%09NFT_META_SECMARK                  = 0xe%0A%09NFT_META_NFPROTO                  = 0xf%0A%09NFT_META_L4PROTO                  = 0x10%0A%09NFT_META_BRI_IIFNAME              = 0x11%0A%09NFT_META_BRI_OIFNAME              = 0x12%0A%09NFT_META_PKTTYPE                  = 0x13%0A%09NFT_META_CPU                      = 0x14%0A%09NFT_META_IIFGROUP                 = 0x15%0A%09NFT_META_OIFGROUP                 = 0x16%0A%09NFT_META_CGROUP                   = 0x17%0A%09NFT_META_PRANDOM                  = 0x18%0A%09NFT_RT_CLASSID                    = 0x0%0A%09NFT_RT_NEXTHOP4                   = 0x1%0A%09NFT_RT_NEXTHOP6                   = 0x2%0A%09NFT_RT_TCPMSS                     = 0x3%0A%09NFT_HASH_JENKINS                  = 0x0%0A%09NFT_HASH_SYM                      = 0x1%0A%09NFTA_HASH_UNSPEC                  = 0x0%0A%09NFTA_HASH_SREG                    = 0x1%0A%09NFTA_HASH_DREG                    = 0x2%0A%09NFTA_HASH_LEN                     = 0x3%0A%09NFTA_HASH_MODULUS                 = 0x4%0A%09NFTA_HASH_SEED                    = 0x5%0A%09NFTA_HASH_OFFSET                  = 0x6%0A%09NFTA_HASH_TYPE                    = 0x7%0A%09NFTA_META_UNSPEC                  = 0x0%0A%09NFTA_META_DREG                    = 0x1%0A%09NFTA_META_KEY                     = 0x2%0A%09NFTA_META_SREG                    = 0x3%0A%09NFTA_RT_UNSPEC                    = 0x0%0A%09NFTA_RT_DREG                      = 0x1%0A%09NFTA_RT_KEY                       = 0x2%0A%09NFT_CT_STATE                      = 0x0%0A%09NFT_CT_DIRECTION                  = 0x1%0A%09NFT_CT_STATUS                     = 0x2%0A%09NFT_CT_MARK                       = 0x3%0A%09NFT_CT_SECMARK                    = 0x4%0A%09NFT_CT_EXPIRATION                 = 0x5%0A%09NFT_CT_HELPER                     = 0x6%0A%09NFT_CT_L3PROTOCOL                 = 0x7%0A%09NFT_CT_SRC                        = 0x8%0A%09NFT_CT_DST                        = 0x9%0A%09NFT_CT_PROTOCOL                   = 0xa%0A%09NFT_CT_PROTO_SRC                  = 0xb%0A%09NFT_CT_PROTO_DST                  = 0xc%0A%09NFT_CT_LABELS                     = 0xd%0A%09NFT_CT_PKTS                       = 0xe%0A%09NFT_CT_BYTES                      = 0xf%0A%09NFT_CT_AVGPKT                     = 0x10%0A%09NFT_CT_ZONE                       = 0x11%0A%09NFT_CT_EVENTMASK                  = 0x12%0A%09NFTA_CT_UNSPEC                    = 0x0%0A%09NFTA_CT_DREG                      = 0x1%0A%09NFTA_CT_KEY                       = 0x2%0A%09NFTA_CT_DIRECTION                 = 0x3%0A%09NFTA_CT_SREG                      = 0x4%0A%09NFT_LIMIT_PKTS                    = 0x0%0A%09NFT_LIMIT_PKT_BYTES               = 0x1%0A%09NFT_LIMIT_F_INV                   = 0x1%0A%09NFTA_LIMIT_UNSPEC                 = 0x0%0A%09NFTA_LIMIT_RATE                   = 0x1%0A%09NFTA_LIMIT_UNIT                   = 0x2%0A%09NFTA_LIMIT_BURST                  = 0x3%0A%09NFTA_LIMIT_TYPE                   = 0x4%0A%09NFTA_LIMIT_FLAGS                  = 0x5%0A%09NFTA_LIMIT_PAD                    = 0x6%0A%09NFTA_COUNTER_UNSPEC               = 0x0%0A%09NFTA_COUNTER_BYTES                = 0x1%0A%09NFTA_COUNTER_PACKETS              = 0x2%0A%09NFTA_COUNTER_PAD                  = 0x3%0A%09NFTA_LOG_UNSPEC                   = 0x0%0A%09NFTA_LOG_GROUP                    = 0x1%0A%09NFTA_LOG_PREFIX                   = 0x2%0A%09NFTA_LOG_SNAPLEN                  = 0x3%0A%09NFTA_LOG_QTHRESHOLD               = 0x4%0A%09NFTA_LOG_LEVEL                    = 0x5%0A%09NFTA_LOG_FLAGS                    = 0x6%0A%09NFTA_QUEUE_UNSPEC                 = 0x0%0A%09NFTA_QUEUE_NUM                    = 0x1%0A%09NFTA_QUEUE_TOTAL                  = 0x2%0A%09NFTA_QUEUE_FLAGS                  = 0x3%0A%09NFTA_QUEUE_SREG_QNUM              = 0x4%0A%09NFT_QUOTA_F_INV                   = 0x1%0A%09NFT_QUOTA_F_DEPLETED              = 0x2%0A%09NFTA_QUOTA_UNSPEC                 = 0x0%0A%09NFTA_QUOTA_BYTES                  = 0x1%0A%09NFTA_QUOTA_FLAGS                  = 0x2%0A%09NFTA_QUOTA_PAD                    = 0x3%0A%09NFTA_QUOTA_CONSUMED               = 0x4%0A%09NFT_REJECT_ICMP_UNREACH           = 0x0%0A%09NFT_REJECT_TCP_RST                = 0x1%0A%09NFT_REJECT_ICMPX_UNREACH          = 0x2%0A%09NFT_REJECT_ICMPX_NO_ROUTE         = 0x0%0A%09NFT_REJECT_ICMPX_PORT_UNREACH     = 0x1%0A%09NFT_REJECT_ICMPX_HOST_UNREACH     = 0x2%0A%09NFT_REJECT_ICMPX_ADMIN_PROHIBITED = 0x3%0A%09NFTA_REJECT_UNSPEC                = 0x0%0A%09NFTA_REJECT_TYPE                  = 0x1%0A%09NFTA_REJECT_ICMP_CODE             = 0x2%0A%09NFT_NAT_SNAT                      = 0x0%0A%09NFT_NAT_DNAT                      = 0x1%0A%09NFTA_NAT_UNSPEC                   = 0x0%0A%09NFTA_NAT_TYPE                     = 0x1%0A%09NFTA_NAT_FAMILY                   = 0x2%0A%09NFTA_NAT_REG_ADDR_MIN             = 0x3%0A%09NFTA_NAT_REG_ADDR_MAX             = 0x4%0A%09NFTA_NAT_REG_PROTO_MIN            = 0x5%0A%09NFTA_NAT_REG_PROTO_MAX            = 0x6%0A%09NFTA_NAT_FLAGS                    = 0x7%0A%09NFTA_MASQ_UNSPEC                  = 0x0%0A%09NFTA_MASQ_FLAGS                   = 0x1%0A%09NFTA_MASQ_REG_PROTO_MIN           = 0x2%0A%09NFTA_MASQ_REG_PROTO_MAX           = 0x3%0A%09NFTA_REDIR_UNSPEC                 = 0x0%0A%09NFTA_REDIR_REG_PROTO_MIN          = 0x1%0A%09NFTA_REDIR_REG_PROTO_MAX          = 0x2%0A%09NFTA_REDIR_FLAGS                  = 0x3%0A%09NFTA_DUP_UNSPEC                   = 0x0%0A%09NFTA_DUP_SREG_ADDR                = 0x1%0A%09NFTA_DUP_SREG_DEV                 = 0x2%0A%09NFTA_FWD_UNSPEC                   = 0x0%0A%09NFTA_FWD_SREG_DEV                 = 0x1%0A%09NFTA_OBJREF_UNSPEC                = 0x0%0A%09NFTA_OBJREF_IMM_TYPE              = 0x1%0A%09NFTA_OBJREF_IMM_NAME              = 0x2%0A%09NFTA_OBJREF_SET_SREG              = 0x3%0A%09NFTA_OBJREF_SET_NAME              = 0x4%0A%09NFTA_OBJREF_SET_ID                = 0x5%0A%09NFTA_GEN_UNSPEC                   = 0x0%0A%09NFTA_GEN_ID                       = 0x1%0A%09NFTA_GEN_PROC_PID                 = 0x2%0A%09NFTA_GEN_PROC_NAME                = 0x3%0A%09NFTA_FIB_UNSPEC                   = 0x0%0A%09NFTA_FIB_DREG                     = 0x1%0A%09NFTA_FIB_RESULT                   = 0x2%0A%09NFTA_FIB_FLAGS                    = 0x3%0A%09NFT_FIB_RESULT_UNSPEC             = 0x0%0A%09NFT_FIB_RESULT_OIF                = 0x1%0A%09NFT_FIB_RESULT_OIFNAME            = 0x2%0A%09NFT_FIB_RESULT_ADDRTYPE           = 0x3%0A%09NFTA_FIB_F_SADDR                  = 0x1%0A%09NFTA_FIB_F_DADDR                  = 0x2%0A%09NFTA_FIB_F_MARK                   = 0x4%0A%09NFTA_FIB_F_IIF                    = 0x8%0A%09NFTA_FIB_F_OIF                    = 0x10%0A%09NFTA_FIB_F_PRESENT                = 0x20%0A%09NFTA_CT_HELPER_UNSPEC             = 0x0%0A%09NFTA_CT_HELPER_NAME               = 0x1%0A%09NFTA_CT_HELPER_L3PROTO            = 0x2%0A%09NFTA_CT_HELPER_L4PROTO            = 0x3%0A%09NFTA_OBJ_UNSPEC                   = 0x0%0A%09NFTA_OBJ_TABLE                    = 0x1%0A%09NFTA_OBJ_NAME                     = 0x2%0A%09NFTA_OBJ_TYPE                     = 0x3%0A%09NFTA_OBJ_DATA                     = 0x4%0A%09NFTA_OBJ_USE                      = 0x5%0A%09NFTA_TRACE_UNSPEC                 = 0x0%0A%09NFTA_TRACE_TABLE                  = 0x1%0A%09NFTA_TRACE_CHAIN                  = 0x2%0A%09NFTA_TRACE_RULE_HANDLE            = 0x3%0A%09NFTA_TRACE_TYPE                   = 0x4%0A%09NFTA_TRACE_VERDICT                = 0x5%0A%09NFTA_TRACE_ID                     = 0x6%0A%09NFTA_TRACE_LL_HEADER              = 0x7%0A%09NFTA_TRACE_NETWORK_HEADER         = 0x8%0A%09NFTA_TRACE_TRANSPORT_HEADER       = 0x9%0A%09NFTA_TRACE_IIF                    = 0xa%0A%09NFTA_TRACE_IIFTYPE                = 0xb%0A%09NFTA_TRACE_OIF                    = 0xc%0A%09NFTA_TRACE_OIFTYPE                = 0xd%0A%09NFTA_TRACE_MARK                   = 0xe%0A%09NFTA_TRACE_NFPROTO                = 0xf%0A%09NFTA_TRACE_POLICY                 = 0x10%0A%09NFTA_TRACE_PAD                    = 0x11%0A%09NFT_TRACETYPE_UNSPEC              = 0x0%0A%09NFT_TRACETYPE_POLICY              = 0x1%0A%09NFT_TRACETYPE_RETURN              = 0x2%0A%09NFT_TRACETYPE_RULE                = 0x3%0A%09NFTA_NG_UNSPEC                    = 0x0%0A%09NFTA_NG_DREG                      = 0x1%0A%09NFTA_NG_MODULUS                   = 0x2%0A%09NFTA_NG_TYPE                      = 0x3%0A%09NFTA_NG_OFFSET                    = 0x4%0A%09NFT_NG_INCREMENTAL                = 0x0%0A%09NFT_NG_RANDOM                     = 0x1%0A)%0A%0Atype RTCTime struct %7B%0A%09Sec   int32%0A%09Min   int32%0A%09Hour  int32%0A%09Mday  int32%0A%09Mon   int32%0A%09Year  int32%0A%09Wday  int32%0A%09Yday  int32%0A%09Isdst int32%0A%7D%0A%0Atype RTCWkAlrm struct %7B%0A%09Enabled uint8%0A%09Pending uint8%0A%09_       %5B2%5Dbyte%0A%09Time    RTCTime%0A%7D%0A%0Atype RTCPLLInfo struct %7B%0A%09Ctrl    int32%0A%09Value   int32%0A%09Max     int32%0A%09Min     int32%0A%09Posmult int32%0A%09Negmult int32%0A%09Clock   int64%0A%7D%0A%0Atype BlkpgIoctlArg struct %7B%0A%09Op      int32%0A%09Flags   int32%0A%09Datalen int32%0A%09_       %5B4%5Dbyte%0A%09Data    *byte%0A%7D%0A%0Atype BlkpgPartition struct %7B%0A%09Start   int64%0A%09Length  int64%0A%09Pno     int32%0A%09Devname %5B64%5Duint8%0A%09Volname %5B64%5Duint8%0A%09_       %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09BLKPG                  = 0x1269%0A%09BLKPG_ADD_PARTITION    = 0x1%0A%09BLKPG_DEL_PARTITION    = 0x2%0A%09BLKPG_RESIZE_PARTITION = 0x3%0A)%0A%0Aconst (%0A%09NETNSA_NONE = 0x0%0A%09NETNSA_NSID = 0x1%0A%09NETNSA_PID  = 0x2%0A%09NETNSA_FD   = 0x3%0A)%0A%0Atype XDPRingOffset struct %7B%0A%09Producer uint64%0A%09Consumer uint64%0A%09Desc     uint64%0A%7D%0A%0Atype XDPMmapOffsets struct %7B%0A%09Rx XDPRingOffset%0A%09Tx XDPRingOffset%0A%09Fr XDPRingOffset%0A%09Cr XDPRingOffset%0A%7D%0A%0Atype XDPUmemReg struct %7B%0A%09Addr     uint64%0A%09Len      uint64%0A%09Size     uint32%0A%09Headroom uint32%0A%7D%0A%0Atype XDPStatistics struct %7B%0A%09Rx_dropped       uint64%0A%09Rx_invalid_descs uint64%0A%09Tx_invalid_descs uint64%0A%7D%0A%0Atype XDPDesc struct %7B%0A%09Addr    uint64%0A%09Len     uint32%0A%09Options uint32%0A%7D%0A
- f 07fbd054547d7b6016303e8f4848bf96ef3970834d0c86df01e03e1388cf6cb6 vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go
+ f bbaead6d239c564329da2096120786ed22cc31335129edb83900a746101ca925 vendor/golang.org/x/sys/unix/ztypes_linux_sparc64.go
dmppatch 4
@@ -121,16 +121,12002 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x1000%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec       int64%0A%09Usec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Timex struct %7B%0A%09Modes     uint32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Offset    int64%0A%09Freq      int64%0A%09Maxerror  int64%0A%09Esterror  int64%0A%09Status    int32%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%09Constant  int64%0A%09Precision int64%0A%09Tolerance int64%0A%09Time      Timeval%0A%09Tick      int64%0A%09Ppsfreq   int64%0A%09Jitter    int64%0A%09Shift     int32%0A%09Pad_cgo_2 %5B4%5Dbyte%0A%09Stabil    int64%0A%09Jitcnt    int64%0A%09Calcnt    int64%0A%09Errcnt    int64%0A%09Stbcnt    int64%0A%09Tai       int32%0A%09Pad_cgo_3 %5B44%5Dbyte%0A%7D%0A%0Atype Time_t int64%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev                uint64%0A%09X__pad1            uint16%0A%09Pad_cgo_0          %5B6%5Dbyte%0A%09Ino                uint64%0A%09Mode               uint32%0A%09Nlink              uint32%0A%09Uid                uint32%0A%09Gid                uint32%0A%09Rdev               uint64%0A%09X__pad2            uint16%0A%09Pad_cgo_1          %5B6%5Dbyte%0A%09Size               int64%0A%09Blksize            int64%0A%09Blocks             int64%0A%09Atim               Timespec%0A%09Mtim               Timespec%0A%09Ctim               Timespec%0A%09X__glibc_reserved4 uint64%0A%09X__glibc_reserved5 uint64%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09Type    int64%0A%09Bsize   int64%0A%09Blocks  uint64%0A%09Bfree   uint64%0A%09Bavail  uint64%0A%09Files   uint64%0A%09Ffree   uint64%0A%09Fsid    Fsid%0A%09Namelen int64%0A%09Frsize  int64%0A%09Flags   int64%0A%09Spare   %5B4%5Dint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino       uint64%0A%09Off       int64%0A%09Reclen    uint16%0A%09Type      uint8%0A%09Name      %5B256%5Dint8%0A%09Pad_cgo_0 %5B5%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09X__val %5B2%5Dint32%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type              int16%0A%09Whence            int16%0A%09Pad_cgo_0         %5B4%5Dbyte%0A%09Start             int64%0A%09Len               int64%0A%09Pid               int32%0A%09X__glibc_reserved int16%0A%09Pad_cgo_1         %5B2%5Dbyte%0A%7D%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrLinklayer struct %7B%0A%09Family   uint16%0A%09Protocol uint16%0A%09Ifindex  int32%0A%09Hatype   uint16%0A%09Pkttype  uint8%0A%09Halen    uint8%0A%09Addr     %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrNetlink struct %7B%0A%09Family uint16%0A%09Pad    uint16%0A%09Pid    uint32%0A%09Groups uint32%0A%7D%0A%0Atype RawSockaddrHCI struct %7B%0A%09Family  uint16%0A%09Dev     uint16%0A%09Channel uint16%0A%7D%0A%0Atype RawSockaddrCAN struct %7B%0A%09Family    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Ifindex   int32%0A%09Addr      %5B8%5Dbyte%0A%7D%0A%0Atype RawSockaddrALG struct %7B%0A%09Family uint16%0A%09Type   %5B14%5Duint8%0A%09Feat   uint32%0A%09Mask   uint32%0A%09Name   %5B64%5Duint8%0A%7D%0A%0Atype RawSockaddrVM struct %7B%0A%09Family    uint16%0A%09Reserved1 uint16%0A%09Port      uint32%0A%09Cid       uint32%0A%09Zero      %5B4%5Duint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B96%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPMreqn struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Address   %5B4%5Dbyte /* in_addr */%0A%09Ifindex   int32%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Pad_cgo_0  %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint64%0A%09Control    *byte%0A%09Controllen uint64%0A%09Flags      int32%0A%09Pad_cgo_1  %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint64%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet4Pktinfo struct %7B%0A%09Ifindex  int32%0A%09Spec_dst %5B4%5Dbyte /* in_addr */%0A%09Addr     %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Data %5B8%5Duint32%0A%7D%0A%0Atype Ucred struct %7B%0A%09Pid int32%0A%09Uid uint32%0A%09Gid uint32%0A%7D%0A%0Atype TCPInfo struct %7B%0A%09State          uint8%0A%09Ca_state       uint8%0A%09Retransmits    uint8%0A%09Probes         uint8%0A%09Backoff        uint8%0A%09Options        uint8%0A%09Pad_cgo_0      %5B2%5Dbyte%0A%09Rto            uint32%0A%09Ato            uint32%0A%09Snd_mss        uint32%0A%09Rcv_mss        uint32%0A%09Unacked        uint32%0A%09Sacked         uint32%0A%09Lost           uint32%0A%09Retrans        uint32%0A%09Fackets        uint32%0A%09Last_data_sent uint32%0A%09Last_ack_sent  uint32%0A%09Last_data_recv uint32%0A%09Last_ack_recv  uint32%0A%09Pmtu           uint32%0A%09Rcv_ssthresh   uint32%0A%09Rtt            uint32%0A%09Rttvar         uint32%0A%09Snd_ssthresh   uint32%0A%09Snd_cwnd       uint32%0A%09Advmss         uint32%0A%09Reordering     uint32%0A%09Rcv_rtt        uint32%0A%09Rcv_space      uint32%0A%09Total_retrans  uint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4     = 0x10%0A%09SizeofSockaddrInet6     = 0x1c%0A%09SizeofSockaddrAny       = 0x70%0A%09SizeofSockaddrUnix      = 0x6e%0A%09SizeofSockaddrLinklayer = 0x14%0A%09SizeofSockaddrNetlink   = 0xc%0A%09SizeofSockaddrHCI       = 0x6%0A%09SizeofSockaddrCAN       = 0x10%0A%09SizeofSockaddrALG       = 0x58%0A%09SizeofSockaddrVM        = 0x10%0A%09SizeofLinger            = 0x8%0A%09SizeofIPMreq            = 0x8%0A%09SizeofIPMreqn           = 0xc%0A%09SizeofIPv6Mreq          = 0x14%0A%09SizeofMsghdr            = 0x38%0A%09SizeofCmsghdr           = 0x10%0A%09SizeofInet4Pktinfo      = 0xc%0A%09SizeofInet6Pktinfo      = 0x14%0A%09SizeofIPv6MTUInfo       = 0x20%0A%09SizeofICMPv6Filter      = 0x20%0A%09SizeofUcred             = 0xc%0A%09SizeofTCPInfo           = 0x68%0A)%0A%0Aconst (%0A%09IFA_UNSPEC           = 0x0%0A%09IFA_ADDRESS          = 0x1%0A%09IFA_LOCAL            = 0x2%0A%09IFA_LABEL            = 0x3%0A%09IFA_BROADCAST        = 0x4%0A%09IFA_ANYCAST          = 0x5%0A%09IFA_CACHEINFO        = 0x6%0A%09IFA_MULTICAST        = 0x7%0A%09IFLA_UNSPEC          = 0x0%0A%09IFLA_ADDRESS         = 0x1%0A%09IFLA_BROADCAST       = 0x2%0A%09IFLA_IFNAME          = 0x3%0A%09IFLA_MTU             = 0x4%0A%09IFLA_LINK            = 0x5%0A%09IFLA_QDISC           = 0x6%0A%09IFLA_STATS           = 0x7%0A%09IFLA_COST            = 0x8%0A%09IFLA_PRIORITY        = 0x9%0A%09IFLA_MASTER          = 0xa%0A%09IFLA_WIRELESS        = 0xb%0A%09IFLA_PROTINFO        = 0xc%0A%09IFLA_TXQLEN          = 0xd%0A%09IFLA_MAP             = 0xe%0A%09IFLA_WEIGHT          = 0xf%0A%09IFLA_OPERSTATE       = 0x10%0A%09IFLA_LINKMODE        = 0x11%0A%09IFLA_LINKINFO        = 0x12%0A%09IFLA_NET_NS_PID      = 0x13%0A%09IFLA_IFALIAS         = 0x14%0A%09IFLA_NUM_VF          = 0x15%0A%09IFLA_VFINFO_LIST     = 0x16%0A%09IFLA_STATS64         = 0x17%0A%09IFLA_VF_PORTS        = 0x18%0A%09IFLA_PORT_SELF       = 0x19%0A%09IFLA_AF_SPEC         = 0x1a%0A%09IFLA_GROUP           = 0x1b%0A%09IFLA_NET_NS_FD       = 0x1c%0A%09IFLA_EXT_MASK        = 0x1d%0A%09IFLA_PROMISCUITY     = 0x1e%0A%09IFLA_NUM_TX_QUEUES   = 0x1f%0A%09IFLA_NUM_RX_QUEUES   = 0x20%0A%09IFLA_CARRIER         = 0x21%0A%09IFLA_PHYS_PORT_ID    = 0x22%0A%09IFLA_CARRIER_CHANGES = 0x23%0A%09IFLA_PHYS_SWITCH_ID  = 0x24%0A%09IFLA_LINK_NETNSID    = 0x25%0A%09IFLA_PHYS_PORT_NAME  = 0x26%0A%09IFLA_PROTO_DOWN      = 0x27%0A%09IFLA_GSO_MAX_SEGS    = 0x28%0A%09IFLA_GSO_MAX_SIZE    = 0x29%0A%09IFLA_PAD             = 0x2a%0A%09IFLA_XDP             = 0x2b%0A%09IFLA_EVENT           = 0x2c%0A%09IFLA_NEW_NETNSID     = 0x2d%0A%09IFLA_IF_NETNSID      = 0x2e%0A%09IFLA_MAX             = 0x2e%0A%09RT_SCOPE_UNIVERSE    = 0x0%0A%09RT_SCOPE_SITE        = 0xc8%0A%09RT_SCOPE_LINK        = 0xfd%0A%09RT_SCOPE_HOST        = 0xfe%0A%09RT_SCOPE_NOWHERE     = 0xff%0A%09RT_TABLE_UNSPEC      = 0x0%0A%09RT_TABLE_COMPAT      = 0xfc%0A%09RT_TABLE_DEFAULT     = 0xfd%0A%09RT_TABLE_MAIN        = 0xfe%0A%09RT_TABLE_LOCAL       = 0xff%0A%09RT_TABLE_MAX         = 0xffffffff%0A%09RTA_UNSPEC           = 0x0%0A%09RTA_DST              = 0x1%0A%09RTA_SRC              = 0x2%0A%09RTA_IIF              = 0x3%0A%09RTA_OIF              = 0x4%0A%09RTA_GATEWAY          = 0x5%0A%09RTA_PRIORITY         = 0x6%0A%09RTA_PREFSRC          = 0x7%0A%09RTA_METRICS          = 0x8%0A%09RTA_MULTIPATH        = 0x9%0A%09RTA_FLOW             = 0xb%0A%09RTA_CACHEINFO        = 0xc%0A%09RTA_TABLE            = 0xf%0A%09RTN_UNSPEC           = 0x0%0A%09RTN_UNICAST          = 0x1%0A%09RTN_LOCAL            = 0x2%0A%09RTN_BROADCAST        = 0x3%0A%09RTN_ANYCAST          = 0x4%0A%09RTN_MULTICAST        = 0x5%0A%09RTN_BLACKHOLE        = 0x6%0A%09RTN_UNREACHABLE      = 0x7%0A%09RTN_PROHIBIT         = 0x8%0A%09RTN_THROW            = 0x9%0A%09RTN_NAT              = 0xa%0A%09RTN_XRESOLVE         = 0xb%0A%09RTNLGRP_NONE         = 0x0%0A%09RTNLGRP_LINK         = 0x1%0A%09RTNLGRP_NOTIFY       = 0x2%0A%09RTNLGRP_NEIGH        = 0x3%0A%09RTNLGRP_TC           = 0x4%0A%09RTNLGRP_IPV4_IFADDR  = 0x5%0A%09RTNLGRP_IPV4_MROUTE  = 0x6%0A%09RTNLGRP_IPV4_ROUTE   = 0x7%0A%09RTNLGRP_IPV4_RULE    = 0x8%0A%09RTNLGRP_IPV6_IFADDR  = 0x9%0A%09RTNLGRP_IPV6_MROUTE  = 0xa%0A%09RTNLGRP_IPV6_ROUTE   = 0xb%0A%09RTNLGRP_IPV6_IFINFO  = 0xc%0A%09RTNLGRP_IPV6_PREFIX  = 0x12%0A%09RTNLGRP_IPV6_RULE    = 0x13%0A%09RTNLGRP_ND_USEROPT   = 0x14%0A%09SizeofNlMsghdr       = 0x10%0A%09SizeofNlMsgerr       = 0x14%0A%09SizeofRtGenmsg       = 0x1%0A%09SizeofNlAttr         = 0x4%0A%09SizeofRtAttr         = 0x4%0A%09SizeofIfInfomsg      = 0x10%0A%09SizeofIfAddrmsg      = 0x8%0A%09SizeofRtMsg          = 0xc%0A%09SizeofRtNexthop      = 0x8%0A)%0A%0Atype NlMsghdr struct %7B%0A%09Len   uint32%0A%09Type  uint16%0A%09Flags uint16%0A%09Seq   uint32%0A%09Pid   uint32%0A%7D%0A%0Atype NlMsgerr struct %7B%0A%09Error int32%0A%09Msg   NlMsghdr%0A%7D%0A%0Atype RtGenmsg struct %7B%0A%09Family uint8%0A%7D%0A%0Atype NlAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype RtAttr struct %7B%0A%09Len  uint16%0A%09Type uint16%0A%7D%0A%0Atype IfInfomsg struct %7B%0A%09Family     uint8%0A%09X__ifi_pad uint8%0A%09Type       uint16%0A%09Index      int32%0A%09Flags      uint32%0A%09Change     uint32%0A%7D%0A%0Atype IfAddrmsg struct %7B%0A%09Family    uint8%0A%09Prefixlen uint8%0A%09Flags     uint8%0A%09Scope     uint8%0A%09Index     uint32%0A%7D%0A%0Atype RtMsg struct %7B%0A%09Family   uint8%0A%09Dst_len  uint8%0A%09Src_len  uint8%0A%09Tos      uint8%0A%09Table    uint8%0A%09Protocol uint8%0A%09Scope    uint8%0A%09Type     uint8%0A%09Flags    uint32%0A%7D%0A%0Atype RtNexthop struct %7B%0A%09Len     uint16%0A%09Flags   uint8%0A%09Hops    uint8%0A%09Ifindex int32%0A%7D%0A%0Aconst (%0A%09SizeofSockFilter = 0x8%0A%09SizeofSockFprog  = 0x10%0A)%0A%0Atype SockFilter struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype SockFprog struct %7B%0A%09Len       uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%09Filter    *SockFilter%0A%7D%0A%0Atype InotifyEvent struct %7B%0A%09Wd     int32%0A%09Mask   uint32%0A%09Cookie uint32%0A%09Len    uint32%0A%7D%0A%0Aconst SizeofInotifyEvent = 0x10%0A%0Atype PtraceRegs struct %7B%0A%09Regs   %5B16%5Duint64%0A%09Tstate uint64%0A%09Tpc    uint64%0A%09Tnpc   uint64%0A%09Y      uint32%0A%09Magic  uint32%0A%7D%0A%0Atype ptracePsw struct %7B%0A%7D%0A%0Atype ptraceFpregs struct %7B%0A%7D%0A%0Atype ptracePer struct %7B%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B16%5Dint64%0A%7D%0A%0Atype Sysinfo_t struct %7B%0A%09Uptime    int64%0A%09Loads     %5B3%5Duint64%0A%09Totalram  uint64%0A%09Freeram   uint64%0A%09Sharedram uint64%0A%09Bufferram uint64%0A%09Totalswap uint64%0A%09Freeswap  uint64%0A%09Procs     uint16%0A%09Pad       uint16%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Totalhigh uint64%0A%09Freehigh  uint64%0A%09Unit      uint32%0A%09X_f       %5B0%5Dint8%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname    %5B65%5Dbyte%0A%09Nodename   %5B65%5Dbyte%0A%09Release    %5B65%5Dbyte%0A%09Version    %5B65%5Dbyte%0A%09Machine    %5B65%5Dbyte%0A%09Domainname %5B65%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree     int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Tinode    uint64%0A%09Fname     %5B6%5Dint8%0A%09Fpack     %5B6%5Dint8%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%7D%0A%0Atype EpollEvent struct %7B%0A%09Events  uint32%0A%09X_padFd int32%0A%09Fd      int32%0A%09Pad     int32%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_REMOVEDIR        = 0x200%0A%09AT_SYMLINK_FOLLOW   = 0x400%0A%09AT_SYMLINK_NOFOLLOW = 0x100%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLIN    = 0x1%0A%09POLLPRI   = 0x2%0A%09POLLOUT   = 0x4%0A%09POLLRDHUP = 0x800%0A%09POLLERR   = 0x8%0A%09POLLHUP   = 0x10%0A%09POLLNVAL  = 0x20%0A)%0A%0Atype Sigset_t struct %7B%0A%09X__val %5B16%5Duint64%0A%7D%0A%0A
 type Ter
- f 03d5699fac307625ec38de51a44700780137d57b889e0d0473349518a4fdaaa7 vendor/golang.org/x/sys/unix/ztypes_netbsd_386.go
+ f cb06569cd584081fc14789b8af48007b0a1ebfc90e2c0c21d1acbcaa38d75790 vendor/golang.org/x/sys/unix/ztypes_netbsd_386.go
dmppatch 7
@@ -148,16 +148,5704 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           uint64%0A%09Mode          uint32%0A%09Ino           uint64%0A%09Nlink         uint32%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Rdev          uint64%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       uint32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Spare         %5B2%5Duint32%0A%7D%0A%0Atype Statfs_t %5B0%5Dbyte%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno    uint64%0A%09Reclen    uint16%0A%09Namlen    uint16%0A%09Type      uint8%0A%09Name      %5B512%5Dint8%0A%09Pad_cgo_0 %5B3%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09X__fsid_val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter uint32%0A%09Flags  uint32%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  int32%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0x98%0A%09SizeofIfData           = 0x84%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x78%0A%09SizeofRtMetrics        = 0x50%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Pad_cgo_0  %5B1%5Dbyte%0A%09Link_state int32%0A%09Mtu        uint64%0A%09Metric     uint64%0A%09Baudrate   uint64%0A%09Ipackets   uint64%0A%09Ierrors    uint64%0A%09Opackets   uint64%0A%09Oerrors    uint64%0A%09Collisions uint64%0A%09Ibytes     uint64%0A%09Obytes     uint64%0A%09Imcasts    uint64%0A%09Omcasts    uint64%0A%09Iqdrops    uint64%0A%09Noproto    uint64%0A%09Lastchange Timespec%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Metric    int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Use       int32%0A%09Inits     int32%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint64%0A%09Mtu      uint64%0A%09Hopcount uint64%0A%09Recvpipe uint64%0A%09Sendpipe uint64%0A%09Ssthresh uint64%0A%09Rtt      uint64%0A%09Rttvar   uint64%0A%09Expire   int64%0A%09Pksent   int64%0A%7D%0A%0Atype Mclpool %5B0%5Dbyte%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x80%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv    uint64%0A%09Drop    uint64%0A%09Capt    uint64%0A%09Padding %5B13%5Duint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0A
 type Ter
@@ -5958,16 +5958,836 @@
 %09Ospeed int32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Sysctlnode struct %7B%0A%09Flags           uint32%0A%09Num             int32%0A%09Name            %5B32%5Dint8%0A%09Ver             uint32%0A%09X__rsvd         uint32%0A%09Un              %5B16%5Dbyte%0A%09X_sysctl_size   %5B8%5Dbyte%0A%09X_sysctl_func   %5B8%5Dbyte%0A%09X_sysctl_parent %5B8%5Dbyte%0A%09X_sysctl_desc   %5B8%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f fb8fc07868ebf24f1f6a3dac854c95c7aa2ae6d904bfe50fbcee031b0f9e0049 vendor/golang.org/x/sys/unix/ztypes_netbsd_amd64.go
+ f a8b9ffc17899005aa6323922be09f0cecb333da5a4a2bcbd7ec849222d2b43e2 vendor/golang.org/x/sys/unix/ztypes_netbsd_amd64.go
dmppatch 7
@@ -150,16 +150,5888 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec       int64%0A%09Usec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           uint64%0A%09Mode          uint32%0A%09Pad_cgo_0     %5B4%5Dbyte%0A%09Ino           uint64%0A%09Nlink         uint32%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Pad_cgo_1     %5B4%5Dbyte%0A%09Rdev          uint64%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       uint32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Spare         %5B2%5Duint32%0A%09Pad_cgo_2     %5B4%5Dbyte%0A%7D%0A%0Atype Statfs_t %5B0%5Dbyte%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno    uint64%0A%09Reclen    uint16%0A%09Namlen    uint16%0A%09Type      uint8%0A%09Name      %5B512%5Dint8%0A%09Pad_cgo_0 %5B3%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09X__fsid_val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Pad_cgo_0  %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Pad_cgo_1  %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident     uint64%0A%09Filter    uint32%0A%09Flags     uint32%0A%09Fflags    uint32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Data      int64%0A%09Udata     int64%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0x98%0A%09SizeofIfData           = 0x88%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x78%0A%09SizeofRtMetrics        = 0x50%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Pad_cgo_0  %5B1%5Dbyte%0A%09Link_state int32%0A%09Mtu        uint64%0A%09Metric     uint64%0A%09Baudrate   uint64%0A%09Ipackets   uint64%0A%09Ierrors    uint64%0A%09Opackets   uint64%0A%09Oerrors    uint64%0A%09Collisions uint64%0A%09Ibytes     uint64%0A%09Obytes     uint64%0A%09Imcasts    uint64%0A%09Omcasts    uint64%0A%09Iqdrops    uint64%0A%09Noproto    uint64%0A%09Lastchange Timespec%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Metric    int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Use       int32%0A%09Inits     int32%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint64%0A%09Mtu      uint64%0A%09Hopcount uint64%0A%09Recvpipe uint64%0A%09Sendpipe uint64%0A%09Ssthresh uint64%0A%09Rtt      uint64%0A%09Rttvar   uint64%0A%09Expire   int64%0A%09Pksent   int64%0A%7D%0A%0Atype Mclpool %5B0%5Dbyte%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x80%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x20%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv    uint64%0A%09Drop    uint64%0A%09Capt    uint64%0A%09Padding %5B13%5Duint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len       uint32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%09Insns     *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0A
 type Ter
@@ -6144,16 +6144,836 @@
 %09Ospeed int32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Sysctlnode struct %7B%0A%09Flags           uint32%0A%09Num             int32%0A%09Name            %5B32%5Dint8%0A%09Ver             uint32%0A%09X__rsvd         uint32%0A%09Un              %5B16%5Dbyte%0A%09X_sysctl_size   %5B8%5Dbyte%0A%09X_sysctl_func   %5B8%5Dbyte%0A%09X_sysctl_parent %5B8%5Dbyte%0A%09X_sysctl_desc   %5B8%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 3743b9fb0481e28a7d71720ece0a1007e5b63e751aa0b52ba80c071b08bed792 vendor/golang.org/x/sys/unix/ztypes_netbsd_arm.go
+ f 0498554619bbcd1f52d5b4abae8757d8f65d44ae9a297c43518477da7553a10d vendor/golang.org/x/sys/unix/ztypes_netbsd_arm.go
dmppatch 7
@@ -148,16 +148,5849 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec       int64%0A%09Nsec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec       int64%0A%09Usec      int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev           uint64%0A%09Mode          uint32%0A%09Pad_cgo_0     %5B4%5Dbyte%0A%09Ino           uint64%0A%09Nlink         uint32%0A%09Uid           uint32%0A%09Gid           uint32%0A%09Pad_cgo_1     %5B4%5Dbyte%0A%09Rdev          uint64%0A%09Atimespec     Timespec%0A%09Mtimespec     Timespec%0A%09Ctimespec     Timespec%0A%09Birthtimespec Timespec%0A%09Size          int64%0A%09Blocks        int64%0A%09Blksize       uint32%0A%09Flags         uint32%0A%09Gen           uint32%0A%09Spare         %5B2%5Duint32%0A%09Pad_cgo_2     %5B4%5Dbyte%0A%7D%0A%0Atype Statfs_t %5B0%5Dbyte%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno    uint64%0A%09Reclen    uint16%0A%09Namlen    uint16%0A%09Type      uint8%0A%09Name      %5B512%5Dint8%0A%09Pad_cgo_0 %5B3%5Dbyte%0A%7D%0A%0Atype Fsid struct %7B%0A%09X__fsid_val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Aconst (%0A%09FADV_NORMAL     = 0x0%0A%09FADV_RANDOM     = 0x1%0A%09FADV_SEQUENTIAL = 0x2%0A%09FADV_WILLNEED   = 0x3%0A%09FADV_DONTNEED   = 0x4%0A%09FADV_NOREUSE    = 0x5%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B12%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     int32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x14%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident     uint32%0A%09Filter    uint32%0A%09Flags     uint32%0A%09Fflags    uint32%0A%09Data      int64%0A%09Udata     int32%0A%09Pad_cgo_0 %5B4%5Dbyte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0x98%0A%09SizeofIfData           = 0x88%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x18%0A%09SizeofRtMsghdr         = 0x78%0A%09SizeofRtMetrics        = 0x50%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Data      IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09Pad_cgo_0  %5B1%5Dbyte%0A%09Link_state int32%0A%09Mtu        uint64%0A%09Metric     uint64%0A%09Baudrate   uint64%0A%09Ipackets   uint64%0A%09Ierrors    uint64%0A%09Opackets   uint64%0A%09Oerrors    uint64%0A%09Collisions uint64%0A%09Ibytes     uint64%0A%09Obytes     uint64%0A%09Imcasts    uint64%0A%09Omcasts    uint64%0A%09Iqdrops    uint64%0A%09Noproto    uint64%0A%09Lastchange Timespec%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Addrs     int32%0A%09Flags     int32%0A%09Metric    int32%0A%09Index     uint16%0A%09Pad_cgo_0 %5B6%5Dbyte%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09Name    %5B16%5Dint8%0A%09What    uint16%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen    uint16%0A%09Version   uint8%0A%09Type      uint8%0A%09Index     uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%09Flags     int32%0A%09Addrs     int32%0A%09Pid       int32%0A%09Seq       int32%0A%09Errno     int32%0A%09Use       int32%0A%09Inits     int32%0A%09Pad_cgo_1 %5B4%5Dbyte%0A%09Rmx       RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint64%0A%09Mtu      uint64%0A%09Hopcount uint64%0A%09Recvpipe uint64%0A%09Sendpipe uint64%0A%09Ssthresh uint64%0A%09Rtt      uint64%0A%09Rttvar   uint64%0A%09Expire   int64%0A%09Pksent   int64%0A%7D%0A%0Atype Mclpool %5B0%5Dbyte%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x80%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv    uint64%0A%09Drop    uint64%0A%09Capt    uint64%0A%09Padding %5B13%5Duint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0A
 type Ter
@@ -6103,16 +6103,836 @@
 %09Ospeed int32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x200%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Sysctlnode struct %7B%0A%09Flags           uint32%0A%09Num             int32%0A%09Name            %5B32%5Dint8%0A%09Ver             uint32%0A%09X__rsvd         uint32%0A%09Un              %5B16%5Dbyte%0A%09X_sysctl_size   %5B8%5Dbyte%0A%09X_sysctl_func   %5B8%5Dbyte%0A%09X_sysctl_parent %5B8%5Dbyte%0A%09X_sysctl_desc   %5B8%5Dbyte%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f a4dc6a2da243de99035589895eefab777f1d45d8a6db6ccbd29d7b3bd60bfab9 vendor/golang.org/x/sys/unix/ztypes_openbsd_386.go
+ f 7927cf4bea4631ae1ff4a3c0fe10e206f1381a00b7100d2bce91b7421a8934f5 vendor/golang.org/x/sys/unix/ztypes_openbsd_386.go
dmppatch 7
@@ -150,16 +150,6329 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Mode           uint32%0A%09Dev            int32%0A%09Ino            uint64%0A%09Nlink          uint32%0A%09Uid            uint32%0A%09Gid            uint32%0A%09Rdev           int32%0A%09Atim           Timespec%0A%09Mtim           Timespec%0A%09Ctim           Timespec%0A%09Size           int64%0A%09Blocks         int64%0A%09Blksize        uint32%0A%09Flags          uint32%0A%09Gen            uint32%0A%09X__st_birthtim Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09F_flags       uint32%0A%09F_bsize       uint32%0A%09F_iosize      uint32%0A%09F_blocks      uint64%0A%09F_bfree       uint64%0A%09F_bavail      int64%0A%09F_files       uint64%0A%09F_ffree       uint64%0A%09F_favail      int64%0A%09F_syncwrites  uint64%0A%09F_syncreads   uint64%0A%09F_asyncwrites uint64%0A%09F_asyncreads  uint64%0A%09F_fsid        Fsid%0A%09F_namemax     uint32%0A%09F_owner       uint32%0A%09F_ctime       uint64%0A%09F_fstypename  %5B16%5Dint8%0A%09F_mntonname   %5B90%5Dint8%0A%09F_mntfromname %5B90%5Dint8%0A%09F_mntfromspec %5B90%5Dint8%0A%09Pad_cgo_0     %5B2%5Dbyte%0A%09Mount_info    %5B160%5Dbyte%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno       uint64%0A%09Off          int64%0A%09Reclen       uint16%0A%09Type         uint8%0A%09Namlen       uint8%0A%09X__d_padding %5B4%5Duint8%0A%09Name         %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B24%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x20%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0xec%0A%09SizeofIfData           = 0xd4%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x1a%0A%09SizeofRtMsghdr         = 0x60%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Xflags  int32%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type         uint8%0A%09Addrlen      uint8%0A%09Hdrlen       uint8%0A%09Link_state   uint8%0A%09Mtu          uint32%0A%09Metric       uint32%0A%09Pad          uint32%0A%09Baudrate     uint64%0A%09Ipackets     uint64%0A%09Ierrors      uint64%0A%09Opackets     uint64%0A%09Oerrors      uint64%0A%09Collisions   uint64%0A%09Ibytes       uint64%0A%09Obytes       uint64%0A%09Imcasts      uint64%0A%09Omcasts      uint64%0A%09Iqdrops      uint64%0A%09Noproto      uint64%0A%09Capabilities uint32%0A%09Lastchange   Timeval%0A%09Mclpool      %5B7%5DMclpool%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Metric  int32%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09What    uint16%0A%09Name    %5B16%5Dint8%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Hdrlen   uint16%0A%09Index    uint16%0A%09Tableid  uint16%0A%09Priority uint8%0A%09Mpls     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Fmask    int32%0A%09Pid      int32%0A%09Seq      int32%0A%09Errno    int32%0A%09Inits    uint32%0A%09Rmx      RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Pksent   uint64%0A%09Expire   int64%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Refcnt   uint32%0A%09Hopcount uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pad      uint32%0A%7D%0A%0Atype Mclpool struct %7B%0A%09Grown int32%0A%09Alive uint16%0A%09Hwm   uint16%0A%09Cwm   uint16%0A%09Lwm   uint16%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  uint32%0A%09Usec uint32%0A%7D%0A%0A
 type Ter
@@ -6585,16 +6585,559 @@
 %09Ospeed int32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x2%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f 51e881e76d79af5c54b1f9eb54fa8d410fb1977c6e3effa59f15350482a006ab vendor/golang.org/x/sys/unix/ztypes_openbsd_amd64.go
+ f e570203b75c6fb4880ed94bb470f66e7f2a7b67baa5f021758dd4d68440fd297 vendor/golang.org/x/sys/unix/ztypes_openbsd_amd64.go
dmppatch 7
@@ -152,16 +152,6207 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Mode    uint32%0A%09Dev     int32%0A%09Ino     uint64%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    int32%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Size    int64%0A%09Blocks  int64%0A%09Blksize int32%0A%09Flags   uint32%0A%09Gen     uint32%0A%09_       %5B4%5Dbyte%0A%09_       Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09F_flags       uint32%0A%09F_bsize       uint32%0A%09F_iosize      uint32%0A%09_             %5B4%5Dbyte%0A%09F_blocks      uint64%0A%09F_bfree       uint64%0A%09F_bavail      int64%0A%09F_files       uint64%0A%09F_ffree       uint64%0A%09F_favail      int64%0A%09F_syncwrites  uint64%0A%09F_syncreads   uint64%0A%09F_asyncwrites uint64%0A%09F_asyncreads  uint64%0A%09F_fsid        Fsid%0A%09F_namemax     uint32%0A%09F_owner       uint32%0A%09F_ctime       uint64%0A%09F_fstypename  %5B16%5Dint8%0A%09F_mntonname   %5B90%5Dint8%0A%09F_mntfromname %5B90%5Dint8%0A%09F_mntfromspec %5B90%5Dint8%0A%09_             %5B2%5Dbyte%0A%09Mount_info    %5B160%5Dbyte%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Type   uint8%0A%09Namlen uint8%0A%09_      %5B4%5Duint8%0A%09Name   %5B256%5Dint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B24%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09_          %5B4%5Dbyte%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09_          %5B4%5Dbyte%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x20%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint64%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0xa8%0A%09SizeofIfData           = 0x90%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x1a%0A%09SizeofRtMsghdr         = 0x60%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Xflags  int32%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type         uint8%0A%09Addrlen      uint8%0A%09Hdrlen       uint8%0A%09Link_state   uint8%0A%09Mtu          uint32%0A%09Metric       uint32%0A%09Rdomain      uint32%0A%09Baudrate     uint64%0A%09Ipackets     uint64%0A%09Ierrors      uint64%0A%09Opackets     uint64%0A%09Oerrors      uint64%0A%09Collisions   uint64%0A%09Ibytes       uint64%0A%09Obytes       uint64%0A%09Imcasts      uint64%0A%09Omcasts      uint64%0A%09Iqdrops      uint64%0A%09Oqdrops      uint64%0A%09Noproto      uint64%0A%09Capabilities uint32%0A%09_            %5B4%5Dbyte%0A%09Lastchange   Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Metric  int32%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09What    uint16%0A%09Name    %5B16%5Dint8%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Hdrlen   uint16%0A%09Index    uint16%0A%09Tableid  uint16%0A%09Priority uint8%0A%09Mpls     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Fmask    int32%0A%09Pid      int32%0A%09Seq      int32%0A%09Errno    int32%0A%09Inits    uint32%0A%09Rmx      RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Pksent   uint64%0A%09Expire   int64%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Refcnt   uint32%0A%09Hopcount uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pad      uint32%0A%7D%0A%0Atype Mclpool struct%7B%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09_     %5B4%5Dbyte%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  BpfTimeval%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  uint32%0A%09Usec uint32%0A%7D%0A%0A
 type Ter
@@ -6465,16 +6465,559 @@
 %09Ospeed int32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x2%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f ffcfa5c5255a61ffefb0df2aeb13410fcd58250d4edbe7b387a5e0fe173efc26 vendor/golang.org/x/sys/unix/ztypes_openbsd_arm.go
+ f d3e2cb82ae1ca0352d57f8b46cbd7bc4f0917115058e3adb7d85af39f7be855b vendor/golang.org/x/sys/unix/ztypes_openbsd_arm.go
dmppatch 7
@@ -150,16 +150,6238 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x4%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x4%0A%09sizeofLongLong = 0x8%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int32%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int32%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int32%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int32%0A%09Ixrss    int32%0A%09Idrss    int32%0A%09Isrss    int32%0A%09Minflt   int32%0A%09Majflt   int32%0A%09Nswap    int32%0A%09Inblock  int32%0A%09Oublock  int32%0A%09Msgsnd   int32%0A%09Msgrcv   int32%0A%09Nsignals int32%0A%09Nvcsw    int32%0A%09Nivcsw   int32%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Mode           uint32%0A%09Dev            int32%0A%09Ino            uint64%0A%09Nlink          uint32%0A%09Uid            uint32%0A%09Gid            uint32%0A%09Rdev           int32%0A%09Atim           Timespec%0A%09Mtim           Timespec%0A%09Ctim           Timespec%0A%09Size           int64%0A%09Blocks         int64%0A%09Blksize        int32%0A%09Flags          uint32%0A%09Gen            uint32%0A%09X__st_birthtim Timespec%0A%7D%0A%0Atype Statfs_t struct %7B%0A%09F_flags       uint32%0A%09F_bsize       uint32%0A%09F_iosize      uint32%0A%09F_blocks      uint64%0A%09F_bfree       uint64%0A%09F_bavail      int64%0A%09F_files       uint64%0A%09F_ffree       uint64%0A%09F_favail      int64%0A%09F_syncwrites  uint64%0A%09F_syncreads   uint64%0A%09F_asyncwrites uint64%0A%09F_asyncreads  uint64%0A%09F_fsid        Fsid%0A%09F_namemax     uint32%0A%09F_owner       uint32%0A%09F_ctime       uint64%0A%09F_fstypename  %5B16%5Duint8%0A%09F_mntonname   %5B90%5Duint8%0A%09F_mntfromname %5B90%5Duint8%0A%09F_mntfromspec %5B90%5Duint8%0A%09Pad_cgo_0     %5B2%5Dbyte%0A%09Mount_info    %5B160%5Dbyte%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Start  int64%0A%09Len    int64%0A%09Pid    int32%0A%09Type   int16%0A%09Whence int16%0A%7D%0A%0Atype Dirent struct %7B%0A%09Fileno       uint64%0A%09Off          int64%0A%09Reclen       uint16%0A%09Type         uint8%0A%09Namlen       uint8%0A%09X__d_padding %5B4%5Duint8%0A%09Name         %5B256%5Duint8%0A%7D%0A%0Atype Fsid struct %7B%0A%09Val %5B2%5Dint32%0A%7D%0A%0Aconst (%0A%09PathMax = 0x400%0A)%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Len      uint8%0A%09Family   uint8%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Path   %5B104%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B24%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Len    uint8%0A%09Family uint8%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B92%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *byte%0A%09Len  uint32%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name       *byte%0A%09Namelen    uint32%0A%09Iov        *Iovec%0A%09Iovlen     uint32%0A%09Control    *byte%0A%09Controllen uint32%0A%09Flags      int32%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09Filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x1c%0A%09SizeofSockaddrAny      = 0x6c%0A%09SizeofSockaddrUnix     = 0x6a%0A%09SizeofSockaddrDatalink = 0x20%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x1c%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x20%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Aconst (%0A%09PTRACE_TRACEME = 0x0%0A%09PTRACE_CONT    = 0x7%0A%09PTRACE_KILL    = 0x8%0A)%0A%0Atype Kevent_t struct %7B%0A%09Ident  uint32%0A%09Filter int16%0A%09Flags  uint16%0A%09Fflags uint32%0A%09Data   int64%0A%09Udata  *byte%0A%7D%0A%0Atype FdSet struct %7B%0A%09Bits %5B32%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofIfMsghdr         = 0x98%0A%09SizeofIfData           = 0x80%0A%09SizeofIfaMsghdr        = 0x18%0A%09SizeofIfAnnounceMsghdr = 0x1a%0A%09SizeofRtMsghdr         = 0x60%0A%09SizeofRtMetrics        = 0x38%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Xflags  int32%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type         uint8%0A%09Addrlen      uint8%0A%09Hdrlen       uint8%0A%09Link_state   uint8%0A%09Mtu          uint32%0A%09Metric       uint32%0A%09Pad          uint32%0A%09Baudrate     uint64%0A%09Ipackets     uint64%0A%09Ierrors      uint64%0A%09Opackets     uint64%0A%09Oerrors      uint64%0A%09Collisions   uint64%0A%09Ibytes       uint64%0A%09Obytes       uint64%0A%09Imcasts      uint64%0A%09Omcasts      uint64%0A%09Iqdrops      uint64%0A%09Noproto      uint64%0A%09Capabilities uint32%0A%09Lastchange   Timeval%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09Tableid uint16%0A%09Pad1    uint8%0A%09Pad2    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Metric  int32%0A%7D%0A%0Atype IfAnnounceMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Hdrlen  uint16%0A%09Index   uint16%0A%09What    uint16%0A%09Name    %5B16%5Duint8%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen   uint16%0A%09Version  uint8%0A%09Type     uint8%0A%09Hdrlen   uint16%0A%09Index    uint16%0A%09Tableid  uint16%0A%09Priority uint8%0A%09Mpls     uint8%0A%09Addrs    int32%0A%09Flags    int32%0A%09Fmask    int32%0A%09Pid      int32%0A%09Seq      int32%0A%09Errno    int32%0A%09Inits    uint32%0A%09Rmx      RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Pksent   uint64%0A%09Expire   int64%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Refcnt   uint32%0A%09Hopcount uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pad      uint32%0A%7D%0A%0Atype Mclpool struct%7B%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x8%0A%09SizeofBpfProgram = 0x8%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv uint32%0A%09Drop uint32%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp    BpfTimeval%0A%09Caplen    uint32%0A%09Datalen   uint32%0A%09Hdrlen    uint16%0A%09Pad_cgo_0 %5B2%5Dbyte%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  uint32%0A%09Usec uint32%0A%7D%0A%0A
 type Ter
@@ -6494,16 +6494,559 @@
 %09Ospeed int32%0A%7D%0A
+%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = -0x64%0A%09AT_SYMLINK_NOFOLLOW = 0x2%0A)%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B256%5Dbyte%0A%09Nodename %5B256%5Dbyte%0A%09Release  %5B256%5Dbyte%0A%09Version  %5B256%5Dbyte%0A%09Machine  %5B256%5Dbyte%0A%7D%0A
- f ce8dff2a4e9c66fbbb976dca61961ea17285777cbffe971bb937034a59b58f70 vendor/golang.org/x/sys/unix/ztypes_solaris_amd64.go
+ f 6f04cbe0660dd7620b21dbc05e754376be31358ad7d4b683f539c6eeb39b9a68 vendor/golang.org/x/sys/unix/ztypes_solaris_amd64.go
dmppatch 7
@@ -152,16 +152,5774 @@
 e unix%0A%0A
+const (%0A%09sizeofPtr      = 0x8%0A%09sizeofShort    = 0x2%0A%09sizeofInt      = 0x4%0A%09sizeofLong     = 0x8%0A%09sizeofLongLong = 0x8%0A%09PathMax        = 0x400%0A%09MaxHostNameLen = 0x100%0A)%0A%0Atype (%0A%09_C_short     int16%0A%09_C_int       int32%0A%09_C_long      int64%0A%09_C_long_long int64%0A)%0A%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Atype Timeval struct %7B%0A%09Sec  int64%0A%09Usec int64%0A%7D%0A%0Atype Timeval32 struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype Tms struct %7B%0A%09Utime  int64%0A%09Stime  int64%0A%09Cutime int64%0A%09Cstime int64%0A%7D%0A%0Atype Utimbuf struct %7B%0A%09Actime  int64%0A%09Modtime int64%0A%7D%0A%0Atype Rusage struct %7B%0A%09Utime    Timeval%0A%09Stime    Timeval%0A%09Maxrss   int64%0A%09Ixrss    int64%0A%09Idrss    int64%0A%09Isrss    int64%0A%09Minflt   int64%0A%09Majflt   int64%0A%09Nswap    int64%0A%09Inblock  int64%0A%09Oublock  int64%0A%09Msgsnd   int64%0A%09Msgrcv   int64%0A%09Nsignals int64%0A%09Nvcsw    int64%0A%09Nivcsw   int64%0A%7D%0A%0Atype Rlimit struct %7B%0A%09Cur uint64%0A%09Max uint64%0A%7D%0A%0Atype _Gid_t uint32%0A%0Atype Stat_t struct %7B%0A%09Dev     uint64%0A%09Ino     uint64%0A%09Mode    uint32%0A%09Nlink   uint32%0A%09Uid     uint32%0A%09Gid     uint32%0A%09Rdev    uint64%0A%09Size    int64%0A%09Atim    Timespec%0A%09Mtim    Timespec%0A%09Ctim    Timespec%0A%09Blksize int32%0A%09_       %5B4%5Dbyte%0A%09Blocks  int64%0A%09Fstype  %5B16%5Dint8%0A%7D%0A%0Atype Flock_t struct %7B%0A%09Type   int16%0A%09Whence int16%0A%09_      %5B4%5Dbyte%0A%09Start  int64%0A%09Len    int64%0A%09Sysid  int32%0A%09Pid    int32%0A%09Pad    %5B4%5Dint64%0A%7D%0A%0Atype Dirent struct %7B%0A%09Ino    uint64%0A%09Off    int64%0A%09Reclen uint16%0A%09Name   %5B1%5Dint8%0A%09_      %5B5%5Dbyte%0A%7D%0A%0Atype _Fsblkcnt_t uint64%0A%0Atype Statvfs_t struct %7B%0A%09Bsize    uint64%0A%09Frsize   uint64%0A%09Blocks   uint64%0A%09Bfree    uint64%0A%09Bavail   uint64%0A%09Files    uint64%0A%09Ffree    uint64%0A%09Favail   uint64%0A%09Fsid     uint64%0A%09Basetype %5B16%5Dint8%0A%09Flag     uint64%0A%09Namemax  uint64%0A%09Fstr     %5B32%5Dint8%0A%7D%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Dint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family         uint16%0A%09Port           uint16%0A%09Flowinfo       uint32%0A%09Addr           %5B16%5Dbyte /* in6_addr */%0A%09Scope_id       uint32%0A%09X__sin6_src_id uint32%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5B108%5Dint8%0A%7D%0A%0Atype RawSockaddrDatalink struct %7B%0A%09Family uint16%0A%09Index  uint16%0A%09Type   uint8%0A%09Nlen   uint8%0A%09Alen   uint8%0A%09Slen   uint8%0A%09Data   %5B244%5Dint8%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B236%5Dint8%0A%7D%0A%0Atype _Socklen uint32%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype Iovec struct %7B%0A%09Base *int8%0A%09Len  uint64%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Atype Msghdr struct %7B%0A%09Name         *byte%0A%09Namelen      uint32%0A%09_            %5B4%5Dbyte%0A%09Iov          *Iovec%0A%09Iovlen       int32%0A%09_            %5B4%5Dbyte%0A%09Accrights    *int8%0A%09Accrightslen int32%0A%09_            %5B4%5Dbyte%0A%7D%0A%0Atype Cmsghdr struct %7B%0A%09Len   uint32%0A%09Level int32%0A%09Type  int32%0A%7D%0A%0Atype Inet6Pktinfo struct %7B%0A%09Addr    %5B16%5Dbyte /* in6_addr */%0A%09Ifindex uint32%0A%7D%0A%0Atype IPv6MTUInfo struct %7B%0A%09Addr RawSockaddrInet6%0A%09Mtu  uint32%0A%7D%0A%0Atype ICMPv6Filter struct %7B%0A%09X__icmp6_filt %5B8%5Duint32%0A%7D%0A%0Aconst (%0A%09SizeofSockaddrInet4    = 0x10%0A%09SizeofSockaddrInet6    = 0x20%0A%09SizeofSockaddrAny      = 0xfc%0A%09SizeofSockaddrUnix     = 0x6e%0A%09SizeofSockaddrDatalink = 0xfc%0A%09SizeofLinger           = 0x8%0A%09SizeofIPMreq           = 0x8%0A%09SizeofIPv6Mreq         = 0x14%0A%09SizeofMsghdr           = 0x30%0A%09SizeofCmsghdr          = 0xc%0A%09SizeofInet6Pktinfo     = 0x14%0A%09SizeofIPv6MTUInfo      = 0x24%0A%09SizeofICMPv6Filter     = 0x20%0A)%0A%0Atype FdSet struct %7B%0A%09Bits %5B1024%5Dint64%0A%7D%0A%0Atype Utsname struct %7B%0A%09Sysname  %5B257%5Dbyte%0A%09Nodename %5B257%5Dbyte%0A%09Release  %5B257%5Dbyte%0A%09Version  %5B257%5Dbyte%0A%09Machine  %5B257%5Dbyte%0A%7D%0A%0Atype Ustat_t struct %7B%0A%09Tfree  int64%0A%09Tinode uint64%0A%09Fname  %5B6%5Dint8%0A%09Fpack  %5B6%5Dint8%0A%09_      %5B4%5Dbyte%0A%7D%0A%0Aconst (%0A%09AT_FDCWD            = 0xffd19553%0A%09AT_SYMLINK_NOFOLLOW = 0x1000%0A%09AT_SYMLINK_FOLLOW   = 0x2000%0A%09AT_REMOVEDIR        = 0x1%0A%09AT_EACCESS          = 0x4%0A)%0A%0Aconst (%0A%09SizeofIfMsghdr  = 0x54%0A%09SizeofIfData    = 0x44%0A%09SizeofIfaMsghdr = 0x14%0A%09SizeofRtMsghdr  = 0x4c%0A%09SizeofRtMetrics = 0x28%0A)%0A%0Atype IfMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Data    IfData%0A%7D%0A%0Atype IfData struct %7B%0A%09Type       uint8%0A%09Addrlen    uint8%0A%09Hdrlen     uint8%0A%09_          %5B1%5Dbyte%0A%09Mtu        uint32%0A%09Metric     uint32%0A%09Baudrate   uint32%0A%09Ipackets   uint32%0A%09Ierrors    uint32%0A%09Opackets   uint32%0A%09Oerrors    uint32%0A%09Collisions uint32%0A%09Ibytes     uint32%0A%09Obytes     uint32%0A%09Imcasts    uint32%0A%09Omcasts    uint32%0A%09Iqdrops    uint32%0A%09Noproto    uint32%0A%09Lastchange Timeval32%0A%7D%0A%0Atype IfaMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Addrs   int32%0A%09Flags   int32%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Metric  int32%0A%7D%0A%0Atype RtMsghdr struct %7B%0A%09Msglen  uint16%0A%09Version uint8%0A%09Type    uint8%0A%09Index   uint16%0A%09_       %5B2%5Dbyte%0A%09Flags   int32%0A%09Addrs   int32%0A%09Pid     int32%0A%09Seq     int32%0A%09Errno   int32%0A%09Use     int32%0A%09Inits   uint32%0A%09Rmx     RtMetrics%0A%7D%0A%0Atype RtMetrics struct %7B%0A%09Locks    uint32%0A%09Mtu      uint32%0A%09Hopcount uint32%0A%09Expire   uint32%0A%09Recvpipe uint32%0A%09Sendpipe uint32%0A%09Ssthresh uint32%0A%09Rtt      uint32%0A%09Rttvar   uint32%0A%09Pksent   uint32%0A%7D%0A%0Aconst (%0A%09SizeofBpfVersion = 0x4%0A%09SizeofBpfStat    = 0x80%0A%09SizeofBpfProgram = 0x10%0A%09SizeofBpfInsn    = 0x8%0A%09SizeofBpfHdr     = 0x14%0A)%0A%0Atype BpfVersion struct %7B%0A%09Major uint16%0A%09Minor uint16%0A%7D%0A%0Atype BpfStat struct %7B%0A%09Recv    uint64%0A%09Drop    uint64%0A%09Capt    uint64%0A%09Padding %5B13%5Duint64%0A%7D%0A%0Atype BpfProgram struct %7B%0A%09Len   uint32%0A%09_     %5B4%5Dbyte%0A%09Insns *BpfInsn%0A%7D%0A%0Atype BpfInsn struct %7B%0A%09Code uint16%0A%09Jt   uint8%0A%09Jf   uint8%0A%09K    uint32%0A%7D%0A%0Atype BpfTimeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Atype BpfHdr struct %7B%0A%09Tstamp  BpfTimeval%0A%09Caplen  uint32%0A%09Datalen uint32%0A%09Hdrlen  uint16%0A%09_       %5B2%5Dbyte%0A%7D%0A%0A
 type Ter
@@ -6014,16 +6014,490 @@
 _     %5B1%5Dbyte%0A%7D%0A
+%0Atype Termio struct %7B%0A%09Iflag uint16%0A%09Oflag uint16%0A%09Cflag uint16%0A%09Lflag uint16%0A%09Line  int8%0A%09Cc    %5B8%5Duint8%0A%09_     %5B1%5Dbyte%0A%7D%0A%0Atype Winsize struct %7B%0A%09Row    uint16%0A%09Col    uint16%0A%09Xpixel uint16%0A%09Ypixel uint16%0A%7D%0A%0Atype PollFd struct %7B%0A%09Fd      int32%0A%09Events  int16%0A%09Revents int16%0A%7D%0A%0Aconst (%0A%09POLLERR    = 0x8%0A%09POLLHUP    = 0x10%0A%09POLLIN     = 0x1%0A%09POLLNVAL   = 0x20%0A%09POLLOUT    = 0x4%0A%09POLLPRI    = 0x2%0A%09POLLRDBAND = 0x80%0A%09POLLRDNORM = 0x40%0A%09POLLWRBAND = 0x100%0A%09POLLWRNORM = 0x4%0A)%0A
- f 1386d2e2eb8ec0a480b544ff0a967fcdd4abcfe1bd1f142f25b09c634d228cb9 vendor/golang.org/x/sys/windows/aliases.go
+ f 1ed908469d018fc34605124b47418422091f4aae525cd91561a9d94787934050 vendor/golang.org/x/sys/windows/aliases.go
dmppatch 3
@@ -196,16 +196,101 @@
 package windows%0A
+%0Aimport %22syscall%22%0A%0Atype Errno = syscall.Errno%0Atype SysProcAttr = syscall.SysProcAttr%0A
+ f 2d3cad76dcf93bd8d395771f4c46aa4f9e732cd69c6fb589c5ab8a371c9c1f2f vendor/golang.org/x/sys/windows/asm_windows_arm.s
dmppatch 2
@@ -0,0 +1,314 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0A#include %22textflag.h%22%0A%0ATEXT %C2%B7getprocaddress(SB),NOSPLIT,$0%0A%09B%09syscall%C2%B7getprocaddress(SB)%0A%0ATEXT %C2%B7loadlibrary(SB),NOSPLIT,$0%0A%09B%09syscall%C2%B7loadlibrary(SB)%0A
- f 35bfa1de8a87825e0db0adc8aa48b116be18d66a03bcc033445c8b2ed164ddaf vendor/golang.org/x/sys/windows/dll_windows.go
+ f 95d1bd87578406553f1509462dc37a277e5c6a1605ae91a9c6f42ea586c7b719 vendor/golang.org/x/sys/windows/dll_windows.go
dmppatch 3
@@ -169,8 +169,11063 @@
 windows%0A
+%0Aimport (%0A%09%22sync%22%0A%09%22sync/atomic%22%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0A// DLLError describes reasons for DLL load failures.%0Atype DLLError struct %7B%0A%09Err     error%0A%09ObjName string%0A%09Msg     string%0A%7D%0A%0Afunc (e *DLLError) Error() string %7B return e.Msg %7D%0A%0A// Implemented in runtime/syscall_windows.goc; we provide jumps to them in our assembly file.%0Afunc loadlibrary(filename *uint16) (handle uintptr, err syscall.Errno)%0Afunc getprocaddress(handle uintptr, procname *uint8) (proc uintptr, err syscall.Errno)%0A%0A// A DLL implements access to a single DLL.%0Atype DLL struct %7B%0A%09Name   string%0A%09Handle Handle%0A%7D%0A%0A// LoadDLL loads DLL file into memory.%0A//%0A// Warning: using LoadDLL without an absolute path name is subject to%0A// DLL preloading attacks. To safely load a system DLL, use LazyDLL%0A// with System set to true, or use LoadLibraryEx directly.%0Afunc LoadDLL(name string) (dll *DLL, err error) %7B%0A%09namep, err := UTF16PtrFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09h, e := loadlibrary(namep)%0A%09if e != 0 %7B%0A%09%09return nil, &DLLError%7B%0A%09%09%09Err:     e,%0A%09%09%09ObjName: name,%0A%09%09%09Msg:     %22Failed to load %22 + name + %22: %22 + e.Error(),%0A%09%09%7D%0A%09%7D%0A%09d := &DLL%7B%0A%09%09Name:   name,%0A%09%09Handle: Handle(h),%0A%09%7D%0A%09return d, nil%0A%7D%0A%0A// MustLoadDLL is like LoadDLL but panics if load operation failes.%0Afunc MustLoadDLL(name string) *DLL %7B%0A%09d, e := LoadDLL(name)%0A%09if e != nil %7B%0A%09%09panic(e)%0A%09%7D%0A%09return d%0A%7D%0A%0A// FindProc searches DLL d for procedure named name and returns *Proc%0A// if found. It returns an error if search fails.%0Afunc (d *DLL) FindProc(name string) (proc *Proc, err error) %7B%0A%09namep, err := BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09a, e := getprocaddress(uintptr(d.Handle), namep)%0A%09if e != 0 %7B%0A%09%09return nil, &DLLError%7B%0A%09%09%09Err:     e,%0A%09%09%09ObjName: name,%0A%09%09%09Msg:     %22Failed to find %22 + name + %22 procedure in %22 + d.Name + %22: %22 + e.Error(),%0A%09%09%7D%0A%09%7D%0A%09p := &Proc%7B%0A%09%09Dll:  d,%0A%09%09Name: name,%0A%09%09addr: a,%0A%09%7D%0A%09return p, nil%0A%7D%0A%0A// MustFindProc is like FindProc but panics if search fails.%0Afunc (d *DLL) MustFindProc(name string) *Proc %7B%0A%09p, e := d.FindProc(name)%0A%09if e != nil %7B%0A%09%09panic(e)%0A%09%7D%0A%09return p%0A%7D%0A%0A// Release unloads DLL d from memory.%0Afunc (d *DLL) Release() (err error) %7B%0A%09return FreeLibrary(d.Handle)%0A%7D%0A%0A// A Proc implements access to a procedure inside a DLL.%0Atype Proc struct %7B%0A%09Dll  *DLL%0A%09Name string%0A%09addr uintptr%0A%7D%0A%0A// Addr returns the address of the procedure represented by p.%0A// The return value can be passed to Syscall to run the procedure.%0Afunc (p *Proc) Addr() uintptr %7B%0A%09return p.addr%0A%7D%0A%0A//go:uintptrescapes%0A%0A// Call executes procedure p with arguments a. It will panic, if more than 15 arguments%0A// are supplied.%0A//%0A// The returned error is always non-nil, constructed from the result of GetLastError.%0A// Callers must inspect the primary return value to decide whether an error occurred%0A// (according to the semantics of the specific function being called) before consulting%0A// the error. The error will be guaranteed to contain windows.Errno.%0Afunc (p *Proc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) %7B%0A%09switch len(a) %7B%0A%09case 0:%0A%09%09return syscall.Syscall(p.Addr(), uintptr(len(a)), 0, 0, 0)%0A%09case 1:%0A%09%09return syscall.Syscall(p.Addr(), uintptr(len(a)), a%5B0%5D, 0, 0)%0A%09case 2:%0A%09%09return syscall.Syscall(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, 0)%0A%09case 3:%0A%09%09return syscall.Syscall(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D)%0A%09case 4:%0A%09%09return syscall.Syscall6(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, 0, 0)%0A%09case 5:%0A%09%09return syscall.Syscall6(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, 0)%0A%09case 6:%0A%09%09return syscall.Syscall6(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D)%0A%09case 7:%0A%09%09return syscall.Syscall9(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, 0, 0)%0A%09case 8:%0A%09%09return syscall.Syscall9(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, 0)%0A%09case 9:%0A%09%09return syscall.Syscall9(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D)%0A%09case 10:%0A%09%09return syscall.Syscall12(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, 0, 0)%0A%09case 11:%0A%09%09return syscall.Syscall12(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, 0)%0A%09case 12:%0A%09%09return syscall.Syscall12(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, a%5B11%5D)%0A%09case 13:%0A%09%09return syscall.Syscall15(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, a%5B11%5D, a%5B12%5D, 0, 0)%0A%09case 14:%0A%09%09return syscall.Syscall15(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, a%5B11%5D, a%5B12%5D, a%5B13%5D, 0)%0A%09case 15:%0A%09%09return syscall.Syscall15(p.Addr(), uintptr(len(a)), a%5B0%5D, a%5B1%5D, a%5B2%5D, a%5B3%5D, a%5B4%5D, a%5B5%5D, a%5B6%5D, a%5B7%5D, a%5B8%5D, a%5B9%5D, a%5B10%5D, a%5B11%5D, a%5B12%5D, a%5B13%5D, a%5B14%5D)%0A%09default:%0A%09%09panic(%22Call %22 + p.Name + %22 with too many arguments %22 + itoa(len(a)) + %22.%22)%0A%09%7D%0A%7D%0A%0A// A LazyDLL implements access to a single DLL.%0A// It will delay the load of the DLL until the first%0A// call to its Handle method or to one of its%0A// LazyProc's Addr method.%0Atype LazyDLL struct %7B%0A%09Name string%0A%0A%09// System determines whether the DLL must be loaded from the%0A%09// Windows System directory, bypassing the normal DLL search%0A%09// path.%0A%09System bool%0A%0A%09mu  sync.Mutex%0A%09dll *DLL // non nil once DLL is loaded%0A%7D%0A%0A// Load loads DLL file d.Name into memory. It returns an error if fails.%0A// Load will not try to load DLL, if it is already loaded into memory.%0Afunc (d *LazyDLL) Load() error %7B%0A%09// Non-racy version of:%0A%09// if d.dll != nil %7B%0A%09if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll))) != nil %7B%0A%09%09return nil%0A%09%7D%0A%09d.mu.Lock()%0A%09defer d.mu.Unlock()%0A%09if d.dll != nil %7B%0A%09%09return nil%0A%09%7D%0A%0A%09// kernel32.dll is special, since it's where LoadLibraryEx comes from.%0A%09// The kernel already special-cases its name, so it's always%0A%09// loaded from system32.%0A%09var dll *DLL%0A%09var err error%0A%09if d.Name == %22kernel32.dll%22 %7B%0A%09%09dll, err = LoadDLL(d.Name)%0A%09%7D else %7B%0A%09%09dll, err = loadLibraryEx(d.Name, d.System)%0A%09%7D%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%0A%09// Non-racy version of:%0A%09// d.dll = dll%0A%09atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&d.dll)), unsafe.Pointer(dll))%0A%09return nil%0A%7D%0A%0A// mustLoad is like Load but panics if search fails.%0Afunc (d *LazyDLL) mustLoad() %7B%0A%09e := d.Load()%0A%09if e != nil %7B%0A%09%09panic(e)%0A%09%7D%0A%7D%0A%0A// Handle returns d's module handle.%0Afunc (d *LazyDLL) Handle() uintptr %7B%0A%09d.mustLoad()%0A%09return uintptr(d.dll.Handle)%0A%7D%0A%0A// NewProc returns a LazyProc for accessing the named procedure in the DLL d.%0Afunc (d *LazyDLL) NewProc(name string) *LazyProc %7B%0A%09return &LazyProc%7Bl: d, Name: name%7D%0A%7D%0A%0A// NewLazyDLL creates new LazyDLL associated with DLL file.%0Afunc NewLazyDLL(name string) *LazyDLL %7B%0A%09return &LazyDLL%7BName: name%7D%0A%7D%0A%0A// NewLazySystemDLL is like NewLazyDLL, but will only%0A// search Windows System directory for the DLL if name is%0A// a base name (like %22advapi32.dll%22).%0Afunc NewLazySystemDLL(name string) *LazyDLL %7B%0A%09return &LazyDLL%7BName: name, System: true%7D%0A%7D%0A%0A// A LazyProc implements access to a procedure inside a LazyDLL.%0A// It delays the lookup until the Addr method is called.%0Atype LazyProc struct %7B%0A%09Name string%0A%0A%09mu   sync.Mutex%0A%09l    *LazyDLL%0A%09proc *Proc%0A%7D%0A%0A// Find searches DLL for procedure named p.Name. It returns%0A// an error if search fails. Find will not search procedure,%0A// if it is already found and loaded into memory.%0Afunc (p *LazyProc) Find() error %7B%0A%09// Non-racy version of:%0A%09// if p.proc == nil %7B%0A%09if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc))) == nil %7B%0A%09%09p.mu.Lock()%0A%09%09defer p.mu.Unlock()%0A%09%09if p.proc == nil %7B%0A%09%09%09e := p.l.Load()%0A%09%09%09if e != nil %7B%0A%09%09%09%09return e%0A%09%09%09%7D%0A%09%09%09proc, e := p.l.dll.FindProc(p.Name)%0A%09%09%09if e != nil %7B%0A%09%09%09%09return e%0A%09%09%09%7D%0A%09%09%09// Non-racy version of:%0A%09%09%09// p.proc = proc%0A%09%09%09atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&p.proc)), unsafe.Pointer(proc))%0A%09%09%7D%0A%09%7D%0A%09return nil%0A%7D%0A%0A// mustFind is like Find but panics if search fails.%0Afunc (p *LazyProc) mustFind() %7B%0A%09e := p.Find()%0A%09if e != nil %7B%0A%09%09panic(e)%0A%09%7D%0A%7D%0A%0A// Addr returns the address of the procedure represented by p.%0A// The return value can be passed to Syscall to run the procedure.%0A// It will panic if the procedure cannot be found.%0Afunc (p *LazyProc) Addr() uintptr %7B%0A%09p.mustFind()%0A%09return p.proc.Addr()%0A%7D%0A%0A//go:uintptrescapes%0A%0A// Call executes procedure p with arguments a. It will panic, if more than 15 arguments%0A// are supplied. It will also panic if the procedure cannot be found.%0A//%0A// The returned error is always non-nil, constructed from the result of GetLastError.%0A// Callers must inspect the primary return value to decide whether an error occurred%0A// (according to the semantics of the specific function being called) before consulting%0A// the error. The error will be guaranteed to contain windows.Errno.%0Afunc (p *LazyProc) Call(a ...uintptr) (r1, r2 uintptr, lastErr error) %7B%0A%09p.mustFind()%0A%09return p.proc.Call(a...)%0A%7D%0A%0Avar canDoSearchSystem32Once struct %7B%0A%09sync.Once%0A%09v bool%0A%7D%0A%0Afunc initCanDoSearchSystem32() %7B%0A%09// https://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx says:%0A%09// %22Windows 7, Windows Server 2008 R2, Windows Vista, and Windows%0A%09// Server 2008: The LOAD_LIBRARY_SEARCH_* flags are available on%0A%09// systems that have KB2533623 installed. To determine whether the%0A%09// flags are available, use GetProcAddress to get the address of the%0A%09// AddDllDirectory, RemoveDllDirectory, or SetDefaultDllDirectories%0A%09// function. If GetProcAddress succeeds, the LOAD_LIBRARY_SEARCH_*%0A%09// flags can be used with LoadLibraryEx.%22%0A%09canDoSearchSystem32Once.v = (modkernel32.NewProc(%22AddDllDirectory%22).Find() == nil)%0A%7D%0A%0Afunc canDoSearchSystem32() bool %7B%0A%09canDoSearchSystem32Once.Do(initCanDoSearchSystem32)%0A%09return canDoSearchSystem32Once.v%0A%7D%0A%0Afunc isBaseName(name string) bool %7B%0A%09for _, c := range name %7B%0A%09%09if c == ':' %7C%7C c == '/' %7C%7C c == '%5C%5C' %7B%0A%09%09%09return false%0A%09%09%7D%0A%09%7D%0A%09return true%0A%7D%0A%0A// loadLibraryEx wraps the Windows LoadLibraryEx function.%0A//%0A// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx%0A//%0A// If name is not an absolute path, LoadLibraryEx searches for the DLL%0A// in a variety of automatic locations unless constrained by flags.%0A// See: https://msdn.microsoft.com/en-us/library/ff919712%2528VS.85%2529.aspx%0Afunc loadLibraryEx(name string, system bool) (*DLL, error) %7B%0A%09loadDLL := name%0A%09var flags uintptr%0A%09if system %7B%0A%09%09if canDoSearchSystem32() %7B%0A%09%09%09const LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800%0A%09%09%09flags = LOAD_LIBRARY_SEARCH_SYSTEM32%0A%09%09%7D else if isBaseName(name) %7B%0A%09%09%09// WindowsXP or unpatched Windows machine%0A%09%09%09// trying to load %22foo.dll%22 out of the system%0A%09%09%09// folder, but LoadLibraryEx doesn't support%0A%09%09%09// that yet on their system, so emulate it.%0A%09%09%09windir, _ := Getenv(%22WINDIR%22) // old var; apparently works on XP%0A%09%09%09if windir == %22%22 %7B%0A%09%09%09%09return nil, errString(%22%25WINDIR%25 not defined%22)%0A%09%09%09%7D%0A%09%09%09loadDLL = windir + %22%5C%5CSystem32%5C%5C%22 + name%0A%09%09%7D%0A%09%7D%0A%09h, err := LoadLibraryEx(loadDLL, 0, flags)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &DLL%7BName: name, Handle: h%7D, nil%0A%7D%0A%0Atype errString string%0A%0Afunc (s errString) Error() string %7B return string(s) %7D%0A
- f 1d9756e565cea8b2df0cb16c1e403b252d3dda357577d5d1703bd6d15f3c34dd vendor/golang.org/x/sys/windows/env_windows.go
+ f 318984a14c6d62c099cfe607e66f3e23511da19ed2280d1267edc5ff9b62fe86 vendor/golang.org/x/sys/windows/env_windows.go
dmppatch 3
@@ -204,8 +204,350 @@
 windows%0A
+%0Aimport %22syscall%22%0A%0Afunc Getenv(key string) (value string, found bool) %7B%0A%09return syscall.Getenv(key)%0A%7D%0A%0Afunc Setenv(key, value string) error %7B%0A%09return syscall.Setenv(key, value)%0A%7D%0A%0Afunc Clearenv() %7B%0A%09syscall.Clearenv()%0A%7D%0A%0Afunc Environ() %5B%5Dstring %7B%0A%09return syscall.Environ()%0A%7D%0A%0Afunc Unsetenv(key string) error %7B%0A%09return syscall.Unsetenv(key)%0A%7D%0A
- f d08387e435d6d1d0fa654ded83d7c886b5760498375549f7c6fbbc63661bce5c vendor/golang.org/x/sys/windows/eventlog.go
+ f 36e6102d274d20dbb5f740376453bb6ab13e02c86e2be706857a07a236b5682e vendor/golang.org/x/sys/windows/eventlog.go
dmppatch 3
@@ -180,16 +180,645 @@
 package windows%0A
+%0Aconst (%0A%09EVENTLOG_SUCCESS          = 0%0A%09EVENTLOG_ERROR_TYPE       = 1%0A%09EVENTLOG_WARNING_TYPE     = 2%0A%09EVENTLOG_INFORMATION_TYPE = 4%0A%09EVENTLOG_AUDIT_SUCCESS    = 8%0A%09EVENTLOG_AUDIT_FAILURE    = 16%0A)%0A%0A//sys%09RegisterEventSource(uncServerName *uint16, sourceName *uint16) (handle Handle, err error) %5Bfailretval==0%5D = advapi32.RegisterEventSourceW%0A//sys%09DeregisterEventSource(handle Handle) (err error) = advapi32.DeregisterEventSource%0A//sys%09ReportEvent(log Handle, etype uint16, category uint16, eventId uint32, usrSId uintptr, numStrings uint16, dataSize uint32, strings **uint16, rawData *byte) (err error) = advapi32.ReportEventW%0A
- f c87224258f6e207f33a4361113bf782d716c33c7e40623b41a6295c1cc6cc7cd vendor/golang.org/x/sys/windows/exec_windows.go
+ f fd58dc33d892badcfd5238722dbaa3b71b0d5e3ffa7a23b36015037530d56146 vendor/golang.org/x/sys/windows/exec_windows.go
dmppatch 3
@@ -196,8 +196,1754 @@
 windows%0A
+%0A// EscapeArg rewrites command line argument s as prescribed%0A// in http://msdn.microsoft.com/en-us/library/ms880421.%0A// This function returns %22%22 (2 double quotes) if s is empty.%0A// Alternatively, these transformations are done:%0A// - every back slash (%5C) is doubled, but only if immediately%0A//   followed by double quote (%22);%0A// - every double quote (%22) is escaped by back slash (%5C);%0A// - finally, s is wrapped with double quotes (arg -%3E %22arg%22),%0A//   but only if there is space or tab inside s.%0Afunc EscapeArg(s string) string %7B%0A%09if len(s) == 0 %7B%0A%09%09return %22%5C%22%5C%22%22%0A%09%7D%0A%09n := len(s)%0A%09hasSpace := false%0A%09for i := 0; i %3C len(s); i++ %7B%0A%09%09switch s%5Bi%5D %7B%0A%09%09case '%22', '%5C%5C':%0A%09%09%09n++%0A%09%09case ' ', '%5Ct':%0A%09%09%09hasSpace = true%0A%09%09%7D%0A%09%7D%0A%09if hasSpace %7B%0A%09%09n += 2%0A%09%7D%0A%09if n == len(s) %7B%0A%09%09return s%0A%09%7D%0A%0A%09qs := make(%5B%5Dbyte, n)%0A%09j := 0%0A%09if hasSpace %7B%0A%09%09qs%5Bj%5D = '%22'%0A%09%09j++%0A%09%7D%0A%09slashes := 0%0A%09for i := 0; i %3C len(s); i++ %7B%0A%09%09switch s%5Bi%5D %7B%0A%09%09default:%0A%09%09%09slashes = 0%0A%09%09%09qs%5Bj%5D = s%5Bi%5D%0A%09%09case '%5C%5C':%0A%09%09%09slashes++%0A%09%09%09qs%5Bj%5D = s%5Bi%5D%0A%09%09case '%22':%0A%09%09%09for ; slashes %3E 0; slashes-- %7B%0A%09%09%09%09qs%5Bj%5D = '%5C%5C'%0A%09%09%09%09j++%0A%09%09%09%7D%0A%09%09%09qs%5Bj%5D = '%5C%5C'%0A%09%09%09j++%0A%09%09%09qs%5Bj%5D = s%5Bi%5D%0A%09%09%7D%0A%09%09j++%0A%09%7D%0A%09if hasSpace %7B%0A%09%09for ; slashes %3E 0; slashes-- %7B%0A%09%09%09qs%5Bj%5D = '%5C%5C'%0A%09%09%09j++%0A%09%09%7D%0A%09%09qs%5Bj%5D = '%22'%0A%09%09j++%0A%09%7D%0A%09return string(qs%5B:j%5D)%0A%7D%0A%0Afunc CloseOnExec(fd Handle) %7B%0A%09SetHandleInformation(Handle(fd), HANDLE_FLAG_INHERIT, 0)%0A%7D%0A%0A// FullPath retrieves the full path of the specified file.%0Afunc FullPath(name string) (path string, err error) %7B%0A%09p, err := UTF16PtrFromString(name)%0A%09if err != nil %7B%0A%09%09return %22%22, err%0A%09%7D%0A%09n := uint32(100)%0A%09for %7B%0A%09%09buf := make(%5B%5Duint16, n)%0A%09%09n, err = GetFullPathName(p, uint32(len(buf)), &buf%5B0%5D, nil)%0A%09%09if err != nil %7B%0A%09%09%09return %22%22, err%0A%09%09%7D%0A%09%09if n %3C= uint32(len(buf)) %7B%0A%09%09%09return UTF16ToString(buf%5B:n%5D), nil%0A%09%09%7D%0A%09%7D%0A%7D%0A
- f e8280d9af46bbc376706573648ec3571699cecffc71815af4c8217f343e4bafe vendor/golang.org/x/sys/windows/memory_windows.go
+ f 218c056f2c289808308ecd2d6e0afd987c1c001e0e75410a4ef23470459681d9 vendor/golang.org/x/sys/windows/memory_windows.go
dmppatch 3
@@ -169,8 +169,537 @@
 windows%0A
+%0Aconst (%0A%09MEM_COMMIT      = 0x00001000%0A%09MEM_RESERVE     = 0x00002000%0A%09MEM_DECOMMIT    = 0x00004000%0A%09MEM_RELEASE     = 0x00008000%0A%09MEM_RESET       = 0x00080000%0A%09MEM_TOP_DOWN    = 0x00100000%0A%09MEM_WRITE_WATCH = 0x00200000%0A%09MEM_PHYSICAL    = 0x00400000%0A%09MEM_RESET_UNDO  = 0x01000000%0A%09MEM_LARGE_PAGES = 0x20000000%0A%0A%09PAGE_NOACCESS          = 0x01%0A%09PAGE_READONLY          = 0x02%0A%09PAGE_READWRITE         = 0x04%0A%09PAGE_WRITECOPY         = 0x08%0A%09PAGE_EXECUTE_READ      = 0x20%0A%09PAGE_EXECUTE_READWRITE = 0x40%0A%09PAGE_EXECUTE_WRITECOPY = 0x80%0A)%0A
- f be89dce4cc3f35642f6141232fe8bb83939153db40216509d170e9f8a75aca70 vendor/golang.org/x/sys/windows/race.go
+ f 42c5afa9e5a630f46ed19d1f86ed902e0d6502413b42cf641d7ef703c0c2db6a vendor/golang.org/x/sys/windows/race.go
dmppatch 3
@@ -193,8 +193,395 @@
 windows%0A
+%0Aimport (%0A%09%22runtime%22%0A%09%22unsafe%22%0A)%0A%0Aconst raceenabled = true%0A%0Afunc raceAcquire(addr unsafe.Pointer) %7B%0A%09runtime.RaceAcquire(addr)%0A%7D%0A%0Afunc raceReleaseMerge(addr unsafe.Pointer) %7B%0A%09runtime.RaceReleaseMerge(addr)%0A%7D%0A%0Afunc raceReadRange(addr unsafe.Pointer, len int) %7B%0A%09runtime.RaceReadRange(addr, len)%0A%7D%0A%0Afunc raceWriteRange(addr unsafe.Pointer, len int) %7B%0A%09runtime.RaceWriteRange(addr, len)%0A%7D%0A
- f 4802bf82b35e668cd0ed529c94f920e0ec007e276e09c03a78cccda6e05f4699 vendor/golang.org/x/sys/windows/race0.go
+ f f483ad20eef4aedcabc598060fa414eab96f19e3391d1d65d9aec420d64ffd9d vendor/golang.org/x/sys/windows/race0.go
dmppatch 3
@@ -194,8 +194,257 @@
 windows%0A
+%0Aimport (%0A%09%22unsafe%22%0A)%0A%0Aconst raceenabled = false%0A%0Afunc raceAcquire(addr unsafe.Pointer) %7B%0A%7D%0A%0Afunc raceReleaseMerge(addr unsafe.Pointer) %7B%0A%7D%0A%0Afunc raceReadRange(addr unsafe.Pointer, len int) %7B%0A%7D%0A%0Afunc raceWriteRange(addr unsafe.Pointer, len int) %7B%0A%7D%0A
- f c161eab0877a67b7f544e08ff45b14f92463cd103a81950a1b5371e59fd31111 vendor/golang.org/x/sys/windows/security_windows.go
+ f 1b64b8331926673dd4f62666d5f4caa048ca0990e5324cdbf099a8759623a359 vendor/golang.org/x/sys/windows/security_windows.go
dmppatch 3
@@ -169,8 +169,14567 @@
 windows%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Aconst (%0A%09STANDARD_RIGHTS_REQUIRED = 0xf0000%0A%09STANDARD_RIGHTS_READ     = 0x20000%0A%09STANDARD_RIGHTS_WRITE    = 0x20000%0A%09STANDARD_RIGHTS_EXECUTE  = 0x20000%0A%09STANDARD_RIGHTS_ALL      = 0x1F0000%0A)%0A%0Aconst (%0A%09NameUnknown          = 0%0A%09NameFullyQualifiedDN = 1%0A%09NameSamCompatible    = 2%0A%09NameDisplay          = 3%0A%09NameUniqueId         = 6%0A%09NameCanonical        = 7%0A%09NameUserPrincipal    = 8%0A%09NameCanonicalEx      = 9%0A%09NameServicePrincipal = 10%0A%09NameDnsDomain        = 12%0A)%0A%0A// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.%0A// http://blogs.msdn.com/b/drnick/archive/2007/12/19/windows-and-upn-format-credentials.aspx%0A//sys%09TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) %5Bfailretval&0xff==0%5D = secur32.TranslateNameW%0A//sys%09GetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) %5Bfailretval&0xff==0%5D = secur32.GetUserNameExW%0A%0A// TranslateAccountName converts a directory service%0A// object name from one format to another.%0Afunc TranslateAccountName(username string, from, to uint32, initSize int) (string, error) %7B%0A%09u, e := UTF16PtrFromString(username)%0A%09if e != nil %7B%0A%09%09return %22%22, e%0A%09%7D%0A%09n := uint32(50)%0A%09for %7B%0A%09%09b := make(%5B%5Duint16, n)%0A%09%09e = TranslateName(u, from, to, &b%5B0%5D, &n)%0A%09%09if e == nil %7B%0A%09%09%09return UTF16ToString(b%5B:n%5D), nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return %22%22, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return %22%22, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Aconst (%0A%09// do not reorder%0A%09NetSetupUnknownStatus = iota%0A%09NetSetupUnjoined%0A%09NetSetupWorkgroupName%0A%09NetSetupDomainName%0A)%0A%0Atype UserInfo10 struct %7B%0A%09Name       *uint16%0A%09Comment    *uint16%0A%09UsrComment *uint16%0A%09FullName   *uint16%0A%7D%0A%0A//sys%09NetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) = netapi32.NetUserGetInfo%0A//sys%09NetGetJoinInformation(server *uint16, name **uint16, bufType *uint32) (neterr error) = netapi32.NetGetJoinInformation%0A//sys%09NetApiBufferFree(buf *byte) (neterr error) = netapi32.NetApiBufferFree%0A%0Aconst (%0A%09// do not reorder%0A%09SidTypeUser = 1 + iota%0A%09SidTypeGroup%0A%09SidTypeDomain%0A%09SidTypeAlias%0A%09SidTypeWellKnownGroup%0A%09SidTypeDeletedAccount%0A%09SidTypeInvalid%0A%09SidTypeUnknown%0A%09SidTypeComputer%0A%09SidTypeLabel%0A)%0A%0Atype SidIdentifierAuthority struct %7B%0A%09Value %5B6%5Dbyte%0A%7D%0A%0Avar (%0A%09SECURITY_NULL_SID_AUTHORITY        = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 0%7D%7D%0A%09SECURITY_WORLD_SID_AUTHORITY       = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 1%7D%7D%0A%09SECURITY_LOCAL_SID_AUTHORITY       = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 2%7D%7D%0A%09SECURITY_CREATOR_SID_AUTHORITY     = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 3%7D%7D%0A%09SECURITY_NON_UNIQUE_AUTHORITY      = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 4%7D%7D%0A%09SECURITY_NT_AUTHORITY              = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 5%7D%7D%0A%09SECURITY_MANDATORY_LABEL_AUTHORITY = SidIdentifierAuthority%7B%5B6%5Dbyte%7B0, 0, 0, 0, 0, 16%7D%7D%0A)%0A%0Aconst (%0A%09SECURITY_NULL_RID                   = 0%0A%09SECURITY_WORLD_RID                  = 0%0A%09SECURITY_LOCAL_RID                  = 0%0A%09SECURITY_CREATOR_OWNER_RID          = 0%0A%09SECURITY_CREATOR_GROUP_RID          = 1%0A%09SECURITY_DIALUP_RID                 = 1%0A%09SECURITY_NETWORK_RID                = 2%0A%09SECURITY_BATCH_RID                  = 3%0A%09SECURITY_INTERACTIVE_RID            = 4%0A%09SECURITY_LOGON_IDS_RID              = 5%0A%09SECURITY_SERVICE_RID                = 6%0A%09SECURITY_LOCAL_SYSTEM_RID           = 18%0A%09SECURITY_BUILTIN_DOMAIN_RID         = 32%0A%09SECURITY_PRINCIPAL_SELF_RID         = 10%0A%09SECURITY_CREATOR_OWNER_SERVER_RID   = 0x2%0A%09SECURITY_CREATOR_GROUP_SERVER_RID   = 0x3%0A%09SECURITY_LOGON_IDS_RID_COUNT        = 0x3%0A%09SECURITY_ANONYMOUS_LOGON_RID        = 0x7%0A%09SECURITY_PROXY_RID                  = 0x8%0A%09SECURITY_ENTERPRISE_CONTROLLERS_RID = 0x9%0A%09SECURITY_SERVER_LOGON_RID           = SECURITY_ENTERPRISE_CONTROLLERS_RID%0A%09SECURITY_AUTHENTICATED_USER_RID     = 0xb%0A%09SECURITY_RESTRICTED_CODE_RID        = 0xc%0A%09SECURITY_NT_NON_UNIQUE_RID          = 0x15%0A)%0A%0A// Predefined domain-relative RIDs for local groups.%0A// See https://msdn.microsoft.com/en-us/library/windows/desktop/aa379649(v=vs.85).aspx%0Aconst (%0A%09DOMAIN_ALIAS_RID_ADMINS                         = 0x220%0A%09DOMAIN_ALIAS_RID_USERS                          = 0x221%0A%09DOMAIN_ALIAS_RID_GUESTS                         = 0x222%0A%09DOMAIN_ALIAS_RID_POWER_USERS                    = 0x223%0A%09DOMAIN_ALIAS_RID_ACCOUNT_OPS                    = 0x224%0A%09DOMAIN_ALIAS_RID_SYSTEM_OPS                     = 0x225%0A%09DOMAIN_ALIAS_RID_PRINT_OPS                      = 0x226%0A%09DOMAIN_ALIAS_RID_BACKUP_OPS                     = 0x227%0A%09DOMAIN_ALIAS_RID_REPLICATOR                     = 0x228%0A%09DOMAIN_ALIAS_RID_RAS_SERVERS                    = 0x229%0A%09DOMAIN_ALIAS_RID_PREW2KCOMPACCESS               = 0x22a%0A%09DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS           = 0x22b%0A%09DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS      = 0x22c%0A%09DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS = 0x22d%0A%09DOMAIN_ALIAS_RID_MONITORING_USERS               = 0X22e%0A%09DOMAIN_ALIAS_RID_LOGGING_USERS                  = 0x22f%0A%09DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS            = 0x230%0A%09DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS             = 0x231%0A%09DOMAIN_ALIAS_RID_DCOM_USERS                     = 0x232%0A%09DOMAIN_ALIAS_RID_IUSERS                         = 0x238%0A%09DOMAIN_ALIAS_RID_CRYPTO_OPERATORS               = 0x239%0A%09DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP     = 0x23b%0A%09DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP = 0x23c%0A%09DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP        = 0x23d%0A%09DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP      = 0x23e%0A)%0A%0A//sys%09LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountSidW%0A//sys%09LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) = advapi32.LookupAccountNameW%0A//sys%09ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) = advapi32.ConvertSidToStringSidW%0A//sys%09ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) = advapi32.ConvertStringSidToSidW%0A//sys%09GetLengthSid(sid *SID) (len uint32) = advapi32.GetLengthSid%0A//sys%09CopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) = advapi32.CopySid%0A//sys%09AllocateAndInitializeSid(identAuth *SidIdentifierAuthority, subAuth byte, subAuth0 uint32, subAuth1 uint32, subAuth2 uint32, subAuth3 uint32, subAuth4 uint32, subAuth5 uint32, subAuth6 uint32, subAuth7 uint32, sid **SID) (err error) = advapi32.AllocateAndInitializeSid%0A//sys%09FreeSid(sid *SID) (err error) %5Bfailretval!=0%5D = advapi32.FreeSid%0A//sys%09EqualSid(sid1 *SID, sid2 *SID) (isEqual bool) = advapi32.EqualSid%0A%0A// The security identifier (SID) structure is a variable-length%0A// structure used to uniquely identify users or groups.%0Atype SID struct%7B%7D%0A%0A// StringToSid converts a string-format security identifier%0A// sid into a valid, functional sid.%0Afunc StringToSid(s string) (*SID, error) %7B%0A%09var sid *SID%0A%09p, e := UTF16PtrFromString(s)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09e = ConvertStringSidToSid(p, &sid)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09defer LocalFree((Handle)(unsafe.Pointer(sid)))%0A%09return sid.Copy()%0A%7D%0A%0A// LookupSID retrieves a security identifier sid for the account%0A// and the name of the domain on which the account was found.%0A// System specify target computer to search.%0Afunc LookupSID(system, account string) (sid *SID, domain string, accType uint32, err error) %7B%0A%09if len(account) == 0 %7B%0A%09%09return nil, %22%22, 0, syscall.EINVAL%0A%09%7D%0A%09acc, e := UTF16PtrFromString(account)%0A%09if e != nil %7B%0A%09%09return nil, %22%22, 0, e%0A%09%7D%0A%09var sys *uint16%0A%09if len(system) %3E 0 %7B%0A%09%09sys, e = UTF16PtrFromString(system)%0A%09%09if e != nil %7B%0A%09%09%09return nil, %22%22, 0, e%0A%09%09%7D%0A%09%7D%0A%09n := uint32(50)%0A%09dn := uint32(50)%0A%09for %7B%0A%09%09b := make(%5B%5Dbyte, n)%0A%09%09db := make(%5B%5Duint16, dn)%0A%09%09sid = (*SID)(unsafe.Pointer(&b%5B0%5D))%0A%09%09e = LookupAccountName(sys, acc, sid, &n, &db%5B0%5D, &dn, &accType)%0A%09%09if e == nil %7B%0A%09%09%09return sid, UTF16ToString(db), accType, nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return nil, %22%22, 0, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return nil, %22%22, 0, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0A// String converts sid to a string format%0A// suitable for display, storage, or transmission.%0Afunc (sid *SID) String() (string, error) %7B%0A%09var s *uint16%0A%09e := ConvertSidToStringSid(sid, &s)%0A%09if e != nil %7B%0A%09%09return %22%22, e%0A%09%7D%0A%09defer LocalFree((Handle)(unsafe.Pointer(s)))%0A%09return UTF16ToString((*%5B256%5Duint16)(unsafe.Pointer(s))%5B:%5D), nil%0A%7D%0A%0A// Len returns the length, in bytes, of a valid security identifier sid.%0Afunc (sid *SID) Len() int %7B%0A%09return int(GetLengthSid(sid))%0A%7D%0A%0A// Copy creates a duplicate of security identifier sid.%0Afunc (sid *SID) Copy() (*SID, error) %7B%0A%09b := make(%5B%5Dbyte, sid.Len())%0A%09sid2 := (*SID)(unsafe.Pointer(&b%5B0%5D))%0A%09e := CopySid(uint32(len(b)), sid2, sid)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09return sid2, nil%0A%7D%0A%0A// LookupAccount retrieves the name of the account for this sid%0A// and the name of the first domain on which this sid is found.%0A// System specify target computer to search for.%0Afunc (sid *SID) LookupAccount(system string) (account, domain string, accType uint32, err error) %7B%0A%09var sys *uint16%0A%09if len(system) %3E 0 %7B%0A%09%09sys, err = UTF16PtrFromString(system)%0A%09%09if err != nil %7B%0A%09%09%09return %22%22, %22%22, 0, err%0A%09%09%7D%0A%09%7D%0A%09n := uint32(50)%0A%09dn := uint32(50)%0A%09for %7B%0A%09%09b := make(%5B%5Duint16, n)%0A%09%09db := make(%5B%5Duint16, dn)%0A%09%09e := LookupAccountSid(sys, sid, &b%5B0%5D, &n, &db%5B0%5D, &dn, &accType)%0A%09%09if e == nil %7B%0A%09%09%09return UTF16ToString(b), UTF16ToString(db), accType, nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return %22%22, %22%22, 0, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return %22%22, %22%22, 0, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Aconst (%0A%09// do not reorder%0A%09TOKEN_ASSIGN_PRIMARY = 1 %3C%3C iota%0A%09TOKEN_DUPLICATE%0A%09TOKEN_IMPERSONATE%0A%09TOKEN_QUERY%0A%09TOKEN_QUERY_SOURCE%0A%09TOKEN_ADJUST_PRIVILEGES%0A%09TOKEN_ADJUST_GROUPS%0A%09TOKEN_ADJUST_DEFAULT%0A%09TOKEN_ADJUST_SESSIONID%0A%0A%09TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED %7C%0A%09%09TOKEN_ASSIGN_PRIMARY %7C%0A%09%09TOKEN_DUPLICATE %7C%0A%09%09TOKEN_IMPERSONATE %7C%0A%09%09TOKEN_QUERY %7C%0A%09%09TOKEN_QUERY_SOURCE %7C%0A%09%09TOKEN_ADJUST_PRIVILEGES %7C%0A%09%09TOKEN_ADJUST_GROUPS %7C%0A%09%09TOKEN_ADJUST_DEFAULT %7C%0A%09%09TOKEN_ADJUST_SESSIONID%0A%09TOKEN_READ  = STANDARD_RIGHTS_READ %7C TOKEN_QUERY%0A%09TOKEN_WRITE = STANDARD_RIGHTS_WRITE %7C%0A%09%09TOKEN_ADJUST_PRIVILEGES %7C%0A%09%09TOKEN_ADJUST_GROUPS %7C%0A%09%09TOKEN_ADJUST_DEFAULT%0A%09TOKEN_EXECUTE = STANDARD_RIGHTS_EXECUTE%0A)%0A%0Aconst (%0A%09// do not reorder%0A%09TokenUser = 1 + iota%0A%09TokenGroups%0A%09TokenPrivileges%0A%09TokenOwner%0A%09TokenPrimaryGroup%0A%09TokenDefaultDacl%0A%09TokenSource%0A%09TokenType%0A%09TokenImpersonationLevel%0A%09TokenStatistics%0A%09TokenRestrictedSids%0A%09TokenSessionId%0A%09TokenGroupsAndPrivileges%0A%09TokenSessionReference%0A%09TokenSandBoxInert%0A%09TokenAuditPolicy%0A%09TokenOrigin%0A%09TokenElevationType%0A%09TokenLinkedToken%0A%09TokenElevation%0A%09TokenHasRestrictions%0A%09TokenAccessInformation%0A%09TokenVirtualizationAllowed%0A%09TokenVirtualizationEnabled%0A%09TokenIntegrityLevel%0A%09TokenUIAccess%0A%09TokenMandatoryPolicy%0A%09TokenLogonSid%0A%09MaxTokenInfoClass%0A)%0A%0Atype SIDAndAttributes struct %7B%0A%09Sid        *SID%0A%09Attributes uint32%0A%7D%0A%0Atype Tokenuser struct %7B%0A%09User SIDAndAttributes%0A%7D%0A%0Atype Tokenprimarygroup struct %7B%0A%09PrimaryGroup *SID%0A%7D%0A%0Atype Tokengroups struct %7B%0A%09GroupCount uint32%0A%09Groups     %5B1%5DSIDAndAttributes%0A%7D%0A%0A// Authorization Functions%0A//sys checkTokenMembership(tokenHandle Token, sidToCheck *SID, isMember *int32) (err error) = advapi32.CheckTokenMembership%0A//sys%09OpenProcessToken(h Handle, access uint32, token *Token) (err error) = advapi32.OpenProcessToken%0A//sys%09GetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) = advapi32.GetTokenInformation%0A//sys%09GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) = userenv.GetUserProfileDirectoryW%0A%0A// An access token contains the security information for a logon session.%0A// The system creates an access token when a user logs on, and every%0A// process executed on behalf of the user has a copy of the token.%0A// The token identifies the user, the user's groups, and the user's%0A// privileges. The system uses the token to control access to securable%0A// objects and to control the ability of the user to perform various%0A// system-related operations on the local computer.%0Atype Token Handle%0A%0A// OpenCurrentProcessToken opens the access token%0A// associated with current process.%0Afunc OpenCurrentProcessToken() (Token, error) %7B%0A%09p, e := GetCurrentProcess()%0A%09if e != nil %7B%0A%09%09return 0, e%0A%09%7D%0A%09var t Token%0A%09e = OpenProcessToken(p, TOKEN_QUERY, &t)%0A%09if e != nil %7B%0A%09%09return 0, e%0A%09%7D%0A%09return t, nil%0A%7D%0A%0A// Close releases access to access token.%0Afunc (t Token) Close() error %7B%0A%09return CloseHandle(Handle(t))%0A%7D%0A%0A// getInfo retrieves a specified type of information about an access token.%0Afunc (t Token) getInfo(class uint32, initSize int) (unsafe.Pointer, error) %7B%0A%09n := uint32(initSize)%0A%09for %7B%0A%09%09b := make(%5B%5Dbyte, n)%0A%09%09e := GetTokenInformation(t, class, &b%5B0%5D, uint32(len(b)), &n)%0A%09%09if e == nil %7B%0A%09%09%09return unsafe.Pointer(&b%5B0%5D), nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return nil, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return nil, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0A// GetTokenUser retrieves access token t user account information.%0Afunc (t Token) GetTokenUser() (*Tokenuser, error) %7B%0A%09i, e := t.getInfo(TokenUser, 50)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09return (*Tokenuser)(i), nil%0A%7D%0A%0A// GetTokenGroups retrieves group accounts associated with access token t.%0Afunc (t Token) GetTokenGroups() (*Tokengroups, error) %7B%0A%09i, e := t.getInfo(TokenGroups, 50)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09return (*Tokengroups)(i), nil%0A%7D%0A%0A// GetTokenPrimaryGroup retrieves access token t primary group information.%0A// A pointer to a SID structure representing a group that will become%0A// the primary group of any objects created by a process using this access token.%0Afunc (t Token) GetTokenPrimaryGroup() (*Tokenprimarygroup, error) %7B%0A%09i, e := t.getInfo(TokenPrimaryGroup, 50)%0A%09if e != nil %7B%0A%09%09return nil, e%0A%09%7D%0A%09return (*Tokenprimarygroup)(i), nil%0A%7D%0A%0A// GetUserProfileDirectory retrieves path to the%0A// root directory of the access token t user's profile.%0Afunc (t Token) GetUserProfileDirectory() (string, error) %7B%0A%09n := uint32(100)%0A%09for %7B%0A%09%09b := make(%5B%5Duint16, n)%0A%09%09e := GetUserProfileDirectory(t, &b%5B0%5D, &n)%0A%09%09if e == nil %7B%0A%09%09%09return UTF16ToString(b), nil%0A%09%09%7D%0A%09%09if e != ERROR_INSUFFICIENT_BUFFER %7B%0A%09%09%09return %22%22, e%0A%09%09%7D%0A%09%09if n %3C= uint32(len(b)) %7B%0A%09%09%09return %22%22, e%0A%09%09%7D%0A%09%7D%0A%7D%0A%0A// IsMember reports whether the access token t is a member of the provided SID.%0Afunc (t Token) IsMember(sid *SID) (bool, error) %7B%0A%09var b int32%0A%09if e := checkTokenMembership(t, sid, &b); e != nil %7B%0A%09%09return false, e%0A%09%7D%0A%09return b != 0, nil%0A%7D%0A
- f d08387e435d6d1d0fa654ded83d7c886b5760498375549f7c6fbbc63661bce5c vendor/golang.org/x/sys/windows/service.go
+ f 01ad9fa76b917b75fe7ac497e53d4ab51b932647d0c0866842b27a7469e03fc8 vendor/golang.org/x/sys/windows/service.go
dmppatch 3
@@ -180,16 +180,7054 @@
 package windows%0A
+%0Aconst (%0A%09SC_MANAGER_CONNECT            = 1%0A%09SC_MANAGER_CREATE_SERVICE     = 2%0A%09SC_MANAGER_ENUMERATE_SERVICE  = 4%0A%09SC_MANAGER_LOCK               = 8%0A%09SC_MANAGER_QUERY_LOCK_STATUS  = 16%0A%09SC_MANAGER_MODIFY_BOOT_CONFIG = 32%0A%09SC_MANAGER_ALL_ACCESS         = 0xf003f%0A)%0A%0A//sys%09OpenSCManager(machineName *uint16, databaseName *uint16, access uint32) (handle Handle, err error) %5Bfailretval==0%5D = advapi32.OpenSCManagerW%0A%0Aconst (%0A%09SERVICE_KERNEL_DRIVER       = 1%0A%09SERVICE_FILE_SYSTEM_DRIVER  = 2%0A%09SERVICE_ADAPTER             = 4%0A%09SERVICE_RECOGNIZER_DRIVER   = 8%0A%09SERVICE_WIN32_OWN_PROCESS   = 16%0A%09SERVICE_WIN32_SHARE_PROCESS = 32%0A%09SERVICE_WIN32               = SERVICE_WIN32_OWN_PROCESS %7C SERVICE_WIN32_SHARE_PROCESS%0A%09SERVICE_INTERACTIVE_PROCESS = 256%0A%09SERVICE_DRIVER              = SERVICE_KERNEL_DRIVER %7C SERVICE_FILE_SYSTEM_DRIVER %7C SERVICE_RECOGNIZER_DRIVER%0A%09SERVICE_TYPE_ALL            = SERVICE_WIN32 %7C SERVICE_ADAPTER %7C SERVICE_DRIVER %7C SERVICE_INTERACTIVE_PROCESS%0A%0A%09SERVICE_BOOT_START   = 0%0A%09SERVICE_SYSTEM_START = 1%0A%09SERVICE_AUTO_START   = 2%0A%09SERVICE_DEMAND_START = 3%0A%09SERVICE_DISABLED     = 4%0A%0A%09SERVICE_ERROR_IGNORE   = 0%0A%09SERVICE_ERROR_NORMAL   = 1%0A%09SERVICE_ERROR_SEVERE   = 2%0A%09SERVICE_ERROR_CRITICAL = 3%0A%0A%09SC_STATUS_PROCESS_INFO = 0%0A%0A%09SC_ACTION_NONE        = 0%0A%09SC_ACTION_RESTART     = 1%0A%09SC_ACTION_REBOOT      = 2%0A%09SC_ACTION_RUN_COMMAND = 3%0A%0A%09SERVICE_STOPPED          = 1%0A%09SERVICE_START_PENDING    = 2%0A%09SERVICE_STOP_PENDING     = 3%0A%09SERVICE_RUNNING          = 4%0A%09SERVICE_CONTINUE_PENDING = 5%0A%09SERVICE_PAUSE_PENDING    = 6%0A%09SERVICE_PAUSED           = 7%0A%09SERVICE_NO_CHANGE        = 0xffffffff%0A%0A%09SERVICE_ACCEPT_STOP                  = 1%0A%09SERVICE_ACCEPT_PAUSE_CONTINUE        = 2%0A%09SERVICE_ACCEPT_SHUTDOWN              = 4%0A%09SERVICE_ACCEPT_PARAMCHANGE           = 8%0A%09SERVICE_ACCEPT_NETBINDCHANGE         = 16%0A%09SERVICE_ACCEPT_HARDWAREPROFILECHANGE = 32%0A%09SERVICE_ACCEPT_POWEREVENT            = 64%0A%09SERVICE_ACCEPT_SESSIONCHANGE         = 128%0A%0A%09SERVICE_CONTROL_STOP                  = 1%0A%09SERVICE_CONTROL_PAUSE                 = 2%0A%09SERVICE_CONTROL_CONTINUE              = 3%0A%09SERVICE_CONTROL_INTERROGATE           = 4%0A%09SERVICE_CONTROL_SHUTDOWN              = 5%0A%09SERVICE_CONTROL_PARAMCHANGE           = 6%0A%09SERVICE_CONTROL_NETBINDADD            = 7%0A%09SERVICE_CONTROL_NETBINDREMOVE         = 8%0A%09SERVICE_CONTROL_NETBINDENABLE         = 9%0A%09SERVICE_CONTROL_NETBINDDISABLE        = 10%0A%09SERVICE_CONTROL_DEVICEEVENT           = 11%0A%09SERVICE_CONTROL_HARDWAREPROFILECHANGE = 12%0A%09SERVICE_CONTROL_POWEREVENT            = 13%0A%09SERVICE_CONTROL_SESSIONCHANGE         = 14%0A%0A%09SERVICE_ACTIVE    = 1%0A%09SERVICE_INACTIVE  = 2%0A%09SERVICE_STATE_ALL = 3%0A%0A%09SERVICE_QUERY_CONFIG           = 1%0A%09SERVICE_CHANGE_CONFIG          = 2%0A%09SERVICE_QUERY_STATUS           = 4%0A%09SERVICE_ENUMERATE_DEPENDENTS   = 8%0A%09SERVICE_START                  = 16%0A%09SERVICE_STOP                   = 32%0A%09SERVICE_PAUSE_CONTINUE         = 64%0A%09SERVICE_INTERROGATE            = 128%0A%09SERVICE_USER_DEFINED_CONTROL   = 256%0A%09SERVICE_ALL_ACCESS             = STANDARD_RIGHTS_REQUIRED %7C SERVICE_QUERY_CONFIG %7C SERVICE_CHANGE_CONFIG %7C SERVICE_QUERY_STATUS %7C SERVICE_ENUMERATE_DEPENDENTS %7C SERVICE_START %7C SERVICE_STOP %7C SERVICE_PAUSE_CONTINUE %7C SERVICE_INTERROGATE %7C SERVICE_USER_DEFINED_CONTROL%0A%09SERVICE_RUNS_IN_SYSTEM_PROCESS = 1%0A%09SERVICE_CONFIG_DESCRIPTION     = 1%0A%09SERVICE_CONFIG_FAILURE_ACTIONS = 2%0A%0A%09NO_ERROR = 0%0A%0A%09SC_ENUM_PROCESS_INFO = 0%0A)%0A%0Atype SERVICE_STATUS struct %7B%0A%09ServiceType             uint32%0A%09CurrentState            uint32%0A%09ControlsAccepted        uint32%0A%09Win32ExitCode           uint32%0A%09ServiceSpecificExitCode uint32%0A%09CheckPoint              uint32%0A%09WaitHint                uint32%0A%7D%0A%0Atype SERVICE_TABLE_ENTRY struct %7B%0A%09ServiceName *uint16%0A%09ServiceProc uintptr%0A%7D%0A%0Atype QUERY_SERVICE_CONFIG struct %7B%0A%09ServiceType      uint32%0A%09StartType        uint32%0A%09ErrorControl     uint32%0A%09BinaryPathName   *uint16%0A%09LoadOrderGroup   *uint16%0A%09TagId            uint32%0A%09Dependencies     *uint16%0A%09ServiceStartName *uint16%0A%09DisplayName      *uint16%0A%7D%0A%0Atype SERVICE_DESCRIPTION struct %7B%0A%09Description *uint16%0A%7D%0A%0Atype SERVICE_STATUS_PROCESS struct %7B%0A%09ServiceType             uint32%0A%09CurrentState            uint32%0A%09ControlsAccepted        uint32%0A%09Win32ExitCode           uint32%0A%09ServiceSpecificExitCode uint32%0A%09CheckPoint              uint32%0A%09WaitHint                uint32%0A%09ProcessId               uint32%0A%09ServiceFlags            uint32%0A%7D%0A%0Atype ENUM_SERVICE_STATUS_PROCESS struct %7B%0A%09ServiceName          *uint16%0A%09DisplayName          *uint16%0A%09ServiceStatusProcess SERVICE_STATUS_PROCESS%0A%7D%0A%0Atype SERVICE_FAILURE_ACTIONS struct %7B%0A%09ResetPeriod  uint32%0A%09RebootMsg    *uint16%0A%09Command      *uint16%0A%09ActionsCount uint32%0A%09Actions      *SC_ACTION%0A%7D%0A%0Atype SC_ACTION struct %7B%0A%09Type  uint32%0A%09Delay uint32%0A%7D%0A%0A//sys%09CloseServiceHandle(handle Handle) (err error) = advapi32.CloseServiceHandle%0A//sys%09CreateService(mgr Handle, serviceName *uint16, displayName *uint16, access uint32, srvType uint32, startType uint32, errCtl uint32, pathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16) (handle Handle, err error) %5Bfailretval==0%5D = advapi32.CreateServiceW%0A//sys%09OpenService(mgr Handle, serviceName *uint16, access uint32) (handle Handle, err error) %5Bfailretval==0%5D = advapi32.OpenServiceW%0A//sys%09DeleteService(service Handle) (err error) = advapi32.DeleteService%0A//sys%09StartService(service Handle, numArgs uint32, argVectors **uint16) (err error) = advapi32.StartServiceW%0A//sys%09QueryServiceStatus(service Handle, status *SERVICE_STATUS) (err error) = advapi32.QueryServiceStatus%0A//sys%09ControlService(service Handle, control uint32, status *SERVICE_STATUS) (err error) = advapi32.ControlService%0A//sys%09StartServiceCtrlDispatcher(serviceTable *SERVICE_TABLE_ENTRY) (err error) = advapi32.StartServiceCtrlDispatcherW%0A//sys%09SetServiceStatus(service Handle, serviceStatus *SERVICE_STATUS) (err error) = advapi32.SetServiceStatus%0A//sys%09ChangeServiceConfig(service Handle, serviceType uint32, startType uint32, errorControl uint32, binaryPathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16, displayName *uint16) (err error) = advapi32.ChangeServiceConfigW%0A//sys%09QueryServiceConfig(service Handle, serviceConfig *QUERY_SERVICE_CONFIG, bufSize uint32, bytesNeeded *uint32) (err error) = advapi32.QueryServiceConfigW%0A//sys%09ChangeServiceConfig2(service Handle, infoLevel uint32, info *byte) (err error) = advapi32.ChangeServiceConfig2W%0A//sys%09QueryServiceConfig2(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) = advapi32.QueryServiceConfig2W%0A//sys%09EnumServicesStatusEx(mgr Handle, infoLevel uint32, serviceType uint32, serviceState uint32, services *byte, bufSize uint32, bytesNeeded *uint32, servicesReturned *uint32, resumeHandle *uint32, groupName *uint16) (err error) = advapi32.EnumServicesStatusExW%0A//sys   QueryServiceStatusEx(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) = advapi32.QueryServiceStatusEx%0A
- f 999c92aefbb289294a360ceabd438085e9f02522555a5e2e69236e446e5d0dae vendor/golang.org/x/sys/windows/str.go
+ f a979ea38da92c56dc17baa7fce72bb82ac4353867d47c5240cee4404bf356875 vendor/golang.org/x/sys/windows/str.go
dmppatch 3
@@ -180,16 +180,324 @@
 package windows%0A
+%0Afunc itoa(val int) string %7B // do it here rather than with fmt to avoid dependency%0A%09if val %3C 0 %7B%0A%09%09return %22-%22 + itoa(-val)%0A%09%7D%0A%09var buf %5B32%5Dbyte // big enough for int64%0A%09i := len(buf) - 1%0A%09for val %3E= 10 %7B%0A%09%09buf%5Bi%5D = byte(val%2510 + '0')%0A%09%09i--%0A%09%09val /= 10%0A%09%7D%0A%09buf%5Bi%5D = byte(val + '0')%0A%09return string(buf%5Bi:%5D)%0A%7D%0A
- f 86894e8c61501206e2ea20d1a8cd1b2b1c6c3041a9969ecd5da85fb9d49e14c0 vendor/golang.org/x/sys/windows/syscall.go
+ f 15bb620236c7bba4ff1edbda701444c99ea5111e9d0b133329f8199a30fd26ac vendor/golang.org/x/sys/windows/syscall.go
dmppatch 3
@@ -1220,8 +1220,1194 @@
 indows%22%0A
+%0Aimport (%0A%09%22syscall%22%0A)%0A%0A// ByteSliceFromString returns a NUL-terminated slice of bytes%0A// containing the text of s. If s contains a NUL byte at any%0A// location, it returns (nil, syscall.EINVAL).%0Afunc ByteSliceFromString(s string) (%5B%5Dbyte, error) %7B%0A%09for i := 0; i %3C len(s); i++ %7B%0A%09%09if s%5Bi%5D == 0 %7B%0A%09%09%09return nil, syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09a := make(%5B%5Dbyte, len(s)+1)%0A%09copy(a, s)%0A%09return a, nil%0A%7D%0A%0A// BytePtrFromString returns a pointer to a NUL-terminated array of%0A// bytes containing the text of s. If s contains a NUL byte at any%0A// location, it returns (nil, syscall.EINVAL).%0Afunc BytePtrFromString(s string) (*byte, error) %7B%0A%09a, err := ByteSliceFromString(s)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &a%5B0%5D, nil%0A%7D%0A%0A// Single-word zero for use when we need a valid pointer to 0 bytes.%0A// See mksyscall.pl.%0Avar _zero uintptr%0A%0Afunc (ts *Timespec) Unix() (sec int64, nsec int64) %7B%0A%09return int64(ts.Sec), int64(ts.Nsec)%0A%7D%0A%0Afunc (tv *Timeval) Unix() (sec int64, nsec int64) %7B%0A%09return int64(tv.Sec), int64(tv.Usec) * 1000%0A%7D%0A%0Afunc (ts *Timespec) Nano() int64 %7B%0A%09return int64(ts.Sec)*1e9 + int64(ts.Nsec)%0A%7D%0A%0Afunc (tv *Timeval) Nano() int64 %7B%0A%09return int64(tv.Sec)*1e9 + int64(tv.Usec)*1000%0A%7D%0A
- f 20dfd94ee30ef16185423639762eb5a57cbf8f6a087c772ed820687588adbe7f vendor/golang.org/x/sys/windows/syscall_windows.go
+ f 9281f087c201a06f5d9d8ba2eb4364af349dc047d7ba845479e2704ff25bc52a vendor/golang.org/x/sys/windows/syscall_windows.go
dmppatch 3
@@ -195,8 +195,46355 @@
 windows%0A
+%0Aimport (%0A%09errorspkg %22errors%22%0A%09%22sync%22%0A%09%22syscall%22%0A%09%22unicode/utf16%22%0A%09%22unsafe%22%0A)%0A%0Atype Handle uintptr%0A%0Aconst (%0A%09InvalidHandle = %5EHandle(0)%0A%0A%09// Flags for DefineDosDevice.%0A%09DDD_EXACT_MATCH_ON_REMOVE = 0x00000004%0A%09DDD_NO_BROADCAST_SYSTEM   = 0x00000008%0A%09DDD_RAW_TARGET_PATH       = 0x00000001%0A%09DDD_REMOVE_DEFINITION     = 0x00000002%0A%0A%09// Return values for GetDriveType.%0A%09DRIVE_UNKNOWN     = 0%0A%09DRIVE_NO_ROOT_DIR = 1%0A%09DRIVE_REMOVABLE   = 2%0A%09DRIVE_FIXED       = 3%0A%09DRIVE_REMOTE      = 4%0A%09DRIVE_CDROM       = 5%0A%09DRIVE_RAMDISK     = 6%0A%0A%09// File system flags from GetVolumeInformation and GetVolumeInformationByHandle.%0A%09FILE_CASE_SENSITIVE_SEARCH        = 0x00000001%0A%09FILE_CASE_PRESERVED_NAMES         = 0x00000002%0A%09FILE_FILE_COMPRESSION             = 0x00000010%0A%09FILE_DAX_VOLUME                   = 0x20000000%0A%09FILE_NAMED_STREAMS                = 0x00040000%0A%09FILE_PERSISTENT_ACLS              = 0x00000008%0A%09FILE_READ_ONLY_VOLUME             = 0x00080000%0A%09FILE_SEQUENTIAL_WRITE_ONCE        = 0x00100000%0A%09FILE_SUPPORTS_ENCRYPTION          = 0x00020000%0A%09FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 0x00800000%0A%09FILE_SUPPORTS_HARD_LINKS          = 0x00400000%0A%09FILE_SUPPORTS_OBJECT_IDS          = 0x00010000%0A%09FILE_SUPPORTS_OPEN_BY_FILE_ID     = 0x01000000%0A%09FILE_SUPPORTS_REPARSE_POINTS      = 0x00000080%0A%09FILE_SUPPORTS_SPARSE_FILES        = 0x00000040%0A%09FILE_SUPPORTS_TRANSACTIONS        = 0x00200000%0A%09FILE_SUPPORTS_USN_JOURNAL         = 0x02000000%0A%09FILE_UNICODE_ON_DISK              = 0x00000004%0A%09FILE_VOLUME_IS_COMPRESSED         = 0x00008000%0A%09FILE_VOLUME_QUOTAS                = 0x00000020%0A)%0A%0A// StringToUTF16 is deprecated. Use UTF16FromString instead.%0A// If s contains a NUL byte this function panics instead of%0A// returning an error.%0Afunc StringToUTF16(s string) %5B%5Duint16 %7B%0A%09a, err := UTF16FromString(s)%0A%09if err != nil %7B%0A%09%09panic(%22windows: string with NUL passed to StringToUTF16%22)%0A%09%7D%0A%09return a%0A%7D%0A%0A// UTF16FromString returns the UTF-16 encoding of the UTF-8 string%0A// s, with a terminating NUL added. If s contains a NUL byte at any%0A// location, it returns (nil, syscall.EINVAL).%0Afunc UTF16FromString(s string) (%5B%5Duint16, error) %7B%0A%09for i := 0; i %3C len(s); i++ %7B%0A%09%09if s%5Bi%5D == 0 %7B%0A%09%09%09return nil, syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return utf16.Encode(%5B%5Drune(s + %22%5Cx00%22)), nil%0A%7D%0A%0A// UTF16ToString returns the UTF-8 encoding of the UTF-16 sequence s,%0A// with a terminating NUL removed.%0Afunc UTF16ToString(s %5B%5Duint16) string %7B%0A%09for i, v := range s %7B%0A%09%09if v == 0 %7B%0A%09%09%09s = s%5B0:i%5D%0A%09%09%09break%0A%09%09%7D%0A%09%7D%0A%09return string(utf16.Decode(s))%0A%7D%0A%0A// StringToUTF16Ptr is deprecated. Use UTF16PtrFromString instead.%0A// If s contains a NUL byte this function panics instead of%0A// returning an error.%0Afunc StringToUTF16Ptr(s string) *uint16 %7B return &StringToUTF16(s)%5B0%5D %7D%0A%0A// UTF16PtrFromString returns pointer to the UTF-16 encoding of%0A// the UTF-8 string s, with a terminating NUL added. If s%0A// contains a NUL byte at any location, it returns (nil, syscall.EINVAL).%0Afunc UTF16PtrFromString(s string) (*uint16, error) %7B%0A%09a, err := UTF16FromString(s)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09return &a%5B0%5D, nil%0A%7D%0A%0Afunc Getpagesize() int %7B return 4096 %7D%0A%0A// NewCallback converts a Go function to a function pointer conforming to the stdcall calling convention.%0A// This is useful when interoperating with Windows code requiring callbacks.%0A// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.%0Afunc NewCallback(fn interface%7B%7D) uintptr %7B%0A%09return syscall.NewCallback(fn)%0A%7D%0A%0A// NewCallbackCDecl converts a Go function to a function pointer conforming to the cdecl calling convention.%0A// This is useful when interoperating with Windows code requiring callbacks.%0A// The argument is expected to be a function with with one uintptr-sized result. The function must not have arguments with size larger than the size of uintptr.%0Afunc NewCallbackCDecl(fn interface%7B%7D) uintptr %7B%0A%09return syscall.NewCallbackCDecl(fn)%0A%7D%0A%0A// windows api calls%0A%0A//sys%09GetLastError() (lasterr error)%0A//sys%09LoadLibrary(libname string) (handle Handle, err error) = LoadLibraryW%0A//sys%09LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) = LoadLibraryExW%0A//sys%09FreeLibrary(handle Handle) (err error)%0A//sys%09GetProcAddress(module Handle, procname string) (proc uintptr, err error)%0A//sys%09GetVersion() (ver uint32, err error)%0A//sys%09FormatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf %5B%5Duint16, args *byte) (n uint32, err error) = FormatMessageW%0A//sys%09ExitProcess(exitcode uint32)%0A//sys%09CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = CreateFileW%0A//sys%09ReadFile(handle Handle, buf %5B%5Dbyte, done *uint32, overlapped *Overlapped) (err error)%0A//sys%09WriteFile(handle Handle, buf %5B%5Dbyte, done *uint32, overlapped *Overlapped) (err error)%0A//sys%09SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) %5Bfailretval==0xffffffff%5D%0A//sys%09CloseHandle(handle Handle) (err error)%0A//sys%09GetStdHandle(stdhandle uint32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D%0A//sys%09SetStdHandle(stdhandle uint32, handle Handle) (err error)%0A//sys%09findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = FindFirstFileW%0A//sys%09findNextFile1(handle Handle, data *win32finddata1) (err error) = FindNextFileW%0A//sys%09FindClose(handle Handle) (err error)%0A//sys%09GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (err error)%0A//sys%09GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) = GetCurrentDirectoryW%0A//sys%09SetCurrentDirectory(path *uint16) (err error) = SetCurrentDirectoryW%0A//sys%09CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) = CreateDirectoryW%0A//sys%09RemoveDirectory(path *uint16) (err error) = RemoveDirectoryW%0A//sys%09DeleteFile(path *uint16) (err error) = DeleteFileW%0A//sys%09MoveFile(from *uint16, to *uint16) (err error) = MoveFileW%0A//sys%09MoveFileEx(from *uint16, to *uint16, flags uint32) (err error) = MoveFileExW%0A//sys%09GetComputerName(buf *uint16, n *uint32) (err error) = GetComputerNameW%0A//sys%09GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) = GetComputerNameExW%0A//sys%09SetEndOfFile(handle Handle) (err error)%0A//sys%09GetSystemTimeAsFileTime(time *Filetime)%0A//sys%09GetSystemTimePreciseAsFileTime(time *Filetime)%0A//sys%09GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, err error) %5Bfailretval==0xffffffff%5D%0A//sys%09CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uint32, threadcnt uint32) (handle Handle, err error)%0A//sys%09GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (err error)%0A//sys%09PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uint32, overlapped *Overlapped) (err error)%0A//sys%09CancelIo(s Handle) (err error)%0A//sys%09CancelIoEx(s Handle, o *Overlapped) (err error)%0A//sys%09CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) = CreateProcessW%0A//sys%09OpenProcess(da uint32, inheritHandle bool, pid uint32) (handle Handle, err error)%0A//sys%09TerminateProcess(handle Handle, exitcode uint32) (err error)%0A//sys%09GetExitCodeProcess(handle Handle, exitcode *uint32) (err error)%0A//sys%09GetStartupInfo(startupInfo *StartupInfo) (err error) = GetStartupInfoW%0A//sys%09GetCurrentProcess() (pseudoHandle Handle, err error)%0A//sys%09GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error)%0A//sys%09DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error)%0A//sys%09WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) %5Bfailretval==0xffffffff%5D%0A//sys%09GetTempPath(buflen uint32, buf *uint16) (n uint32, err error) = GetTempPathW%0A//sys%09CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error)%0A//sys%09GetFileType(filehandle Handle) (n uint32, err error)%0A//sys%09CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) = advapi32.CryptAcquireContextW%0A//sys%09CryptReleaseContext(provhandle Handle, flags uint32) (err error) = advapi32.CryptReleaseContext%0A//sys%09CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) = advapi32.CryptGenRandom%0A//sys%09GetEnvironmentStrings() (envs *uint16, err error) %5Bfailretval==nil%5D = kernel32.GetEnvironmentStringsW%0A//sys%09FreeEnvironmentStrings(envs *uint16) (err error) = kernel32.FreeEnvironmentStringsW%0A//sys%09GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) = kernel32.GetEnvironmentVariableW%0A//sys%09SetEnvironmentVariable(name *uint16, value *uint16) (err error) = kernel32.SetEnvironmentVariableW%0A//sys%09SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error)%0A//sys%09GetFileAttributes(name *uint16) (attrs uint32, err error) %5Bfailretval==INVALID_FILE_ATTRIBUTES%5D = kernel32.GetFileAttributesW%0A//sys%09SetFileAttributes(name *uint16, attrs uint32) (err error) = kernel32.SetFileAttributesW%0A//sys%09GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) = kernel32.GetFileAttributesExW%0A//sys%09GetCommandLine() (cmd *uint16) = kernel32.GetCommandLineW%0A//sys%09CommandLineToArgv(cmd *uint16, argc *int32) (argv *%5B8192%5D*%5B8192%5Duint16, err error) %5Bfailretval==nil%5D = shell32.CommandLineToArgvW%0A//sys%09LocalFree(hmem Handle) (handle Handle, err error) %5Bfailretval!=0%5D%0A//sys%09SetHandleInformation(handle Handle, mask uint32, flags uint32) (err error)%0A//sys%09FlushFileBuffers(handle Handle) (err error)%0A//sys%09GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error) = kernel32.GetFullPathNameW%0A//sys%09GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) = kernel32.GetLongPathNameW%0A//sys%09GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) = kernel32.GetShortPathNameW%0A//sys%09CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) = kernel32.CreateFileMappingW%0A//sys%09MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error)%0A//sys%09UnmapViewOfFile(addr uintptr) (err error)%0A//sys%09FlushViewOfFile(addr uintptr, length uintptr) (err error)%0A//sys%09VirtualLock(addr uintptr, length uintptr) (err error)%0A//sys%09VirtualUnlock(addr uintptr, length uintptr) (err error)%0A//sys%09VirtualAlloc(address uintptr, size uintptr, alloctype uint32, protect uint32) (value uintptr, err error) = kernel32.VirtualAlloc%0A//sys%09VirtualFree(address uintptr, size uintptr, freetype uint32) (err error) = kernel32.VirtualFree%0A//sys%09VirtualProtect(address uintptr, size uintptr, newprotect uint32, oldprotect *uint32) (err error) = kernel32.VirtualProtect%0A//sys%09TransmitFile(s Handle, handle Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *Overlapped, transmitFileBuf *TransmitFileBuffers, flags uint32) (err error) = mswsock.TransmitFile%0A//sys%09ReadDirectoryChanges(handle Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) = kernel32.ReadDirectoryChangesW%0A//sys%09CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) = crypt32.CertOpenSystemStoreW%0A//sys   CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = crypt32.CertOpenStore%0A//sys%09CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) %5Bfailretval==nil%5D = crypt32.CertEnumCertificatesInStore%0A//sys   CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) = crypt32.CertAddCertificateContextToStore%0A//sys%09CertCloseStore(store Handle, flags uint32) (err error) = crypt32.CertCloseStore%0A//sys   CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) = crypt32.CertGetCertificateChain%0A//sys   CertFreeCertificateChain(ctx *CertChainContext) = crypt32.CertFreeCertificateChain%0A//sys   CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *CertContext, err error) %5Bfailretval==nil%5D = crypt32.CertCreateCertificateContext%0A//sys   CertFreeCertificateContext(ctx *CertContext) (err error) = crypt32.CertFreeCertificateContext%0A//sys   CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) = crypt32.CertVerifyCertificateChainPolicy%0A//sys%09RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) = advapi32.RegOpenKeyExW%0A//sys%09RegCloseKey(key Handle) (regerrno error) = advapi32.RegCloseKey%0A//sys%09RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) = advapi32.RegQueryInfoKeyW%0A//sys%09RegEnumKeyEx(key Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *Filetime) (regerrno error) = advapi32.RegEnumKeyExW%0A//sys%09RegQueryValueEx(key Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) = advapi32.RegQueryValueExW%0A//sys%09getCurrentProcessId() (pid uint32) = kernel32.GetCurrentProcessId%0A//sys%09GetConsoleMode(console Handle, mode *uint32) (err error) = kernel32.GetConsoleMode%0A//sys%09SetConsoleMode(console Handle, mode uint32) (err error) = kernel32.SetConsoleMode%0A//sys%09GetConsoleScreenBufferInfo(console Handle, info *ConsoleScreenBufferInfo) (err error) = kernel32.GetConsoleScreenBufferInfo%0A//sys%09WriteConsole(console Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error) = kernel32.WriteConsoleW%0A//sys%09ReadConsole(console Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) = kernel32.ReadConsoleW%0A//sys%09CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = kernel32.CreateToolhelp32Snapshot%0A//sys%09Process32First(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32FirstW%0A//sys%09Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) = kernel32.Process32NextW%0A//sys%09DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error)%0A// This function returns 1 byte BOOLEAN rather than the 4 byte BOOL.%0A//sys%09CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) %5Bfailretval&0xff==0%5D = CreateSymbolicLinkW%0A//sys%09CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) %5Bfailretval&0xff==0%5D = CreateHardLinkW%0A//sys%09GetCurrentThreadId() (id uint32)%0A//sys%09CreateEvent(eventAttrs *SecurityAttributes, manualReset uint32, initialState uint32, name *uint16) (handle Handle, err error) = kernel32.CreateEventW%0A//sys%09CreateEventEx(eventAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) = kernel32.CreateEventExW%0A//sys%09OpenEvent(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) = kernel32.OpenEventW%0A//sys%09SetEvent(event Handle) (err error) = kernel32.SetEvent%0A//sys%09ResetEvent(event Handle) (err error) = kernel32.ResetEvent%0A//sys%09PulseEvent(event Handle) (err error) = kernel32.PulseEvent%0A%0A// Volume Management Functions%0A//sys%09DefineDosDevice(flags uint32, deviceName *uint16, targetPath *uint16) (err error) = DefineDosDeviceW%0A//sys%09DeleteVolumeMountPoint(volumeMountPoint *uint16) (err error) = DeleteVolumeMountPointW%0A//sys%09FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = FindFirstVolumeW%0A//sys%09FindFirstVolumeMountPoint(rootPathName *uint16, volumeMountPoint *uint16, bufferLength uint32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = FindFirstVolumeMountPointW%0A//sys%09FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) = FindNextVolumeW%0A//sys%09FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) = FindNextVolumeMountPointW%0A//sys%09FindVolumeClose(findVolume Handle) (err error)%0A//sys%09FindVolumeMountPointClose(findVolumeMountPoint Handle) (err error)%0A//sys%09GetDriveType(rootPathName *uint16) (driveType uint32) = GetDriveTypeW%0A//sys%09GetLogicalDrives() (drivesBitMask uint32, err error) %5Bfailretval==0%5D%0A//sys%09GetLogicalDriveStrings(bufferLength uint32, buffer *uint16) (n uint32, err error) %5Bfailretval==0%5D = GetLogicalDriveStringsW%0A//sys%09GetVolumeInformation(rootPathName *uint16, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) = GetVolumeInformationW%0A//sys%09GetVolumeInformationByHandle(file Handle, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) = GetVolumeInformationByHandleW%0A//sys%09GetVolumeNameForVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16, bufferlength uint32) (err error) = GetVolumeNameForVolumeMountPointW%0A//sys%09GetVolumePathName(fileName *uint16, volumePathName *uint16, bufferLength uint32) (err error) = GetVolumePathNameW%0A//sys%09GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) = GetVolumePathNamesForVolumeNameW%0A//sys%09QueryDosDevice(deviceName *uint16, targetPath *uint16, max uint32) (n uint32, err error) %5Bfailretval==0%5D = QueryDosDeviceW%0A//sys%09SetVolumeLabel(rootPathName *uint16, volumeName *uint16) (err error) = SetVolumeLabelW%0A//sys%09SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) = SetVolumeMountPointW%0A%0A// syscall interface implementation for other packages%0A%0A// GetProcAddressByOrdinal retrieves the address of the exported%0A// function from module by ordinal.%0Afunc GetProcAddressByOrdinal(module Handle, ordinal uintptr) (proc uintptr, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetProcAddress.Addr(), 2, uintptr(module), ordinal, 0)%0A%09proc = uintptr(r0)%0A%09if proc == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Exit(code int) %7B ExitProcess(uint32(code)) %7D%0A%0Afunc makeInheritSa() *SecurityAttributes %7B%0A%09var sa SecurityAttributes%0A%09sa.Length = uint32(unsafe.Sizeof(sa))%0A%09sa.InheritHandle = 1%0A%09return &sa%0A%7D%0A%0Afunc Open(path string, mode int, perm uint32) (fd Handle, err error) %7B%0A%09if len(path) == 0 %7B%0A%09%09return InvalidHandle, ERROR_FILE_NOT_FOUND%0A%09%7D%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return InvalidHandle, err%0A%09%7D%0A%09var access uint32%0A%09switch mode & (O_RDONLY %7C O_WRONLY %7C O_RDWR) %7B%0A%09case O_RDONLY:%0A%09%09access = GENERIC_READ%0A%09case O_WRONLY:%0A%09%09access = GENERIC_WRITE%0A%09case O_RDWR:%0A%09%09access = GENERIC_READ %7C GENERIC_WRITE%0A%09%7D%0A%09if mode&O_CREAT != 0 %7B%0A%09%09access %7C= GENERIC_WRITE%0A%09%7D%0A%09if mode&O_APPEND != 0 %7B%0A%09%09access &%5E= GENERIC_WRITE%0A%09%09access %7C= FILE_APPEND_DATA%0A%09%7D%0A%09sharemode := uint32(FILE_SHARE_READ %7C FILE_SHARE_WRITE)%0A%09var sa *SecurityAttributes%0A%09if mode&O_CLOEXEC == 0 %7B%0A%09%09sa = makeInheritSa()%0A%09%7D%0A%09var createmode uint32%0A%09switch %7B%0A%09case mode&(O_CREAT%7CO_EXCL) == (O_CREAT %7C O_EXCL):%0A%09%09createmode = CREATE_NEW%0A%09case mode&(O_CREAT%7CO_TRUNC) == (O_CREAT %7C O_TRUNC):%0A%09%09createmode = CREATE_ALWAYS%0A%09case mode&O_CREAT == O_CREAT:%0A%09%09createmode = OPEN_ALWAYS%0A%09case mode&O_TRUNC == O_TRUNC:%0A%09%09createmode = TRUNCATE_EXISTING%0A%09default:%0A%09%09createmode = OPEN_EXISTING%0A%09%7D%0A%09h, e := CreateFile(pathp, access, sharemode, sa, createmode, FILE_ATTRIBUTE_NORMAL, 0)%0A%09return h, e%0A%7D%0A%0Afunc Read(fd Handle, p %5B%5Dbyte) (n int, err error) %7B%0A%09var done uint32%0A%09e := ReadFile(fd, p, &done, nil)%0A%09if e != nil %7B%0A%09%09if e == ERROR_BROKEN_PIPE %7B%0A%09%09%09// NOTE(brainman): work around ERROR_BROKEN_PIPE is returned on reading EOF from stdin%0A%09%09%09return 0, nil%0A%09%09%7D%0A%09%09return 0, e%0A%09%7D%0A%09if raceenabled %7B%0A%09%09if done %3E 0 %7B%0A%09%09%09raceWriteRange(unsafe.Pointer(&p%5B0%5D), int(done))%0A%09%09%7D%0A%09%09raceAcquire(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09return int(done), nil%0A%7D%0A%0Afunc Write(fd Handle, p %5B%5Dbyte) (n int, err error) %7B%0A%09if raceenabled %7B%0A%09%09raceReleaseMerge(unsafe.Pointer(&ioSync))%0A%09%7D%0A%09var done uint32%0A%09e := WriteFile(fd, p, &done, nil)%0A%09if e != nil %7B%0A%09%09return 0, e%0A%09%7D%0A%09if raceenabled && done %3E 0 %7B%0A%09%09raceReadRange(unsafe.Pointer(&p%5B0%5D), int(done))%0A%09%7D%0A%09return int(done), nil%0A%7D%0A%0Avar ioSync int64%0A%0Afunc Seek(fd Handle, offset int64, whence int) (newoffset int64, err error) %7B%0A%09var w uint32%0A%09switch whence %7B%0A%09case 0:%0A%09%09w = FILE_BEGIN%0A%09case 1:%0A%09%09w = FILE_CURRENT%0A%09case 2:%0A%09%09w = FILE_END%0A%09%7D%0A%09hi := int32(offset %3E%3E 32)%0A%09lo := int32(offset)%0A%09// use GetFileType to check pipe, pipe can't do seek%0A%09ft, _ := GetFileType(fd)%0A%09if ft == FILE_TYPE_PIPE %7B%0A%09%09return 0, syscall.EPIPE%0A%09%7D%0A%09rlo, e := SetFilePointer(fd, lo, &hi, w)%0A%09if e != nil %7B%0A%09%09return 0, e%0A%09%7D%0A%09return int64(hi)%3C%3C32 + int64(rlo), nil%0A%7D%0A%0Afunc Close(fd Handle) (err error) %7B%0A%09return CloseHandle(fd)%0A%7D%0A%0Avar (%0A%09Stdin  = getStdHandle(STD_INPUT_HANDLE)%0A%09Stdout = getStdHandle(STD_OUTPUT_HANDLE)%0A%09Stderr = getStdHandle(STD_ERROR_HANDLE)%0A)%0A%0Afunc getStdHandle(stdhandle uint32) (fd Handle) %7B%0A%09r, _ := GetStdHandle(stdhandle)%0A%09CloseOnExec(r)%0A%09return r%0A%7D%0A%0Aconst ImplementsGetwd = true%0A%0Afunc Getwd() (wd string, err error) %7B%0A%09b := make(%5B%5Duint16, 300)%0A%09n, e := GetCurrentDirectory(uint32(len(b)), &b%5B0%5D)%0A%09if e != nil %7B%0A%09%09return %22%22, e%0A%09%7D%0A%09return string(utf16.Decode(b%5B0:n%5D)), nil%0A%7D%0A%0Afunc Chdir(path string) (err error) %7B%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return SetCurrentDirectory(pathp)%0A%7D%0A%0Afunc Mkdir(path string, mode uint32) (err error) %7B%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return CreateDirectory(pathp, nil)%0A%7D%0A%0Afunc Rmdir(path string) (err error) %7B%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return RemoveDirectory(pathp)%0A%7D%0A%0Afunc Unlink(path string) (err error) %7B%0A%09pathp, err := UTF16PtrFromString(path)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return DeleteFile(pathp)%0A%7D%0A%0Afunc Rename(oldpath, newpath string) (err error) %7B%0A%09from, err := UTF16PtrFromString(oldpath)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09to, err := UTF16PtrFromString(newpath)%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return MoveFileEx(from, to, MOVEFILE_REPLACE_EXISTING)%0A%7D%0A%0Afunc ComputerName() (name string, err error) %7B%0A%09var n uint32 = MAX_COMPUTERNAME_LENGTH + 1%0A%09b := make(%5B%5Duint16, n)%0A%09e := GetComputerName(&b%5B0%5D, &n)%0A%09if e != nil %7B%0A%09%09return %22%22, e%0A%09%7D%0A%09return string(utf16.Decode(b%5B0:n%5D)), nil%0A%7D%0A%0Afunc Ftruncate(fd Handle, length int64) (err error) %7B%0A%09curoffset, e := Seek(fd, 0, 1)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09defer Seek(fd, curoffset, 0)%0A%09_, e = Seek(fd, length, 0)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09e = SetEndOfFile(fd)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09return nil%0A%7D%0A%0Afunc Gettimeofday(tv *Timeval) (err error) %7B%0A%09var ft Filetime%0A%09GetSystemTimeAsFileTime(&ft)%0A%09*tv = NsecToTimeval(ft.Nanoseconds())%0A%09return nil%0A%7D%0A%0Afunc Pipe(p %5B%5DHandle) (err error) %7B%0A%09if len(p) != 2 %7B%0A%09%09return syscall.EINVAL%0A%09%7D%0A%09var r, w Handle%0A%09e := CreatePipe(&r, &w, makeInheritSa(), 0)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09p%5B0%5D = r%0A%09p%5B1%5D = w%0A%09return nil%0A%7D%0A%0Afunc Utimes(path string, tv %5B%5DTimeval) (err error) %7B%0A%09if len(tv) != 2 %7B%0A%09%09return syscall.EINVAL%0A%09%7D%0A%09pathp, e := UTF16PtrFromString(path)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09h, e := CreateFile(pathp,%0A%09%09FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nil,%0A%09%09OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09defer Close(h)%0A%09a := NsecToFiletime(tv%5B0%5D.Nanoseconds())%0A%09w := NsecToFiletime(tv%5B1%5D.Nanoseconds())%0A%09return SetFileTime(h, nil, &a, &w)%0A%7D%0A%0Afunc UtimesNano(path string, ts %5B%5DTimespec) (err error) %7B%0A%09if len(ts) != 2 %7B%0A%09%09return syscall.EINVAL%0A%09%7D%0A%09pathp, e := UTF16PtrFromString(path)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09h, e := CreateFile(pathp,%0A%09%09FILE_WRITE_ATTRIBUTES, FILE_SHARE_WRITE, nil,%0A%09%09OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, 0)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09defer Close(h)%0A%09a := NsecToFiletime(TimespecToNsec(ts%5B0%5D))%0A%09w := NsecToFiletime(TimespecToNsec(ts%5B1%5D))%0A%09return SetFileTime(h, nil, &a, &w)%0A%7D%0A%0Afunc Fsync(fd Handle) (err error) %7B%0A%09return FlushFileBuffers(fd)%0A%7D%0A%0Afunc Chmod(path string, mode uint32) (err error) %7B%0A%09if mode == 0 %7B%0A%09%09return syscall.EINVAL%0A%09%7D%0A%09p, e := UTF16PtrFromString(path)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09attrs, e := GetFileAttributes(p)%0A%09if e != nil %7B%0A%09%09return e%0A%09%7D%0A%09if mode&S_IWRITE != 0 %7B%0A%09%09attrs &%5E= FILE_ATTRIBUTE_READONLY%0A%09%7D else %7B%0A%09%09attrs %7C= FILE_ATTRIBUTE_READONLY%0A%09%7D%0A%09return SetFileAttributes(p, attrs)%0A%7D%0A%0Afunc LoadGetSystemTimePreciseAsFileTime() error %7B%0A%09return procGetSystemTimePreciseAsFileTime.Find()%0A%7D%0A%0Afunc LoadCancelIoEx() error %7B%0A%09return procCancelIoEx.Find()%0A%7D%0A%0Afunc LoadSetFileCompletionNotificationModes() error %7B%0A%09return procSetFileCompletionNotificationModes.Find()%0A%7D%0A%0A// net api calls%0A%0Aconst socket_error = uintptr(%5Euint32(0))%0A%0A//sys%09WSAStartup(verreq uint32, data *WSAData) (sockerr error) = ws2_32.WSAStartup%0A//sys%09WSACleanup() (err error) %5Bfailretval==socket_error%5D = ws2_32.WSACleanup%0A//sys%09WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSAIoctl%0A//sys%09socket(af int32, typ int32, protocol int32) (handle Handle, err error) %5Bfailretval==InvalidHandle%5D = ws2_32.socket%0A//sys%09Setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.setsockopt%0A//sys%09Getsockopt(s Handle, level int32, optname int32, optval *byte, optlen *int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.getsockopt%0A//sys%09bind(s Handle, name unsafe.Pointer, namelen int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.bind%0A//sys%09connect(s Handle, name unsafe.Pointer, namelen int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.connect%0A//sys%09getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.getsockname%0A//sys%09getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.getpeername%0A//sys%09listen(s Handle, backlog int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.listen%0A//sys%09shutdown(s Handle, how int32) (err error) %5Bfailretval==socket_error%5D = ws2_32.shutdown%0A//sys%09Closesocket(s Handle) (err error) %5Bfailretval==socket_error%5D = ws2_32.closesocket%0A//sys%09AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (err error) = mswsock.AcceptEx%0A//sys%09GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) = mswsock.GetAcceptExSockaddrs%0A//sys%09WSARecv(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSARecv%0A//sys%09WSASend(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSASend%0A//sys%09WSARecvFrom(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32,  from *RawSockaddrAny, fromlen *int32, overlapped *Overlapped, croutine *byte) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSARecvFrom%0A//sys%09WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32,  overlapped *Overlapped, croutine *byte) (err error) %5Bfailretval==socket_error%5D = ws2_32.WSASendTo%0A//sys%09GetHostByName(name string) (h *Hostent, err error) %5Bfailretval==nil%5D = ws2_32.gethostbyname%0A//sys%09GetServByName(name string, proto string) (s *Servent, err error) %5Bfailretval==nil%5D = ws2_32.getservbyname%0A//sys%09Ntohs(netshort uint16) (u uint16) = ws2_32.ntohs%0A//sys%09GetProtoByName(name string) (p *Protoent, err error) %5Bfailretval==nil%5D = ws2_32.getprotobyname%0A//sys%09DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) = dnsapi.DnsQuery_W%0A//sys%09DnsRecordListFree(rl *DNSRecord, freetype uint32) = dnsapi.DnsRecordListFree%0A//sys%09DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) = dnsapi.DnsNameCompare_W%0A//sys%09GetAddrInfoW(nodename *uint16, servicename *uint16, hints *AddrinfoW, result **AddrinfoW) (sockerr error) = ws2_32.GetAddrInfoW%0A//sys%09FreeAddrInfoW(addrinfo *AddrinfoW) = ws2_32.FreeAddrInfoW%0A//sys%09GetIfEntry(pIfRow *MibIfRow) (errcode error) = iphlpapi.GetIfEntry%0A//sys%09GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode error) = iphlpapi.GetAdaptersInfo%0A//sys%09SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) = kernel32.SetFileCompletionNotificationModes%0A//sys%09WSAEnumProtocols(protocols *int32, protocolBuffer *WSAProtocolInfo, bufferLength *uint32) (n int32, err error) %5Bfailretval==-1%5D = ws2_32.WSAEnumProtocolsW%0A//sys%09GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) = iphlpapi.GetAdaptersAddresses%0A//sys%09GetACP() (acp uint32) = kernel32.GetACP%0A//sys%09MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) = kernel32.MultiByteToWideChar%0A%0A// For testing: clients can set this flag to force%0A// creation of IPv6 sockets to return EAFNOSUPPORT.%0Avar SocketDisableIPv6 bool%0A%0Atype RawSockaddrInet4 struct %7B%0A%09Family uint16%0A%09Port   uint16%0A%09Addr   %5B4%5Dbyte /* in_addr */%0A%09Zero   %5B8%5Duint8%0A%7D%0A%0Atype RawSockaddrInet6 struct %7B%0A%09Family   uint16%0A%09Port     uint16%0A%09Flowinfo uint32%0A%09Addr     %5B16%5Dbyte /* in6_addr */%0A%09Scope_id uint32%0A%7D%0A%0Atype RawSockaddr struct %7B%0A%09Family uint16%0A%09Data   %5B14%5Dint8%0A%7D%0A%0Atype RawSockaddrAny struct %7B%0A%09Addr RawSockaddr%0A%09Pad  %5B100%5Dint8%0A%7D%0A%0Atype Sockaddr interface %7B%0A%09sockaddr() (ptr unsafe.Pointer, len int32, err error) // lowercase; only we can define Sockaddrs%0A%7D%0A%0Atype SockaddrInet4 struct %7B%0A%09Port int%0A%09Addr %5B4%5Dbyte%0A%09raw  RawSockaddrInet4%0A%7D%0A%0Afunc (sa *SockaddrInet4) sockaddr() (unsafe.Pointer, int32, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, syscall.EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), int32(unsafe.Sizeof(sa.raw)), nil%0A%7D%0A%0Atype SockaddrInet6 struct %7B%0A%09Port   int%0A%09ZoneId uint32%0A%09Addr   %5B16%5Dbyte%0A%09raw    RawSockaddrInet6%0A%7D%0A%0Afunc (sa *SockaddrInet6) sockaddr() (unsafe.Pointer, int32, error) %7B%0A%09if sa.Port %3C 0 %7C%7C sa.Port %3E 0xFFFF %7B%0A%09%09return nil, 0, syscall.EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_INET6%0A%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&sa.raw.Port))%0A%09p%5B0%5D = byte(sa.Port %3E%3E 8)%0A%09p%5B1%5D = byte(sa.Port)%0A%09sa.raw.Scope_id = sa.ZoneId%0A%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09sa.raw.Addr%5Bi%5D = sa.Addr%5Bi%5D%0A%09%7D%0A%09return unsafe.Pointer(&sa.raw), int32(unsafe.Sizeof(sa.raw)), nil%0A%7D%0A%0Atype RawSockaddrUnix struct %7B%0A%09Family uint16%0A%09Path   %5BUNIX_PATH_MAX%5Dint8%0A%7D%0A%0Atype SockaddrUnix struct %7B%0A%09Name string%0A%09raw  RawSockaddrUnix%0A%7D%0A%0Afunc (sa *SockaddrUnix) sockaddr() (unsafe.Pointer, int32, error) %7B%0A%09name := sa.Name%0A%09n := len(name)%0A%09if n %3E len(sa.raw.Path) %7B%0A%09%09return nil, 0, syscall.EINVAL%0A%09%7D%0A%09if n == len(sa.raw.Path) && name%5B0%5D != '@' %7B%0A%09%09return nil, 0, syscall.EINVAL%0A%09%7D%0A%09sa.raw.Family = AF_UNIX%0A%09for i := 0; i %3C n; i++ %7B%0A%09%09sa.raw.Path%5Bi%5D = int8(name%5Bi%5D)%0A%09%7D%0A%09// length is family (uint16), name, NUL.%0A%09sl := int32(2)%0A%09if n %3E 0 %7B%0A%09%09sl += int32(n) + 1%0A%09%7D%0A%09if sa.raw.Path%5B0%5D == '@' %7B%0A%09%09sa.raw.Path%5B0%5D = 0%0A%09%09// Don't count trailing NUL for abstract address.%0A%09%09sl--%0A%09%7D%0A%0A%09return unsafe.Pointer(&sa.raw), sl, nil%0A%7D%0A%0Afunc (rsa *RawSockaddrAny) Sockaddr() (Sockaddr, error) %7B%0A%09switch rsa.Addr.Family %7B%0A%09case AF_UNIX:%0A%09%09pp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrUnix)%0A%09%09if pp.Path%5B0%5D == 0 %7B%0A%09%09%09// %22Abstract%22 Unix domain socket.%0A%09%09%09// Rewrite leading NUL as @ for textual display.%0A%09%09%09// (This is the standard convention.)%0A%09%09%09// Not friendly to overwrite in place,%0A%09%09%09// but the callers below don't care.%0A%09%09%09pp.Path%5B0%5D = '@'%0A%09%09%7D%0A%0A%09%09// Assume path ends at NUL.%0A%09%09// This is not technically the Linux semantics for%0A%09%09// abstract Unix domain sockets--they are supposed%0A%09%09// to be uninterpreted fixed-size binary blobs--but%0A%09%09// everyone uses this convention.%0A%09%09n := 0%0A%09%09for n %3C len(pp.Path) && pp.Path%5Bn%5D != 0 %7B%0A%09%09%09n++%0A%09%09%7D%0A%09%09bytes := (*%5B10000%5Dbyte)(unsafe.Pointer(&pp.Path%5B0%5D))%5B0:n%5D%0A%09%09sa.Name = string(bytes)%0A%09%09return sa, nil%0A%0A%09case AF_INET:%0A%09%09pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet4)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%0A%09case AF_INET6:%0A%09%09pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))%0A%09%09sa := new(SockaddrInet6)%0A%09%09p := (*%5B2%5Dbyte)(unsafe.Pointer(&pp.Port))%0A%09%09sa.Port = int(p%5B0%5D)%3C%3C8 + int(p%5B1%5D)%0A%09%09sa.ZoneId = pp.Scope_id%0A%09%09for i := 0; i %3C len(sa.Addr); i++ %7B%0A%09%09%09sa.Addr%5Bi%5D = pp.Addr%5Bi%5D%0A%09%09%7D%0A%09%09return sa, nil%0A%09%7D%0A%09return nil, syscall.EAFNOSUPPORT%0A%7D%0A%0Afunc Socket(domain, typ, proto int) (fd Handle, err error) %7B%0A%09if domain == AF_INET6 && SocketDisableIPv6 %7B%0A%09%09return InvalidHandle, syscall.EAFNOSUPPORT%0A%09%7D%0A%09return socket(int32(domain), int32(typ), int32(proto))%0A%7D%0A%0Afunc SetsockoptInt(fd Handle, level, opt int, value int) (err error) %7B%0A%09v := int32(value)%0A%09return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&v)), int32(unsafe.Sizeof(v)))%0A%7D%0A%0Afunc Bind(fd Handle, sa Sockaddr) (err error) %7B%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return bind(fd, ptr, n)%0A%7D%0A%0Afunc Connect(fd Handle, sa Sockaddr) (err error) %7B%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return connect(fd, ptr, n)%0A%7D%0A%0Afunc Getsockname(fd Handle) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09l := int32(unsafe.Sizeof(rsa))%0A%09if err = getsockname(fd, &rsa, &l); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return rsa.Sockaddr()%0A%7D%0A%0Afunc Getpeername(fd Handle) (sa Sockaddr, err error) %7B%0A%09var rsa RawSockaddrAny%0A%09l := int32(unsafe.Sizeof(rsa))%0A%09if err = getpeername(fd, &rsa, &l); err != nil %7B%0A%09%09return%0A%09%7D%0A%09return rsa.Sockaddr()%0A%7D%0A%0Afunc Listen(s Handle, n int) (err error) %7B%0A%09return listen(s, int32(n))%0A%7D%0A%0Afunc Shutdown(fd Handle, how int) (err error) %7B%0A%09return shutdown(fd, int32(how))%0A%7D%0A%0Afunc WSASendto(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to Sockaddr, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09rsa, l, err := to.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return WSASendTo(s, bufs, bufcnt, sent, flags, (*RawSockaddrAny)(unsafe.Pointer(rsa)), l, overlapped, croutine)%0A%7D%0A%0Afunc LoadGetAddrInfo() error %7B%0A%09return procGetAddrInfoW.Find()%0A%7D%0A%0Avar connectExFunc struct %7B%0A%09once sync.Once%0A%09addr uintptr%0A%09err  error%0A%7D%0A%0Afunc LoadConnectEx() error %7B%0A%09connectExFunc.once.Do(func() %7B%0A%09%09var s Handle%0A%09%09s, connectExFunc.err = Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)%0A%09%09if connectExFunc.err != nil %7B%0A%09%09%09return%0A%09%09%7D%0A%09%09defer CloseHandle(s)%0A%09%09var n uint32%0A%09%09connectExFunc.err = WSAIoctl(s,%0A%09%09%09SIO_GET_EXTENSION_FUNCTION_POINTER,%0A%09%09%09(*byte)(unsafe.Pointer(&WSAID_CONNECTEX)),%0A%09%09%09uint32(unsafe.Sizeof(WSAID_CONNECTEX)),%0A%09%09%09(*byte)(unsafe.Pointer(&connectExFunc.addr)),%0A%09%09%09uint32(unsafe.Sizeof(connectExFunc.addr)),%0A%09%09%09&n, nil, 0)%0A%09%7D)%0A%09return connectExFunc.err%0A%7D%0A%0Afunc connectEx(s Handle, name unsafe.Pointer, namelen int32, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(connectExFunc.addr, 7, uintptr(s), uintptr(name), uintptr(namelen), uintptr(unsafe.Pointer(sendBuf)), uintptr(sendDataLen), uintptr(unsafe.Pointer(bytesSent)), uintptr(unsafe.Pointer(overlapped)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = error(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ConnectEx(fd Handle, sa Sockaddr, sendBuf *byte, sendDataLen uint32, bytesSent *uint32, overlapped *Overlapped) error %7B%0A%09err := LoadConnectEx()%0A%09if err != nil %7B%0A%09%09return errorspkg.New(%22failed to find ConnectEx: %22 + err.Error())%0A%09%7D%0A%09ptr, n, err := sa.sockaddr()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09return connectEx(fd, ptr, n, sendBuf, sendDataLen, bytesSent, overlapped)%0A%7D%0A%0Avar sendRecvMsgFunc struct %7B%0A%09once     sync.Once%0A%09sendAddr uintptr%0A%09recvAddr uintptr%0A%09err      error%0A%7D%0A%0Afunc loadWSASendRecvMsg() error %7B%0A%09sendRecvMsgFunc.once.Do(func() %7B%0A%09%09var s Handle%0A%09%09s, sendRecvMsgFunc.err = Socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)%0A%09%09if sendRecvMsgFunc.err != nil %7B%0A%09%09%09return%0A%09%09%7D%0A%09%09defer CloseHandle(s)%0A%09%09var n uint32%0A%09%09sendRecvMsgFunc.err = WSAIoctl(s,%0A%09%09%09SIO_GET_EXTENSION_FUNCTION_POINTER,%0A%09%09%09(*byte)(unsafe.Pointer(&WSAID_WSARECVMSG)),%0A%09%09%09uint32(unsafe.Sizeof(WSAID_WSARECVMSG)),%0A%09%09%09(*byte)(unsafe.Pointer(&sendRecvMsgFunc.recvAddr)),%0A%09%09%09uint32(unsafe.Sizeof(sendRecvMsgFunc.recvAddr)),%0A%09%09%09&n, nil, 0)%0A%09%09if sendRecvMsgFunc.err != nil %7B%0A%09%09%09return%0A%09%09%7D%0A%09%09sendRecvMsgFunc.err = WSAIoctl(s,%0A%09%09%09SIO_GET_EXTENSION_FUNCTION_POINTER,%0A%09%09%09(*byte)(unsafe.Pointer(&WSAID_WSASENDMSG)),%0A%09%09%09uint32(unsafe.Sizeof(WSAID_WSASENDMSG)),%0A%09%09%09(*byte)(unsafe.Pointer(&sendRecvMsgFunc.sendAddr)),%0A%09%09%09uint32(unsafe.Sizeof(sendRecvMsgFunc.sendAddr)),%0A%09%09%09&n, nil, 0)%0A%09%7D)%0A%09return sendRecvMsgFunc.err%0A%7D%0A%0Afunc WSASendMsg(fd Handle, msg *WSAMsg, flags uint32, bytesSent *uint32, overlapped *Overlapped, croutine *byte) error %7B%0A%09err := loadWSASendRecvMsg()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall6(sendRecvMsgFunc.sendAddr, 6, uintptr(fd), uintptr(unsafe.Pointer(msg)), uintptr(flags), uintptr(unsafe.Pointer(bytesSent)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return err%0A%7D%0A%0Afunc WSARecvMsg(fd Handle, msg *WSAMsg, bytesReceived *uint32, overlapped *Overlapped, croutine *byte) error %7B%0A%09err := loadWSASendRecvMsg()%0A%09if err != nil %7B%0A%09%09return err%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall6(sendRecvMsgFunc.recvAddr, 5, uintptr(fd), uintptr(unsafe.Pointer(msg)), uintptr(unsafe.Pointer(bytesReceived)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return err%0A%7D%0A%0A// Invented structures to support what package os expects.%0Atype Rusage struct %7B%0A%09CreationTime Filetime%0A%09ExitTime     Filetime%0A%09KernelTime   Filetime%0A%09UserTime     Filetime%0A%7D%0A%0Atype WaitStatus struct %7B%0A%09ExitCode uint32%0A%7D%0A%0Afunc (w WaitStatus) Exited() bool %7B return true %7D%0A%0Afunc (w WaitStatus) ExitStatus() int %7B return int(w.ExitCode) %7D%0A%0Afunc (w WaitStatus) Signal() Signal %7B return -1 %7D%0A%0Afunc (w WaitStatus) CoreDump() bool %7B return false %7D%0A%0Afunc (w WaitStatus) Stopped() bool %7B return false %7D%0A%0Afunc (w WaitStatus) Continued() bool %7B return false %7D%0A%0Afunc (w WaitStatus) StopSignal() Signal %7B return -1 %7D%0A%0Afunc (w WaitStatus) Signaled() bool %7B return false %7D%0A%0Afunc (w WaitStatus) TrapCause() int %7B return -1 %7D%0A%0A// Timespec is an invented structure on Windows, but here for%0A// consistency with the corresponding package for other operating systems.%0Atype Timespec struct %7B%0A%09Sec  int64%0A%09Nsec int64%0A%7D%0A%0Afunc TimespecToNsec(ts Timespec) int64 %7B return int64(ts.Sec)*1e9 + int64(ts.Nsec) %7D%0A%0Afunc NsecToTimespec(nsec int64) (ts Timespec) %7B%0A%09ts.Sec = nsec / 1e9%0A%09ts.Nsec = nsec %25 1e9%0A%09return%0A%7D%0A%0A// TODO(brainman): fix all needed for net%0A%0Afunc Accept(fd Handle) (nfd Handle, sa Sockaddr, err error) %7B return 0, nil, syscall.EWINDOWS %7D%0Afunc Recvfrom(fd Handle, p %5B%5Dbyte, flags int) (n int, from Sockaddr, err error) %7B%0A%09return 0, nil, syscall.EWINDOWS%0A%7D%0Afunc Sendto(fd Handle, p %5B%5Dbyte, flags int, to Sockaddr) (err error)       %7B return syscall.EWINDOWS %7D%0Afunc SetsockoptTimeval(fd Handle, level, opt int, tv *Timeval) (err error) %7B return syscall.EWINDOWS %7D%0A%0A// The Linger struct is wrong but we only noticed after Go 1.%0A// sysLinger is the real system call structure.%0A%0A// BUG(brainman): The definition of Linger is not appropriate for direct use%0A// with Setsockopt and Getsockopt.%0A// Use SetsockoptLinger instead.%0A%0Atype Linger struct %7B%0A%09Onoff  int32%0A%09Linger int32%0A%7D%0A%0Atype sysLinger struct %7B%0A%09Onoff  uint16%0A%09Linger uint16%0A%7D%0A%0Atype IPMreq struct %7B%0A%09Multiaddr %5B4%5Dbyte /* in_addr */%0A%09Interface %5B4%5Dbyte /* in_addr */%0A%7D%0A%0Atype IPv6Mreq struct %7B%0A%09Multiaddr %5B16%5Dbyte /* in6_addr */%0A%09Interface uint32%0A%7D%0A%0Afunc GetsockoptInt(fd Handle, level, opt int) (int, error) %7B return -1, syscall.EWINDOWS %7D%0A%0Afunc SetsockoptLinger(fd Handle, level, opt int, l *Linger) (err error) %7B%0A%09sys := sysLinger%7BOnoff: uint16(l.Onoff), Linger: uint16(l.Linger)%7D%0A%09return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&sys)), int32(unsafe.Sizeof(sys)))%0A%7D%0A%0Afunc SetsockoptInet4Addr(fd Handle, level, opt int, value %5B4%5Dbyte) (err error) %7B%0A%09return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(&value%5B0%5D)), 4)%0A%7D%0Afunc SetsockoptIPMreq(fd Handle, level, opt int, mreq *IPMreq) (err error) %7B%0A%09return Setsockopt(fd, int32(level), int32(opt), (*byte)(unsafe.Pointer(mreq)), int32(unsafe.Sizeof(*mreq)))%0A%7D%0Afunc SetsockoptIPv6Mreq(fd Handle, level, opt int, mreq *IPv6Mreq) (err error) %7B%0A%09return syscall.EWINDOWS%0A%7D%0A%0Afunc Getpid() (pid int) %7B return int(getCurrentProcessId()) %7D%0A%0Afunc FindFirstFile(name *uint16, data *Win32finddata) (handle Handle, err error) %7B%0A%09// NOTE(rsc): The Win32finddata struct is wrong for the system call:%0A%09// the two paths are each one uint16 short. Use the correct struct,%0A%09// a win32finddata1, and then copy the results out.%0A%09// There is no loss of expressivity here, because the final%0A%09// uint16, if it is used, is supposed to be a NUL, and Go doesn't need that.%0A%09// For Go 1.1, we might avoid the allocation of win32finddata1 here%0A%09// by adding a final Bug %5B2%5Duint16 field to the struct and then%0A%09// adjusting the fields in the result directly.%0A%09var data1 win32finddata1%0A%09handle, err = findFirstFile1(name, &data1)%0A%09if err == nil %7B%0A%09%09copyFindData(data, &data1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindNextFile(handle Handle, data *Win32finddata) (err error) %7B%0A%09var data1 win32finddata1%0A%09err = findNextFile1(handle, &data1)%0A%09if err == nil %7B%0A%09%09copyFindData(data, &data1)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getProcessEntry(pid int) (*ProcessEntry32, error) %7B%0A%09snapshot, err := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0)%0A%09if err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09defer CloseHandle(snapshot)%0A%09var procEntry ProcessEntry32%0A%09procEntry.Size = uint32(unsafe.Sizeof(procEntry))%0A%09if err = Process32First(snapshot, &procEntry); err != nil %7B%0A%09%09return nil, err%0A%09%7D%0A%09for %7B%0A%09%09if procEntry.ProcessID == uint32(pid) %7B%0A%09%09%09return &procEntry, nil%0A%09%09%7D%0A%09%09err = Process32Next(snapshot, &procEntry)%0A%09%09if err != nil %7B%0A%09%09%09return nil, err%0A%09%09%7D%0A%09%7D%0A%7D%0A%0Afunc Getppid() (ppid int) %7B%0A%09pe, err := getProcessEntry(Getpid())%0A%09if err != nil %7B%0A%09%09return -1%0A%09%7D%0A%09return int(pe.ParentProcessID)%0A%7D%0A%0A// TODO(brainman): fix all needed for os%0Afunc Fchdir(fd Handle) (err error)             %7B return syscall.EWINDOWS %7D%0Afunc Link(oldpath, newpath string) (err error) %7B return syscall.EWINDOWS %7D%0Afunc Symlink(path, link string) (err error)    %7B return syscall.EWINDOWS %7D%0A%0Afunc Fchmod(fd Handle, mode uint32) (err error)        %7B return syscall.EWINDOWS %7D%0Afunc Chown(path string, uid int, gid int) (err error)  %7B return syscall.EWINDOWS %7D%0Afunc Lchown(path string, uid int, gid int) (err error) %7B return syscall.EWINDOWS %7D%0Afunc Fchown(fd Handle, uid int, gid int) (err error)   %7B return syscall.EWINDOWS %7D%0A%0Afunc Getuid() (uid int)                  %7B return -1 %7D%0Afunc Geteuid() (euid int)                %7B return -1 %7D%0Afunc Getgid() (gid int)                  %7B return -1 %7D%0Afunc Getegid() (egid int)                %7B return -1 %7D%0Afunc Getgroups() (gids %5B%5Dint, err error) %7B return nil, syscall.EWINDOWS %7D%0A%0Atype Signal int%0A%0Afunc (s Signal) Signal() %7B%7D%0A%0Afunc (s Signal) String() string %7B%0A%09if 0 %3C= s && int(s) %3C len(signals) %7B%0A%09%09str := signals%5Bs%5D%0A%09%09if str != %22%22 %7B%0A%09%09%09return str%0A%09%09%7D%0A%09%7D%0A%09return %22signal %22 + itoa(int(s))%0A%7D%0A%0Afunc LoadCreateSymbolicLink() error %7B%0A%09return procCreateSymbolicLinkW.Find()%0A%7D%0A%0A// Readlink returns the destination of the named symbolic link.%0Afunc Readlink(path string, buf %5B%5Dbyte) (n int, err error) %7B%0A%09fd, err := CreateFile(StringToUTF16Ptr(path), GENERIC_READ, 0, nil, OPEN_EXISTING,%0A%09%09FILE_FLAG_OPEN_REPARSE_POINT%7CFILE_FLAG_BACKUP_SEMANTICS, 0)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%09defer CloseHandle(fd)%0A%0A%09rdbbuf := make(%5B%5Dbyte, MAXIMUM_REPARSE_DATA_BUFFER_SIZE)%0A%09var bytesReturned uint32%0A%09err = DeviceIoControl(fd, FSCTL_GET_REPARSE_POINT, nil, 0, &rdbbuf%5B0%5D, uint32(len(rdbbuf)), &bytesReturned, nil)%0A%09if err != nil %7B%0A%09%09return -1, err%0A%09%7D%0A%0A%09rdb := (*reparseDataBuffer)(unsafe.Pointer(&rdbbuf%5B0%5D))%0A%09var s string%0A%09switch rdb.ReparseTag %7B%0A%09case IO_REPARSE_TAG_SYMLINK:%0A%09%09data := (*symbolicLinkReparseBuffer)(unsafe.Pointer(&rdb.reparseBuffer))%0A%09%09p := (*%5B0xffff%5Duint16)(unsafe.Pointer(&data.PathBuffer%5B0%5D))%0A%09%09s = UTF16ToString(p%5Bdata.PrintNameOffset/2 : (data.PrintNameLength-data.PrintNameOffset)/2%5D)%0A%09case IO_REPARSE_TAG_MOUNT_POINT:%0A%09%09data := (*mountPointReparseBuffer)(unsafe.Pointer(&rdb.reparseBuffer))%0A%09%09p := (*%5B0xffff%5Duint16)(unsafe.Pointer(&data.PathBuffer%5B0%5D))%0A%09%09s = UTF16ToString(p%5Bdata.PrintNameOffset/2 : (data.PrintNameLength-data.PrintNameOffset)/2%5D)%0A%09default:%0A%09%09// the path is not a symlink or junction but another type of reparse%0A%09%09// point%0A%09%09return -1, syscall.ENOENT%0A%09%7D%0A%09n = copy(buf, %5B%5Dbyte(s))%0A%0A%09return n, nil%0A%7D%0A
- f 35bfa1de8a87825e0db0adc8aa48b116be18d66a03bcc033445c8b2ed164ddaf vendor/golang.org/x/sys/windows/types_windows.go
+ f 07a35c3b401edcf6cd9932dffb73e04d5a517f066fff263350263175a670ee21 vendor/golang.org/x/sys/windows/types_windows.go
dmppatch 3
@@ -169,8 +169,39195 @@
 windows%0A
+%0Aimport %22syscall%22%0A%0Aconst (%0A%09// Windows errors.%0A%09ERROR_FILE_NOT_FOUND         syscall.Errno = 2%0A%09ERROR_PATH_NOT_FOUND         syscall.Errno = 3%0A%09ERROR_ACCESS_DENIED          syscall.Errno = 5%0A%09ERROR_NO_MORE_FILES          syscall.Errno = 18%0A%09ERROR_HANDLE_EOF             syscall.Errno = 38%0A%09ERROR_NETNAME_DELETED        syscall.Errno = 64%0A%09ERROR_FILE_EXISTS            syscall.Errno = 80%0A%09ERROR_BROKEN_PIPE            syscall.Errno = 109%0A%09ERROR_BUFFER_OVERFLOW        syscall.Errno = 111%0A%09ERROR_INSUFFICIENT_BUFFER    syscall.Errno = 122%0A%09ERROR_MOD_NOT_FOUND          syscall.Errno = 126%0A%09ERROR_PROC_NOT_FOUND         syscall.Errno = 127%0A%09ERROR_ALREADY_EXISTS         syscall.Errno = 183%0A%09ERROR_ENVVAR_NOT_FOUND       syscall.Errno = 203%0A%09ERROR_MORE_DATA              syscall.Errno = 234%0A%09ERROR_OPERATION_ABORTED      syscall.Errno = 995%0A%09ERROR_IO_PENDING             syscall.Errno = 997%0A%09ERROR_SERVICE_SPECIFIC_ERROR syscall.Errno = 1066%0A%09ERROR_NOT_FOUND              syscall.Errno = 1168%0A%09ERROR_PRIVILEGE_NOT_HELD     syscall.Errno = 1314%0A%09WSAEACCES                    syscall.Errno = 10013%0A%09WSAEMSGSIZE                  syscall.Errno = 10040%0A%09WSAECONNRESET                syscall.Errno = 10054%0A)%0A%0Aconst (%0A%09// Invented values to support what package os expects.%0A%09O_RDONLY   = 0x00000%0A%09O_WRONLY   = 0x00001%0A%09O_RDWR     = 0x00002%0A%09O_CREAT    = 0x00040%0A%09O_EXCL     = 0x00080%0A%09O_NOCTTY   = 0x00100%0A%09O_TRUNC    = 0x00200%0A%09O_NONBLOCK = 0x00800%0A%09O_APPEND   = 0x00400%0A%09O_SYNC     = 0x01000%0A%09O_ASYNC    = 0x02000%0A%09O_CLOEXEC  = 0x80000%0A)%0A%0Aconst (%0A%09// More invented values for signals%0A%09SIGHUP  = Signal(0x1)%0A%09SIGINT  = Signal(0x2)%0A%09SIGQUIT = Signal(0x3)%0A%09SIGILL  = Signal(0x4)%0A%09SIGTRAP = Signal(0x5)%0A%09SIGABRT = Signal(0x6)%0A%09SIGBUS  = Signal(0x7)%0A%09SIGFPE  = Signal(0x8)%0A%09SIGKILL = Signal(0x9)%0A%09SIGSEGV = Signal(0xb)%0A%09SIGPIPE = Signal(0xd)%0A%09SIGALRM = Signal(0xe)%0A%09SIGTERM = Signal(0xf)%0A)%0A%0Avar signals = %5B...%5Dstring%7B%0A%091:  %22hangup%22,%0A%092:  %22interrupt%22,%0A%093:  %22quit%22,%0A%094:  %22illegal instruction%22,%0A%095:  %22trace/breakpoint trap%22,%0A%096:  %22aborted%22,%0A%097:  %22bus error%22,%0A%098:  %22floating point exception%22,%0A%099:  %22killed%22,%0A%0910: %22user defined signal 1%22,%0A%0911: %22segmentation fault%22,%0A%0912: %22user defined signal 2%22,%0A%0913: %22broken pipe%22,%0A%0914: %22alarm clock%22,%0A%0915: %22terminated%22,%0A%7D%0A%0Aconst (%0A%09GENERIC_READ    = 0x80000000%0A%09GENERIC_WRITE   = 0x40000000%0A%09GENERIC_EXECUTE = 0x20000000%0A%09GENERIC_ALL     = 0x10000000%0A%0A%09FILE_LIST_DIRECTORY   = 0x00000001%0A%09FILE_APPEND_DATA      = 0x00000004%0A%09FILE_WRITE_ATTRIBUTES = 0x00000100%0A%0A%09FILE_SHARE_READ   = 0x00000001%0A%09FILE_SHARE_WRITE  = 0x00000002%0A%09FILE_SHARE_DELETE = 0x00000004%0A%0A%09FILE_ATTRIBUTE_READONLY              = 0x00000001%0A%09FILE_ATTRIBUTE_HIDDEN                = 0x00000002%0A%09FILE_ATTRIBUTE_SYSTEM                = 0x00000004%0A%09FILE_ATTRIBUTE_DIRECTORY             = 0x00000010%0A%09FILE_ATTRIBUTE_ARCHIVE               = 0x00000020%0A%09FILE_ATTRIBUTE_DEVICE                = 0x00000040%0A%09FILE_ATTRIBUTE_NORMAL                = 0x00000080%0A%09FILE_ATTRIBUTE_TEMPORARY             = 0x00000100%0A%09FILE_ATTRIBUTE_SPARSE_FILE           = 0x00000200%0A%09FILE_ATTRIBUTE_REPARSE_POINT         = 0x00000400%0A%09FILE_ATTRIBUTE_COMPRESSED            = 0x00000800%0A%09FILE_ATTRIBUTE_OFFLINE               = 0x00001000%0A%09FILE_ATTRIBUTE_NOT_CONTENT_INDEXED   = 0x00002000%0A%09FILE_ATTRIBUTE_ENCRYPTED             = 0x00004000%0A%09FILE_ATTRIBUTE_INTEGRITY_STREAM      = 0x00008000%0A%09FILE_ATTRIBUTE_VIRTUAL               = 0x00010000%0A%09FILE_ATTRIBUTE_NO_SCRUB_DATA         = 0x00020000%0A%09FILE_ATTRIBUTE_RECALL_ON_OPEN        = 0x00040000%0A%09FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = 0x00400000%0A%0A%09INVALID_FILE_ATTRIBUTES = 0xffffffff%0A%0A%09CREATE_NEW        = 1%0A%09CREATE_ALWAYS     = 2%0A%09OPEN_EXISTING     = 3%0A%09OPEN_ALWAYS       = 4%0A%09TRUNCATE_EXISTING = 5%0A%0A%09FILE_FLAG_OPEN_REPARSE_POINT = 0x00200000%0A%09FILE_FLAG_BACKUP_SEMANTICS   = 0x02000000%0A%09FILE_FLAG_OVERLAPPED         = 0x40000000%0A%0A%09HANDLE_FLAG_INHERIT    = 0x00000001%0A%09STARTF_USESTDHANDLES   = 0x00000100%0A%09STARTF_USESHOWWINDOW   = 0x00000001%0A%09DUPLICATE_CLOSE_SOURCE = 0x00000001%0A%09DUPLICATE_SAME_ACCESS  = 0x00000002%0A%0A%09STD_INPUT_HANDLE  = -10 & (1%3C%3C32 - 1)%0A%09STD_OUTPUT_HANDLE = -11 & (1%3C%3C32 - 1)%0A%09STD_ERROR_HANDLE  = -12 & (1%3C%3C32 - 1)%0A%0A%09FILE_BEGIN   = 0%0A%09FILE_CURRENT = 1%0A%09FILE_END     = 2%0A%0A%09LANG_ENGLISH       = 0x09%0A%09SUBLANG_ENGLISH_US = 0x01%0A%0A%09FORMAT_MESSAGE_ALLOCATE_BUFFER = 256%0A%09FORMAT_MESSAGE_IGNORE_INSERTS  = 512%0A%09FORMAT_MESSAGE_FROM_STRING     = 1024%0A%09FORMAT_MESSAGE_FROM_HMODULE    = 2048%0A%09FORMAT_MESSAGE_FROM_SYSTEM     = 4096%0A%09FORMAT_MESSAGE_ARGUMENT_ARRAY  = 8192%0A%09FORMAT_MESSAGE_MAX_WIDTH_MASK  = 255%0A%0A%09MAX_PATH      = 260%0A%09MAX_LONG_PATH = 32768%0A%0A%09MAX_COMPUTERNAME_LENGTH = 15%0A%0A%09TIME_ZONE_ID_UNKNOWN  = 0%0A%09TIME_ZONE_ID_STANDARD = 1%0A%0A%09TIME_ZONE_ID_DAYLIGHT = 2%0A%09IGNORE                = 0%0A%09INFINITE              = 0xffffffff%0A%0A%09WAIT_TIMEOUT   = 258%0A%09WAIT_ABANDONED = 0x00000080%0A%09WAIT_OBJECT_0  = 0x00000000%0A%09WAIT_FAILED    = 0xFFFFFFFF%0A%0A%09PROCESS_TERMINATE         = 1%0A%09PROCESS_QUERY_INFORMATION = 0x00000400%0A%09SYNCHRONIZE               = 0x00100000%0A%0A%09FILE_MAP_COPY    = 0x01%0A%09FILE_MAP_WRITE   = 0x02%0A%09FILE_MAP_READ    = 0x04%0A%09FILE_MAP_EXECUTE = 0x20%0A%0A%09CTRL_C_EVENT     = 0%0A%09CTRL_BREAK_EVENT = 1%0A%0A%09// Windows reserves errors %3E= 1%3C%3C29 for application use.%0A%09APPLICATION_ERROR = 1 %3C%3C 29%0A)%0A%0Aconst (%0A%09// Process creation flags.%0A%09CREATE_BREAKAWAY_FROM_JOB        = 0x01000000%0A%09CREATE_DEFAULT_ERROR_MODE        = 0x04000000%0A%09CREATE_NEW_CONSOLE               = 0x00000010%0A%09CREATE_NEW_PROCESS_GROUP         = 0x00000200%0A%09CREATE_NO_WINDOW                 = 0x08000000%0A%09CREATE_PROTECTED_PROCESS         = 0x00040000%0A%09CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000%0A%09CREATE_SEPARATE_WOW_VDM          = 0x00000800%0A%09CREATE_SHARED_WOW_VDM            = 0x00001000%0A%09CREATE_SUSPENDED                 = 0x00000004%0A%09CREATE_UNICODE_ENVIRONMENT       = 0x00000400%0A%09DEBUG_ONLY_THIS_PROCESS          = 0x00000002%0A%09DEBUG_PROCESS                    = 0x00000001%0A%09DETACHED_PROCESS                 = 0x00000008%0A%09EXTENDED_STARTUPINFO_PRESENT     = 0x00080000%0A%09INHERIT_PARENT_AFFINITY          = 0x00010000%0A)%0A%0Aconst (%0A%09// flags for CreateToolhelp32Snapshot%0A%09TH32CS_SNAPHEAPLIST = 0x01%0A%09TH32CS_SNAPPROCESS  = 0x02%0A%09TH32CS_SNAPTHREAD   = 0x04%0A%09TH32CS_SNAPMODULE   = 0x08%0A%09TH32CS_SNAPMODULE32 = 0x10%0A%09TH32CS_SNAPALL      = TH32CS_SNAPHEAPLIST %7C TH32CS_SNAPMODULE %7C TH32CS_SNAPPROCESS %7C TH32CS_SNAPTHREAD%0A%09TH32CS_INHERIT      = 0x80000000%0A)%0A%0Aconst (%0A%09// filters for ReadDirectoryChangesW%0A%09FILE_NOTIFY_CHANGE_FILE_NAME   = 0x001%0A%09FILE_NOTIFY_CHANGE_DIR_NAME    = 0x002%0A%09FILE_NOTIFY_CHANGE_ATTRIBUTES  = 0x004%0A%09FILE_NOTIFY_CHANGE_SIZE        = 0x008%0A%09FILE_NOTIFY_CHANGE_LAST_WRITE  = 0x010%0A%09FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x020%0A%09FILE_NOTIFY_CHANGE_CREATION    = 0x040%0A%09FILE_NOTIFY_CHANGE_SECURITY    = 0x100%0A)%0A%0Aconst (%0A%09// do not reorder%0A%09FILE_ACTION_ADDED = iota + 1%0A%09FILE_ACTION_REMOVED%0A%09FILE_ACTION_MODIFIED%0A%09FILE_ACTION_RENAMED_OLD_NAME%0A%09FILE_ACTION_RENAMED_NEW_NAME%0A)%0A%0Aconst (%0A%09// wincrypt.h%0A%09PROV_RSA_FULL                    = 1%0A%09PROV_RSA_SIG                     = 2%0A%09PROV_DSS                         = 3%0A%09PROV_FORTEZZA                    = 4%0A%09PROV_MS_EXCHANGE                 = 5%0A%09PROV_SSL                         = 6%0A%09PROV_RSA_SCHANNEL                = 12%0A%09PROV_DSS_DH                      = 13%0A%09PROV_EC_ECDSA_SIG                = 14%0A%09PROV_EC_ECNRA_SIG                = 15%0A%09PROV_EC_ECDSA_FULL               = 16%0A%09PROV_EC_ECNRA_FULL               = 17%0A%09PROV_DH_SCHANNEL                 = 18%0A%09PROV_SPYRUS_LYNKS                = 20%0A%09PROV_RNG                         = 21%0A%09PROV_INTEL_SEC                   = 22%0A%09PROV_REPLACE_OWF                 = 23%0A%09PROV_RSA_AES                     = 24%0A%09CRYPT_VERIFYCONTEXT              = 0xF0000000%0A%09CRYPT_NEWKEYSET                  = 0x00000008%0A%09CRYPT_DELETEKEYSET               = 0x00000010%0A%09CRYPT_MACHINE_KEYSET             = 0x00000020%0A%09CRYPT_SILENT                     = 0x00000040%0A%09CRYPT_DEFAULT_CONTAINER_OPTIONAL = 0x00000080%0A%0A%09USAGE_MATCH_TYPE_AND = 0%0A%09USAGE_MATCH_TYPE_OR  = 1%0A%0A%09/* msgAndCertEncodingType values for CertOpenStore function */%0A%09X509_ASN_ENCODING   = 0x00000001%0A%09PKCS_7_ASN_ENCODING = 0x00010000%0A%0A%09/* storeProvider values for CertOpenStore function */%0A%09CERT_STORE_PROV_MSG               = 1%0A%09CERT_STORE_PROV_MEMORY            = 2%0A%09CERT_STORE_PROV_FILE              = 3%0A%09CERT_STORE_PROV_REG               = 4%0A%09CERT_STORE_PROV_PKCS7             = 5%0A%09CERT_STORE_PROV_SERIALIZED        = 6%0A%09CERT_STORE_PROV_FILENAME_A        = 7%0A%09CERT_STORE_PROV_FILENAME_W        = 8%0A%09CERT_STORE_PROV_FILENAME          = CERT_STORE_PROV_FILENAME_W%0A%09CERT_STORE_PROV_SYSTEM_A          = 9%0A%09CERT_STORE_PROV_SYSTEM_W          = 10%0A%09CERT_STORE_PROV_SYSTEM            = CERT_STORE_PROV_SYSTEM_W%0A%09CERT_STORE_PROV_COLLECTION        = 11%0A%09CERT_STORE_PROV_SYSTEM_REGISTRY_A = 12%0A%09CERT_STORE_PROV_SYSTEM_REGISTRY_W = 13%0A%09CERT_STORE_PROV_SYSTEM_REGISTRY   = CERT_STORE_PROV_SYSTEM_REGISTRY_W%0A%09CERT_STORE_PROV_PHYSICAL_W        = 14%0A%09CERT_STORE_PROV_PHYSICAL          = CERT_STORE_PROV_PHYSICAL_W%0A%09CERT_STORE_PROV_SMART_CARD_W      = 15%0A%09CERT_STORE_PROV_SMART_CARD        = CERT_STORE_PROV_SMART_CARD_W%0A%09CERT_STORE_PROV_LDAP_W            = 16%0A%09CERT_STORE_PROV_LDAP              = CERT_STORE_PROV_LDAP_W%0A%09CERT_STORE_PROV_PKCS12            = 17%0A%0A%09/* store characteristics (low WORD of flag) for CertOpenStore function */%0A%09CERT_STORE_NO_CRYPT_RELEASE_FLAG            = 0x00000001%0A%09CERT_STORE_SET_LOCALIZED_NAME_FLAG          = 0x00000002%0A%09CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 0x00000004%0A%09CERT_STORE_DELETE_FLAG                      = 0x00000010%0A%09CERT_STORE_UNSAFE_PHYSICAL_FLAG             = 0x00000020%0A%09CERT_STORE_SHARE_STORE_FLAG                 = 0x00000040%0A%09CERT_STORE_SHARE_CONTEXT_FLAG               = 0x00000080%0A%09CERT_STORE_MANIFOLD_FLAG                    = 0x00000100%0A%09CERT_STORE_ENUM_ARCHIVED_FLAG               = 0x00000200%0A%09CERT_STORE_UPDATE_KEYID_FLAG                = 0x00000400%0A%09CERT_STORE_BACKUP_RESTORE_FLAG              = 0x00000800%0A%09CERT_STORE_MAXIMUM_ALLOWED_FLAG             = 0x00001000%0A%09CERT_STORE_CREATE_NEW_FLAG                  = 0x00002000%0A%09CERT_STORE_OPEN_EXISTING_FLAG               = 0x00004000%0A%09CERT_STORE_READONLY_FLAG                    = 0x00008000%0A%0A%09/* store locations (high WORD of flag) for CertOpenStore function */%0A%09CERT_SYSTEM_STORE_CURRENT_USER               = 0x00010000%0A%09CERT_SYSTEM_STORE_LOCAL_MACHINE              = 0x00020000%0A%09CERT_SYSTEM_STORE_CURRENT_SERVICE            = 0x00040000%0A%09CERT_SYSTEM_STORE_SERVICES                   = 0x00050000%0A%09CERT_SYSTEM_STORE_USERS                      = 0x00060000%0A%09CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY  = 0x00070000%0A%09CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY = 0x00080000%0A%09CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE   = 0x00090000%0A%09CERT_SYSTEM_STORE_UNPROTECTED_FLAG           = 0x40000000%0A%09CERT_SYSTEM_STORE_RELOCATE_FLAG              = 0x80000000%0A%0A%09/* Miscellaneous high-WORD flags for CertOpenStore function */%0A%09CERT_REGISTRY_STORE_REMOTE_FLAG      = 0x00010000%0A%09CERT_REGISTRY_STORE_SERIALIZED_FLAG  = 0x00020000%0A%09CERT_REGISTRY_STORE_ROAMING_FLAG     = 0x00040000%0A%09CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG = 0x00080000%0A%09CERT_REGISTRY_STORE_LM_GPT_FLAG      = 0x01000000%0A%09CERT_REGISTRY_STORE_CLIENT_GPT_FLAG  = 0x80000000%0A%09CERT_FILE_STORE_COMMIT_ENABLE_FLAG   = 0x00010000%0A%09CERT_LDAP_STORE_SIGN_FLAG            = 0x00010000%0A%09CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG  = 0x00020000%0A%09CERT_LDAP_STORE_OPENED_FLAG          = 0x00040000%0A%09CERT_LDAP_STORE_UNBIND_FLAG          = 0x00080000%0A%0A%09/* addDisposition values for CertAddCertificateContextToStore function */%0A%09CERT_STORE_ADD_NEW                                 = 1%0A%09CERT_STORE_ADD_USE_EXISTING                        = 2%0A%09CERT_STORE_ADD_REPLACE_EXISTING                    = 3%0A%09CERT_STORE_ADD_ALWAYS                              = 4%0A%09CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = 5%0A%09CERT_STORE_ADD_NEWER                               = 6%0A%09CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES            = 7%0A%0A%09/* ErrorStatus values for CertTrustStatus struct */%0A%09CERT_TRUST_NO_ERROR                          = 0x00000000%0A%09CERT_TRUST_IS_NOT_TIME_VALID                 = 0x00000001%0A%09CERT_TRUST_IS_REVOKED                        = 0x00000004%0A%09CERT_TRUST_IS_NOT_SIGNATURE_VALID            = 0x00000008%0A%09CERT_TRUST_IS_NOT_VALID_FOR_USAGE            = 0x00000010%0A%09CERT_TRUST_IS_UNTRUSTED_ROOT                 = 0x00000020%0A%09CERT_TRUST_REVOCATION_STATUS_UNKNOWN         = 0x00000040%0A%09CERT_TRUST_IS_CYCLIC                         = 0x00000080%0A%09CERT_TRUST_INVALID_EXTENSION                 = 0x00000100%0A%09CERT_TRUST_INVALID_POLICY_CONSTRAINTS        = 0x00000200%0A%09CERT_TRUST_INVALID_BASIC_CONSTRAINTS         = 0x00000400%0A%09CERT_TRUST_INVALID_NAME_CONSTRAINTS          = 0x00000800%0A%09CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = 0x00001000%0A%09CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT   = 0x00002000%0A%09CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = 0x00004000%0A%09CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT      = 0x00008000%0A%09CERT_TRUST_IS_PARTIAL_CHAIN                  = 0x00010000%0A%09CERT_TRUST_CTL_IS_NOT_TIME_VALID             = 0x00020000%0A%09CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID        = 0x00040000%0A%09CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE        = 0x00080000%0A%09CERT_TRUST_HAS_WEAK_SIGNATURE                = 0x00100000%0A%09CERT_TRUST_IS_OFFLINE_REVOCATION             = 0x01000000%0A%09CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY          = 0x02000000%0A%09CERT_TRUST_IS_EXPLICIT_DISTRUST              = 0x04000000%0A%09CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT    = 0x08000000%0A%0A%09/* InfoStatus values for CertTrustStatus struct */%0A%09CERT_TRUST_HAS_EXACT_MATCH_ISSUER        = 0x00000001%0A%09CERT_TRUST_HAS_KEY_MATCH_ISSUER          = 0x00000002%0A%09CERT_TRUST_HAS_NAME_MATCH_ISSUER         = 0x00000004%0A%09CERT_TRUST_IS_SELF_SIGNED                = 0x00000008%0A%09CERT_TRUST_HAS_PREFERRED_ISSUER          = 0x00000100%0A%09CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY     = 0x00000400%0A%09CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS    = 0x00000400%0A%09CERT_TRUST_IS_PEER_TRUSTED               = 0x00000800%0A%09CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED     = 0x00001000%0A%09CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE = 0x00002000%0A%09CERT_TRUST_IS_CA_TRUSTED                 = 0x00004000%0A%09CERT_TRUST_IS_COMPLEX_CHAIN              = 0x00010000%0A%0A%09/* policyOID values for CertVerifyCertificateChainPolicy function */%0A%09CERT_CHAIN_POLICY_BASE              = 1%0A%09CERT_CHAIN_POLICY_AUTHENTICODE      = 2%0A%09CERT_CHAIN_POLICY_AUTHENTICODE_TS   = 3%0A%09CERT_CHAIN_POLICY_SSL               = 4%0A%09CERT_CHAIN_POLICY_BASIC_CONSTRAINTS = 5%0A%09CERT_CHAIN_POLICY_NT_AUTH           = 6%0A%09CERT_CHAIN_POLICY_MICROSOFT_ROOT    = 7%0A%09CERT_CHAIN_POLICY_EV                = 8%0A%09CERT_CHAIN_POLICY_SSL_F12           = 9%0A%0A%09CERT_E_EXPIRED       = 0x800B0101%0A%09CERT_E_ROLE          = 0x800B0103%0A%09CERT_E_PURPOSE       = 0x800B0106%0A%09CERT_E_UNTRUSTEDROOT = 0x800B0109%0A%09CERT_E_CN_NO_MATCH   = 0x800B010F%0A%0A%09/* AuthType values for SSLExtraCertChainPolicyPara struct */%0A%09AUTHTYPE_CLIENT = 1%0A%09AUTHTYPE_SERVER = 2%0A%0A%09/* Checks values for SSLExtraCertChainPolicyPara struct */%0A%09SECURITY_FLAG_IGNORE_REVOCATION        = 0x00000080%0A%09SECURITY_FLAG_IGNORE_UNKNOWN_CA        = 0x00000100%0A%09SECURITY_FLAG_IGNORE_WRONG_USAGE       = 0x00000200%0A%09SECURITY_FLAG_IGNORE_CERT_CN_INVALID   = 0x00001000%0A%09SECURITY_FLAG_IGNORE_CERT_DATE_INVALID = 0x00002000%0A)%0A%0Avar (%0A%09OID_PKIX_KP_SERVER_AUTH = %5B%5Dbyte(%221.3.6.1.5.5.7.3.1%5Cx00%22)%0A%09OID_SERVER_GATED_CRYPTO = %5B%5Dbyte(%221.3.6.1.4.1.311.10.3.3%5Cx00%22)%0A%09OID_SGC_NETSCAPE        = %5B%5Dbyte(%222.16.840.1.113730.4.1%5Cx00%22)%0A)%0A%0A// Pointer represents a pointer to an arbitrary Windows type.%0A//%0A// Pointer-typed fields may point to one of many different types. It's%0A// up to the caller to provide a pointer to the appropriate type, cast%0A// to Pointer. The caller must obey the unsafe.Pointer rules while%0A// doing so.%0Atype Pointer *struct%7B%7D%0A%0A// Invented values to support what package os expects.%0Atype Timeval struct %7B%0A%09Sec  int32%0A%09Usec int32%0A%7D%0A%0Afunc (tv *Timeval) Nanoseconds() int64 %7B%0A%09return (int64(tv.Sec)*1e6 + int64(tv.Usec)) * 1e3%0A%7D%0A%0Afunc NsecToTimeval(nsec int64) (tv Timeval) %7B%0A%09tv.Sec = int32(nsec / 1e9)%0A%09tv.Usec = int32(nsec %25 1e9 / 1e3)%0A%09return%0A%7D%0A%0Atype SecurityAttributes struct %7B%0A%09Length             uint32%0A%09SecurityDescriptor uintptr%0A%09InheritHandle      uint32%0A%7D%0A%0Atype Overlapped struct %7B%0A%09Internal     uintptr%0A%09InternalHigh uintptr%0A%09Offset       uint32%0A%09OffsetHigh   uint32%0A%09HEvent       Handle%0A%7D%0A%0Atype FileNotifyInformation struct %7B%0A%09NextEntryOffset uint32%0A%09Action          uint32%0A%09FileNameLength  uint32%0A%09FileName        uint16%0A%7D%0A%0Atype Filetime struct %7B%0A%09LowDateTime  uint32%0A%09HighDateTime uint32%0A%7D%0A%0A// Nanoseconds returns Filetime ft in nanoseconds%0A// since Epoch (00:00:00 UTC, January 1, 1970).%0Afunc (ft *Filetime) Nanoseconds() int64 %7B%0A%09// 100-nanosecond intervals since January 1, 1601%0A%09nsec := int64(ft.HighDateTime)%3C%3C32 + int64(ft.LowDateTime)%0A%09// change starting time to the Epoch (00:00:00 UTC, January 1, 1970)%0A%09nsec -= 116444736000000000%0A%09// convert into nanoseconds%0A%09nsec *= 100%0A%09return nsec%0A%7D%0A%0Afunc NsecToFiletime(nsec int64) (ft Filetime) %7B%0A%09// convert into 100-nanosecond%0A%09nsec /= 100%0A%09// change starting time to January 1, 1601%0A%09nsec += 116444736000000000%0A%09// split into high / low%0A%09ft.LowDateTime = uint32(nsec & 0xffffffff)%0A%09ft.HighDateTime = uint32(nsec %3E%3E 32 & 0xffffffff)%0A%09return ft%0A%7D%0A%0Atype Win32finddata struct %7B%0A%09FileAttributes    uint32%0A%09CreationTime      Filetime%0A%09LastAccessTime    Filetime%0A%09LastWriteTime     Filetime%0A%09FileSizeHigh      uint32%0A%09FileSizeLow       uint32%0A%09Reserved0         uint32%0A%09Reserved1         uint32%0A%09FileName          %5BMAX_PATH - 1%5Duint16%0A%09AlternateFileName %5B13%5Duint16%0A%7D%0A%0A// This is the actual system call structure.%0A// Win32finddata is what we committed to in Go 1.%0Atype win32finddata1 struct %7B%0A%09FileAttributes    uint32%0A%09CreationTime      Filetime%0A%09LastAccessTime    Filetime%0A%09LastWriteTime     Filetime%0A%09FileSizeHigh      uint32%0A%09FileSizeLow       uint32%0A%09Reserved0         uint32%0A%09Reserved1         uint32%0A%09FileName          %5BMAX_PATH%5Duint16%0A%09AlternateFileName %5B14%5Duint16%0A%7D%0A%0Afunc copyFindData(dst *Win32finddata, src *win32finddata1) %7B%0A%09dst.FileAttributes = src.FileAttributes%0A%09dst.CreationTime = src.CreationTime%0A%09dst.LastAccessTime = src.LastAccessTime%0A%09dst.LastWriteTime = src.LastWriteTime%0A%09dst.FileSizeHigh = src.FileSizeHigh%0A%09dst.FileSizeLow = src.FileSizeLow%0A%09dst.Reserved0 = src.Reserved0%0A%09dst.Reserved1 = src.Reserved1%0A%0A%09// The src is 1 element bigger than dst, but it must be NUL.%0A%09copy(dst.FileName%5B:%5D, src.FileName%5B:%5D)%0A%09copy(dst.AlternateFileName%5B:%5D, src.AlternateFileName%5B:%5D)%0A%7D%0A%0Atype ByHandleFileInformation struct %7B%0A%09FileAttributes     uint32%0A%09CreationTime       Filetime%0A%09LastAccessTime     Filetime%0A%09LastWriteTime      Filetime%0A%09VolumeSerialNumber uint32%0A%09FileSizeHigh       uint32%0A%09FileSizeLow        uint32%0A%09NumberOfLinks      uint32%0A%09FileIndexHigh      uint32%0A%09FileIndexLow       uint32%0A%7D%0A%0Aconst (%0A%09GetFileExInfoStandard = 0%0A%09GetFileExMaxInfoLevel = 1%0A)%0A%0Atype Win32FileAttributeData struct %7B%0A%09FileAttributes uint32%0A%09CreationTime   Filetime%0A%09LastAccessTime Filetime%0A%09LastWriteTime  Filetime%0A%09FileSizeHigh   uint32%0A%09FileSizeLow    uint32%0A%7D%0A%0A// ShowWindow constants%0Aconst (%0A%09// winuser.h%0A%09SW_HIDE            = 0%0A%09SW_NORMAL          = 1%0A%09SW_SHOWNORMAL      = 1%0A%09SW_SHOWMINIMIZED   = 2%0A%09SW_SHOWMAXIMIZED   = 3%0A%09SW_MAXIMIZE        = 3%0A%09SW_SHOWNOACTIVATE  = 4%0A%09SW_SHOW            = 5%0A%09SW_MINIMIZE        = 6%0A%09SW_SHOWMINNOACTIVE = 7%0A%09SW_SHOWNA          = 8%0A%09SW_RESTORE         = 9%0A%09SW_SHOWDEFAULT     = 10%0A%09SW_FORCEMINIMIZE   = 11%0A)%0A%0Atype StartupInfo struct %7B%0A%09Cb            uint32%0A%09_             *uint16%0A%09Desktop       *uint16%0A%09Title         *uint16%0A%09X             uint32%0A%09Y             uint32%0A%09XSize         uint32%0A%09YSize         uint32%0A%09XCountChars   uint32%0A%09YCountChars   uint32%0A%09FillAttribute uint32%0A%09Flags         uint32%0A%09ShowWindow    uint16%0A%09_             uint16%0A%09_             *byte%0A%09StdInput      Handle%0A%09StdOutput     Handle%0A%09StdErr        Handle%0A%7D%0A%0Atype ProcessInformation struct %7B%0A%09Process   Handle%0A%09Thread    Handle%0A%09ProcessId uint32%0A%09ThreadId  uint32%0A%7D%0A%0Atype ProcessEntry32 struct %7B%0A%09Size            uint32%0A%09Usage           uint32%0A%09ProcessID       uint32%0A%09DefaultHeapID   uintptr%0A%09ModuleID        uint32%0A%09Threads         uint32%0A%09ParentProcessID uint32%0A%09PriClassBase    int32%0A%09Flags           uint32%0A%09ExeFile         %5BMAX_PATH%5Duint16%0A%7D%0A%0Atype Systemtime struct %7B%0A%09Year         uint16%0A%09Month        uint16%0A%09DayOfWeek    uint16%0A%09Day          uint16%0A%09Hour         uint16%0A%09Minute       uint16%0A%09Second       uint16%0A%09Milliseconds uint16%0A%7D%0A%0Atype Timezoneinformation struct %7B%0A%09Bias         int32%0A%09StandardName %5B32%5Duint16%0A%09StandardDate Systemtime%0A%09StandardBias int32%0A%09DaylightName %5B32%5Duint16%0A%09DaylightDate Systemtime%0A%09DaylightBias int32%0A%7D%0A%0A// Socket related.%0A%0Aconst (%0A%09AF_UNSPEC  = 0%0A%09AF_UNIX    = 1%0A%09AF_INET    = 2%0A%09AF_INET6   = 23%0A%09AF_NETBIOS = 17%0A%0A%09SOCK_STREAM    = 1%0A%09SOCK_DGRAM     = 2%0A%09SOCK_RAW       = 3%0A%09SOCK_SEQPACKET = 5%0A%0A%09IPPROTO_IP   = 0%0A%09IPPROTO_IPV6 = 0x29%0A%09IPPROTO_TCP  = 6%0A%09IPPROTO_UDP  = 17%0A%0A%09SOL_SOCKET                = 0xffff%0A%09SO_REUSEADDR              = 4%0A%09SO_KEEPALIVE              = 8%0A%09SO_DONTROUTE              = 16%0A%09SO_BROADCAST              = 32%0A%09SO_LINGER                 = 128%0A%09SO_RCVBUF                 = 0x1002%0A%09SO_SNDBUF                 = 0x1001%0A%09SO_UPDATE_ACCEPT_CONTEXT  = 0x700b%0A%09SO_UPDATE_CONNECT_CONTEXT = 0x7010%0A%0A%09IOC_OUT                            = 0x40000000%0A%09IOC_IN                             = 0x80000000%0A%09IOC_VENDOR                         = 0x18000000%0A%09IOC_INOUT                          = IOC_IN %7C IOC_OUT%0A%09IOC_WS2                            = 0x08000000%0A%09SIO_GET_EXTENSION_FUNCTION_POINTER = IOC_INOUT %7C IOC_WS2 %7C 6%0A%09SIO_KEEPALIVE_VALS                 = IOC_IN %7C IOC_VENDOR %7C 4%0A%09SIO_UDP_CONNRESET                  = IOC_IN %7C IOC_VENDOR %7C 12%0A%0A%09// cf. http://support.microsoft.com/default.aspx?scid=kb;en-us;257460%0A%0A%09IP_TOS             = 0x3%0A%09IP_TTL             = 0x4%0A%09IP_MULTICAST_IF    = 0x9%0A%09IP_MULTICAST_TTL   = 0xa%0A%09IP_MULTICAST_LOOP  = 0xb%0A%09IP_ADD_MEMBERSHIP  = 0xc%0A%09IP_DROP_MEMBERSHIP = 0xd%0A%0A%09IPV6_V6ONLY         = 0x1b%0A%09IPV6_UNICAST_HOPS   = 0x4%0A%09IPV6_MULTICAST_IF   = 0x9%0A%09IPV6_MULTICAST_HOPS = 0xa%0A%09IPV6_MULTICAST_LOOP = 0xb%0A%09IPV6_JOIN_GROUP     = 0xc%0A%09IPV6_LEAVE_GROUP    = 0xd%0A%0A%09MSG_OOB       = 0x1%0A%09MSG_PEEK      = 0x2%0A%09MSG_DONTROUTE = 0x4%0A%09MSG_WAITALL   = 0x8%0A%0A%09MSG_TRUNC  = 0x0100%0A%09MSG_CTRUNC = 0x0200%0A%09MSG_BCAST  = 0x0400%0A%09MSG_MCAST  = 0x0800%0A%0A%09SOMAXCONN = 0x7fffffff%0A%0A%09TCP_NODELAY = 1%0A%0A%09SHUT_RD   = 0%0A%09SHUT_WR   = 1%0A%09SHUT_RDWR = 2%0A%0A%09WSADESCRIPTION_LEN = 256%0A%09WSASYS_STATUS_LEN  = 128%0A)%0A%0Atype WSABuf struct %7B%0A%09Len uint32%0A%09Buf *byte%0A%7D%0A%0Atype WSAMsg struct %7B%0A%09Name        *syscall.RawSockaddrAny%0A%09Namelen     int32%0A%09Buffers     *WSABuf%0A%09BufferCount uint32%0A%09Control     WSABuf%0A%09Flags       uint32%0A%7D%0A%0A// Invented values to support what package os expects.%0Aconst (%0A%09S_IFMT   = 0x1f000%0A%09S_IFIFO  = 0x1000%0A%09S_IFCHR  = 0x2000%0A%09S_IFDIR  = 0x4000%0A%09S_IFBLK  = 0x6000%0A%09S_IFREG  = 0x8000%0A%09S_IFLNK  = 0xa000%0A%09S_IFSOCK = 0xc000%0A%09S_ISUID  = 0x800%0A%09S_ISGID  = 0x400%0A%09S_ISVTX  = 0x200%0A%09S_IRUSR  = 0x100%0A%09S_IWRITE = 0x80%0A%09S_IWUSR  = 0x80%0A%09S_IXUSR  = 0x40%0A)%0A%0Aconst (%0A%09FILE_TYPE_CHAR    = 0x0002%0A%09FILE_TYPE_DISK    = 0x0001%0A%09FILE_TYPE_PIPE    = 0x0003%0A%09FILE_TYPE_REMOTE  = 0x8000%0A%09FILE_TYPE_UNKNOWN = 0x0000%0A)%0A%0Atype Hostent struct %7B%0A%09Name     *byte%0A%09Aliases  **byte%0A%09AddrType uint16%0A%09Length   uint16%0A%09AddrList **byte%0A%7D%0A%0Atype Protoent struct %7B%0A%09Name    *byte%0A%09Aliases **byte%0A%09Proto   uint16%0A%7D%0A%0Aconst (%0A%09DNS_TYPE_A       = 0x0001%0A%09DNS_TYPE_NS      = 0x0002%0A%09DNS_TYPE_MD      = 0x0003%0A%09DNS_TYPE_MF      = 0x0004%0A%09DNS_TYPE_CNAME   = 0x0005%0A%09DNS_TYPE_SOA     = 0x0006%0A%09DNS_TYPE_MB      = 0x0007%0A%09DNS_TYPE_MG      = 0x0008%0A%09DNS_TYPE_MR      = 0x0009%0A%09DNS_TYPE_NULL    = 0x000a%0A%09DNS_TYPE_WKS     = 0x000b%0A%09DNS_TYPE_PTR     = 0x000c%0A%09DNS_TYPE_HINFO   = 0x000d%0A%09DNS_TYPE_MINFO   = 0x000e%0A%09DNS_TYPE_MX      = 0x000f%0A%09DNS_TYPE_TEXT    = 0x0010%0A%09DNS_TYPE_RP      = 0x0011%0A%09DNS_TYPE_AFSDB   = 0x0012%0A%09DNS_TYPE_X25     = 0x0013%0A%09DNS_TYPE_ISDN    = 0x0014%0A%09DNS_TYPE_RT      = 0x0015%0A%09DNS_TYPE_NSAP    = 0x0016%0A%09DNS_TYPE_NSAPPTR = 0x0017%0A%09DNS_TYPE_SIG     = 0x0018%0A%09DNS_TYPE_KEY     = 0x0019%0A%09DNS_TYPE_PX      = 0x001a%0A%09DNS_TYPE_GPOS    = 0x001b%0A%09DNS_TYPE_AAAA    = 0x001c%0A%09DNS_TYPE_LOC     = 0x001d%0A%09DNS_TYPE_NXT     = 0x001e%0A%09DNS_TYPE_EID     = 0x001f%0A%09DNS_TYPE_NIMLOC  = 0x0020%0A%09DNS_TYPE_SRV     = 0x0021%0A%09DNS_TYPE_ATMA    = 0x0022%0A%09DNS_TYPE_NAPTR   = 0x0023%0A%09DNS_TYPE_KX      = 0x0024%0A%09DNS_TYPE_CERT    = 0x0025%0A%09DNS_TYPE_A6      = 0x0026%0A%09DNS_TYPE_DNAME   = 0x0027%0A%09DNS_TYPE_SINK    = 0x0028%0A%09DNS_TYPE_OPT     = 0x0029%0A%09DNS_TYPE_DS      = 0x002B%0A%09DNS_TYPE_RRSIG   = 0x002E%0A%09DNS_TYPE_NSEC    = 0x002F%0A%09DNS_TYPE_DNSKEY  = 0x0030%0A%09DNS_TYPE_DHCID   = 0x0031%0A%09DNS_TYPE_UINFO   = 0x0064%0A%09DNS_TYPE_UID     = 0x0065%0A%09DNS_TYPE_GID     = 0x0066%0A%09DNS_TYPE_UNSPEC  = 0x0067%0A%09DNS_TYPE_ADDRS   = 0x00f8%0A%09DNS_TYPE_TKEY    = 0x00f9%0A%09DNS_TYPE_TSIG    = 0x00fa%0A%09DNS_TYPE_IXFR    = 0x00fb%0A%09DNS_TYPE_AXFR    = 0x00fc%0A%09DNS_TYPE_MAILB   = 0x00fd%0A%09DNS_TYPE_MAILA   = 0x00fe%0A%09DNS_TYPE_ALL     = 0x00ff%0A%09DNS_TYPE_ANY     = 0x00ff%0A%09DNS_TYPE_WINS    = 0xff01%0A%09DNS_TYPE_WINSR   = 0xff02%0A%09DNS_TYPE_NBSTAT  = 0xff01%0A)%0A%0Aconst (%0A%09DNS_INFO_NO_RECORDS = 0x251D%0A)%0A%0Aconst (%0A%09// flags inside DNSRecord.Dw%0A%09DnsSectionQuestion   = 0x0000%0A%09DnsSectionAnswer     = 0x0001%0A%09DnsSectionAuthority  = 0x0002%0A%09DnsSectionAdditional = 0x0003%0A)%0A%0Atype DNSSRVData struct %7B%0A%09Target   *uint16%0A%09Priority uint16%0A%09Weight   uint16%0A%09Port     uint16%0A%09Pad      uint16%0A%7D%0A%0Atype DNSPTRData struct %7B%0A%09Host *uint16%0A%7D%0A%0Atype DNSMXData struct %7B%0A%09NameExchange *uint16%0A%09Preference   uint16%0A%09Pad          uint16%0A%7D%0A%0Atype DNSTXTData struct %7B%0A%09StringCount uint16%0A%09StringArray %5B1%5D*uint16%0A%7D%0A%0Atype DNSRecord struct %7B%0A%09Next     *DNSRecord%0A%09Name     *uint16%0A%09Type     uint16%0A%09Length   uint16%0A%09Dw       uint32%0A%09Ttl      uint32%0A%09Reserved uint32%0A%09Data     %5B40%5Dbyte%0A%7D%0A%0Aconst (%0A%09TF_DISCONNECT         = 1%0A%09TF_REUSE_SOCKET       = 2%0A%09TF_WRITE_BEHIND       = 4%0A%09TF_USE_DEFAULT_WORKER = 0%0A%09TF_USE_SYSTEM_THREAD  = 16%0A%09TF_USE_KERNEL_APC     = 32%0A)%0A%0Atype TransmitFileBuffers struct %7B%0A%09Head       uintptr%0A%09HeadLength uint32%0A%09Tail       uintptr%0A%09TailLength uint32%0A%7D%0A%0Aconst (%0A%09IFF_UP           = 1%0A%09IFF_BROADCAST    = 2%0A%09IFF_LOOPBACK     = 4%0A%09IFF_POINTTOPOINT = 8%0A%09IFF_MULTICAST    = 16%0A)%0A%0Aconst SIO_GET_INTERFACE_LIST = 0x4004747F%0A%0A// TODO(mattn): SockaddrGen is union of sockaddr/sockaddr_in/sockaddr_in6_old.%0A// will be fixed to change variable type as suitable.%0A%0Atype SockaddrGen %5B24%5Dbyte%0A%0Atype InterfaceInfo struct %7B%0A%09Flags            uint32%0A%09Address          SockaddrGen%0A%09BroadcastAddress SockaddrGen%0A%09Netmask          SockaddrGen%0A%7D%0A%0Atype IpAddressString struct %7B%0A%09String %5B16%5Dbyte%0A%7D%0A%0Atype IpMaskString IpAddressString%0A%0Atype IpAddrString struct %7B%0A%09Next      *IpAddrString%0A%09IpAddress IpAddressString%0A%09IpMask    IpMaskString%0A%09Context   uint32%0A%7D%0A%0Aconst MAX_ADAPTER_NAME_LENGTH = 256%0Aconst MAX_ADAPTER_DESCRIPTION_LENGTH = 128%0Aconst MAX_ADAPTER_ADDRESS_LENGTH = 8%0A%0Atype IpAdapterInfo struct %7B%0A%09Next                *IpAdapterInfo%0A%09ComboIndex          uint32%0A%09AdapterName         %5BMAX_ADAPTER_NAME_LENGTH + 4%5Dbyte%0A%09Description         %5BMAX_ADAPTER_DESCRIPTION_LENGTH + 4%5Dbyte%0A%09AddressLength       uint32%0A%09Address             %5BMAX_ADAPTER_ADDRESS_LENGTH%5Dbyte%0A%09Index               uint32%0A%09Type                uint32%0A%09DhcpEnabled         uint32%0A%09CurrentIpAddress    *IpAddrString%0A%09IpAddressList       IpAddrString%0A%09GatewayList         IpAddrString%0A%09DhcpServer          IpAddrString%0A%09HaveWins            bool%0A%09PrimaryWinsServer   IpAddrString%0A%09SecondaryWinsServer IpAddrString%0A%09LeaseObtained       int64%0A%09LeaseExpires        int64%0A%7D%0A%0Aconst MAXLEN_PHYSADDR = 8%0Aconst MAX_INTERFACE_NAME_LEN = 256%0Aconst MAXLEN_IFDESCR = 256%0A%0Atype MibIfRow struct %7B%0A%09Name            %5BMAX_INTERFACE_NAME_LEN%5Duint16%0A%09Index           uint32%0A%09Type            uint32%0A%09Mtu             uint32%0A%09Speed           uint32%0A%09PhysAddrLen     uint32%0A%09PhysAddr        %5BMAXLEN_PHYSADDR%5Dbyte%0A%09AdminStatus     uint32%0A%09OperStatus      uint32%0A%09LastChange      uint32%0A%09InOctets        uint32%0A%09InUcastPkts     uint32%0A%09InNUcastPkts    uint32%0A%09InDiscards      uint32%0A%09InErrors        uint32%0A%09InUnknownProtos uint32%0A%09OutOctets       uint32%0A%09OutUcastPkts    uint32%0A%09OutNUcastPkts   uint32%0A%09OutDiscards     uint32%0A%09OutErrors       uint32%0A%09OutQLen         uint32%0A%09DescrLen        uint32%0A%09Descr           %5BMAXLEN_IFDESCR%5Dbyte%0A%7D%0A%0Atype CertInfo struct %7B%0A%09// Not implemented%0A%7D%0A%0Atype CertContext struct %7B%0A%09EncodingType uint32%0A%09EncodedCert  *byte%0A%09Length       uint32%0A%09CertInfo     *CertInfo%0A%09Store        Handle%0A%7D%0A%0Atype CertChainContext struct %7B%0A%09Size                       uint32%0A%09TrustStatus                CertTrustStatus%0A%09ChainCount                 uint32%0A%09Chains                     **CertSimpleChain%0A%09LowerQualityChainCount     uint32%0A%09LowerQualityChains         **CertChainContext%0A%09HasRevocationFreshnessTime uint32%0A%09RevocationFreshnessTime    uint32%0A%7D%0A%0Atype CertTrustListInfo struct %7B%0A%09// Not implemented%0A%7D%0A%0Atype CertSimpleChain struct %7B%0A%09Size                       uint32%0A%09TrustStatus                CertTrustStatus%0A%09NumElements                uint32%0A%09Elements                   **CertChainElement%0A%09TrustListInfo              *CertTrustListInfo%0A%09HasRevocationFreshnessTime uint32%0A%09RevocationFreshnessTime    uint32%0A%7D%0A%0Atype CertChainElement struct %7B%0A%09Size              uint32%0A%09CertContext       *CertContext%0A%09TrustStatus       CertTrustStatus%0A%09RevocationInfo    *CertRevocationInfo%0A%09IssuanceUsage     *CertEnhKeyUsage%0A%09ApplicationUsage  *CertEnhKeyUsage%0A%09ExtendedErrorInfo *uint16%0A%7D%0A%0Atype CertRevocationCrlInfo struct %7B%0A%09// Not implemented%0A%7D%0A%0Atype CertRevocationInfo struct %7B%0A%09Size             uint32%0A%09RevocationResult uint32%0A%09RevocationOid    *byte%0A%09OidSpecificInfo  Pointer%0A%09HasFreshnessTime uint32%0A%09FreshnessTime    uint32%0A%09CrlInfo          *CertRevocationCrlInfo%0A%7D%0A%0Atype CertTrustStatus struct %7B%0A%09ErrorStatus uint32%0A%09InfoStatus  uint32%0A%7D%0A%0Atype CertUsageMatch struct %7B%0A%09Type  uint32%0A%09Usage CertEnhKeyUsage%0A%7D%0A%0Atype CertEnhKeyUsage struct %7B%0A%09Length           uint32%0A%09UsageIdentifiers **byte%0A%7D%0A%0Atype CertChainPara struct %7B%0A%09Size                         uint32%0A%09RequestedUsage               CertUsageMatch%0A%09RequstedIssuancePolicy       CertUsageMatch%0A%09URLRetrievalTimeout          uint32%0A%09CheckRevocationFreshnessTime uint32%0A%09RevocationFreshnessTime      uint32%0A%09CacheResync                  *Filetime%0A%7D%0A%0Atype CertChainPolicyPara struct %7B%0A%09Size            uint32%0A%09Flags           uint32%0A%09ExtraPolicyPara Pointer%0A%7D%0A%0Atype SSLExtraCertChainPolicyPara struct %7B%0A%09Size       uint32%0A%09AuthType   uint32%0A%09Checks     uint32%0A%09ServerName *uint16%0A%7D%0A%0Atype CertChainPolicyStatus struct %7B%0A%09Size              uint32%0A%09Error             uint32%0A%09ChainIndex        uint32%0A%09ElementIndex      uint32%0A%09ExtraPolicyStatus Pointer%0A%7D%0A%0Aconst (%0A%09// do not reorder%0A%09HKEY_CLASSES_ROOT = 0x80000000 + iota%0A%09HKEY_CURRENT_USER%0A%09HKEY_LOCAL_MACHINE%0A%09HKEY_USERS%0A%09HKEY_PERFORMANCE_DATA%0A%09HKEY_CURRENT_CONFIG%0A%09HKEY_DYN_DATA%0A%0A%09KEY_QUERY_VALUE        = 1%0A%09KEY_SET_VALUE          = 2%0A%09KEY_CREATE_SUB_KEY     = 4%0A%09KEY_ENUMERATE_SUB_KEYS = 8%0A%09KEY_NOTIFY             = 16%0A%09KEY_CREATE_LINK        = 32%0A%09KEY_WRITE              = 0x20006%0A%09KEY_EXECUTE            = 0x20019%0A%09KEY_READ               = 0x20019%0A%09KEY_WOW64_64KEY        = 0x0100%0A%09KEY_WOW64_32KEY        = 0x0200%0A%09KEY_ALL_ACCESS         = 0xf003f%0A)%0A%0Aconst (%0A%09// do not reorder%0A%09REG_NONE = iota%0A%09REG_SZ%0A%09REG_EXPAND_SZ%0A%09REG_BINARY%0A%09REG_DWORD_LITTLE_ENDIAN%0A%09REG_DWORD_BIG_ENDIAN%0A%09REG_LINK%0A%09REG_MULTI_SZ%0A%09REG_RESOURCE_LIST%0A%09REG_FULL_RESOURCE_DESCRIPTOR%0A%09REG_RESOURCE_REQUIREMENTS_LIST%0A%09REG_QWORD_LITTLE_ENDIAN%0A%09REG_DWORD = REG_DWORD_LITTLE_ENDIAN%0A%09REG_QWORD = REG_QWORD_LITTLE_ENDIAN%0A)%0A%0Atype AddrinfoW struct %7B%0A%09Flags     int32%0A%09Family    int32%0A%09Socktype  int32%0A%09Protocol  int32%0A%09Addrlen   uintptr%0A%09Canonname *uint16%0A%09Addr      uintptr%0A%09Next      *AddrinfoW%0A%7D%0A%0Aconst (%0A%09AI_PASSIVE     = 1%0A%09AI_CANONNAME   = 2%0A%09AI_NUMERICHOST = 4%0A)%0A%0Atype GUID struct %7B%0A%09Data1 uint32%0A%09Data2 uint16%0A%09Data3 uint16%0A%09Data4 %5B8%5Dbyte%0A%7D%0A%0Avar WSAID_CONNECTEX = GUID%7B%0A%090x25a207b9,%0A%090xddf3,%0A%090x4660,%0A%09%5B8%5Dbyte%7B0x8e, 0xe9, 0x76, 0xe5, 0x8c, 0x74, 0x06, 0x3e%7D,%0A%7D%0A%0Avar WSAID_WSASENDMSG = GUID%7B%0A%090xa441e712,%0A%090x754f,%0A%090x43ca,%0A%09%5B8%5Dbyte%7B0x84, 0xa7, 0x0d, 0xee, 0x44, 0xcf, 0x60, 0x6d%7D,%0A%7D%0A%0Avar WSAID_WSARECVMSG = GUID%7B%0A%090xf689d7c8,%0A%090x6f1f,%0A%090x436b,%0A%09%5B8%5Dbyte%7B0x8a, 0x53, 0xe5, 0x4f, 0xe3, 0x51, 0xc3, 0x22%7D,%0A%7D%0A%0Aconst (%0A%09FILE_SKIP_COMPLETION_PORT_ON_SUCCESS = 1%0A%09FILE_SKIP_SET_EVENT_ON_HANDLE        = 2%0A)%0A%0Aconst (%0A%09WSAPROTOCOL_LEN    = 255%0A%09MAX_PROTOCOL_CHAIN = 7%0A%09BASE_PROTOCOL      = 1%0A%09LAYERED_PROTOCOL   = 0%0A%0A%09XP1_CONNECTIONLESS           = 0x00000001%0A%09XP1_GUARANTEED_DELIVERY      = 0x00000002%0A%09XP1_GUARANTEED_ORDER         = 0x00000004%0A%09XP1_MESSAGE_ORIENTED         = 0x00000008%0A%09XP1_PSEUDO_STREAM            = 0x00000010%0A%09XP1_GRACEFUL_CLOSE           = 0x00000020%0A%09XP1_EXPEDITED_DATA           = 0x00000040%0A%09XP1_CONNECT_DATA             = 0x00000080%0A%09XP1_DISCONNECT_DATA          = 0x00000100%0A%09XP1_SUPPORT_BROADCAST        = 0x00000200%0A%09XP1_SUPPORT_MULTIPOINT       = 0x00000400%0A%09XP1_MULTIPOINT_CONTROL_PLANE = 0x00000800%0A%09XP1_MULTIPOINT_DATA_PLANE    = 0x00001000%0A%09XP1_QOS_SUPPORTED            = 0x00002000%0A%09XP1_UNI_SEND                 = 0x00008000%0A%09XP1_UNI_RECV                 = 0x00010000%0A%09XP1_IFS_HANDLES              = 0x00020000%0A%09XP1_PARTIAL_MESSAGE          = 0x00040000%0A%09XP1_SAN_SUPPORT_SDP          = 0x00080000%0A%0A%09PFL_MULTIPLE_PROTO_ENTRIES  = 0x00000001%0A%09PFL_RECOMMENDED_PROTO_ENTRY = 0x00000002%0A%09PFL_HIDDEN                  = 0x00000004%0A%09PFL_MATCHES_PROTOCOL_ZERO   = 0x00000008%0A%09PFL_NETWORKDIRECT_PROVIDER  = 0x00000010%0A)%0A%0Atype WSAProtocolInfo struct %7B%0A%09ServiceFlags1     uint32%0A%09ServiceFlags2     uint32%0A%09ServiceFlags3     uint32%0A%09ServiceFlags4     uint32%0A%09ProviderFlags     uint32%0A%09ProviderId        GUID%0A%09CatalogEntryId    uint32%0A%09ProtocolChain     WSAProtocolChain%0A%09Version           int32%0A%09AddressFamily     int32%0A%09MaxSockAddr       int32%0A%09MinSockAddr       int32%0A%09SocketType        int32%0A%09Protocol          int32%0A%09ProtocolMaxOffset int32%0A%09NetworkByteOrder  int32%0A%09SecurityScheme    int32%0A%09MessageSize       uint32%0A%09ProviderReserved  uint32%0A%09ProtocolName      %5BWSAPROTOCOL_LEN + 1%5Duint16%0A%7D%0A%0Atype WSAProtocolChain struct %7B%0A%09ChainLen     int32%0A%09ChainEntries %5BMAX_PROTOCOL_CHAIN%5Duint32%0A%7D%0A%0Atype TCPKeepalive struct %7B%0A%09OnOff    uint32%0A%09Time     uint32%0A%09Interval uint32%0A%7D%0A%0Atype symbolicLinkReparseBuffer struct %7B%0A%09SubstituteNameOffset uint16%0A%09SubstituteNameLength uint16%0A%09PrintNameOffset      uint16%0A%09PrintNameLength      uint16%0A%09Flags                uint32%0A%09PathBuffer           %5B1%5Duint16%0A%7D%0A%0Atype mountPointReparseBuffer struct %7B%0A%09SubstituteNameOffset uint16%0A%09SubstituteNameLength uint16%0A%09PrintNameOffset      uint16%0A%09PrintNameLength      uint16%0A%09PathBuffer           %5B1%5Duint16%0A%7D%0A%0Atype reparseDataBuffer struct %7B%0A%09ReparseTag        uint32%0A%09ReparseDataLength uint16%0A%09Reserved          uint16%0A%0A%09// GenericReparseBuffer%0A%09reparseBuffer byte%0A%7D%0A%0Aconst (%0A%09FSCTL_GET_REPARSE_POINT          = 0x900A8%0A%09MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 16 * 1024%0A%09IO_REPARSE_TAG_MOUNT_POINT       = 0xA0000003%0A%09IO_REPARSE_TAG_SYMLINK           = 0xA000000C%0A%09SYMBOLIC_LINK_FLAG_DIRECTORY     = 0x1%0A)%0A%0Aconst (%0A%09ComputerNameNetBIOS                   = 0%0A%09ComputerNameDnsHostname               = 1%0A%09ComputerNameDnsDomain                 = 2%0A%09ComputerNameDnsFullyQualified         = 3%0A%09ComputerNamePhysicalNetBIOS           = 4%0A%09ComputerNamePhysicalDnsHostname       = 5%0A%09ComputerNamePhysicalDnsDomain         = 6%0A%09ComputerNamePhysicalDnsFullyQualified = 7%0A%09ComputerNameMax                       = 8%0A)%0A%0Aconst (%0A%09MOVEFILE_REPLACE_EXISTING      = 0x1%0A%09MOVEFILE_COPY_ALLOWED          = 0x2%0A%09MOVEFILE_DELAY_UNTIL_REBOOT    = 0x4%0A%09MOVEFILE_WRITE_THROUGH         = 0x8%0A%09MOVEFILE_CREATE_HARDLINK       = 0x10%0A%09MOVEFILE_FAIL_IF_NOT_TRACKABLE = 0x20%0A)%0A%0Aconst GAA_FLAG_INCLUDE_PREFIX = 0x00000010%0A%0Aconst (%0A%09IF_TYPE_OTHER              = 1%0A%09IF_TYPE_ETHERNET_CSMACD    = 6%0A%09IF_TYPE_ISO88025_TOKENRING = 9%0A%09IF_TYPE_PPP                = 23%0A%09IF_TYPE_SOFTWARE_LOOPBACK  = 24%0A%09IF_TYPE_ATM                = 37%0A%09IF_TYPE_IEEE80211          = 71%0A%09IF_TYPE_TUNNEL             = 131%0A%09IF_TYPE_IEEE1394           = 144%0A)%0A%0Atype SocketAddress struct %7B%0A%09Sockaddr       *syscall.RawSockaddrAny%0A%09SockaddrLength int32%0A%7D%0A%0Atype IpAdapterUnicastAddress struct %7B%0A%09Length             uint32%0A%09Flags              uint32%0A%09Next               *IpAdapterUnicastAddress%0A%09Address            SocketAddress%0A%09PrefixOrigin       int32%0A%09SuffixOrigin       int32%0A%09DadState           int32%0A%09ValidLifetime      uint32%0A%09PreferredLifetime  uint32%0A%09LeaseLifetime      uint32%0A%09OnLinkPrefixLength uint8%0A%7D%0A%0Atype IpAdapterAnycastAddress struct %7B%0A%09Length  uint32%0A%09Flags   uint32%0A%09Next    *IpAdapterAnycastAddress%0A%09Address SocketAddress%0A%7D%0A%0Atype IpAdapterMulticastAddress struct %7B%0A%09Length  uint32%0A%09Flags   uint32%0A%09Next    *IpAdapterMulticastAddress%0A%09Address SocketAddress%0A%7D%0A%0Atype IpAdapterDnsServerAdapter struct %7B%0A%09Length   uint32%0A%09Reserved uint32%0A%09Next     *IpAdapterDnsServerAdapter%0A%09Address  SocketAddress%0A%7D%0A%0Atype IpAdapterPrefix struct %7B%0A%09Length       uint32%0A%09Flags        uint32%0A%09Next         *IpAdapterPrefix%0A%09Address      SocketAddress%0A%09PrefixLength uint32%0A%7D%0A%0Atype IpAdapterAddresses struct %7B%0A%09Length                uint32%0A%09IfIndex               uint32%0A%09Next                  *IpAdapterAddresses%0A%09AdapterName           *byte%0A%09FirstUnicastAddress   *IpAdapterUnicastAddress%0A%09FirstAnycastAddress   *IpAdapterAnycastAddress%0A%09FirstMulticastAddress *IpAdapterMulticastAddress%0A%09FirstDnsServerAddress *IpAdapterDnsServerAdapter%0A%09DnsSuffix             *uint16%0A%09Description           *uint16%0A%09FriendlyName          *uint16%0A%09PhysicalAddress       %5Bsyscall.MAX_ADAPTER_ADDRESS_LENGTH%5Dbyte%0A%09PhysicalAddressLength uint32%0A%09Flags                 uint32%0A%09Mtu                   uint32%0A%09IfType                uint32%0A%09OperStatus            uint32%0A%09Ipv6IfIndex           uint32%0A%09ZoneIndices           %5B16%5Duint32%0A%09FirstPrefix           *IpAdapterPrefix%0A%09/* more fields might be present here. */%0A%7D%0A%0Aconst (%0A%09IfOperStatusUp             = 1%0A%09IfOperStatusDown           = 2%0A%09IfOperStatusTesting        = 3%0A%09IfOperStatusUnknown        = 4%0A%09IfOperStatusDormant        = 5%0A%09IfOperStatusNotPresent     = 6%0A%09IfOperStatusLowerLayerDown = 7%0A)%0A%0A// Console related constants used for the mode parameter to SetConsoleMode. See%0A// https://docs.microsoft.com/en-us/windows/console/setconsolemode for details.%0A%0Aconst (%0A%09ENABLE_PROCESSED_INPUT        = 0x1%0A%09ENABLE_LINE_INPUT             = 0x2%0A%09ENABLE_ECHO_INPUT             = 0x4%0A%09ENABLE_WINDOW_INPUT           = 0x8%0A%09ENABLE_MOUSE_INPUT            = 0x10%0A%09ENABLE_INSERT_MODE            = 0x20%0A%09ENABLE_QUICK_EDIT_MODE        = 0x40%0A%09ENABLE_EXTENDED_FLAGS         = 0x80%0A%09ENABLE_AUTO_POSITION          = 0x100%0A%09ENABLE_VIRTUAL_TERMINAL_INPUT = 0x200%0A%0A%09ENABLE_PROCESSED_OUTPUT            = 0x1%0A%09ENABLE_WRAP_AT_EOL_OUTPUT          = 0x2%0A%09ENABLE_VIRTUAL_TERMINAL_PROCESSING = 0x4%0A%09DISABLE_NEWLINE_AUTO_RETURN        = 0x8%0A%09ENABLE_LVB_GRID_WORLDWIDE          = 0x10%0A)%0A%0Atype Coord struct %7B%0A%09X int16%0A%09Y int16%0A%7D%0A%0Atype SmallRect struct %7B%0A%09Left   int16%0A%09Top    int16%0A%09Right  int16%0A%09Bottom int16%0A%7D%0A%0A// Used with GetConsoleScreenBuffer to retrieve information about a console%0A// screen buffer. See%0A// https://docs.microsoft.com/en-us/windows/console/console-screen-buffer-info-str%0A// for details.%0A%0Atype ConsoleScreenBufferInfo struct %7B%0A%09Size              Coord%0A%09CursorPosition    Coord%0A%09Attributes        uint16%0A%09Window            SmallRect%0A%09MaximumWindowSize Coord%0A%7D%0A%0Aconst UNIX_PATH_MAX = 108 // defined in afunix.h%0A
- f 35bfa1de8a87825e0db0adc8aa48b116be18d66a03bcc033445c8b2ed164ddaf vendor/golang.org/x/sys/windows/types_windows_386.go
+ f fba7c3ffd3cdaf0d535ac67df50b1225827c6f04a75334cbb2384ed1c3515b69 vendor/golang.org/x/sys/windows/types_windows_386.go
dmppatch 3
@@ -169,8 +169,309 @@
 windows%0A
+%0Atype WSAData struct %7B%0A%09Version      uint16%0A%09HighVersion  uint16%0A%09Description  %5BWSADESCRIPTION_LEN + 1%5Dbyte%0A%09SystemStatus %5BWSASYS_STATUS_LEN + 1%5Dbyte%0A%09MaxSockets   uint16%0A%09MaxUdpDg     uint16%0A%09VendorInfo   *byte%0A%7D%0A%0Atype Servent struct %7B%0A%09Name    *byte%0A%09Aliases **byte%0A%09Port    uint16%0A%09Proto   *byte%0A%7D%0A
- f 35bfa1de8a87825e0db0adc8aa48b116be18d66a03bcc033445c8b2ed164ddaf vendor/golang.org/x/sys/windows/types_windows_amd64.go
+ f 6ebf889bcbd4ef923625462e1514af19ffdad94e7659f7dbab7506cba112b69b vendor/golang.org/x/sys/windows/types_windows_amd64.go
dmppatch 3
@@ -169,8 +169,309 @@
 windows%0A
+%0Atype WSAData struct %7B%0A%09Version      uint16%0A%09HighVersion  uint16%0A%09MaxSockets   uint16%0A%09MaxUdpDg     uint16%0A%09VendorInfo   *byte%0A%09Description  %5BWSADESCRIPTION_LEN + 1%5Dbyte%0A%09SystemStatus %5BWSASYS_STATUS_LEN + 1%5Dbyte%0A%7D%0A%0Atype Servent struct %7B%0A%09Name    *byte%0A%09Aliases **byte%0A%09Proto   *byte%0A%09Port    uint16%0A%7D%0A
+ f 6ac145a95a50eb1ddbb6bd4313b3e506634266c5ce698a7fb189e3ca39f0c712 vendor/golang.org/x/sys/windows/types_windows_arm.go
dmppatch 2
@@ -0,0 +1,477 @@
+// Copyright 2018 The Go Authors. All rights reserved.%0A// Use of this source code is governed by a BSD-style%0A// license that can be found in the LICENSE file.%0A%0Apackage windows%0A%0Atype WSAData struct %7B%0A%09Version      uint16%0A%09HighVersion  uint16%0A%09Description  %5BWSADESCRIPTION_LEN + 1%5Dbyte%0A%09SystemStatus %5BWSASYS_STATUS_LEN + 1%5Dbyte%0A%09MaxSockets   uint16%0A%09MaxUdpDg     uint16%0A%09VendorInfo   *byte%0A%7D%0A%0Atype Servent struct %7B%0A%09Name    *byte%0A%09Aliases **byte%0A%09Port    uint16%0A%09Proto   *byte%0A%7D%0A
- f 0876f5fc883cf56a1591e5aec36f4c45a1b303d5589392dd5e4896499987b0f8 vendor/golang.org/x/sys/windows/zsyscall_windows.go
+ f 3ce9ab48aced222411dc83f7d17b3d4265c8a1526dc504b7a79b0f7d03bf0995 vendor/golang.org/x/sys/windows/zsyscall_windows.go
dmppatch 3
@@ -59,8 +59,90869 @@
 windows%0A
+%0Aimport (%0A%09%22syscall%22%0A%09%22unsafe%22%0A)%0A%0Avar _ unsafe.Pointer%0A%0A// Do the interface allocations only once for common%0A// Errno values.%0Aconst (%0A%09errnoERROR_IO_PENDING = 997%0A)%0A%0Avar (%0A%09errERROR_IO_PENDING error = syscall.Errno(errnoERROR_IO_PENDING)%0A)%0A%0A// errnoErr returns common boxed Errno values, to prevent%0A// allocations at runtime.%0Afunc errnoErr(e syscall.Errno) error %7B%0A%09switch e %7B%0A%09case 0:%0A%09%09return nil%0A%09case errnoERROR_IO_PENDING:%0A%09%09return errERROR_IO_PENDING%0A%09%7D%0A%09// TODO: add more here, after collecting data on the common%0A%09// error values see on Windows. (perhaps when running%0A%09// all.bat?)%0A%09return e%0A%7D%0A%0Avar (%0A%09modadvapi32 = NewLazySystemDLL(%22advapi32.dll%22)%0A%09modkernel32 = NewLazySystemDLL(%22kernel32.dll%22)%0A%09modshell32  = NewLazySystemDLL(%22shell32.dll%22)%0A%09modmswsock  = NewLazySystemDLL(%22mswsock.dll%22)%0A%09modcrypt32  = NewLazySystemDLL(%22crypt32.dll%22)%0A%09modws2_32   = NewLazySystemDLL(%22ws2_32.dll%22)%0A%09moddnsapi   = NewLazySystemDLL(%22dnsapi.dll%22)%0A%09modiphlpapi = NewLazySystemDLL(%22iphlpapi.dll%22)%0A%09modsecur32  = NewLazySystemDLL(%22secur32.dll%22)%0A%09modnetapi32 = NewLazySystemDLL(%22netapi32.dll%22)%0A%09moduserenv  = NewLazySystemDLL(%22userenv.dll%22)%0A%0A%09procRegisterEventSourceW               = modadvapi32.NewProc(%22RegisterEventSourceW%22)%0A%09procDeregisterEventSource              = modadvapi32.NewProc(%22DeregisterEventSource%22)%0A%09procReportEventW                       = modadvapi32.NewProc(%22ReportEventW%22)%0A%09procOpenSCManagerW                     = modadvapi32.NewProc(%22OpenSCManagerW%22)%0A%09procCloseServiceHandle                 = modadvapi32.NewProc(%22CloseServiceHandle%22)%0A%09procCreateServiceW                     = modadvapi32.NewProc(%22CreateServiceW%22)%0A%09procOpenServiceW                       = modadvapi32.NewProc(%22OpenServiceW%22)%0A%09procDeleteService                      = modadvapi32.NewProc(%22DeleteService%22)%0A%09procStartServiceW                      = modadvapi32.NewProc(%22StartServiceW%22)%0A%09procQueryServiceStatus                 = modadvapi32.NewProc(%22QueryServiceStatus%22)%0A%09procControlService                     = modadvapi32.NewProc(%22ControlService%22)%0A%09procStartServiceCtrlDispatcherW        = modadvapi32.NewProc(%22StartServiceCtrlDispatcherW%22)%0A%09procSetServiceStatus                   = modadvapi32.NewProc(%22SetServiceStatus%22)%0A%09procChangeServiceConfigW               = modadvapi32.NewProc(%22ChangeServiceConfigW%22)%0A%09procQueryServiceConfigW                = modadvapi32.NewProc(%22QueryServiceConfigW%22)%0A%09procChangeServiceConfig2W              = modadvapi32.NewProc(%22ChangeServiceConfig2W%22)%0A%09procQueryServiceConfig2W               = modadvapi32.NewProc(%22QueryServiceConfig2W%22)%0A%09procEnumServicesStatusExW              = modadvapi32.NewProc(%22EnumServicesStatusExW%22)%0A%09procQueryServiceStatusEx               = modadvapi32.NewProc(%22QueryServiceStatusEx%22)%0A%09procGetLastError                       = modkernel32.NewProc(%22GetLastError%22)%0A%09procLoadLibraryW                       = modkernel32.NewProc(%22LoadLibraryW%22)%0A%09procLoadLibraryExW                     = modkernel32.NewProc(%22LoadLibraryExW%22)%0A%09procFreeLibrary                        = modkernel32.NewProc(%22FreeLibrary%22)%0A%09procGetProcAddress                     = modkernel32.NewProc(%22GetProcAddress%22)%0A%09procGetVersion                         = modkernel32.NewProc(%22GetVersion%22)%0A%09procFormatMessageW                     = modkernel32.NewProc(%22FormatMessageW%22)%0A%09procExitProcess                        = modkernel32.NewProc(%22ExitProcess%22)%0A%09procCreateFileW                        = modkernel32.NewProc(%22CreateFileW%22)%0A%09procReadFile                           = modkernel32.NewProc(%22ReadFile%22)%0A%09procWriteFile                          = modkernel32.NewProc(%22WriteFile%22)%0A%09procSetFilePointer                     = modkernel32.NewProc(%22SetFilePointer%22)%0A%09procCloseHandle                        = modkernel32.NewProc(%22CloseHandle%22)%0A%09procGetStdHandle                       = modkernel32.NewProc(%22GetStdHandle%22)%0A%09procSetStdHandle                       = modkernel32.NewProc(%22SetStdHandle%22)%0A%09procFindFirstFileW                     = modkernel32.NewProc(%22FindFirstFileW%22)%0A%09procFindNextFileW                      = modkernel32.NewProc(%22FindNextFileW%22)%0A%09procFindClose                          = modkernel32.NewProc(%22FindClose%22)%0A%09procGetFileInformationByHandle         = modkernel32.NewProc(%22GetFileInformationByHandle%22)%0A%09procGetCurrentDirectoryW               = modkernel32.NewProc(%22GetCurrentDirectoryW%22)%0A%09procSetCurrentDirectoryW               = modkernel32.NewProc(%22SetCurrentDirectoryW%22)%0A%09procCreateDirectoryW                   = modkernel32.NewProc(%22CreateDirectoryW%22)%0A%09procRemoveDirectoryW                   = modkernel32.NewProc(%22RemoveDirectoryW%22)%0A%09procDeleteFileW                        = modkernel32.NewProc(%22DeleteFileW%22)%0A%09procMoveFileW                          = modkernel32.NewProc(%22MoveFileW%22)%0A%09procMoveFileExW                        = modkernel32.NewProc(%22MoveFileExW%22)%0A%09procGetComputerNameW                   = modkernel32.NewProc(%22GetComputerNameW%22)%0A%09procGetComputerNameExW                 = modkernel32.NewProc(%22GetComputerNameExW%22)%0A%09procSetEndOfFile                       = modkernel32.NewProc(%22SetEndOfFile%22)%0A%09procGetSystemTimeAsFileTime            = modkernel32.NewProc(%22GetSystemTimeAsFileTime%22)%0A%09procGetSystemTimePreciseAsFileTime     = modkernel32.NewProc(%22GetSystemTimePreciseAsFileTime%22)%0A%09procGetTimeZoneInformation             = modkernel32.NewProc(%22GetTimeZoneInformation%22)%0A%09procCreateIoCompletionPort             = modkernel32.NewProc(%22CreateIoCompletionPort%22)%0A%09procGetQueuedCompletionStatus          = modkernel32.NewProc(%22GetQueuedCompletionStatus%22)%0A%09procPostQueuedCompletionStatus         = modkernel32.NewProc(%22PostQueuedCompletionStatus%22)%0A%09procCancelIo                           = modkernel32.NewProc(%22CancelIo%22)%0A%09procCancelIoEx                         = modkernel32.NewProc(%22CancelIoEx%22)%0A%09procCreateProcessW                     = modkernel32.NewProc(%22CreateProcessW%22)%0A%09procOpenProcess                        = modkernel32.NewProc(%22OpenProcess%22)%0A%09procTerminateProcess                   = modkernel32.NewProc(%22TerminateProcess%22)%0A%09procGetExitCodeProcess                 = modkernel32.NewProc(%22GetExitCodeProcess%22)%0A%09procGetStartupInfoW                    = modkernel32.NewProc(%22GetStartupInfoW%22)%0A%09procGetCurrentProcess                  = modkernel32.NewProc(%22GetCurrentProcess%22)%0A%09procGetProcessTimes                    = modkernel32.NewProc(%22GetProcessTimes%22)%0A%09procDuplicateHandle                    = modkernel32.NewProc(%22DuplicateHandle%22)%0A%09procWaitForSingleObject                = modkernel32.NewProc(%22WaitForSingleObject%22)%0A%09procGetTempPathW                       = modkernel32.NewProc(%22GetTempPathW%22)%0A%09procCreatePipe                         = modkernel32.NewProc(%22CreatePipe%22)%0A%09procGetFileType                        = modkernel32.NewProc(%22GetFileType%22)%0A%09procCryptAcquireContextW               = modadvapi32.NewProc(%22CryptAcquireContextW%22)%0A%09procCryptReleaseContext                = modadvapi32.NewProc(%22CryptReleaseContext%22)%0A%09procCryptGenRandom                     = modadvapi32.NewProc(%22CryptGenRandom%22)%0A%09procGetEnvironmentStringsW             = modkernel32.NewProc(%22GetEnvironmentStringsW%22)%0A%09procFreeEnvironmentStringsW            = modkernel32.NewProc(%22FreeEnvironmentStringsW%22)%0A%09procGetEnvironmentVariableW            = modkernel32.NewProc(%22GetEnvironmentVariableW%22)%0A%09procSetEnvironmentVariableW            = modkernel32.NewProc(%22SetEnvironmentVariableW%22)%0A%09procSetFileTime                        = modkernel32.NewProc(%22SetFileTime%22)%0A%09procGetFileAttributesW                 = modkernel32.NewProc(%22GetFileAttributesW%22)%0A%09procSetFileAttributesW                 = modkernel32.NewProc(%22SetFileAttributesW%22)%0A%09procGetFileAttributesExW               = modkernel32.NewProc(%22GetFileAttributesExW%22)%0A%09procGetCommandLineW                    = modkernel32.NewProc(%22GetCommandLineW%22)%0A%09procCommandLineToArgvW                 = modshell32.NewProc(%22CommandLineToArgvW%22)%0A%09procLocalFree                          = modkernel32.NewProc(%22LocalFree%22)%0A%09procSetHandleInformation               = modkernel32.NewProc(%22SetHandleInformation%22)%0A%09procFlushFileBuffers                   = modkernel32.NewProc(%22FlushFileBuffers%22)%0A%09procGetFullPathNameW                   = modkernel32.NewProc(%22GetFullPathNameW%22)%0A%09procGetLongPathNameW                   = modkernel32.NewProc(%22GetLongPathNameW%22)%0A%09procGetShortPathNameW                  = modkernel32.NewProc(%22GetShortPathNameW%22)%0A%09procCreateFileMappingW                 = modkernel32.NewProc(%22CreateFileMappingW%22)%0A%09procMapViewOfFile                      = modkernel32.NewProc(%22MapViewOfFile%22)%0A%09procUnmapViewOfFile                    = modkernel32.NewProc(%22UnmapViewOfFile%22)%0A%09procFlushViewOfFile                    = modkernel32.NewProc(%22FlushViewOfFile%22)%0A%09procVirtualLock                        = modkernel32.NewProc(%22VirtualLock%22)%0A%09procVirtualUnlock                      = modkernel32.NewProc(%22VirtualUnlock%22)%0A%09procVirtualAlloc                       = modkernel32.NewProc(%22VirtualAlloc%22)%0A%09procVirtualFree                        = modkernel32.NewProc(%22VirtualFree%22)%0A%09procVirtualProtect                     = modkernel32.NewProc(%22VirtualProtect%22)%0A%09procTransmitFile                       = modmswsock.NewProc(%22TransmitFile%22)%0A%09procReadDirectoryChangesW              = modkernel32.NewProc(%22ReadDirectoryChangesW%22)%0A%09procCertOpenSystemStoreW               = modcrypt32.NewProc(%22CertOpenSystemStoreW%22)%0A%09procCertOpenStore                      = modcrypt32.NewProc(%22CertOpenStore%22)%0A%09procCertEnumCertificatesInStore        = modcrypt32.NewProc(%22CertEnumCertificatesInStore%22)%0A%09procCertAddCertificateContextToStore   = modcrypt32.NewProc(%22CertAddCertificateContextToStore%22)%0A%09procCertCloseStore                     = modcrypt32.NewProc(%22CertCloseStore%22)%0A%09procCertGetCertificateChain            = modcrypt32.NewProc(%22CertGetCertificateChain%22)%0A%09procCertFreeCertificateChain           = modcrypt32.NewProc(%22CertFreeCertificateChain%22)%0A%09procCertCreateCertificateContext       = modcrypt32.NewProc(%22CertCreateCertificateContext%22)%0A%09procCertFreeCertificateContext         = modcrypt32.NewProc(%22CertFreeCertificateContext%22)%0A%09procCertVerifyCertificateChainPolicy   = modcrypt32.NewProc(%22CertVerifyCertificateChainPolicy%22)%0A%09procRegOpenKeyExW                      = modadvapi32.NewProc(%22RegOpenKeyExW%22)%0A%09procRegCloseKey                        = modadvapi32.NewProc(%22RegCloseKey%22)%0A%09procRegQueryInfoKeyW                   = modadvapi32.NewProc(%22RegQueryInfoKeyW%22)%0A%09procRegEnumKeyExW                      = modadvapi32.NewProc(%22RegEnumKeyExW%22)%0A%09procRegQueryValueExW                   = modadvapi32.NewProc(%22RegQueryValueExW%22)%0A%09procGetCurrentProcessId                = modkernel32.NewProc(%22GetCurrentProcessId%22)%0A%09procGetConsoleMode                     = modkernel32.NewProc(%22GetConsoleMode%22)%0A%09procSetConsoleMode                     = modkernel32.NewProc(%22SetConsoleMode%22)%0A%09procGetConsoleScreenBufferInfo         = modkernel32.NewProc(%22GetConsoleScreenBufferInfo%22)%0A%09procWriteConsoleW                      = modkernel32.NewProc(%22WriteConsoleW%22)%0A%09procReadConsoleW                       = modkernel32.NewProc(%22ReadConsoleW%22)%0A%09procCreateToolhelp32Snapshot           = modkernel32.NewProc(%22CreateToolhelp32Snapshot%22)%0A%09procProcess32FirstW                    = modkernel32.NewProc(%22Process32FirstW%22)%0A%09procProcess32NextW                     = modkernel32.NewProc(%22Process32NextW%22)%0A%09procDeviceIoControl                    = modkernel32.NewProc(%22DeviceIoControl%22)%0A%09procCreateSymbolicLinkW                = modkernel32.NewProc(%22CreateSymbolicLinkW%22)%0A%09procCreateHardLinkW                    = modkernel32.NewProc(%22CreateHardLinkW%22)%0A%09procGetCurrentThreadId                 = modkernel32.NewProc(%22GetCurrentThreadId%22)%0A%09procCreateEventW                       = modkernel32.NewProc(%22CreateEventW%22)%0A%09procCreateEventExW                     = modkernel32.NewProc(%22CreateEventExW%22)%0A%09procOpenEventW                         = modkernel32.NewProc(%22OpenEventW%22)%0A%09procSetEvent                           = modkernel32.NewProc(%22SetEvent%22)%0A%09procResetEvent                         = modkernel32.NewProc(%22ResetEvent%22)%0A%09procPulseEvent                         = modkernel32.NewProc(%22PulseEvent%22)%0A%09procDefineDosDeviceW                   = modkernel32.NewProc(%22DefineDosDeviceW%22)%0A%09procDeleteVolumeMountPointW            = modkernel32.NewProc(%22DeleteVolumeMountPointW%22)%0A%09procFindFirstVolumeW                   = modkernel32.NewProc(%22FindFirstVolumeW%22)%0A%09procFindFirstVolumeMountPointW         = modkernel32.NewProc(%22FindFirstVolumeMountPointW%22)%0A%09procFindNextVolumeW                    = modkernel32.NewProc(%22FindNextVolumeW%22)%0A%09procFindNextVolumeMountPointW          = modkernel32.NewProc(%22FindNextVolumeMountPointW%22)%0A%09procFindVolumeClose                    = modkernel32.NewProc(%22FindVolumeClose%22)%0A%09procFindVolumeMountPointClose          = modkernel32.NewProc(%22FindVolumeMountPointClose%22)%0A%09procGetDriveTypeW                      = modkernel32.NewProc(%22GetDriveTypeW%22)%0A%09procGetLogicalDrives                   = modkernel32.NewProc(%22GetLogicalDrives%22)%0A%09procGetLogicalDriveStringsW            = modkernel32.NewProc(%22GetLogicalDriveStringsW%22)%0A%09procGetVolumeInformationW              = modkernel32.NewProc(%22GetVolumeInformationW%22)%0A%09procGetVolumeInformationByHandleW      = modkernel32.NewProc(%22GetVolumeInformationByHandleW%22)%0A%09procGetVolumeNameForVolumeMountPointW  = modkernel32.NewProc(%22GetVolumeNameForVolumeMountPointW%22)%0A%09procGetVolumePathNameW                 = modkernel32.NewProc(%22GetVolumePathNameW%22)%0A%09procGetVolumePathNamesForVolumeNameW   = modkernel32.NewProc(%22GetVolumePathNamesForVolumeNameW%22)%0A%09procQueryDosDeviceW                    = modkernel32.NewProc(%22QueryDosDeviceW%22)%0A%09procSetVolumeLabelW                    = modkernel32.NewProc(%22SetVolumeLabelW%22)%0A%09procSetVolumeMountPointW               = modkernel32.NewProc(%22SetVolumeMountPointW%22)%0A%09procWSAStartup                         = modws2_32.NewProc(%22WSAStartup%22)%0A%09procWSACleanup                         = modws2_32.NewProc(%22WSACleanup%22)%0A%09procWSAIoctl                           = modws2_32.NewProc(%22WSAIoctl%22)%0A%09procsocket                             = modws2_32.NewProc(%22socket%22)%0A%09procsetsockopt                         = modws2_32.NewProc(%22setsockopt%22)%0A%09procgetsockopt                         = modws2_32.NewProc(%22getsockopt%22)%0A%09procbind                               = modws2_32.NewProc(%22bind%22)%0A%09procconnect                            = modws2_32.NewProc(%22connect%22)%0A%09procgetsockname                        = modws2_32.NewProc(%22getsockname%22)%0A%09procgetpeername                        = modws2_32.NewProc(%22getpeername%22)%0A%09proclisten                             = modws2_32.NewProc(%22listen%22)%0A%09procshutdown                           = modws2_32.NewProc(%22shutdown%22)%0A%09procclosesocket                        = modws2_32.NewProc(%22closesocket%22)%0A%09procAcceptEx                           = modmswsock.NewProc(%22AcceptEx%22)%0A%09procGetAcceptExSockaddrs               = modmswsock.NewProc(%22GetAcceptExSockaddrs%22)%0A%09procWSARecv                            = modws2_32.NewProc(%22WSARecv%22)%0A%09procWSASend                            = modws2_32.NewProc(%22WSASend%22)%0A%09procWSARecvFrom                        = modws2_32.NewProc(%22WSARecvFrom%22)%0A%09procWSASendTo                          = modws2_32.NewProc(%22WSASendTo%22)%0A%09procgethostbyname                      = modws2_32.NewProc(%22gethostbyname%22)%0A%09procgetservbyname                      = modws2_32.NewProc(%22getservbyname%22)%0A%09procntohs                              = modws2_32.NewProc(%22ntohs%22)%0A%09procgetprotobyname                     = modws2_32.NewProc(%22getprotobyname%22)%0A%09procDnsQuery_W                         = moddnsapi.NewProc(%22DnsQuery_W%22)%0A%09procDnsRecordListFree                  = moddnsapi.NewProc(%22DnsRecordListFree%22)%0A%09procDnsNameCompare_W                   = moddnsapi.NewProc(%22DnsNameCompare_W%22)%0A%09procGetAddrInfoW                       = modws2_32.NewProc(%22GetAddrInfoW%22)%0A%09procFreeAddrInfoW                      = modws2_32.NewProc(%22FreeAddrInfoW%22)%0A%09procGetIfEntry                         = modiphlpapi.NewProc(%22GetIfEntry%22)%0A%09procGetAdaptersInfo                    = modiphlpapi.NewProc(%22GetAdaptersInfo%22)%0A%09procSetFileCompletionNotificationModes = modkernel32.NewProc(%22SetFileCompletionNotificationModes%22)%0A%09procWSAEnumProtocolsW                  = modws2_32.NewProc(%22WSAEnumProtocolsW%22)%0A%09procGetAdaptersAddresses               = modiphlpapi.NewProc(%22GetAdaptersAddresses%22)%0A%09procGetACP                             = modkernel32.NewProc(%22GetACP%22)%0A%09procMultiByteToWideChar                = modkernel32.NewProc(%22MultiByteToWideChar%22)%0A%09procTranslateNameW                     = modsecur32.NewProc(%22TranslateNameW%22)%0A%09procGetUserNameExW                     = modsecur32.NewProc(%22GetUserNameExW%22)%0A%09procNetUserGetInfo                     = modnetapi32.NewProc(%22NetUserGetInfo%22)%0A%09procNetGetJoinInformation              = modnetapi32.NewProc(%22NetGetJoinInformation%22)%0A%09procNetApiBufferFree                   = modnetapi32.NewProc(%22NetApiBufferFree%22)%0A%09procLookupAccountSidW                  = modadvapi32.NewProc(%22LookupAccountSidW%22)%0A%09procLookupAccountNameW                 = modadvapi32.NewProc(%22LookupAccountNameW%22)%0A%09procConvertSidToStringSidW             = modadvapi32.NewProc(%22ConvertSidToStringSidW%22)%0A%09procConvertStringSidToSidW             = modadvapi32.NewProc(%22ConvertStringSidToSidW%22)%0A%09procGetLengthSid                       = modadvapi32.NewProc(%22GetLengthSid%22)%0A%09procCopySid                            = modadvapi32.NewProc(%22CopySid%22)%0A%09procAllocateAndInitializeSid           = modadvapi32.NewProc(%22AllocateAndInitializeSid%22)%0A%09procFreeSid                            = modadvapi32.NewProc(%22FreeSid%22)%0A%09procEqualSid                           = modadvapi32.NewProc(%22EqualSid%22)%0A%09procCheckTokenMembership               = modadvapi32.NewProc(%22CheckTokenMembership%22)%0A%09procOpenProcessToken                   = modadvapi32.NewProc(%22OpenProcessToken%22)%0A%09procGetTokenInformation                = modadvapi32.NewProc(%22GetTokenInformation%22)%0A%09procGetUserProfileDirectoryW           = moduserenv.NewProc(%22GetUserProfileDirectoryW%22)%0A)%0A%0Afunc RegisterEventSource(uncServerName *uint16, sourceName *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procRegisterEventSourceW.Addr(), 2, uintptr(unsafe.Pointer(uncServerName)), uintptr(unsafe.Pointer(sourceName)), 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeregisterEventSource(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDeregisterEventSource.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ReportEvent(log Handle, etype uint16, category uint16, eventId uint32, usrSId uintptr, numStrings uint16, dataSize uint32, strings **uint16, rawData *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procReportEventW.Addr(), 9, uintptr(log), uintptr(etype), uintptr(category), uintptr(eventId), uintptr(usrSId), uintptr(numStrings), uintptr(dataSize), uintptr(unsafe.Pointer(strings)), uintptr(unsafe.Pointer(rawData)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenSCManager(machineName *uint16, databaseName *uint16, access uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procOpenSCManagerW.Addr(), 3, uintptr(unsafe.Pointer(machineName)), uintptr(unsafe.Pointer(databaseName)), uintptr(access))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CloseServiceHandle(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCloseServiceHandle.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateService(mgr Handle, serviceName *uint16, displayName *uint16, access uint32, srvType uint32, startType uint32, errCtl uint32, pathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall15(procCreateServiceW.Addr(), 13, uintptr(mgr), uintptr(unsafe.Pointer(serviceName)), uintptr(unsafe.Pointer(displayName)), uintptr(access), uintptr(srvType), uintptr(startType), uintptr(errCtl), uintptr(unsafe.Pointer(pathName)), uintptr(unsafe.Pointer(loadOrderGroup)), uintptr(unsafe.Pointer(tagId)), uintptr(unsafe.Pointer(dependencies)), uintptr(unsafe.Pointer(serviceStartName)), uintptr(unsafe.Pointer(password)), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenService(mgr Handle, serviceName *uint16, access uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procOpenServiceW.Addr(), 3, uintptr(mgr), uintptr(unsafe.Pointer(serviceName)), uintptr(access))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeleteService(service Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDeleteService.Addr(), 1, uintptr(service), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc StartService(service Handle, numArgs uint32, argVectors **uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procStartServiceW.Addr(), 3, uintptr(service), uintptr(numArgs), uintptr(unsafe.Pointer(argVectors)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc QueryServiceStatus(service Handle, status *SERVICE_STATUS) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procQueryServiceStatus.Addr(), 2, uintptr(service), uintptr(unsafe.Pointer(status)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ControlService(service Handle, control uint32, status *SERVICE_STATUS) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procControlService.Addr(), 3, uintptr(service), uintptr(control), uintptr(unsafe.Pointer(status)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc StartServiceCtrlDispatcher(serviceTable *SERVICE_TABLE_ENTRY) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procStartServiceCtrlDispatcherW.Addr(), 1, uintptr(unsafe.Pointer(serviceTable)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetServiceStatus(service Handle, serviceStatus *SERVICE_STATUS) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetServiceStatus.Addr(), 2, uintptr(service), uintptr(unsafe.Pointer(serviceStatus)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ChangeServiceConfig(service Handle, serviceType uint32, startType uint32, errorControl uint32, binaryPathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16, displayName *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall12(procChangeServiceConfigW.Addr(), 11, uintptr(service), uintptr(serviceType), uintptr(startType), uintptr(errorControl), uintptr(unsafe.Pointer(binaryPathName)), uintptr(unsafe.Pointer(loadOrderGroup)), uintptr(unsafe.Pointer(tagId)), uintptr(unsafe.Pointer(dependencies)), uintptr(unsafe.Pointer(serviceStartName)), uintptr(unsafe.Pointer(password)), uintptr(unsafe.Pointer(displayName)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc QueryServiceConfig(service Handle, serviceConfig *QUERY_SERVICE_CONFIG, bufSize uint32, bytesNeeded *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procQueryServiceConfigW.Addr(), 4, uintptr(service), uintptr(unsafe.Pointer(serviceConfig)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ChangeServiceConfig2(service Handle, infoLevel uint32, info *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procChangeServiceConfig2W.Addr(), 3, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(info)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc QueryServiceConfig2(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procQueryServiceConfig2W.Addr(), 5, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(buff)), uintptr(buffSize), uintptr(unsafe.Pointer(bytesNeeded)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc EnumServicesStatusEx(mgr Handle, infoLevel uint32, serviceType uint32, serviceState uint32, services *byte, bufSize uint32, bytesNeeded *uint32, servicesReturned *uint32, resumeHandle *uint32, groupName *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall12(procEnumServicesStatusExW.Addr(), 10, uintptr(mgr), uintptr(infoLevel), uintptr(serviceType), uintptr(serviceState), uintptr(unsafe.Pointer(services)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), uintptr(unsafe.Pointer(servicesReturned)), uintptr(unsafe.Pointer(resumeHandle)), uintptr(unsafe.Pointer(groupName)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc QueryServiceStatusEx(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procQueryServiceStatusEx.Addr(), 5, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(buff)), uintptr(buffSize), uintptr(unsafe.Pointer(bytesNeeded)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetLastError() (lasterr error) %7B%0A%09r0, _, _ := syscall.Syscall(procGetLastError.Addr(), 0, 0, 0, 0)%0A%09if r0 != 0 %7B%0A%09%09lasterr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LoadLibrary(libname string) (handle Handle, err error) %7B%0A%09var _p0 *uint16%0A%09_p0, err = syscall.UTF16PtrFromString(libname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _LoadLibrary(_p0)%0A%7D%0A%0Afunc _LoadLibrary(libname *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procLoadLibraryW.Addr(), 1, uintptr(unsafe.Pointer(libname)), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) %7B%0A%09var _p0 *uint16%0A%09_p0, err = syscall.UTF16PtrFromString(libname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _LoadLibraryEx(_p0, zero, flags)%0A%7D%0A%0Afunc _LoadLibraryEx(libname *uint16, zero Handle, flags uintptr) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procLoadLibraryExW.Addr(), 3, uintptr(unsafe.Pointer(libname)), uintptr(zero), uintptr(flags))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FreeLibrary(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFreeLibrary.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetProcAddress(module Handle, procname string) (proc uintptr, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = syscall.BytePtrFromString(procname)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _GetProcAddress(module, _p0)%0A%7D%0A%0Afunc _GetProcAddress(module Handle, procname *byte) (proc uintptr, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetProcAddress.Addr(), 2, uintptr(module), uintptr(unsafe.Pointer(procname)), 0)%0A%09proc = uintptr(r0)%0A%09if proc == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVersion() (ver uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetVersion.Addr(), 0, 0, 0, 0)%0A%09ver = uint32(r0)%0A%09if ver == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FormatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf %5B%5Duint16, args *byte) (n uint32, err error) %7B%0A%09var _p0 *uint16%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r0, _, e1 := syscall.Syscall9(procFormatMessageW.Addr(), 7, uintptr(flags), uintptr(msgsrc), uintptr(msgid), uintptr(langid), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(args)), 0, 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ExitProcess(exitcode uint32) %7B%0A%09syscall.Syscall(procExitProcess.Addr(), 1, uintptr(exitcode), 0, 0)%0A%09return%0A%7D%0A%0Afunc CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall9(procCreateFileW.Addr(), 7, uintptr(unsafe.Pointer(name)), uintptr(access), uintptr(mode), uintptr(unsafe.Pointer(sa)), uintptr(createmode), uintptr(attrs), uintptr(templatefile), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ReadFile(handle Handle, buf %5B%5Dbyte, done *uint32, overlapped *Overlapped) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall6(procReadFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WriteFile(handle Handle, buf %5B%5Dbyte, done *uint32, overlapped *Overlapped) (err error) %7B%0A%09var _p0 *byte%0A%09if len(buf) %3E 0 %7B%0A%09%09_p0 = &buf%5B0%5D%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall6(procWriteFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procSetFilePointer.Addr(), 4, uintptr(handle), uintptr(lowoffset), uintptr(unsafe.Pointer(highoffsetptr)), uintptr(whence), 0, 0)%0A%09newlowoffset = uint32(r0)%0A%09if newlowoffset == 0xffffffff %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CloseHandle(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCloseHandle.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetStdHandle(stdhandle uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetStdHandle.Addr(), 1, uintptr(stdhandle), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetStdHandle(stdhandle uint32, handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetStdHandle.Addr(), 2, uintptr(stdhandle), uintptr(handle), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procFindFirstFileW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(data)), 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc findNextFile1(handle Handle, data *win32finddata1) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindNextFileW.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindClose(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindClose.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetFileInformationByHandle.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetCurrentDirectoryW.Addr(), 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetCurrentDirectory(path *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetCurrentDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCreateDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(sa)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RemoveDirectory(path *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procRemoveDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeleteFile(path *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDeleteFileW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc MoveFile(from *uint16, to *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procMoveFileW.Addr(), 2, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc MoveFileEx(from *uint16, to *uint16, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procMoveFileExW.Addr(), 3, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), uintptr(flags))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetComputerName(buf *uint16, n *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetComputerNameW.Addr(), 2, uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetComputerNameExW.Addr(), 3, uintptr(nametype), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetEndOfFile(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetEndOfFile.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetSystemTimeAsFileTime(time *Filetime) %7B%0A%09syscall.Syscall(procGetSystemTimeAsFileTime.Addr(), 1, uintptr(unsafe.Pointer(time)), 0, 0)%0A%09return%0A%7D%0A%0Afunc GetSystemTimePreciseAsFileTime(time *Filetime) %7B%0A%09syscall.Syscall(procGetSystemTimePreciseAsFileTime.Addr(), 1, uintptr(unsafe.Pointer(time)), 0, 0)%0A%09return%0A%7D%0A%0Afunc GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetTimeZoneInformation.Addr(), 1, uintptr(unsafe.Pointer(tzi)), 0, 0)%0A%09rc = uint32(r0)%0A%09if rc == 0xffffffff %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uint32, threadcnt uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCreateIoCompletionPort.Addr(), 4, uintptr(filehandle), uintptr(cphandle), uintptr(key), uintptr(threadcnt), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uint32, overlapped **Overlapped, timeout uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procGetQueuedCompletionStatus.Addr(), 5, uintptr(cphandle), uintptr(unsafe.Pointer(qty)), uintptr(unsafe.Pointer(key)), uintptr(unsafe.Pointer(overlapped)), uintptr(timeout), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uint32, overlapped *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procPostQueuedCompletionStatus.Addr(), 4, uintptr(cphandle), uintptr(qty), uintptr(key), uintptr(unsafe.Pointer(overlapped)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CancelIo(s Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCancelIo.Addr(), 1, uintptr(s), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CancelIoEx(s Handle, o *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCancelIoEx.Addr(), 2, uintptr(s), uintptr(unsafe.Pointer(o)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) %7B%0A%09var _p0 uint32%0A%09if inheritHandles %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall12(procCreateProcessW.Addr(), 10, uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenProcess(da uint32, inheritHandle bool, pid uint32) (handle Handle, err error) %7B%0A%09var _p0 uint32%0A%09if inheritHandle %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r0, _, e1 := syscall.Syscall(procOpenProcess.Addr(), 3, uintptr(da), uintptr(_p0), uintptr(pid))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc TerminateProcess(handle Handle, exitcode uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procTerminateProcess.Addr(), 2, uintptr(handle), uintptr(exitcode), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetExitCodeProcess(handle Handle, exitcode *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetExitCodeProcess.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(exitcode)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetStartupInfo(startupInfo *StartupInfo) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetStartupInfoW.Addr(), 1, uintptr(unsafe.Pointer(startupInfo)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetCurrentProcess() (pseudoHandle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetCurrentProcess.Addr(), 0, 0, 0, 0)%0A%09pseudoHandle = Handle(r0)%0A%09if pseudoHandle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procGetProcessTimes.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(creationTime)), uintptr(unsafe.Pointer(exitTime)), uintptr(unsafe.Pointer(kernelTime)), uintptr(unsafe.Pointer(userTime)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error) %7B%0A%09var _p0 uint32%0A%09if bInheritHandle %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall9(procDuplicateHandle.Addr(), 7, uintptr(hSourceProcessHandle), uintptr(hSourceHandle), uintptr(hTargetProcessHandle), uintptr(unsafe.Pointer(lpTargetHandle)), uintptr(dwDesiredAccess), uintptr(_p0), uintptr(dwOptions), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procWaitForSingleObject.Addr(), 2, uintptr(handle), uintptr(waitMilliseconds), 0)%0A%09event = uint32(r0)%0A%09if event == 0xffffffff %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetTempPath(buflen uint32, buf *uint16) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetTempPathW.Addr(), 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procCreatePipe.Addr(), 4, uintptr(unsafe.Pointer(readhandle)), uintptr(unsafe.Pointer(writehandle)), uintptr(unsafe.Pointer(sa)), uintptr(size), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFileType(filehandle Handle) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetFileType.Addr(), 1, uintptr(filehandle), 0, 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procCryptAcquireContextW.Addr(), 5, uintptr(unsafe.Pointer(provhandle)), uintptr(unsafe.Pointer(container)), uintptr(unsafe.Pointer(provider)), uintptr(provtype), uintptr(flags), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CryptReleaseContext(provhandle Handle, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCryptReleaseContext.Addr(), 2, uintptr(provhandle), uintptr(flags), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCryptGenRandom.Addr(), 3, uintptr(provhandle), uintptr(buflen), uintptr(unsafe.Pointer(buf)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetEnvironmentStrings() (envs *uint16, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetEnvironmentStringsW.Addr(), 0, 0, 0, 0)%0A%09envs = (*uint16)(unsafe.Pointer(r0))%0A%09if envs == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FreeEnvironmentStrings(envs *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFreeEnvironmentStringsW.Addr(), 1, uintptr(unsafe.Pointer(envs)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetEnvironmentVariableW.Addr(), 3, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(buffer)), uintptr(size))%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetEnvironmentVariable(name *uint16, value *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetEnvironmentVariableW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(value)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procSetFileTime.Addr(), 4, uintptr(handle), uintptr(unsafe.Pointer(ctime)), uintptr(unsafe.Pointer(atime)), uintptr(unsafe.Pointer(wtime)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFileAttributes(name *uint16) (attrs uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetFileAttributesW.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)%0A%09attrs = uint32(r0)%0A%09if attrs == INVALID_FILE_ATTRIBUTES %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetFileAttributes(name *uint16, attrs uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetFileAttributesW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(attrs), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetFileAttributesExW.Addr(), 3, uintptr(unsafe.Pointer(name)), uintptr(level), uintptr(unsafe.Pointer(info)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetCommandLine() (cmd *uint16) %7B%0A%09r0, _, _ := syscall.Syscall(procGetCommandLineW.Addr(), 0, 0, 0, 0)%0A%09cmd = (*uint16)(unsafe.Pointer(r0))%0A%09return%0A%7D%0A%0Afunc CommandLineToArgv(cmd *uint16, argc *int32) (argv *%5B8192%5D*%5B8192%5Duint16, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCommandLineToArgvW.Addr(), 2, uintptr(unsafe.Pointer(cmd)), uintptr(unsafe.Pointer(argc)), 0)%0A%09argv = (*%5B8192%5D*%5B8192%5Duint16)(unsafe.Pointer(r0))%0A%09if argv == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LocalFree(hmem Handle) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procLocalFree.Addr(), 1, uintptr(hmem), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle != 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetHandleInformation(handle Handle, mask uint32, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetHandleInformation.Addr(), 3, uintptr(handle), uintptr(mask), uintptr(flags))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FlushFileBuffers(handle Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFlushFileBuffers.Addr(), 1, uintptr(handle), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procGetFullPathNameW.Addr(), 4, uintptr(unsafe.Pointer(path)), uintptr(buflen), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(fname)), 0, 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetLongPathNameW.Addr(), 3, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(buf)), uintptr(buflen))%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetShortPathNameW.Addr(), 3, uintptr(unsafe.Pointer(longpath)), uintptr(unsafe.Pointer(shortpath)), uintptr(buflen))%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCreateFileMappingW.Addr(), 6, uintptr(fhandle), uintptr(unsafe.Pointer(sa)), uintptr(prot), uintptr(maxSizeHigh), uintptr(maxSizeLow), uintptr(unsafe.Pointer(name)))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procMapViewOfFile.Addr(), 5, uintptr(handle), uintptr(access), uintptr(offsetHigh), uintptr(offsetLow), uintptr(length), 0)%0A%09addr = uintptr(r0)%0A%09if addr == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc UnmapViewOfFile(addr uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procUnmapViewOfFile.Addr(), 1, uintptr(addr), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FlushViewOfFile(addr uintptr, length uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFlushViewOfFile.Addr(), 2, uintptr(addr), uintptr(length), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualLock(addr uintptr, length uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procVirtualLock.Addr(), 2, uintptr(addr), uintptr(length), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualUnlock(addr uintptr, length uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procVirtualUnlock.Addr(), 2, uintptr(addr), uintptr(length), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualAlloc(address uintptr, size uintptr, alloctype uint32, protect uint32) (value uintptr, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procVirtualAlloc.Addr(), 4, uintptr(address), uintptr(size), uintptr(alloctype), uintptr(protect), 0, 0)%0A%09value = uintptr(r0)%0A%09if value == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualFree(address uintptr, size uintptr, freetype uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procVirtualFree.Addr(), 3, uintptr(address), uintptr(size), uintptr(freetype))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc VirtualProtect(address uintptr, size uintptr, newprotect uint32, oldprotect *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procVirtualProtect.Addr(), 4, uintptr(address), uintptr(size), uintptr(newprotect), uintptr(unsafe.Pointer(oldprotect)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc TransmitFile(s Handle, handle Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *Overlapped, transmitFileBuf *TransmitFileBuffers, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procTransmitFile.Addr(), 7, uintptr(s), uintptr(handle), uintptr(bytesToWrite), uintptr(bytsPerSend), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(transmitFileBuf)), uintptr(flags), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ReadDirectoryChanges(handle Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) %7B%0A%09var _p0 uint32%0A%09if watchSubTree %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r1, _, e1 := syscall.Syscall9(procReadDirectoryChangesW.Addr(), 8, uintptr(handle), uintptr(unsafe.Pointer(buf)), uintptr(buflen), uintptr(_p0), uintptr(mask), uintptr(unsafe.Pointer(retlen)), uintptr(unsafe.Pointer(overlapped)), uintptr(completionRoutine), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCertOpenSystemStoreW.Addr(), 2, uintptr(hprov), uintptr(unsafe.Pointer(name)), 0)%0A%09store = Handle(r0)%0A%09if store == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCertOpenStore.Addr(), 5, uintptr(storeProvider), uintptr(msgAndCertEncodingType), uintptr(cryptProv), uintptr(flags), uintptr(para), 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCertEnumCertificatesInStore.Addr(), 2, uintptr(store), uintptr(unsafe.Pointer(prevContext)), 0)%0A%09context = (*CertContext)(unsafe.Pointer(r0))%0A%09if context == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procCertAddCertificateContextToStore.Addr(), 4, uintptr(store), uintptr(unsafe.Pointer(certContext)), uintptr(addDisposition), uintptr(unsafe.Pointer(storeContext)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertCloseStore(store Handle, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCertCloseStore.Addr(), 2, uintptr(store), uintptr(flags), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procCertGetCertificateChain.Addr(), 8, uintptr(engine), uintptr(unsafe.Pointer(leaf)), uintptr(unsafe.Pointer(time)), uintptr(additionalStore), uintptr(unsafe.Pointer(para)), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(chainCtx)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertFreeCertificateChain(ctx *CertChainContext) %7B%0A%09syscall.Syscall(procCertFreeCertificateChain.Addr(), 1, uintptr(unsafe.Pointer(ctx)), 0, 0)%0A%09return%0A%7D%0A%0Afunc CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *CertContext, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCertCreateCertificateContext.Addr(), 3, uintptr(certEncodingType), uintptr(unsafe.Pointer(certEncoded)), uintptr(encodedLen))%0A%09context = (*CertContext)(unsafe.Pointer(r0))%0A%09if context == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertFreeCertificateContext(ctx *CertContext) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCertFreeCertificateContext.Addr(), 1, uintptr(unsafe.Pointer(ctx)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procCertVerifyCertificateChainPolicy.Addr(), 4, uintptr(policyOID), uintptr(unsafe.Pointer(chain)), uintptr(unsafe.Pointer(para)), uintptr(unsafe.Pointer(status)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall6(procRegOpenKeyExW.Addr(), 5, uintptr(key), uintptr(unsafe.Pointer(subkey)), uintptr(options), uintptr(desiredAccess), uintptr(unsafe.Pointer(result)), 0)%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegCloseKey(key Handle) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall(procRegCloseKey.Addr(), 1, uintptr(key), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall12(procRegQueryInfoKeyW.Addr(), 12, uintptr(key), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(subkeysLen)), uintptr(unsafe.Pointer(maxSubkeyLen)), uintptr(unsafe.Pointer(maxClassLen)), uintptr(unsafe.Pointer(valuesLen)), uintptr(unsafe.Pointer(maxValueNameLen)), uintptr(unsafe.Pointer(maxValueLen)), uintptr(unsafe.Pointer(saLen)), uintptr(unsafe.Pointer(lastWriteTime)))%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegEnumKeyEx(key Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *Filetime) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall9(procRegEnumKeyExW.Addr(), 8, uintptr(key), uintptr(index), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(lastWriteTime)), 0)%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc RegQueryValueEx(key Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) %7B%0A%09r0, _, _ := syscall.Syscall6(procRegQueryValueExW.Addr(), 6, uintptr(key), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(valtype)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(buflen)))%0A%09if r0 != 0 %7B%0A%09%09regerrno = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getCurrentProcessId() (pid uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetCurrentProcessId.Addr(), 0, 0, 0, 0)%0A%09pid = uint32(r0)%0A%09return%0A%7D%0A%0Afunc GetConsoleMode(console Handle, mode *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetConsoleMode.Addr(), 2, uintptr(console), uintptr(unsafe.Pointer(mode)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetConsoleMode(console Handle, mode uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetConsoleMode.Addr(), 2, uintptr(console), uintptr(mode), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetConsoleScreenBufferInfo(console Handle, info *ConsoleScreenBufferInfo) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetConsoleScreenBufferInfo.Addr(), 2, uintptr(console), uintptr(unsafe.Pointer(info)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WriteConsole(console Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procWriteConsoleW.Addr(), 5, uintptr(console), uintptr(unsafe.Pointer(buf)), uintptr(towrite), uintptr(unsafe.Pointer(written)), uintptr(unsafe.Pointer(reserved)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ReadConsole(console Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procReadConsoleW.Addr(), 5, uintptr(console), uintptr(unsafe.Pointer(buf)), uintptr(toread), uintptr(unsafe.Pointer(read)), uintptr(unsafe.Pointer(inputControl)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procCreateToolhelp32Snapshot.Addr(), 2, uintptr(flags), uintptr(processId), 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Process32First(snapshot Handle, procEntry *ProcessEntry32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procProcess32FirstW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(procEntry)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procProcess32NextW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(procEntry)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procDeviceIoControl.Addr(), 8, uintptr(handle), uintptr(ioControlCode), uintptr(unsafe.Pointer(inBuffer)), uintptr(inBufferSize), uintptr(unsafe.Pointer(outBuffer)), uintptr(outBufferSize), uintptr(unsafe.Pointer(bytesReturned)), uintptr(unsafe.Pointer(overlapped)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCreateSymbolicLinkW.Addr(), 3, uintptr(unsafe.Pointer(symlinkfilename)), uintptr(unsafe.Pointer(targetfilename)), uintptr(flags))%0A%09if r1&0xff == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCreateHardLinkW.Addr(), 3, uintptr(unsafe.Pointer(filename)), uintptr(unsafe.Pointer(existingfilename)), uintptr(reserved))%0A%09if r1&0xff == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetCurrentThreadId() (id uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetCurrentThreadId.Addr(), 0, 0, 0, 0)%0A%09id = uint32(r0)%0A%09return%0A%7D%0A%0Afunc CreateEvent(eventAttrs *SecurityAttributes, manualReset uint32, initialState uint32, name *uint16) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCreateEventW.Addr(), 4, uintptr(unsafe.Pointer(eventAttrs)), uintptr(manualReset), uintptr(initialState), uintptr(unsafe.Pointer(name)), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc CreateEventEx(eventAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procCreateEventExW.Addr(), 4, uintptr(unsafe.Pointer(eventAttrs)), uintptr(unsafe.Pointer(name)), uintptr(flags), uintptr(desiredAccess), 0, 0)%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenEvent(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) %7B%0A%09var _p0 uint32%0A%09if inheritHandle %7B%0A%09%09_p0 = 1%0A%09%7D else %7B%0A%09%09_p0 = 0%0A%09%7D%0A%09r0, _, e1 := syscall.Syscall(procOpenEventW.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(unsafe.Pointer(name)))%0A%09handle = Handle(r0)%0A%09if handle == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetEvent(event Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetEvent.Addr(), 1, uintptr(event), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ResetEvent(event Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procResetEvent.Addr(), 1, uintptr(event), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc PulseEvent(event Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procPulseEvent.Addr(), 1, uintptr(event), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DefineDosDevice(flags uint32, deviceName *uint16, targetPath *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDefineDosDeviceW.Addr(), 3, uintptr(flags), uintptr(unsafe.Pointer(deviceName)), uintptr(unsafe.Pointer(targetPath)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DeleteVolumeMountPoint(volumeMountPoint *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procDeleteVolumeMountPointW.Addr(), 1, uintptr(unsafe.Pointer(volumeMountPoint)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procFindFirstVolumeW.Addr(), 2, uintptr(unsafe.Pointer(volumeName)), uintptr(bufferLength), 0)%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindFirstVolumeMountPoint(rootPathName *uint16, volumeMountPoint *uint16, bufferLength uint32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procFindFirstVolumeMountPointW.Addr(), 3, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(bufferLength))%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindNextVolumeW.Addr(), 3, uintptr(findVolume), uintptr(unsafe.Pointer(volumeName)), uintptr(bufferLength))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindNextVolumeMountPointW.Addr(), 3, uintptr(findVolumeMountPoint), uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(bufferLength))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindVolumeClose(findVolume Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindVolumeClose.Addr(), 1, uintptr(findVolume), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FindVolumeMountPointClose(findVolumeMountPoint Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFindVolumeMountPointClose.Addr(), 1, uintptr(findVolumeMountPoint), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetDriveType(rootPathName *uint16) (driveType uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetDriveTypeW.Addr(), 1, uintptr(unsafe.Pointer(rootPathName)), 0, 0)%0A%09driveType = uint32(r0)%0A%09return%0A%7D%0A%0Afunc GetLogicalDrives() (drivesBitMask uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetLogicalDrives.Addr(), 0, 0, 0, 0)%0A%09drivesBitMask = uint32(r0)%0A%09if drivesBitMask == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetLogicalDriveStrings(bufferLength uint32, buffer *uint16) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procGetLogicalDriveStringsW.Addr(), 2, uintptr(bufferLength), uintptr(unsafe.Pointer(buffer)), 0)%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumeInformation(rootPathName *uint16, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procGetVolumeInformationW.Addr(), 8, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeNameBuffer)), uintptr(volumeNameSize), uintptr(unsafe.Pointer(volumeNameSerialNumber)), uintptr(unsafe.Pointer(maximumComponentLength)), uintptr(unsafe.Pointer(fileSystemFlags)), uintptr(unsafe.Pointer(fileSystemNameBuffer)), uintptr(fileSystemNameSize), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumeInformationByHandle(file Handle, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procGetVolumeInformationByHandleW.Addr(), 8, uintptr(file), uintptr(unsafe.Pointer(volumeNameBuffer)), uintptr(volumeNameSize), uintptr(unsafe.Pointer(volumeNameSerialNumber)), uintptr(unsafe.Pointer(maximumComponentLength)), uintptr(unsafe.Pointer(fileSystemFlags)), uintptr(unsafe.Pointer(fileSystemNameBuffer)), uintptr(fileSystemNameSize), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumeNameForVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16, bufferlength uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetVolumeNameForVolumeMountPointW.Addr(), 3, uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(unsafe.Pointer(volumeName)), uintptr(bufferlength))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumePathName(fileName *uint16, volumePathName *uint16, bufferLength uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetVolumePathNameW.Addr(), 3, uintptr(unsafe.Pointer(fileName)), uintptr(unsafe.Pointer(volumePathName)), uintptr(bufferLength))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procGetVolumePathNamesForVolumeNameW.Addr(), 4, uintptr(unsafe.Pointer(volumeName)), uintptr(unsafe.Pointer(volumePathNames)), uintptr(bufferLength), uintptr(unsafe.Pointer(returnLength)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc QueryDosDevice(deviceName *uint16, targetPath *uint16, max uint32) (n uint32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procQueryDosDeviceW.Addr(), 3, uintptr(unsafe.Pointer(deviceName)), uintptr(unsafe.Pointer(targetPath)), uintptr(max))%0A%09n = uint32(r0)%0A%09if n == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetVolumeLabel(rootPathName *uint16, volumeName *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetVolumeLabelW.Addr(), 2, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeName)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetVolumeMountPointW.Addr(), 2, uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(unsafe.Pointer(volumeName)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSAStartup(verreq uint32, data *WSAData) (sockerr error) %7B%0A%09r0, _, _ := syscall.Syscall(procWSAStartup.Addr(), 2, uintptr(verreq), uintptr(unsafe.Pointer(data)), 0)%0A%09if r0 != 0 %7B%0A%09%09sockerr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSACleanup() (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procWSACleanup.Addr(), 0, 0, 0, 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSAIoctl.Addr(), 9, uintptr(s), uintptr(iocc), uintptr(unsafe.Pointer(inbuf)), uintptr(cbif), uintptr(unsafe.Pointer(outbuf)), uintptr(cbob), uintptr(unsafe.Pointer(cbbr)), uintptr(unsafe.Pointer(overlapped)), uintptr(completionRoutine))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc socket(af int32, typ int32, protocol int32) (handle Handle, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procsocket.Addr(), 3, uintptr(af), uintptr(typ), uintptr(protocol))%0A%09handle = Handle(r0)%0A%09if handle == InvalidHandle %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procsetsockopt.Addr(), 5, uintptr(s), uintptr(level), uintptr(optname), uintptr(unsafe.Pointer(optval)), uintptr(optlen), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Getsockopt(s Handle, level int32, optname int32, optval *byte, optlen *int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procgetsockopt.Addr(), 5, uintptr(s), uintptr(level), uintptr(optname), uintptr(unsafe.Pointer(optval)), uintptr(unsafe.Pointer(optlen)), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc bind(s Handle, name unsafe.Pointer, namelen int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procbind.Addr(), 3, uintptr(s), uintptr(name), uintptr(namelen))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc connect(s Handle, name unsafe.Pointer, namelen int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procconnect.Addr(), 3, uintptr(s), uintptr(name), uintptr(namelen))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procgetsockname.Addr(), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procgetpeername.Addr(), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc listen(s Handle, backlog int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(proclisten.Addr(), 2, uintptr(s), uintptr(backlog), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc shutdown(s Handle, how int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procshutdown.Addr(), 2, uintptr(s), uintptr(how), 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Closesocket(s Handle) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procclosesocket.Addr(), 1, uintptr(s), 0, 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procAcceptEx.Addr(), 8, uintptr(ls), uintptr(as), uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(overlapped)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) %7B%0A%09syscall.Syscall9(procGetAcceptExSockaddrs.Addr(), 8, uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(lrsa)), uintptr(unsafe.Pointer(lrsalen)), uintptr(unsafe.Pointer(rrsa)), uintptr(unsafe.Pointer(rrsalen)), 0)%0A%09return%0A%7D%0A%0Afunc WSARecv(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSARecv.Addr(), 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSASend(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSASend.Addr(), 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSARecvFrom(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, from *RawSockaddrAny, fromlen *int32, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSARecvFrom.Addr(), 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32, overlapped *Overlapped, croutine *byte) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procWSASendTo.Addr(), 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(to)), uintptr(tolen), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))%0A%09if r1 == socket_error %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetHostByName(name string) (h *Hostent, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = syscall.BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _GetHostByName(_p0)%0A%7D%0A%0Afunc _GetHostByName(name *byte) (h *Hostent, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procgethostbyname.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)%0A%09h = (*Hostent)(unsafe.Pointer(r0))%0A%09if h == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetServByName(name string, proto string) (s *Servent, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = syscall.BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09var _p1 *byte%0A%09_p1, err = syscall.BytePtrFromString(proto)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _GetServByName(_p0, _p1)%0A%7D%0A%0Afunc _GetServByName(name *byte, proto *byte) (s *Servent, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procgetservbyname.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(proto)), 0)%0A%09s = (*Servent)(unsafe.Pointer(r0))%0A%09if s == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc Ntohs(netshort uint16) (u uint16) %7B%0A%09r0, _, _ := syscall.Syscall(procntohs.Addr(), 1, uintptr(netshort), 0, 0)%0A%09u = uint16(r0)%0A%09return%0A%7D%0A%0Afunc GetProtoByName(name string) (p *Protoent, err error) %7B%0A%09var _p0 *byte%0A%09_p0, err = syscall.BytePtrFromString(name)%0A%09if err != nil %7B%0A%09%09return%0A%09%7D%0A%09return _GetProtoByName(_p0)%0A%7D%0A%0Afunc _GetProtoByName(name *byte) (p *Protoent, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procgetprotobyname.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)%0A%09p = (*Protoent)(unsafe.Pointer(r0))%0A%09if p == nil %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) %7B%0A%09var _p0 *uint16%0A%09_p0, status = syscall.UTF16PtrFromString(name)%0A%09if status != nil %7B%0A%09%09return%0A%09%7D%0A%09return _DnsQuery(_p0, qtype, options, extra, qrs, pr)%0A%7D%0A%0Afunc _DnsQuery(name *uint16, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) %7B%0A%09r0, _, _ := syscall.Syscall6(procDnsQuery_W.Addr(), 6, uintptr(unsafe.Pointer(name)), uintptr(qtype), uintptr(options), uintptr(unsafe.Pointer(extra)), uintptr(unsafe.Pointer(qrs)), uintptr(unsafe.Pointer(pr)))%0A%09if r0 != 0 %7B%0A%09%09status = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc DnsRecordListFree(rl *DNSRecord, freetype uint32) %7B%0A%09syscall.Syscall(procDnsRecordListFree.Addr(), 2, uintptr(unsafe.Pointer(rl)), uintptr(freetype), 0)%0A%09return%0A%7D%0A%0Afunc DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) %7B%0A%09r0, _, _ := syscall.Syscall(procDnsNameCompare_W.Addr(), 2, uintptr(unsafe.Pointer(name1)), uintptr(unsafe.Pointer(name2)), 0)%0A%09same = r0 != 0%0A%09return%0A%7D%0A%0Afunc GetAddrInfoW(nodename *uint16, servicename *uint16, hints *AddrinfoW, result **AddrinfoW) (sockerr error) %7B%0A%09r0, _, _ := syscall.Syscall6(procGetAddrInfoW.Addr(), 4, uintptr(unsafe.Pointer(nodename)), uintptr(unsafe.Pointer(servicename)), uintptr(unsafe.Pointer(hints)), uintptr(unsafe.Pointer(result)), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09sockerr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FreeAddrInfoW(addrinfo *AddrinfoW) %7B%0A%09syscall.Syscall(procFreeAddrInfoW.Addr(), 1, uintptr(unsafe.Pointer(addrinfo)), 0, 0)%0A%09return%0A%7D%0A%0Afunc GetIfEntry(pIfRow *MibIfRow) (errcode error) %7B%0A%09r0, _, _ := syscall.Syscall(procGetIfEntry.Addr(), 1, uintptr(unsafe.Pointer(pIfRow)), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09errcode = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode error) %7B%0A%09r0, _, _ := syscall.Syscall(procGetAdaptersInfo.Addr(), 2, uintptr(unsafe.Pointer(ai)), uintptr(unsafe.Pointer(ol)), 0)%0A%09if r0 != 0 %7B%0A%09%09errcode = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procSetFileCompletionNotificationModes.Addr(), 2, uintptr(handle), uintptr(flags), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc WSAEnumProtocols(protocols *int32, protocolBuffer *WSAProtocolInfo, bufferLength *uint32) (n int32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall(procWSAEnumProtocolsW.Addr(), 3, uintptr(unsafe.Pointer(protocols)), uintptr(unsafe.Pointer(protocolBuffer)), uintptr(unsafe.Pointer(bufferLength)))%0A%09n = int32(r0)%0A%09if n == -1 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) %7B%0A%09r0, _, _ := syscall.Syscall6(procGetAdaptersAddresses.Addr(), 5, uintptr(family), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(adapterAddresses)), uintptr(unsafe.Pointer(sizePointer)), 0)%0A%09if r0 != 0 %7B%0A%09%09errcode = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetACP() (acp uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetACP.Addr(), 0, 0, 0, 0)%0A%09acp = uint32(r0)%0A%09return%0A%7D%0A%0Afunc MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) %7B%0A%09r0, _, e1 := syscall.Syscall6(procMultiByteToWideChar.Addr(), 6, uintptr(codePage), uintptr(dwFlags), uintptr(unsafe.Pointer(str)), uintptr(nstr), uintptr(unsafe.Pointer(wchar)), uintptr(nwchar))%0A%09nwrite = int32(r0)%0A%09if nwrite == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procTranslateNameW.Addr(), 5, uintptr(unsafe.Pointer(accName)), uintptr(accNameFormat), uintptr(desiredNameFormat), uintptr(unsafe.Pointer(translatedName)), uintptr(unsafe.Pointer(nSize)), 0)%0A%09if r1&0xff == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetUserNameExW.Addr(), 3, uintptr(nameFormat), uintptr(unsafe.Pointer(nameBuffre)), uintptr(unsafe.Pointer(nSize)))%0A%09if r1&0xff == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc NetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) %7B%0A%09r0, _, _ := syscall.Syscall6(procNetUserGetInfo.Addr(), 4, uintptr(unsafe.Pointer(serverName)), uintptr(unsafe.Pointer(userName)), uintptr(level), uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09neterr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc NetGetJoinInformation(server *uint16, name **uint16, bufType *uint32) (neterr error) %7B%0A%09r0, _, _ := syscall.Syscall(procNetGetJoinInformation.Addr(), 3, uintptr(unsafe.Pointer(server)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(bufType)))%0A%09if r0 != 0 %7B%0A%09%09neterr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc NetApiBufferFree(buf *byte) (neterr error) %7B%0A%09r0, _, _ := syscall.Syscall(procNetApiBufferFree.Addr(), 1, uintptr(unsafe.Pointer(buf)), 0, 0)%0A%09if r0 != 0 %7B%0A%09%09neterr = syscall.Errno(r0)%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procLookupAccountSidW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall9(procLookupAccountNameW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(accountName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(sidLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procConvertSidToStringSidW.Addr(), 2, uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(stringSid)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procConvertStringSidToSidW.Addr(), 2, uintptr(unsafe.Pointer(stringSid)), uintptr(unsafe.Pointer(sid)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetLengthSid(sid *SID) (len uint32) %7B%0A%09r0, _, _ := syscall.Syscall(procGetLengthSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)%0A%09len = uint32(r0)%0A%09return%0A%7D%0A%0Afunc CopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCopySid.Addr(), 3, uintptr(destSidLen), uintptr(unsafe.Pointer(destSid)), uintptr(unsafe.Pointer(srcSid)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc AllocateAndInitializeSid(identAuth *SidIdentifierAuthority, subAuth byte, subAuth0 uint32, subAuth1 uint32, subAuth2 uint32, subAuth3 uint32, subAuth4 uint32, subAuth5 uint32, subAuth6 uint32, subAuth7 uint32, sid **SID) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall12(procAllocateAndInitializeSid.Addr(), 11, uintptr(unsafe.Pointer(identAuth)), uintptr(subAuth), uintptr(subAuth0), uintptr(subAuth1), uintptr(subAuth2), uintptr(subAuth3), uintptr(subAuth4), uintptr(subAuth5), uintptr(subAuth6), uintptr(subAuth7), uintptr(unsafe.Pointer(sid)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc FreeSid(sid *SID) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procFreeSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)%0A%09if r1 != 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc EqualSid(sid1 *SID, sid2 *SID) (isEqual bool) %7B%0A%09r0, _, _ := syscall.Syscall(procEqualSid.Addr(), 2, uintptr(unsafe.Pointer(sid1)), uintptr(unsafe.Pointer(sid2)), 0)%0A%09isEqual = r0 != 0%0A%09return%0A%7D%0A%0Afunc checkTokenMembership(tokenHandle Token, sidToCheck *SID, isMember *int32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procCheckTokenMembership.Addr(), 3, uintptr(tokenHandle), uintptr(unsafe.Pointer(sidToCheck)), uintptr(unsafe.Pointer(isMember)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc OpenProcessToken(h Handle, access uint32, token *Token) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procOpenProcessToken.Addr(), 3, uintptr(h), uintptr(access), uintptr(unsafe.Pointer(token)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetTokenInformation(t Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall6(procGetTokenInformation.Addr(), 5, uintptr(t), uintptr(infoClass), uintptr(unsafe.Pointer(info)), uintptr(infoLen), uintptr(unsafe.Pointer(returnedLen)), 0)%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A%0Afunc GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) %7B%0A%09r1, _, e1 := syscall.Syscall(procGetUserProfileDirectoryW.Addr(), 3, uintptr(t), uintptr(unsafe.Pointer(dir)), uintptr(unsafe.Pointer(dirLen)))%0A%09if r1 == 0 %7B%0A%09%09if e1 != 0 %7B%0A%09%09%09err = errnoErr(e1)%0A%09%09%7D else %7B%0A%09%09%09err = syscall.EINVAL%0A%09%09%7D%0A%09%7D%0A%09return%0A%7D%0A
+ f 72ef069cd92c6866a087779d52f2833f6f5ff27c1fc951d808c02f998f959d49 vendor/modules.txt
dmppatch 2
@@ -0,0 +1,839 @@
+# github.com/fatih/color v1.7.0%0Agithub.com/fatih/color%0A# github.com/mattn/go-colorable v0.0.9%0Agithub.com/mattn/go-colorable%0A# github.com/mattn/go-isatty v0.0.4%0Agithub.com/mattn/go-isatty%0A# github.com/mutecomm/mute v0.0.0-20180427225835-8124193e6371%0Agithub.com/mutecomm/mute/util/fuzzer%0A# github.com/sergi/go-diff v1.0.0%0Agithub.com/sergi/go-diff/diffmatchpatch%0A# golang.org/x/crypto v0.0.0-20180910181607-0e37d006457b%0Agolang.org/x/crypto/ed25519%0Agolang.org/x/crypto/argon2%0Agolang.org/x/crypto/nacl/secretbox%0Agolang.org/x/crypto/ssh/terminal%0Agolang.org/x/crypto/ed25519/internal/edwards25519%0Agolang.org/x/crypto/blake2b%0Agolang.org/x/crypto/internal/subtle%0Agolang.org/x/crypto/poly1305%0Agolang.org/x/crypto/salsa20/salsa%0A# golang.org/x/sys v0.0.0-20180926160741-c2ed4eda69e7%0Agolang.org/x/sys/cpu%0Agolang.org/x/sys/unix%0Agolang.org/x/sys/windows%0A
treehash 5cbdd342debccf01fbbe4bd7db68edb4c0613d26dc77ffa0c6ae4dddc74f3155
