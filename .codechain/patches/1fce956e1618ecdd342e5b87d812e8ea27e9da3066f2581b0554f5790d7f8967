diff --git a/.codechain/tree/a/command/apply.go b/.codechain/tree/b/command/apply.go
index 99fde68..fc6faec 100644
--- a/.codechain/tree/a/command/apply.go
+++ b/.codechain/tree/b/command/apply.go
@@ -1,12 +1,26 @@
 package command
 
 import (
-	"errors"
 	"flag"
 	"fmt"
 	"os"
+
+	"github.com/frankbraun/codechain/hashchain"
+	"github.com/frankbraun/codechain/tree"
+	"github.com/frankbraun/codechain/util/log"
 )
 
+func apply(c *hashchain.HashChain) error {
+	targetHash, _ := c.LastSignedTreeHash()
+	treeHashes := c.TreeHashes()
+	err := tree.Sync(".", targetHash, patchDir, treeHashes, excludePaths, false)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
+
 // Apply implements the 'apply' command.
 func Apply(argv0 string, args ...string) error {
 	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
@@ -15,13 +29,23 @@ func Apply(argv0 string, args ...string) error {
 		fmt.Fprintf(os.Stderr, "Apply all patches with enough signatures to code tree.\n")
 		fs.PrintDefaults()
 	}
+	verbose := fs.Bool("v", false, "Be verbose")
 	if err := fs.Parse(args); err != nil {
 		return err
 	}
+	if *verbose {
+		log.Std = log.NewStd(os.Stdout)
+	}
 	if fs.NArg() != 0 {
 		fs.Usage()
 		return flag.ErrHelp
 	}
-	// TODO
-	return errors.New("not implemented")
+	c, err := hashchain.Read(hashchainFile)
+	if err != nil {
+		return err
+	}
+	if err := c.Close(); err != nil {
+		return err
+	}
+	return apply(c)
 }
diff --git a/.codechain/tree/a/command/cleanslate.go b/.codechain/tree/b/command/cleanslate.go
index dd0d696..5171ddd 100644
--- a/.codechain/tree/a/command/cleanslate.go
+++ b/.codechain/tree/b/command/cleanslate.go
@@ -1,12 +1,74 @@
 package command
 
 import (
+	"bytes"
 	"errors"
 	"flag"
 	"fmt"
+	"io/ioutil"
 	"os"
+	"path/filepath"
+	"strings"
+
+	"github.com/frankbraun/codechain/util/terminal"
 )
 
+func cleanSlate() error {
+	files, err := ioutil.ReadDir(".")
+	if err != nil {
+		return err
+	}
+outerA:
+	for _, fi := range files {
+		if excludePaths != nil {
+			canonical := filepath.ToSlash(fi.Name())
+			for _, excludePath := range excludePaths {
+				if excludePath == canonical {
+					continue outerA
+				}
+			}
+		}
+		if fi.IsDir() {
+			fmt.Println(fi.Name() + "/")
+		} else {
+			fmt.Println(fi.Name())
+		}
+	}
+
+	for {
+		fmt.Print("delete all files and directories listed above? [y/n]: ")
+		answer, err := terminal.ReadLine(os.Stdin)
+		if err != nil {
+			return err
+		}
+		a := string(bytes.ToLower(answer))
+		if strings.HasPrefix(a, "y") {
+			break
+		} else if strings.HasPrefix(a, "n") {
+			return errors.New("aborted")
+		} else {
+			fmt.Println("answer not recognized")
+		}
+	}
+
+outerB:
+	for _, fi := range files {
+		if excludePaths != nil {
+			canonical := filepath.ToSlash(fi.Name())
+			for _, excludePath := range excludePaths {
+				if excludePath == canonical {
+					continue outerB
+				}
+			}
+		}
+		if err := os.RemoveAll(fi.Name()); err != nil {
+			return err
+		}
+	}
+
+	return nil
+}
+
 // CleanSlate implements the 'cleanslate' command.
 func CleanSlate(argv0 string, args ...string) error {
 	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
@@ -22,6 +84,5 @@ func CleanSlate(argv0 string, args ...string) error {
 		fs.Usage()
 		return flag.ErrHelp
 	}
-	// TODO
-	return errors.New("not implemented")
+	return cleanSlate()
 }
diff --git a/.codechain/tree/a/command/helper.go b/.codechain/tree/b/command/helper.go
index e413a95..4b1f775 100644
--- a/.codechain/tree/a/command/helper.go
+++ b/.codechain/tree/b/command/helper.go
@@ -15,6 +15,31 @@ import (
 	"golang.org/x/crypto/ed25519"
 )
 
+func seckeyCheck(seckey string) error {
+	if seckey != "" {
+		exists, err := file.Exists(seckey)
+		if err != nil {
+			return err
+		}
+		if !exists {
+			return fmt.Errorf("file '%s' doesn't exists", seckey)
+		}
+	} else {
+		homeDir := home.AppDataDir("codechain", false)
+		homeDir = filepath.Join(homeDir, secretsDir)
+		// make sure we have the secrets directory present
+		exists, err := file.Exists(homeDir)
+		if err != nil {
+			return err
+		}
+		if !exists {
+			return fmt.Errorf("directory '%s' doesn't exists: you have no secrets",
+				homeDir)
+		}
+	}
+	return nil
+}
+
 func seckeyRead(filename string) (*[64]byte, *[64]byte, []byte, error) {
 	exists, err := file.Exists(filename)
 	if err != nil {
diff --git a/.codechain/tree/a/command/publish.go b/.codechain/tree/b/command/publish.go
index 7d316a1..967bb3b 100644
--- a/.codechain/tree/a/command/publish.go
+++ b/.codechain/tree/b/command/publish.go
@@ -14,8 +14,8 @@ import (
 	"github.com/frankbraun/codechain/tree"
 	"github.com/frankbraun/codechain/util/file"
 	"github.com/frankbraun/codechain/util/git"
-	"github.com/frankbraun/codechain/util/home"
 	"github.com/frankbraun/codechain/util/interrupt"
+	"github.com/frankbraun/codechain/util/log"
 	"github.com/frankbraun/codechain/util/terminal"
 )
 
@@ -29,7 +29,7 @@ func publish(c *hashchain.HashChain, secKeyFile string, verbose bool) error {
 	// get last published treehash
 	treeHash := c.LastTreeHash()
 
-	// make sure patch file for last
+	// make sure patch file doesn't exist for last tree hash
 	patchFile := filepath.Join(patchDir, treeHash)
 	exists, err := file.Exists(patchFile)
 	if err != nil {
@@ -40,10 +40,17 @@ func publish(c *hashchain.HashChain, secKeyFile string, verbose bool) error {
 	}
 
 	// bring .codechain/tree/a in sync with last published treehash
-	err = tree.Sync(treeDirA, treeHash, patchDir, verbose, excludePaths)
+	if verbose {
+		fmt.Println("sync tree/a")
+	}
+	treeHashes := c.TreeHashes()
+	err = tree.Sync(treeDirA, treeHash, patchDir, treeHashes, excludePaths, true)
 	if err != nil {
 		return err
 	}
+	if verbose {
+		fmt.Println("done")
+	}
 
 	// calculate current treehash
 	curHash, err := tree.Hash(".", excludePaths)
@@ -52,7 +59,7 @@ func publish(c *hashchain.HashChain, secKeyFile string, verbose bool) error {
 	}
 	fmt.Printf("%x\n", curHash[:])
 
-	// bring .codechain/tree/b in sync with last published treehash
+	// bring .codechain/tree/b in sync with the tree hash to be published
 	tmpHash, err := tree.Hash(treeDirB, excludePaths)
 	if err != nil {
 		return err
@@ -132,27 +139,11 @@ func Publish(argv0 string, args ...string) error {
 	if err := fs.Parse(args); err != nil {
 		return err
 	}
-	var homeDir string
-	if *seckey != "" {
-		exists, err := file.Exists(*seckey)
-		if err != nil {
-			return err
-		}
-		if !exists {
-			return fmt.Errorf("file '%s' doesn't exists", *seckey)
-		}
-	} else {
-		homeDir = home.AppDataDir("codechain", false)
-		homeDir = filepath.Join(homeDir, secretsDir)
-		// make sure we have the secrets directory at least present
-		exists, err := file.Exists(homeDir)
-		if err != nil {
-			return err
-		}
-		if !exists {
-			return fmt.Errorf("directory '%s' doesn't exists: you have no secrets",
-				homeDir)
-		}
+	if err := seckeyCheck(*seckey); err != nil {
+		return err
+	}
+	if *verbose {
+		log.Std = log.NewStd(os.Stdout)
 	}
 	if fs.NArg() != 0 {
 		fs.Usage()
diff --git a/.codechain/tree/a/command/review.go b/.codechain/tree/b/command/review.go
index 270bf89..17e4780 100644
--- a/.codechain/tree/a/command/review.go
+++ b/.codechain/tree/b/command/review.go
@@ -1,12 +1,126 @@
 package command
 
 import (
+	"bytes"
 	"errors"
 	"flag"
 	"fmt"
 	"os"
+	"strings"
+
+	"github.com/frankbraun/codechain/hashchain"
+	"github.com/frankbraun/codechain/tree"
+	"github.com/frankbraun/codechain/util/git"
+	"github.com/frankbraun/codechain/util/interrupt"
+	"github.com/frankbraun/codechain/util/log"
+	"github.com/frankbraun/codechain/util/terminal"
 )
 
+func review(c *hashchain.HashChain, secKeyFile string) error {
+	// load secret key
+	secKey, _, _, err := seckeyLoad(c, secKeyFile)
+	if err != nil {
+		return err
+	}
+
+	// get last tree hashes
+	signedTreeHash, idx := c.LastSignedTreeHash()
+	if signedTreeHash == c.LastTreeHash() {
+		fmt.Printf("%s: already signed\n", signedTreeHash)
+		return nil
+	}
+	treeHashes := c.TreeHashes()
+	treeComments := c.TreeComments()
+	if len(treeHashes) != len(treeComments) {
+		return fmt.Errorf("invariant failed: len(treeHashes) == len(treeComments)")
+	}
+
+	if log.Std != nil {
+		log.Println("treeHashes :")
+		for _, h := range treeHashes {
+			log.Println(h)
+		}
+		log.Println("treeComments:")
+		for _, c := range treeComments {
+			log.Println(c)
+		}
+	}
+
+	// TODO: also show commits which have been signed, but not by this signer
+	// TODO: deal with explicit treehash
+	// TODO: show changes in signers/sigctl!
+
+	for i := idx + 1; i < len(treeHashes); i++ {
+		// bring .codechain/tree/a in sync
+		err = tree.Sync(treeDirA, treeHashes[i-1], patchDir, treeHashes, excludePaths, true)
+		if err != nil {
+			return err
+		}
+
+		// bring .codechain/tree/b in sync
+		err = tree.Sync(treeDirB, treeHashes[i], patchDir, treeHashes, excludePaths, true)
+		if err != nil {
+			return err
+		}
+
+		// show patches info
+		pub, comment := c.SignerInfo(treeHashes[i])
+		fmt.Printf("patch %d/%d\n", i-idx, len(treeHashes)-idx-1)
+		if treeComments[i] != "" {
+			fmt.Println(treeComments[i])
+		}
+		fmt.Printf("developer: %s\n", pub)
+		if comment != "" {
+			fmt.Println(comment)
+		}
+		for {
+			fmt.Print("review patch? [y/n]: ")
+			answer, err := terminal.ReadLine(os.Stdin)
+			if err != nil {
+				return err
+			}
+			a := string(bytes.ToLower(answer))
+			if strings.HasPrefix(a, "y") {
+				break
+			} else if strings.HasPrefix(a, "n") {
+				return errors.New("aborted")
+			} else {
+				fmt.Println("answer not recognized")
+			}
+		}
+
+		// display diff *pager
+		if err := git.DiffPager(treeDirA, treeDirB); err != nil {
+			return err
+		}
+
+		// confirm patch
+		for {
+			fmt.Print("sign patch? [y/n]: ")
+			answer, err := terminal.ReadLine(os.Stdin)
+			if err != nil {
+				return err
+			}
+			a := string(bytes.ToLower(answer))
+			if strings.HasPrefix(a, "y") {
+				break
+			} else if strings.HasPrefix(a, "n") {
+				return errors.New("aborted")
+			} else {
+				fmt.Println("answer not recognized")
+			}
+		}
+	}
+
+	// sign patches and add to hash chain
+	entry, err := c.Signature(c.LastEntryHash(), *secKey)
+	if err != nil {
+		return err
+	}
+	fmt.Println(entry)
+	return nil
+}
+
 // Review implements the 'review' command.
 func Review(argv0 string, args ...string) error {
 	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
@@ -15,13 +129,51 @@ func Review(argv0 string, args ...string) error {
 		fmt.Fprintf(os.Stderr, "Review code changes (all or up to treehash) and changes of signers and sigctl.\n")
 		fs.PrintDefaults()
 	}
+	seckey := fs.String("s", "", "Secret key file")
+	verbose := fs.Bool("v", false, "Be verbose")
 	if err := fs.Parse(args); err != nil {
 		return err
 	}
-	if fs.NArg() != 0 {
+	if err := seckeyCheck(*seckey); err != nil {
+		return err
+	}
+	if *verbose {
+		log.Std = log.NewStd(os.Stdout)
+	}
+	if fs.NArg() != 0 && fs.NArg() != 1 {
 		fs.Usage()
 		return flag.ErrHelp
 	}
-	// TODO
-	return errors.New("not implemented")
+	if err := os.MkdirAll(treeDirA, 0755); err != nil {
+		return err
+	}
+	if err := os.MkdirAll(treeDirB, 0755); err != nil {
+		return err
+	}
+	/* TODO
+	var treehash string
+	if fs.NArg() == 1 {
+		treehash = fs.Arg(0)
+		// TODO
+		return errors.New("not implemented")
+	}
+	*/
+	c, err := hashchain.Read(hashchainFile)
+	if err != nil {
+		return err
+	}
+	defer c.Close()
+	// add interrupt handler
+	interrupt.AddInterruptHandler(func() {
+		c.Close()
+	})
+	// run review
+	go func() {
+		if err := review(c, *seckey); err != nil {
+			interrupt.ShutdownChannel <- err
+			return
+		}
+		interrupt.ShutdownChannel <- nil
+	}()
+	return <-interrupt.ShutdownChannel
 }
diff --git a/.codechain/tree/a/command/status.go b/.codechain/tree/b/command/status.go
index 6d9b78b..c80897d 100644
--- a/.codechain/tree/a/command/status.go
+++ b/.codechain/tree/b/command/status.go
@@ -4,10 +4,59 @@ import (
 	"flag"
 	"fmt"
 	"os"
+	"sort"
 
 	"github.com/frankbraun/codechain/hashchain"
 )
 
+// TODO: move to hashchain?
+func showSigner(c *hashchain.HashChain) {
+	fmt.Printf("signers (%d-of-%d required):\n", c.M(), c.N())
+	var signer []string
+	for s := range c.Signer() {
+		signer = append(signer, s)
+	}
+	sort.Strings(signer)
+	for _, s := range signer {
+		fmt.Printf("%d %s %s\n", c.SignerWeight(s), s, c.SignerComment(s))
+	}
+}
+
+func showSignedReleases(c *hashchain.HashChain) {
+	_, idx := c.LastSignedTreeHash()
+	if idx == 0 {
+		fmt.Println("no signed releases yet")
+		return
+	}
+	treeHashes := c.TreeHashes()
+	treeComments := c.TreeComments()
+	fmt.Println("signed releases:")
+	for i := 1; i <= idx; i++ {
+		fmt.Printf("%s %s\n", treeHashes[i], treeComments[i])
+	}
+}
+
+func showUnsignedReleases(c *hashchain.HashChain) {
+	_, idx := c.LastSignedTreeHash()
+	treeHashes := c.TreeHashes()
+	if idx == len(treeHashes)-1 {
+		fmt.Println("no unsigned releases")
+		return
+	}
+	treeComments := c.TreeComments()
+	fmt.Println("unsigned releases:")
+	for i := idx + 1; i < len(treeHashes); i++ {
+		fmt.Printf("%s %s\n", treeHashes[i], treeComments[i])
+	}
+}
+
+func status(c *hashchain.HashChain) error {
+	showSigner(c)
+	showSignedReleases(c)
+	showUnsignedReleases(c)
+	return nil
+}
+
 // Status implement the 'status' command.
 func Status(argv0 string, args ...string) error {
 	fs := flag.NewFlagSet(argv0, flag.ContinueOnError)
@@ -23,10 +72,10 @@ func Status(argv0 string, args ...string) error {
 		fs.Usage()
 		return flag.ErrHelp
 	}
-	_, err := hashchain.Read(hashchainFile)
+	c, err := hashchain.Read(hashchainFile)
 	if err != nil {
 		return err
 	}
-	// TODO: implement
-	return nil
+	defer c.Close()
+	return status(c)
 }
diff --git a/.codechain/tree/a/hashchain/hashchain.go b/.codechain/tree/b/hashchain/hashchain.go
index f0a42ec..47633e4 100644
--- a/.codechain/tree/a/hashchain/hashchain.go
+++ b/.codechain/tree/b/hashchain/hashchain.go
@@ -15,21 +15,65 @@ type HashChain struct {
 	state *state.State
 }
 
+// M returns the signature threshold.
+func (c *HashChain) M() int {
+	return c.state.M()
+}
+
+// N returns the total weight of all signers.
+func (c *HashChain) N() int {
+	return c.state.N()
+}
+
 // LastEntryHash returns the hash of the last entry.
 func (c *HashChain) LastEntryHash() [32]byte {
 	return c.chain[len(c.chain)-1].Hash()
 }
 
-// LastTreeHash returns the most current tree hash.
+// LastTreeHash returns the most current tree hash (can be unsigned).
 func (c *HashChain) LastTreeHash() string {
 	return c.state.LastTreeHash()
 }
 
+// LastSignedTreeHash returns the last signed tree hash.
+func (c *HashChain) LastSignedTreeHash() (string, int) {
+	return c.state.LastSignedTreeHash()
+}
+
+// TreeHashes returns a list of all tree hashes in order (starting from
+// tree.EmptyHash).
+func (c *HashChain) TreeHashes() []string {
+	return c.state.TreeHashes()
+}
+
+// TreeComments returns a list of all tree comments in order (starting from
+// tree.EmptyHash).
+func (c *HashChain) TreeComments() []string {
+	return c.state.TreeComments()
+}
+
 // Signer returns a map containing all active signers for hash chain.
 func (c *HashChain) Signer() map[string]bool {
 	return c.state.Signer()
 }
 
+// SignerComment returns the signer comment for given pubKey.
+func (c *HashChain) SignerComment(pubKey string) string {
+	return c.state.SignerComment(pubKey)
+}
+
+// SignerWeight returns the signer weight for given pubKey.
+func (c *HashChain) SignerWeight(pubKey string) int {
+	return c.state.SignerWeight(pubKey)
+}
+
+// SignerInfo returns signer pubKey and comment for patch with given treeHash.
+func (c *HashChain) SignerInfo(treeHash string) (string, string) {
+	link := c.chain[c.state.SourceLine(treeHash)]
+	pubKey := link.typeFields[1]
+	return pubKey, c.state.SignerComment(pubKey)
+}
+
 // EntryHash returns the entry hash for the given treeHash.
 func (c *HashChain) EntryHash(treeHash [32]byte) [32]byte {
 	var h [32]byte
diff --git a/.codechain/tree/a/hashchain/internal/state/state.go b/.codechain/tree/b/hashchain/internal/state/state.go
index f8fb0d2..5ac85a3 100644
--- a/.codechain/tree/a/hashchain/internal/state/state.go
+++ b/.codechain/tree/b/hashchain/internal/state/state.go
@@ -45,6 +45,11 @@ func New(pubKey, comment string) *State {
 	return s
 }
 
+// M returns the signature threshold.
+func (s *State) M() int {
+	return s.m
+}
+
 // N returns the total weight of all signers.
 func (s *State) N() int {
 	return s.n
@@ -86,6 +91,11 @@ func (s *State) LinkHashes() int {
 	return len(s.linkHashes)
 }
 
+// SourceLine returns the line number where the given tree hash was signed.
+func (s *State) SourceLine(treeHash string) int {
+	return s.linkHashes[s.treeHashes[treeHash]]
+}
+
 // HasSigner checks wether the state s contains a valid the signer with
 // pubKey.
 func (s *State) HasSigner(pubKey [32]byte) bool {
@@ -127,6 +137,38 @@ func (s *State) LastTreeHash() string {
 	return s.signedTreeHashes[len(s.signedTreeHashes)-1]
 }
 
+// LastSignedTreeHash returns the last signed tree hash.
+func (s *State) LastSignedTreeHash() (string, int) {
+	idx := len(s.signedTreeHashes) - 1
+	return s.signedTreeHashes[idx], idx
+}
+
+// TreeHashes returns a list of all tree hashes in order (starting from
+// tree.EmptyHash).
+func (s *State) TreeHashes() []string {
+	treeHashes := append([]string{}, s.signedTreeHashes...)
+	for i := s.signedLine + 1; i < len(s.unconfirmedOPs); i++ {
+		op, ok := s.unconfirmedOPs[i].(*sourceOP)
+		if ok {
+			treeHashes = append(treeHashes, op.treeHash)
+		}
+	}
+	return treeHashes
+}
+
+// TreeComments returns a list of all tree comments in order (starting from
+// tree.EmptyHash).
+func (s *State) TreeComments() []string {
+	treeComments := append([]string{}, s.signedTreeComments...)
+	for i := s.signedLine + 1; i < len(s.unconfirmedOPs); i++ {
+		op, ok := s.unconfirmedOPs[i].(*sourceOP)
+		if ok {
+			treeComments = append(treeComments, op.comment)
+		}
+	}
+	return treeComments
+}
+
 // LastWeight returns the last weight added for given pubKey (unconfirmed or
 // confirmed).
 func (s *State) LastWeight(pubKey [32]byte) (int, error) {
@@ -159,6 +201,16 @@ func (s *State) Signer() map[string]bool {
 	return signer
 }
 
+// SignerComment returns the signer comment for given pubKey.
+func (s *State) SignerComment(pubKey string) string {
+	return s.signerComments[pubKey]
+}
+
+// SignerWeight returns the signer weight for given pubKey.
+func (s *State) SignerWeight(pubKey string) int {
+	return s.signerWeights[pubKey]
+}
+
 // AddSourceHash adds treeHash at given linkHash to state.
 func (s *State) AddSourceHash(linkHash, treeHash, pubKey [32]byte, comment string) {
 	link := hex.Encode(linkHash[:])
@@ -241,6 +293,7 @@ func (s *State) Sign(linkHash, pubKey [32]byte) error {
 			break
 		}
 	}
+	s.signedLine = i - 1
 	s.signerBarriers[pub] = i - 1
 	s.unconfirmedOPs = append(s.unconfirmedOPs, nop)
 	return nil
diff --git a/.codechain/tree/a/tree/sync.go b/.codechain/tree/b/tree/sync.go
index d8ca20f..2d33612 100644
--- a/.codechain/tree/a/tree/sync.go
+++ b/.codechain/tree/b/tree/sync.go
@@ -3,28 +3,103 @@ package tree
 import (
 	"errors"
 	"fmt"
+	"os"
+	"path/filepath"
 
 	"github.com/frankbraun/codechain/internal/hex"
+	"github.com/frankbraun/codechain/util"
+	"github.com/frankbraun/codechain/util/git"
+	"github.com/frankbraun/codechain/util/log"
 )
 
 // Sync treeDir to the state of treeHash with patches from patchDir.
 // Prints status info if verbose is true.
-func Sync(treeDir, treeHash, patchDir string, verbose bool, excludePaths []string) error {
+func Sync(
+	treeDir, targetHash, patchDir string,
+	treeHashes []string,
+	excludePaths []string,
+	canRemoveDir bool,
+) error {
+	// argument checking
+	if treeHashes[0] != EmptyHash {
+		return fmt.Errorf("tree: treeHashes doesn't start with EmptyHash")
+	}
+	if !util.ContainsString(treeHashes, targetHash) {
+		return fmt.Errorf("tree: targetHash unknown: %s", targetHash)
+	}
+
 	hash, err := Hash(treeDir, excludePaths)
 	if err != nil {
 		return err
 	}
 	hashStr := hex.Encode(hash[:])
-	if verbose {
-		fmt.Printf("treeDir : %x\n", hash[:])
-		fmt.Printf("treeHash: %s\n", treeHash)
-	}
+	log.Printf("treeDir    : %s\n", treeDir)
+	log.Printf("treeDirHash: %x\n", hash[:])
+	log.Printf("targetHash : %s\n", targetHash)
 
-	if hashStr == treeHash {
-		fmt.Println("treeDir in sync")
+	if hashStr == targetHash {
+		log.Println("treeDir in sync")
 		return nil
 	}
 
-	// TODO
-	return errors.New("not implemented")
+	// find target hash index
+	var idx int
+	for ; idx < len(treeHashes); idx++ {
+		if treeHashes[idx] == targetHash {
+			break
+		}
+	}
+
+	// find start position
+	var i int
+	for ; i < idx; i++ {
+		if hashStr == treeHashes[i] {
+			break
+		}
+	}
+	if i == idx {
+		if !canRemoveDir {
+			return errors.New("tree: could not find a valid start to apply, try with empty dir")
+		}
+		if err := os.RemoveAll(treeDir); err != nil {
+			return err
+		}
+		if err := os.Mkdir(treeDir, 0755); err != nil {
+			return err
+		}
+	}
+
+	for _, h := range treeHashes {
+		log.Printf("apply patch: %s\n", h)
+
+		// verify previous patch
+		p, err := Hash(treeDir, excludePaths)
+		if err != nil {
+			return err
+		}
+		if hex.Encode(p[:]) != h {
+			return fmt.Errorf("tree: patch failed to create target: %s", h)
+		}
+
+		// check if we are done
+		if h == targetHash {
+			break
+		}
+
+		// open patch file
+		patch, err := os.Open(filepath.Join(patchDir, h))
+		if err != nil {
+			return err
+		}
+
+		// apply patch
+		log.Println("applying patch")
+		err = git.Apply(patch, 4, treeDir, true, false)
+		if err != nil {
+			patch.Close()
+			return err
+		}
+		patch.Close()
+	}
+	return nil
 }
diff --git a/.codechain/tree/a/util/git/git.go b/.codechain/tree/b/util/git/git.go
index 1cf0c11..85aad45 100644
--- a/.codechain/tree/a/util/git/git.go
+++ b/.codechain/tree/b/util/git/git.go
@@ -19,6 +19,8 @@ func diff(a, b string, capture bool) ([]byte, error) {
 	} else {
 		cmd.Stdout = os.Stdout
 	}
+	var stderr bytes.Buffer
+	cmd.Stderr = &stderr
 	if err := cmd.Run(); err != nil {
 		if exiterr, ok := err.(*exec.ExitError); ok {
 			if status, ok := exiterr.Sys().(syscall.WaitStatus); ok {
@@ -31,7 +33,7 @@ func diff(a, b string, capture bool) ([]byte, error) {
 					}
 				}
 			}
-			return nil, fmt.Errorf("%s: %s", exiterr, string(exiterr.Stderr))
+			return nil, fmt.Errorf("%s: %s", exiterr, stderr.String())
 		}
 		return nil, err
 	}
@@ -54,8 +56,11 @@ func DiffPager(a, b string) error {
 // Apply calls `git apply` with the given patch in directory dir.
 // Set p > 1 to remove more than 1 leading slashes from traditional diff paths.
 // Use reverse to enable option -R.
-func Apply(patch io.Reader, p int, dir string, reverse bool) error {
+func Apply(patch io.Reader, p int, dir string, dirOpt, reverse bool) error {
 	args := []string{"apply"}
+	if dirOpt {
+		args = append(args, "--directory", dir)
+	}
 	if p > 1 {
 		args = append(args, "-p", strconv.Itoa(p))
 	}
@@ -63,12 +68,15 @@ func Apply(patch io.Reader, p int, dir string, reverse bool) error {
 		args = append(args, "-R")
 	}
 	cmd := exec.Command("git", args...)
+	// TODO: check for "."?
 	cmd.Dir = dir
 	cmd.Stdin = patch
 	cmd.Stdout = os.Stdout
+	var stderr bytes.Buffer
+	cmd.Stderr = &stderr
 	if err := cmd.Run(); err != nil {
 		if exiterr, ok := err.(*exec.ExitError); ok {
-			return fmt.Errorf("%s: %s", exiterr, string(exiterr.Stderr))
+			return fmt.Errorf("%s: %s", exiterr, stderr.String())
 		}
 		return err
 	}
diff --git a/.codechain/tree/a/util/git/git_test.go b/.codechain/tree/b/util/git/git_test.go
index 8fa25b6..898b6e1 100644
--- a/.codechain/tree/a/util/git/git_test.go
+++ b/.codechain/tree/b/util/git/git_test.go
@@ -1,4 +1,4 @@
-package git
+package git_test
 
 import (
 	"bytes"
@@ -10,6 +10,7 @@ import (
 
 	"github.com/frankbraun/codechain/tree"
 	"github.com/frankbraun/codechain/util/file"
+	"github.com/frankbraun/codechain/util/git"
 )
 
 const expectedPatch = `diff --git a/treeA/bar/baz.txt b/treeA/bar/baz.txt
@@ -49,7 +50,7 @@ func TestDiffApply(t *testing.T) {
 		t.Fatalf("os.Chdir() should not fail: %v", err)
 	}
 	// diff trees
-	patch, err := Diff("treeB", "treeA")
+	patch, err := git.Diff("treeB", "treeA")
 	if err != nil {
 		t.Fatalf("Diff() failed: %v", err)
 	}
@@ -58,7 +59,7 @@ func TestDiffApply(t *testing.T) {
 	}
 	// apply patch to treeB
 	r := bytes.NewBuffer(patch)
-	err = Apply(r, 2, treeB, false)
+	err = git.Apply(r, 2, treeB, false, false)
 	if err != nil {
 		t.Fatalf("Apply() failed: %v", err)
 	}
@@ -76,12 +77,12 @@ func TestDiffApply(t *testing.T) {
 	}
 	// try to apply patch to treeB again (should fail)
 	r = bytes.NewBuffer(patch)
-	err = Apply(r, 2, treeB, false)
+	err = git.Apply(r, 2, treeB, false, false)
 	if err == nil {
 		t.Error("Apply() should fail")
 	}
 	// diff trees again (should be empty)
-	patch2, err := Diff("treeA", "treeB")
+	patch2, err := git.Diff("treeA", "treeB")
 	if err != nil {
 		t.Fatalf("Diff() failed: %v", err)
 	}
@@ -90,7 +91,7 @@ func TestDiffApply(t *testing.T) {
 	}
 	// apply patch to treeB in reverse
 	r = bytes.NewBuffer(patch)
-	err = Apply(r, 2, treeB, true)
+	err = git.Apply(r, 2, treeB, false, true)
 	if err != nil {
 		t.Fatalf("Apply() failed: %v", err)
 	}
diff --git a/.codechain/tree/b/util/log/log.go b/.codechain/tree/b/util/log/log.go
new file mode 100644
index 0000000..69427e2
--- /dev/null
+++ b/.codechain/tree/b/util/log/log.go
@@ -0,0 +1,35 @@
+// Package log implements a minimal logging framework based on stdlib's log.
+package log
+
+import (
+	"fmt"
+	"io"
+	"log"
+)
+
+// Std is the standard logger. The default is nil (nothing is logged).
+var Std *log.Logger
+
+// NewStd returns a new logger with standard flags (log.LstdFlags) and no
+// prefix.
+func NewStd(out io.Writer) *log.Logger {
+	return log.New(out, "", log.LstdFlags)
+}
+
+// Printf calls Output to print to the standard logger.
+// Arguments are handled in the manner of fmt.Printf.
+func Printf(format string, v ...interface{}) {
+	if Std == nil {
+		return
+	}
+	Std.Output(2, fmt.Sprintf(format, v...))
+}
+
+// Println calls Output to print to the standard logger.
+// Arguments are handled in the manner of fmt.Println.
+func Println(v ...interface{}) {
+	if Std == nil {
+		return
+	}
+	Std.Output(2, fmt.Sprintln(v...))
+}
diff --git a/.codechain/tree/b/util/util.go b/.codechain/tree/b/util/util.go
new file mode 100644
index 0000000..8462c91
--- /dev/null
+++ b/.codechain/tree/b/util/util.go
@@ -0,0 +1,13 @@
+// Package util contains utility functions.
+package util
+
+// ContainsString returns true, if the the string array sa contains the string s.
+// Otherwise, it returns false.
+func ContainsString(sa []string, s string) bool {
+	for _, v := range sa {
+		if v == s {
+			return true
+		}
+	}
+	return false
+}
